(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

exports.grid = [
'.hypergrid-container {',
'	position: relative;',
'	height: 500px;',
'}',
'.hypergrid-container > div:first-child {',
'	position: absolute;',
'	left: 0;',
'	top: 0;',
'	right: 0;',
'	bottom: 0;',
'}',
'.hypergrid-container > div:first-child > div.info {',
'	position: absolute;',
'	display: none; /* initially hidden */',
'	margin-top: 150px; /* to place below headers */',
'	color: #eee;',
'	text-shadow: 1px 1px #ccc;',
'	font-size: 36pt;',
'	font-weight: bold;',
'	text-align: center;',
'	top: 0; right: 0; bottom: 0; left: 0;',
'}',
'.hypergrid-textfield {',
'	position: absolute;',
'	font-size: 12px;',
'	color: black;',
'	background-color: ivory;',
'	box-sizing: border-box;',
'	margin: 0;',
'	padding: 0 5px;',
'	border: 0; /*border: 1px solid #777;*/',
'	outline: 0;',
'}',
'',
'div.hypergrid-combobox {',
'	position: absolute;',
'	display: none;',
'	outline: 0;',
'	padding: 0;',
'	border: 0; /*border: 1px solid #777;*/',
'	box-sizing: border-box;',
'	background-color: ivory;',
'	color: black;',
'	font-size: 12px;',
'}',
'div.hypergrid-combobox > input {',
'	position: absolute;',
'	margin-top: -1px;',
'	height: 100%;',
'	right: 20px;',
'	left: 0;',
'	width: 100%;',
'	outline: 0;',
'	padding: 0;',
'',
'	border: 5px solid transparent;',
'	border-right-width: 20px;',
'	border-bottom-width: 0;',
'	border-top-width: 0;',
'	box-sizing: border-box;',
'',
'	font-size: 12px;',
'	color: black;',
'	background-color: transparent;',
'}',
'div.hypergrid-combobox > span {',
'	position: absolute;',
'	box-sizing: border-box;',
'	width: 20px;',
'	height: 100%;',
'	right: 0;',
'	text-align: center;',
'	font-size: 1.5em;',
'	line-height: 1em;',
'}',
'div.hypergrid-combobox span[title] {',
'	color: lightgrey;',
'	cursor: pointer;',
'	margin-top: -2px;',
'}',
'div.hypergrid-combobox span[title]:hover {',
'	color: grey;',
'}',
'div.hypergrid-combobox span[title]:active, div.hypergrid-combobox span[title].active {',
'	color: blue;',
'}',
'div.hypergrid-combobox > span {',
'	margin-top: -1px;',
'}',
'div.hypergrid-combobox > span::after {',
'	content: \'\\25BE\';',
'	font-size: 20px;',
'}',
'div.hypergrid-combobox > div {',
'	position: absolute;',
'	left: -1px;',
'	right: -1px;',
'	top: 14px;',
'	height: 0;',
'	transition: height .25s;',
'	visibility: hidden;',
'	/*box-shadow: white 0 0 1px 1px;*/',
'	box-sizing: border-box;',
'	border: 1px solid #777;',
'	background-color: ivory;',
'	-webkit-user-select: none;',
'	-moz-user-select: none;',
'	-ms-user-select: none;',
'}',
'div.hypergrid-combobox > div > div {',
'	position: absolute;',
'	height: 13px;',
'	width: 100%;',
'	text-align: center;',
'}',
'div.hypergrid-combobox > div span[title] {',
'	font-weight: bold;',
'	font-size: 12px;',
'	font-family: verdana, geneva, sans-serif;',
'	margin-left: 6px;',
'	margin-right: 6px;',
'}',
'div.hypergrid-combobox > div span:not([title]) {',
'	font-style: italic;',
'	padding-top: 1px;',
'}',
'div.hypergrid-combobox > div select {',
'	position: absolute;',
'	padding-top: 2px;',
'	border: 0;',
'	outline: 0;',
'	border-top: 1px solid #777;',
'	width: 100%;',
'	top: 15px;',
'	bottom: 0;',
'	left: 0;',
'	right: 0;',
'	background-color: transparent;',
'	font-family: sans-serif;',
'	font-weight: bold;',
'	font-size: 9px;',
'}',
'div.hypergrid-combobox > div select option:hover {',
'	background-color: #777;',
'	color: ivory;',
'}'
].join('\n');

},{}],2:[function(require,module,exports){
module.exports = {
	"calendar": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAc0lEQVR4nIXQwQkCMRSE4U9ZLMCT9Xjaq2AfNhfYU5oQLMAOtoN48EWei5iBIRPe/yYQ3qrhf1lFG7iKcEaJxSfukUvMWgdHavt0uWHtg2QwxXnAnJZ2uOLyVZtybzzhgWNmfoFl0/YB87NbzR1cjP9xeQHSDC6mcL1xFQAAAABJRU5ErkJggg=="
	},
	"checked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAYJJREFUOE+NkstLglEQxf0fahG0iFrUxm2ElFDYLohCqCDaCAkWPaxIRbFFEJEaGEKLDCoMETRFUAMLyaIHBUG6sSKIMtKFqEhLT818ZUgmDhzu3DPn9z0uV1RrmUwmyGQyqNVqfFvViwBxu5RFPZuLSyGMKhz/qlEsRV19K8xm6y+w7bpBPFnAferjj3bdQX6DpHcAUwavAHUN2RGIZxBJZHH2mC/TUeydwwTZvBegLENNgw7sX6Wh1FswNmPEmjPCDyGRRwCtW9E3tMgdAtQw7GZjYcNX+gza2wJ3ZXsSZUuQ0vWCOV8SHfJJ/uluhbHUj1v8PKNMszIoQNRMHCShD6Wh8zyhrbOPwz8w+STKlCCJ7oRNUzQH63kBs5thBghePXxlj2aUoSxDPcuXPNiLAc5EEZ6HIkbmV2DYiXBPHs0o079+K0DTVj/s11mE00A0L+g4VcDp10qKZMAzytBhMaTRaPmYg885DlcSzSij0eoEiIouoUqlqqqaL2rlEok+Ad4vlfzPoVDsAAAAAElFTkSuQmCC"
	},
	"down-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAABpJREFUGFdjgIL/eDAKIKgABggqgAE0BQwMAPTlD/Fpi0JfAAAAAElFTkSuQmCC"
	},
	"filter-off": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAChSURBVChTzZHBCoUgFET9TqEiskgyWoutQvRLRIr+cR7XQAjiJW/1BgZmMUevXsY5xy9OoDEGMcYiUzeB67qibVuwQjVNA6311V+WBeM4vsLDMEApde/1fY9pmtI453neHEKAlBJd1z0fXtc16PbjODK07zvmeUZVVd8nooc75zJIOX3Gm6i0bVsGKf8xKIRIuyJTLgJJ3nvQzsjW2geIsQ/pr9hMVrSncAAAAABJRU5ErkJggg=="
	},
	"filter-on": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAACoSURBVChTY3BqfP2fHAzWmDbj7f8p294RhVOBasEa02e+/e/VBmQQCTxaX/9PnvYGoj5ywpv/Qd2ENft3vv4f1gfVBAP+nW/+h/a+ATtn1q73KHjytvdgg3070DTBgHvL6/8g22fsQGiaDmSHA21xaybgIpDHixa8hWssnA8NDEIApCh3LkIjiD2INYJCL2X6W3B8gdhEaQQBUOCA4gyE8+e9xaKJgQEA/74BNE3cElkAAAAASUVORK5CYII="
	},
	"unchecked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAARBJREFUOE+9krtug1AQRPldSio7FQ1tZImOkoKOBomGT0EURC5ino54yTw90WywQhTkIkVWGoF2zuxdrlD+t0zThKZpT0Vmxb8CQRCg6zr0fb8rer7vfwcPxxdcrx+YpgnzPGNZlh9ibxxHlGUJshLSdV0at9tNpg7DIBrX5+OkPM9BVkKGYSBJEtR1jbZrBdiqbVtUVYU0TUFWQq+nE+I4xvvlImGaW7FHjwxZCVmWhbfzGVmWoSgKWXUr9uiRISshx3FkEldomubXauzRI0NWQp7nyUR+NG/rfr/jUXxnjx5vmKyEbNuWox9Xvid6ZMhK6HA4wnVdhGGIKIp2RY8MWQmx+JuoqvpUZFb8L6UonyYL3uOtrFH+AAAAAElFTkSuQmCC"
	},
	"up-down-spin": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGJJREFUOE+lkwEKACEIBH2Zb/PnHsoGeaVJDUjGOgRRpKpkiIj+y4MME3eDR7kaKOVNsJyMNjIHzGy9YnW6J7qIcrriQimeCqORNABd0fpRTkt8uVUj7EsxC6vs/q3e/Q6iD2bwnByjPXHNAAAAAElFTkSuQmCC"
	},
	"up-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGFJREFUOE+lkkEKQCEIRD2ZJ3Ph3iN4WD9GflpYhj0YYowpGgJmbikd3gjMDFokwbuT1iAiurG5nomgqo5QaPo9ERQRI6Jf7sfGjudy2je23+i0Wl2oQ85TOdlfrJQOazF8br+rqTXQKn0AAAAASUVORK5CYII="
	},
};

},{}],3:[function(require,module,exports){
/* eslint-env browser */

/**
 * This is a registry of `HTMLImageIcon` objects.
 *
 * Hypergrid comes with a few images (see below).
 *
 * Application developer is free to register additional image objects here (see {@link module:images.add|add}).
 * @module images
 */

'use strict';

var _ = require('object-iterators');

var images = require('./images'); // this is the file generated by gulpfile.js (and ignored by git)

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/calendar.png">
 * @name calendar
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/checked.png">
 * @name checked
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/unchecked.png">
 * @name unchecked
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/filter-off.png">
 * @name filter-off
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/filter-on.png">
 * @name filter-on
 * @memberOf module:images
 */

/**
 * <img src="https://raw.githubusercontent.com/openfin/fin-hypergrid/master/images/up-down.png">
 * @name up-down
 * @memberOf module:images
 */

_(images).each(function(image, key) {
    var element = new Image();
    element.src = 'data:' + image.type + ';base64,' + image.data;
    images[key] = element;
});

/**
 * Synonym of {@link module:images.checked|checked} (unaffected if `checked` overridden).
 * @name checkbox-on
 * @memberOf module:images
 */
images['checkbox-on'] = images.checked;

/**
 * Synonym of {@link module:images.unchecked|unchecked} (unaffected if `unchecked` overridden).
 * @name checkbox-off
 * @memberOf module:images
 */
images['checkbox-off'] = images.unchecked;

/**
 * @name add
 * @method
 * @param {string} key
 * @param {HTMLImageElement} img
 * @memberOf module:images
 */
images.add = function(key, img) {
    return images[key] = img;
};

/**
 * Convenience function.
 * @name checkbox
 * @method
 * @param {boolean} state
 * @returns {HTMLImageElement} {@link module:images.checked|checked} when `state` is truthy or {@link module:images.unchecked|unchecked} otherwise.
 * @memberOf module:images
 */
images.checkbox = function(state) {
    return images[state ? 'checked' : 'unchecked'];
};

/**
 * Convenience function.
 * @name filter
 * @method
 * @param {boolean} state
 * @returns {HTMLImageElement} {@link module:images.filter-off|filter-off} when `state` is truthy or {@link module:images.filter-on|filter-on} otherwise.
 * @memberOf module:images
 */
images.filter = function(state) {
    return images[state ? 'filter-on' : 'filter-off'];
};

module.exports = images;

},{"./images":2,"object-iterators":36}],4:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/** @module automat */

var ENCODERS = /%\{(\d+)\}/g; // double $$ to encode

var REPLACERS = /\$\{(.*?)\}/g; // single $ to replace


/**
 * @summary String formatter.
 *
 * @desc String substitution is performed on numbered _replacer_ patterns like `${n}` or _encoder_ patterns like `%{n}` where n is the zero-based `arguments` index. So `${0}` would be replaced with the first argument following `text`.
 *
 * Encoders are just like replacers except the argument is HTML-encoded before being used.
 *
 * To change the format patterns, assign new `RegExp` patterns to `automat.encoders` and `automat.replacers`.
 *
 * @param {string|function} template - A template to be formatted as described above. Overloads:
 * * A string primitive containing the template.
 * * A function to be called with `this` as the calling context. The template is the value returned from this call.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {string} The formatted text.
 *
 * @memberOf module:automat
 */
function automat(template, replacements/*...*/) {
    var hasReplacements = arguments.length > 1;

    // if `template` is a function, convert it to text
    if (typeof template === 'function') {
        template = template.call(this); // non-template function: call it with context and use return value
    }

    if (hasReplacements) {
        var args = arguments;
        template = template.replace(automat.replacersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            return args.length > key ? args[key] : '';
        });

        template = template.replace(automat.encodersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            if (args.length > key) {
                var htmlEncoderNode = document.createElement('DIV');
                htmlEncoderNode.textContent = args[key];
                return htmlEncoderNode.innerHTML;
            } else {
                return '';
            }
        });
    }

    return template;
}

/**
 * @summary Replace contents of `el` with `Nodes` generated from formatted template.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} [el] - Node in which to return markup generated from template. If omitted, a new `<div>...</div>` element will be created and returned.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {HTMLElement} The `el` provided or a new `<div>...</div>` element, its `innerHTML` set to the formatted text.
 *
 * @memberOf module:automat
 */
function replace(template, el, replacements/*...*/) {
    var elOmitted = typeof el !== 'object',
        args = Array.prototype.slice.call(arguments, 1);

    if (elOmitted) {
        el = document.createElement('DIV');
        args.unshift(template);
    } else {
        args[0] = template;
    }

    el.innerHTML = automat.apply(null, args);

    return el;
}

/**
 * @summary Append or insert `Node`s generated from formatted template into given `el`.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} el
 *
 * @param {Node} [referenceNode=null] Inserts before this element within `el` or at end of `el` if `null`.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @returns {Node[]} Array of the generated nodes (this is an actual Array instance; not an Array-like object).
 *
 * @memberOf module:automat
 */
function append(template, el, referenceNode, replacements/*...*/) {
    var replacementsStartAt = 3,
        referenceNodeOmitted = typeof referenceNode !== 'object';  // replacements are never objects

    if (referenceNodeOmitted) {
        referenceNode = null;
        replacementsStartAt = 2;
    }

    replacements = Array.prototype.slice.call(arguments, replacementsStartAt);
    var result = [],
        div = replace.apply(null, [template].concat(replacements));

    while (div.childNodes.length) {
        result.push(div.firstChild);
        el.insertBefore(div.firstChild, referenceNode); // removes child from div
    }

    return result;
}

/**
 * Use this convenience wrapper to return the first child node described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `Node` in your template.
 *
 * @memberOf module:automat
 */
function firstChild(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstChild;
}

/**
 * Use this convenience wrapper to return the first child element described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `HTMLElement` in your template.
 *
 * @memberOf module:automat
 */
function firstElement(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstElementChild;
}

/**
 * @summary Finds string substitution lexemes that require HTML encoding.
 * @desc Modify to suit.
 * @default %{n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.encodersRegex = ENCODERS;

/**
 * @summary Finds string substitution lexemes.
 * @desc Modify to suit.
 * @default ${n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.replacersRegex = REPLACERS;

automat.format = automat; // if you find using just `automat()` confusing
automat.replace = replace;
automat.append = append;
automat.firstChild = firstChild;
automat.firstElement = firstElement;

module.exports = automat;

},{}],5:[function(require,module,exports){
'use strict';

/* eslint-env browser */

/** @namespace cssInjector */

/**
 * @summary Insert base stylesheet into DOM
 *
 * @desc Creates a new `<style>...</style>` element from the named text string(s) and inserts it but only if it does not already exist in the specified container as per `referenceElement`.
 *
 * > Caveat: If stylesheet is for use in a shadow DOM, you must specify a local `referenceElement`.
 *
 * @returns A reference to the newly created `<style>...</style>` element.
 *
 * @param {string|string[]} cssRules
 * @param {string} [ID]
 * @param {undefined|null|Element|string} [referenceElement] - Container for insertion. Overloads:
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 *
 * @memberOf cssInjector
 */
function cssInjector(cssRules, ID, referenceElement) {
    if (typeof referenceElement === 'string') {
        referenceElement = document.querySelector(referenceElement);
        if (!referenceElement) {
            throw 'Cannot find reference element for CSS injection.';
        }
    } else if (referenceElement && !(referenceElement instanceof Element)) {
        throw 'Given value not a reference element.';
    }

    var container = referenceElement && referenceElement.parentNode || document.head || document.getElementsByTagName('head')[0];

    if (ID) {
        ID = cssInjector.idPrefix + ID;

        if (container.querySelector('#' + ID)) {
            return; // stylesheet already in DOM
        }
    }

    var style = document.createElement('style');
    style.type = 'text/css';
    if (ID) {
        style.id = ID;
    }
    if (cssRules instanceof Array) {
        cssRules = cssRules.join('\n');
    }
    cssRules = '\n' + cssRules + '\n';
    if (style.styleSheet) {
        style.styleSheet.cssText = cssRules;
    } else {
        style.appendChild(document.createTextNode(cssRules));
    }

    if (referenceElement === undefined) {
        referenceElement = container.firstChild;
    }

    container.insertBefore(style, referenceElement);

    return style;
}

/**
 * @summary Optional prefix for `<style>` tag IDs.
 * @desc Defaults to `'injected-stylesheet-'`.
 * @type {string}
 * @memberOf cssInjector
 */
cssInjector.idPrefix = 'injected-stylesheet-';

// Interface
module.exports = cssInjector;

},{}],6:[function(require,module,exports){
'use strict';

var overrider = require('overrider');

/** @namespace extend-me **/

/** @summary Extends an existing constructor into a new constructor.
 *
 * @returns {ChildConstructor} A new constructor, extended from the given context, possibly with some prototype additions.
 *
 * @desc Extends "objects" (constructors), with optional additional code, optional prototype additions, and optional prototype member aliases.
 *
 * > CAVEAT: Not to be confused with Underscore-style .extend() which is something else entirely. I've used the name "extend" here because other packages (like Backbone.js) use it this way. You are free to call it whatever you want when you "require" it, such as `var inherits = require('extend')`.
 *
 * Provide a constructor as the context and any prototype additions you require in the first argument.
 *
 * For example, if you wish to be able to extend `BaseConstructor` to a new constructor with prototype overrides and/or additions, basic usage is:
 *
 * ```javascript
 * var Base = require('extend-me').Base;
 * var BaseConstructor = Base.extend(basePrototype); // mixes in .extend
 * var ChildConstructor = BaseConstructor.extend(childPrototypeOverridesAndAdditions);
 * var GrandchildConstructor = ChildConstructor.extend(grandchildPrototypeOverridesAndAdditions);
 * ```
 *
 * This function (`extend()`) is added to the new extended object constructor as a property `.extend`, essentially making the object constructor itself easily "extendable." (Note: This is a property of each constructor and not a method of its prototype!)
 *
 * @param {string} [extendedClassName] - This is simply added to the prototype as $$CLASS_NAME. Useful for debugging because all derived constructors appear to have the same name ("Constructor") in the debugger.
 *
 * @param {extendedPrototypeAdditionsObject} [prototypeAdditions] - Object with members to copy to new constructor's prototype.
 *
 * @property {boolean} [debug] - See parameter `extendedClassName` _(above)_.
 *
 * @property {object} Base - A convenient base class from which all other classes can be extended.
 *
 * @memberOf extend-me
 */
function extend(extendedClassName, prototypeAdditions) {
    switch (arguments.length) {
        case 0:
            prototypeAdditions = {};
            break;
        case 1:
            switch (typeof extendedClassName) {
                case 'object':
                    prototypeAdditions = extendedClassName;
                    extendedClassName = undefined;
                    break;
                case 'string':
                    prototypeAdditions = {};
                    break;
                default:
                    throw 'Single-parameter overload must be either string or object.';
            }
            break;
        case 2:
            if (typeof extendedClassName !== 'string' || typeof prototypeAdditions !== 'object') {
                throw 'Two-parameter overload must be string, object.';
            }
            break;
        default:
            throw 'Too many parameters';
    }

    function Constructor() {
        if (prototypeAdditions.preInitialize) {
            prototypeAdditions.preInitialize.apply(this, arguments);
        }

        initializePrototypeChain.apply(this, arguments);

        if (prototypeAdditions.postInitialize) {
            prototypeAdditions.postInitialize.apply(this, arguments);
        }
    }

    Constructor.extend = extend;

    var prototype = Constructor.prototype = Object.create(this.prototype);
    prototype.constructor = Constructor;

    if (extendedClassName) {
        prototype.$$CLASS_NAME = extendedClassName;
    }

    overrider(prototype, prototypeAdditions);

    return Constructor;
}

function Base() {}
Base.prototype = {
    constructor: Base.prototype.constructor,
    get super() {
        return Object.getPrototypeOf(Object.getPrototypeOf(this));
    }
};
Base.extend = extend;
extend.Base = Base;

/** @typedef {function} extendedConstructor
 * @property prototype.super - A reference to the prototype this constructor was extended from.
 * @property [extend] - If `prototypeAdditions.extendable` was truthy, this will be a reference to {@link extend.extend|extend}.
 */

/** @typedef {object} extendedPrototypeAdditionsObject
 * @desc All members are copied to the new object. The following have special meaning.
 * @property {function} [initialize] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after similar function in all ancestors called with same signature.
 * @property {function} [preInitialize] - Called before the `initialize` cascade. Gets passed new object as context + same args as constructor itself.
 * @property {function} [postInitialize] - Called after the `initialize` cascade. Gets passed new object as context + same args as constructor itself.
 */

/** @summary Call all `initialize` methods found in prototype chain, beginning with the most senior ancestor's first.
 * @desc This recursive routine is called by the constructor.
 * 1. Walks back the prototype chain to `Object`'s prototype
 * 2. Walks forward to new object, calling any `initialize` methods it finds along the way with the same context and arguments with which the constructor was called.
 * @private
 * @memberOf extend-me
 */
function initializePrototypeChain() {
    var term = this,
        args = arguments;
    recur(term);

    function recur(obj) {
        var proto = Object.getPrototypeOf(obj);
        if (proto.constructor !== Object) {
            recur(proto);
            if (proto.hasOwnProperty('initialize')) {
                proto.initialize.apply(term, args);
            }
        }
    }
}

module.exports = extend;

},{"overrider":37}],7:[function(require,module,exports){
'use strict';

function DataSourceBase() {}

DataSourceBase.extend = require('extend-me');

DataSourceBase.prototype = {
    constructor: DataSourceBase.prototype.constructor,

    replaceIndent: '_',

    isNullObject: true,

    drillDownCharMap: {
        OPEN: '\u25bc', // BLACK DOWN-POINTING TRIANGLE aka '▼'
        CLOSE: '\u25b6', // BLACK RIGHT-POINTING TRIANGLE aka '▶'
        undefined: '' // for leaf rows
    },

    DataSourceError: DataSourceError,

    initialize: function(dataSource) {
        this.dataSource = dataSource;

        if (this.type) {
            // find this type's DCI if already defined, else create it
            var pipe = dataSource;
            while (pipe) {
                if (pipe.type === this.type) {
                    /** @summary Data control interface.
                     * @desc A DCI is create for all data sources that have a defined type. Data sources that share the same type also share the same DCI instance.
                     */
                    this.controller = pipe.controller;
                    break;
                }
                pipe = pipe.dataSource;
            }
            if (this.controller === undefined) {
                this.controller = this.newController();
            }
        }
    },

    // GETTERS/SETTERS

    get schema() {
        if (this.dataSource) {
            return this.dataSource.schema;
        }
    },
    set schema(schema) {
        if (this.dataSource) {
            this.dataSource.schema = schema;
        }
    },


    // "SET" METHODS (ALWAYS HAVE ARGS)

    setSchema: function() {
        if (this.dataSource) {
            return this.dataSource.setSchema.apply(this.dataSource, arguments);
        }
    },

    setData: function() {
        if (this.dataSource) {
            return this.dataSource.setData.apply(this.dataSource, arguments);
        }
    },

    setValue: function() {
        if (this.dataSource) {
            return this.dataSource.setValue.apply(this.dataSource, arguments);
        }
    },

    newController: function() {
        return {};
    },

    /**
     * @summary Set the `controller` property of the matching data source(s).
     * @param {string} type - Refers to _all_ data sources in the pipeline with matching `type` property.
     * @param {undefined|*} controller - If `undefined`, resets the DCI.
     * @returns {undefined|*} - `controller` or a null DCI generated by data model if `controller` is falsy or `undefined` if no such type.
     * @memberOf DataSourceBase#
     */
    setController: function(type, controller) {
        var result, pipe;

        if (controller === undefined) {
            controller = this.newController.call(pipe);
        }

        pipe = this;
        do {
            if (pipe.type === type) {
                result = pipe.controller = controller;
            }
            pipe = pipe.dataSource;
        } while (pipe);

        return result;
    },

    /**
     * @summary Get the DCI (`controller` property) of the first matching data source.
     * @param {string} type - Refers to first data source in the pipeline with matching `type` property. (All such data sources share the same value.)
     * @returns {undefined|*} The DCI; or `undefined` if no such type.
     * @memberOf DataSourceBase#
     */
    getController: function(type) {
        var pipe;

        pipe = this;
        do {
            if (pipe.type === type) {
                return pipe.controller;
            }
            pipe = pipe.dataSource;
        } while (pipe);
    },


    // "GET" METHODS WITHOUT ARGS

    getSchema: function() {
        if (this.dataSource) {
            return this.dataSource.getSchema();
        }
    },

    getRowCount: function() {
        if (this.dataSource) {
            return this.dataSource.getRowCount();
        }
    },

    getColumnCount: function() {
        if (this.dataSource) {
            return this.dataSource.getColumnCount();
        }
    },

    getGrandTotals: function() {
        //row: Ideally this should be set and get bottom/top totals
        //Currently this function is just sending the same for both in aggregations
        if (this.dataSource) {
            return this.dataSource.getGrandTotals();
        }
    },


    // "GET" METHODS WITH ARGS

    getProperty: function getProperty(propName) {
        if (propName in this) {
            return this[propName];
        }

        if (this.dataSource) {
            return getProperty.call(this.dataSource, propName);
        }
    },

    getDataIndex: function() {
        if (this.dataSource) {
            return this.dataSource.getDataIndex.apply(this.dataSource, arguments);
        }
    },

    getRow: function() {
        if (this.dataSource) {
            return this.dataSource.getRow.apply(this.dataSource, arguments);
        }
    },

    findRow: function() {
        if (this.dataSource) {
            return this.dataSource.findRow.apply(this.dataSource, arguments);
        }
    },

    revealRow: function() {
        if (this.dataSource) {
            return this.dataSource.revealRow.apply(this.dataSource, arguments);
        }
    },

    getValue: function() {
        if (this.dataSource) {
            return this.dataSource.getValue.apply(this.dataSource, arguments);
        }
    },

    click: function() {
        if (this.dataSource) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }
    },


    // BOOLEAN METHODS (NO ARGS)

    isDrillDown: function() {
        if (this.dataSource) {
            return this.dataSource.isDrillDown();
        }
    },

    viewMakesSense: function() {
        if (this.dataSource) {
            return this.dataSource.viewMakesSense();
        }
    },


    // OTHER METHODS

    apply: function() {
        throw new DataSourceError('Nothing to apply.');
    },


    /**
     * Get new object with name and index given the name or the index.
     * @param {string|number} columnOrIndex - Column name or index.
     * @returns {{name: string, index: number}}
     */
    getColumnInfo: function(columnOrIndex) {
        var name, index, result;

        if (typeof columnOrIndex === 'number') {
            index = columnOrIndex;
            name = this.schema[index].name;
        } else {
            name = columnOrIndex;
            index = this.schema.findIndex(function(columnSchema) {
                return columnSchema.name === name;
            });
        }

        if (name && index >= 0) {
            result = {
                name: name,
                index: index
            };
        }

        return result;
    },

    fixIndentForTableDisplay: function(string) {
        var count = string.search(/\S/);
        var end = string.substring(count);
        var result = Array(count + 1).join(this.replaceIndent) + end;
        return result;
    },

    dump: function(max) {
        max = Math.min(this.getRowCount(), max || Math.max(100, this.getRowCount()));
        var data = [];
        var fields = this.schema ? this.schema.map(function(cs) { return cs.name; }) : this.getHeaders();
        var cCount = this.getColumnCount();
        var viewMakesSense = this.viewMakesSense;
        for (var r = 0; r < max; r++) {
            var row = {};
            for (var c = 0; c < cCount; c++) {
                var val = this.getValue(c, r);
                if (c === 0 && viewMakesSense) {
                    val = this.fixIndentForTableDisplay(val);
                }
                row[fields[c]] = val;
            }
            data[r] = row;
        }
        console.table(data);
    }
};

function DataSourceError(message) {
    this.message = message;
}

// extend from `Error`
DataSourceError.prototype = Object.create(Error.prototype);

// override error name displayed in console
DataSourceError.prototype.name = 'DataSourceError';

module.exports = DataSourceBase;

},{"extend-me":6}],8:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

var cssInjector = require('css-injector');

/**
 * @constructor FinBar
 * @summary Create a scrollbar object.
 * @desc Creating a scrollbar is a three-step process:
 *
 * 1. Instantiate the scrollbar object by calling this constructor function. Upon instantiation, the DOM element for the scrollbar (with a single child element for the scrollbar "thumb") is created but is not insert it into the DOM.
 * 2. After instantiation, it is the caller's responsibility to insert the scrollbar, {@link FinBar#bar|this.bar}, into the DOM.
 * 3. After insertion, the caller must call {@link FinBar#resize|resize()} at least once to size and position the scrollbar and its thumb. After that, `resize()` should also be called repeatedly on resize events (as the content element is being resized).
 *
 * Suggested configurations:
 * * _**Unbound**_<br/>
 * The scrollbar serves merely as a simple range (slider) control. Omit both `options.onchange` and `options.content`.
 * * _**Bound to virtual content element**_<br/>
 * Virtual content is projected into the element using a custom event handler supplied by the programmer in `options.onchange`. A typical use case would be to handle scrolling of the virtual content. Other use cases include data transformations, graphics transformations, _etc._
 * * _**Bound to real content**_<br/>
 * Set `options.content` to the "real" content element but omit `options.onchange`. This will cause the scrollbar to use the built-in event handler (`this.scrollRealContent`) which implements smooth scrolling of the content element within the container.
 *
 * @param {finbarOptions} [options={}] - Options object. See the type definition for member details.
 */
function FinBar(options) {

    // make bound versions of all the mouse event handler
    var bound = this._bound = {};
    for (key in handlersToBeBound) {
        bound[key] = handlersToBeBound[key].bind(this);
    }

    /**
     * @name thumb
     * @summary The generated scrollbar thumb element.
     * @desc The thumb element's parent element is always the {@link FinBar#bar|bar} element.
     *
     * This property is typically referenced internally only. The size and position of the thumb element is maintained by `_calcThumb()`.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var thumb = this.thumb = document.createElement('div');
    thumb.classList.add('thumb');
    thumb.onclick = bound.shortStop;
    thumb.onmouseover = bound.onmouseover;
    thumb.onmouseout = this._bound.onmouseout;

    /**
     * @name bar
     * @summary The generated scrollbar element.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     *
     * Thus the node tree is typically:
     * * A **content container** element, which contains:
     *   * The content element(s)
     *   * This **scrollbar element**, which in turn contains:
     *     * The **thumb element**
     *
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var bar = this.bar = document.createElement('div');
    bar.classList.add('finbar-vertical');
    bar.onmousedown = this._bound.onmousedown;
    if (this.paging) { bar.onclick = bound.onclick; }
    bar.appendChild(thumb);

    options = options || {};

    // presets
    this.orientation = 'vertical';
    this._min = this._index = 0;
    this._max = 100;

    // options
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var option = options[key];
            switch (key) {

                case 'index':
                    this._index = option;
                    break;

                case 'range':
                    validRange(option);
                    this._min = option.min;
                    this._max = option.max;
                    this.contentSize = option.max - option.min + 1;
                    break;

                default:
                    if (
                        key.charAt(0) !== '_' &&
                        typeof FinBar.prototype[key] !== 'function'
                    ) {
                        // override prototype defaults for standard ;
                        // extend with additional properties (for use in onchange event handlers)
                        this[key] = option;
                    }
                    break;

            }
        }
    }

    cssInjector(cssFinBars, 'finbar-base', options.cssStylesheetReferenceElement);
}

FinBar.prototype = {

    /**
     * @summary The scrollbar orientation.
     * @desc Set by the constructor to either `'vertical'` or `'horizontal'`. See the similarly named property in the {@link finbarOptions} object.
     *
     * Useful values are `'vertical'` (the default) or `'horizontal'`.
     *
     * Setting this property resets `this.oh` and `this.deltaProp` and changes the class names so as to reposition the scrollbar as per the CSS rules for the new orientation.
     * @default 'vertical'
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set orientation(orientation) {
        if (orientation === this._orientation) {
            return;
        }

        this._orientation = orientation;

        /**
         * @readonly
         * @name oh
         * @summary <u>O</u>rientation <u>h</u>ash for this scrollbar.
         * @desc Set by the `orientation` setter to either the vertical or the horizontal orientation hash. The property should always be synchronized with `orientation`; do not update directly!
         *
         * This object is used internally to access scrollbars' DOM element properties in a generalized way without needing to constantly query the scrollbar orientation. For example, instead of explicitly coding `this.bar.top` for a vertical scrollbar and `this.bar.left` for a horizontal scrollbar, simply code `this.bar[this.oh.leading]` instead. See the {@link orientationHashType} definition for details.
         *
         * This object is useful externally for coding generalized {@link finbarOnChange} event handler functions that serve both horizontal and vertical scrollbars.
         * @type {orientationHashType}
         * @memberOf FinBar.prototype
         */
        this.oh = orientationHashes[this._orientation];

        if (!this.oh) {
            error('Invalid value for `options._orientation.');
        }

        /**
         * @name deltaProp
         * @summary The name of the `WheelEvent` property this scrollbar should listen to.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * Useful values are `'deltaX'`, `'deltaY'`, or `'deltaZ'`. A value of `null` means to ignore mouse wheel events entirely.
         *
         * The mouse wheel is one-dimensional and only emits events with `deltaY` data. This property is provided so that you can override the default of `'deltaX'` with a value of `'deltaY'` on your horizontal scrollbar primarily to accommodate certain "panoramic" interface designs where the mouse wheel should control horizontal rather than vertical scrolling. Just give `{ deltaProp: 'deltaY' }` in your horizontal scrollbar instantiation.
         *
         * Caveat: Note that a 2-finger drag on an Apple trackpad emits events with _both_ `deltaX ` and `deltaY` data so you might want to delay making the above adjustment until you can determine that you are getting Y data only with no X data at all (which is a sure bet you on a mouse wheel rather than a trackpad).

         * @type {object|null}
         * @memberOf FinBar.prototype
         */
        this.deltaProp = this.oh.delta;

        this.bar.className = this.bar.className.replace(/(vertical|horizontal)/g, orientation);

        if (this.bar.style.cssText || this.thumb.style.cssText) {
            this.bar.removeAttribute('style');
            this.thumb.removeAttribute('style');
            this.resize();
        }
    },
    get orientation() {
        return this._orientation;
    },

    /**
     * @summary Callback for scroll events.
     * @desc Set by the constructor via the similarly named property in the {@link finbarOptions} object. After instantiation, `this.onchange` may be updated directly.
     *
     * This event handler is called whenever the value of the scrollbar is changed through user interaction. The typical use case is when the content is scrolled. It is called with the `FinBar` object as its context and the current value of the scrollbar (its index, rounded) as the only parameter.
     *
     * Set this property to `null` to stop emitting such events.
     * @type {function(number)|null}
     * @memberOf FinBar.prototype
     */
    onchange: null,

    /**
     * @summary Add a CSS class name to the bar element's class list.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * The bar element's class list will always include `finbar-vertical` (or `finbar-horizontal` based on the current orientation). Whenever this property is set to some value, first the old prefix+orientation is removed from the bar element's class list; then the new prefix+orientation is added to the bar element's class list. This property causes _an additional_ class name to be added to the bar element's class list. Therefore, this property will only add at most one additional class name to the list.
     *
     * To remove _classname-orientation_ from the bar element's class list, set this property to a falsy value, such as `null`.
     *
     * > NOTE: You only need to specify an additional class name when you need to have mulltiple different styles of scrollbars on the same page. If this is not a requirement, then you don't need to make a new class; you would just create some additional rules using the same selectors in the built-in stylesheet (../css/finbars.css):
     * *`div.finbar-vertical` (or `div.finbar-horizontal`) for the scrollbar
     * *`div.finbar-vertical > div` (or `div.finbar-horizontal > div`) for the "thumb."
     *
     * Of course, your rules should come after the built-ins.
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set classPrefix(prefix) {
        if (this._classPrefix) {
            this.bar.classList.remove(this._classPrefix + this.orientation);
        }

        this._classPrefix = prefix;

        if (prefix) {
            this.bar.classList.add(prefix + '-' + this.orientation);
        }
    },
    get classPrefix() {
        return this._classPrefix;
    },

    /**
     * @name increment
     * @summary Number of scrollbar index units representing a pageful. Used exclusively for paging up and down and for setting thumb size relative to content size.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * Can also be given as a parameter to the {@link FinBar#resize|resize} method, which is pertinent because content area size changes affect the definition of a "pageful." However, you only need to do this if this value is being used. It not used when:
     * * you define `paging.up` and `paging.down`
     * * your scrollbar is using `scrollRealContent`
     * @type {number}
     * @memberOf FinBar.prototype
     */
    increment: 1,

    /**
     * @name barStyles
     * @summary Scrollbar styles to be applied by {@link FinBar#resize|resize()}.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * This is a value to be assigned to {@link FinBar#styles|styles} on each call to {@link FinBar#resize|resize()}. That is, a hash of values to be copied to the scrollbar element's style object on resize; or `null` for none.
     *
     * @see {@link FinBar#style|style}
     * @type {finbarStyles|null}
     * @memberOf FinBar.prototype
     */
    barStyles: null,

    /**
     * @name style
     * @summary Additional scrollbar styles.
     * @desc See type definition for more details. These styles are applied directly to the scrollbar's `bar` element.
     *
     * Values are adjusted as follows before being applied to the element:
     * 1. Included "pseudo-property" names from the scrollbar's orientation hash, {@link FinBar#oh|oh}, are translated to actual property names before being applied.
     * 2. When there are margins, percentages are translated to absolute pixel values because CSS ignores margins in its percentage calculations.
     * 3. If you give a value without a unit (a raw number), "px" unit is appended.
     *
     * General notes:
     * 1. It is always preferable to specify styles via a stylesheet. Only set this property when you need to specifically override (a) stylesheet value(s).
     * 2. Can be set directly or via calls to the {@link FinBar#resize|resize} method.
     * 3. Should only be set after the scrollbar has been inserted into the DOM.
     * 4. Before applying these new values to the element, _all_ in-line style values are reset (by removing the element's `style` attribute), exposing inherited values (from stylesheets).
     * 5. Empty object has no effect.
     * 6. Falsey value in place of object has no effect.
     *
     * > CAVEAT: Do not attempt to treat the object you assign to this property as if it were `this.bar.style`. Specifically, changing this object after assigning it will have no effect on the scrollbar. You must assign it again if you want it to have an effect.
     *
     * @see {@link FinBar#barStyles|barStyles}
     * @type {finbarStyles}
     * @memberOf FinBar.prototype
     */
    set style(styles) {
        var keys = Object.keys(styles = extend({}, styles, this._auxStyles));

        if (keys.length) {
            var bar = this.bar,
                barRect = bar.getBoundingClientRect(),
                container = this.container || bar.parentElement,
                containerRect = container.getBoundingClientRect(),
                oh = this.oh;

            // Before applying new styles, revert all styles to values inherited from stylesheets
            bar.removeAttribute('style');

            keys.forEach(function (key) {
                var val = styles[key];

                if (key in oh) {
                    key = oh[key];
                }

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                } else if (/%$/.test(val)) {
                    // When bar size given as percentage of container, if bar has margins, restate size in pixels less margins.
                    // (If left as percentage, CSS's calculation will not exclude margins.)
                    var oriented = axis[key],
                        margins = barRect[oriented.marginLeading] + barRect[oriented.marginTrailing];
                    if (margins) {
                        val = parseInt(val, 10) / 100 * containerRect[oriented.size] - margins + 'px';
                    }
                }

                bar.style[key] = val;
            });
        }
    },

    /**
     * @readonly
     * @name paging
     * @summary Enable page up/dn clicks.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
     *
     * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
     *
     * Changing the truthiness of this value after instantiation currently has no effect.
     * @type {boolean|object}
     * @memberOf FinBar.prototype
     */
    paging: true,

    /**
     * @name range
     * @summary Setter for the minimum and maximum scroll values.
     * @desc Set by the constructor. These values are the limits for {@link FooBar#index|index}.
     *
     * The setter accepts an object with exactly two numeric properties: `.min` which must be less than `.max`. The values are extracted and the object is discarded.
     *
     * The getter returns a new object with `.min` and '.max`.
     *
     * @type {rangeType}
     * @memberOf FinBar.prototype
     */
    set range(range) {
        validRange(range);
        this._min = range.min;
        this._max = range.max;
        this.contentSize = range.max - range.min + 1;
        this.index = this.index; // re-clamp
    },
    get range() {
        return {
            min: this._min,
            max: this._max
        };
    },

    /**
     * @summary Index value of the scrollbar.
     * @desc This is the position of the scroll thumb.
     *
     * Setting this value clamps it to {@link FinBar#min|min}..{@link FinBar#max|max}, scroll the content, and moves thumb.
     *
     * Getting this value returns the current index. The returned value will be in the range `min`..`max`. It is intentionally not rounded.
     *
     * Use this value as an alternative to (or in addition to) using the {@link FinBar#onchange|onchange} callback function.
     *
     * @see {@link FinBar#_setScroll|_setScroll}
     * @type {number}
     * @memberOf FinBar.prototype
     */
    set index(idx) {
        idx = Math.min(this._max, Math.max(this._min, idx)); // clamp it
        this._setScroll(idx);
        // this._setThumbSize();
    },
    get index() {
        return this._index;
    },

    /**
     * @private
     * @summary Move the thumb.
     * @desc Also displays the index value in the test panel and invokes the callback.
     * @param idx - The new scroll index, a value in the range `min`..`max`.
     * @param [scaled=f(idx)] - The new thumb position in pixels and scaled relative to the containing {@link FinBar#bar|bar} element, i.e., a proportional number in the range `0`..`thumbMax`. When omitted, a function of `idx` is used.
     * @memberOf FinBar.prototype
     */
    _setScroll: function (idx, scaled) {
        this._index = idx;

        // Display the index value in the test panel
        if (this.testPanelItem && this.testPanelItem.index instanceof Element) {
            this.testPanelItem.index.innerHTML = Math.round(idx);
        }

        // Call the callback
        if (this.onchange) {
            this.onchange.call(this, Math.round(idx));
        }

        // Move the thumb
        if (scaled === undefined) {
            scaled = (idx - this._min) / (this._max - this._min) * this._thumbMax;
        }
        this.thumb.style[this.oh.leading] = scaled + 'px';
    },

    scrollRealContent: function (idx) {
        var containerRect = this.content.parentElement.getBoundingClientRect(),
            sizeProp = this.oh.size,
            maxScroll = Math.max(0, this.content[sizeProp] - containerRect[sizeProp]),
            //scroll = Math.min(idx, maxScroll);
            scroll = (idx - this._min) / (this._max - this._min) * maxScroll;
        //console.log('scroll: ' + scroll);
        this.content.style[this.oh.leading] = -scroll + 'px';
    },

    /**
     * @summary Recalculate thumb position.
     *
     * @desc This method recalculates the thumb size and position. Call it once after inserting your scrollbar into the DOM, and repeatedly while resizing the scrollbar (which typically happens when the scrollbar's parent is resized by user.
     *
     * > This function shifts args if first arg omitted.
     *
     * @param {number} [increment=this.increment] - Resets {@link FooBar#increment|increment} (see).
     *
     * @param {finbarStyles} [barStyles=this.barStyles] - (See type definition for details.) Scrollbar styles to be applied to the bar element.
     *
     * Only specify a `barStyles` object when you need to override stylesheet values. If provided, becomes the new default (`this.barStyles`), for use as a default on subsequent calls.
     *
     * It is generally the case that the scrollbar's new position is sufficiently described by the current styles. Therefore, it is unusual to need to provide a `barStyles` object on every call to `resize`.
     *
     * @returns {FinBar} Self for chaining.
     * @memberOf FinBar.prototype
     */
    resize: function (increment, barStyles) {
        var bar = this.bar;

        if (!bar.parentNode) {
            return; // not in DOM yet so nothing to do
        }

        var container = this.container || bar.parentElement,
            containerRect = container.getBoundingClientRect();

        // shift args if if 1st arg omitted
        if (typeof increment === 'object') {
            barStyles = increment;
            increment = undefined;
        }

        this.style = this.barStyles = barStyles || this.barStyles;

        // Bound to real content: Content was given but no onchange handler.
        // Set up .onchange, .containerSize, and .increment.
        // Note this only makes sense if your index unit is pixels.
        if (this.content) {
            if (!this.onchange) {
                this.onchange = this.scrollRealContent;
                this.contentSize = this.content[this.oh.size];
                this._min = 0;
                this._max = this.contentSize - 1;
            }
        }
        if (this.onchange === this.scrollRealContent) {
            this.containerSize = containerRect[this.oh.size];
            this.increment = this.containerSize / (this.contentSize - this.containerSize) * (this._max - this._min);
        } else {
            this.containerSize = 1;
            this.increment = increment || this.increment;
        }

        var index = this.index;
        this.testPanelItem = this.testPanelItem || this._addTestPanelItem();
        this._setThumbSize();
        this.index = index;

        if (this.deltaProp !== null) {
            container.addEventListener('wheel', this._bound.onwheel);
        }

        return this;
    },

    /**
     * @summary Shorten trailing end of scrollbar by thickness of some other scrollbar.
     * @desc In the "classical" scenario where vertical scroll bar is on the right and horizontal scrollbar is on the bottom, you want to shorten the "trailing end" (bottom and right ends, respectively) of at least one of them so they don't overlay.
     *
     * This convenience function is an programmatic alternative to hardcoding the correct style with the correct value in your stylesheet; or setting the correct style with the correct value in the {@link FinBar#barStyles|barStyles} object.
     *
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     *
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenBy: function (otherFinBar) { return this.shortenEndBy('trailing', otherFinBar); },

    /**
     * @summary Shorten leading end of scrollbar by thickness of some other scrollbar.
     * @desc Supports non-classical scrollbar scenarios where vertical scroll bar may be on left and horizontal scrollbar may be on top, in which case you want to shorten the "leading end" rather than the trailing end.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    foreshortenBy: function (otherFinBar) { return this.shortenEndBy('leading', otherFinBar); },

    /**
     * @summary Generalized shortening function.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     * @param {string} whichEnd - a CSS style property name or an orientation hash name that translates to a CSS style property name.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenEndBy: function (whichEnd, otherFinBar) {
        if (!otherFinBar) {
            delete this._auxStyles;
        } else if (otherFinBar instanceof FinBar && otherFinBar.orientation !== this.orientation) {
            var otherStyle = window.getComputedStyle(otherFinBar.bar),
                ooh = orientationHashes[otherFinBar.orientation];
            this._auxStyles = {};
            this._auxStyles[whichEnd] = otherStyle[ooh.thickness];
        }
        return this; // for chaining
    },

    /**
     * @private
     * @summary Sets the proportional thumb size and hides thumb when 100%.
     * @desc The thumb size has an absolute minimum of 20 (pixels).
     * @memberOf FinBar.prototype
     */
    _setThumbSize: function () {
        var oh = this.oh,
            thumbComp = window.getComputedStyle(this.thumb),
            thumbMarginLeading = parseInt(thumbComp[oh.marginLeading]),
            thumbMarginTrailing = parseInt(thumbComp[oh.marginTrailing]),
            thumbMargins = thumbMarginLeading + thumbMarginTrailing,
            barSize = this.bar.getBoundingClientRect()[oh.size],
            thumbSize = Math.max(20, barSize * this.containerSize / this.contentSize);

        if (this.containerSize < this.contentSize) {
            this.bar.style.visibility = 'visible';
            this.thumb.style[oh.size] = thumbSize + 'px';
        } else {
            this.bar.style.visibility = 'hidden';
        }

        /**
         * @private
         * @name _thumbMax
         * @summary Maximum offset of thumb's leading edge.
         * @desc This is the pixel offset within the scrollbar of the thumb when it is at its maximum position at the extreme end of its range.
         *
         * This value takes into account the newly calculated size of the thumb element (including its margins) and the inner size of the scrollbar (the thumb's containing element, including _its_ margins).
         *
         * NOTE: Scrollbar padding is not taken into account and assumed to be 0 in the current implementation and is assumed to be `0`; use thumb margins in place of scrollbar padding.
         * @type {number}
         * @memberOf FinBar.prototype
         */
        this._thumbMax = barSize - thumbSize - thumbMargins;

        this._thumbMarginLeading = thumbMarginLeading; // used in mousedown
    },

    /**
     * @summary Remove the scrollbar.
     * @desc Unhooks all the event handlers and then removes the element from the DOM. Always call this method prior to disposing of the scrollbar object.
     * @memberOf FinBar.prototype
     */
    remove: function () {
        this.bar.onmousedown = null;
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        (this.container || this.bar.parentElement)._removeEvt('wheel', this._bound.onwheel);

        this.bar.onclick =
            this.thumb.onclick =
                this.thumb.onmouseover =
                    this.thumb.transitionend =
                        this.thumb.onmouseout = null;

        this.bar.remove();
    },

    /**
     * @private
     * @function _addTestPanelItem
     * @summary Append a test panel element.
     * @desc If there is a test panel in the DOM (typically an `<ol>...</ol>` element) with class names of both `this.classPrefix` and `'test-panel'` (or, barring that, any element with class name `'test-panel'`), an `<li>...</li>` element will be created and appended to it. This new element will contain a span for each class name given.
     *
     * You should define a CSS selector `.listening` for these spans. This class will be added to the spans to alter their appearance when a listener is added with that class name (prefixed with 'on').
     *
     * (This is an internal function that is called once by the constructor on every instantiation.)
     * @returns {Element|undefined} The appended `<li>...</li>` element or `undefined` if there is no test panel.
     * @memberOf FinBar.prototype
     */
    _addTestPanelItem: function () {
        var testPanelItem,
            testPanelElement = document.querySelector('.' + this._classPrefix + '.test-panel') || document.querySelector('.test-panel');

        if (testPanelElement) {
            var testPanelItemPartNames = [ 'mousedown', 'mousemove', 'mouseup', 'index' ],
                item = document.createElement('li');

            testPanelItemPartNames.forEach(function (partName) {
                item.innerHTML += '<span class="' + partName + '">' + partName.replace('mouse', '') + '</span>';
            });

            testPanelElement.appendChild(item);

            testPanelItem = {};
            testPanelItemPartNames.forEach(function (partName) {
                testPanelItem[partName] = item.getElementsByClassName(partName)[0];
            });
        }

        return testPanelItem;
    },

    _addEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.add('listening'); }
        window.addEventListener(evtName, this._bound['on' + evtName]);
    },

    _removeEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.remove('listening'); }
        window.removeEventListener(evtName, this._bound['on' + evtName]);
    }
};

function extend(obj) {
    for (var i = 1; i < arguments.length; ++i) {
        var objn = arguments[i];
        if (objn) {
            for (var key in objn) {
                obj[key] = objn[key];
            }
        }
    }
    return obj;
}

function validRange(range) {
    var keys = Object.keys(range),
        valid =  keys.length === 2 &&
            typeof range.min === 'number' &&
            typeof range.max === 'number' &&
            range.min <= range.max;

    if (!valid) {
        error('Invalid .range object.');
    }
}

/**
 * @private
 * @name handlersToBeBound
 * @type {object}
 * @desc The functions defined in this object are all DOM event handlers that are bound by the FinBar constructor to each new instance. In other words, the `this` value of these handlers, once bound, refer to the FinBar object and not to the event emitter. "Do not consume raw."
 */
var handlersToBeBound = {
    shortStop: function (evt) {
        evt.stopPropagation();
    },

    onwheel: function (evt) {
        this.index += evt[this.deltaProp];
        evt.stopPropagation();
        evt.preventDefault();
    },

    onclick: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect(),
            goingUp = evt[this.oh.coordinate] < thumbBox[this.oh.leading];

        if (typeof this.paging === 'object') {
            this.index = this.paging[goingUp ? 'up' : 'down'](Math.round(this.index));
        } else {
            this.index += goingUp ? -this.increment : this.increment;
        }

        // make the thumb glow momentarily
        this.thumb.classList.add('hover');
        var self = this;
        this.thumb.addEventListener('transitionend', function waitForIt() {
            this.removeEventListener('transitionend', waitForIt);
            self._bound.onmouseup(evt);
        });

        evt.stopPropagation();
    },

    onmouseover: function () {
        this.thumb.classList.add('hover');
    },

    onmouseout: function () {
        this.thumb.classList.remove('hover');
    },

    onmousedown: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect();
        this.pinOffset = evt[this.oh.axis] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this._thumbMarginLeading;
        document.documentElement.style.cursor = 'default';

        this._addEvt('mousemove');
        this._addEvt('mouseup');

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmousemove: function (evt) {
        var scaled = Math.min(this._thumbMax, Math.max(0, evt[this.oh.axis] - this.pinOffset));
        var idx = scaled / this._thumbMax * (this._max - this._min) + this._min;

        this._setScroll(idx, scaled);

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmouseup: function (evt) {
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        document.documentElement.style.cursor = 'auto';

        var thumbBox = this.thumb.getBoundingClientRect();
        if (
            thumbBox.left <= evt.clientX && evt.clientX <= thumbBox.right &&
            thumbBox.top <= evt.clientY && evt.clientY <= thumbBox.bottom
        ) {
            this._bound.onmouseover(evt);
        } else {
            this._bound.onmouseout(evt);
        }

        evt.stopPropagation();
        evt.preventDefault();
    }
};

var orientationHashes = {
    vertical: {
        coordinate:     'clientY',
        axis:           'pageY',
        size:           'height',
        outside:        'right',
        inside:         'left',
        leading:        'top',
        trailing:       'bottom',
        marginLeading:  'marginTop',
        marginTrailing: 'marginBottom',
        thickness:      'width',
        delta:          'deltaY'
    },
    horizontal: {
        coordinate:     'clientX',
        axis:           'pageX',
        size:           'width',
        outside:        'bottom',
        inside:         'top',
        leading:        'left',
        trailing:       'right',
        marginLeading:  'marginLeft',
        marginTrailing: 'marginRight',
        thickness:      'height',
        delta:          'deltaX'
    }
};

var axis = {
    top:    'vertical',
    bottom: 'vertical',
    height: 'vertical',
    left:   'horizontal',
    right:  'horizontal',
    width:  'horizontal'
};

var cssFinBars; // definition inserted by gulpfile between following comments
/* inject:css */
cssFinBars = 'div.finbar-horizontal,div.finbar-vertical{position:absolute;margin:3px}div.finbar-horizontal>.thumb,div.finbar-vertical>.thumb{position:absolute;background-color:#d3d3d3;-webkit-box-shadow:0 0 1px #000;-moz-box-shadow:0 0 1px #000;box-shadow:0 0 1px #000;border-radius:4px;margin:2px;opacity:.4;transition:opacity .5s}div.finbar-horizontal>.thumb.hover,div.finbar-vertical>.thumb.hover{opacity:1;transition:opacity .5s}div.finbar-vertical{top:0;bottom:0;right:0;width:11px}div.finbar-vertical>.thumb{top:0;right:0;width:7px}div.finbar-horizontal{left:0;right:0;bottom:0;height:11px}div.finbar-horizontal>.thumb{left:0;bottom:0;height:7px}';
/* endinject */

function error(msg) {
    throw 'finbars: ' + msg;
}

// Interface
module.exports = FinBar;

},{"css-injector":5}],9:[function(require,module,exports){
'use strict';

module.exports = {
    JSDataSource: require('./js/DataSource'),
    DataSourceSorter: require('./js/DataSourceSorter'),
    DataSourceSorterComposite: require('./js/DataSourceSorterComposite'),
    DataSourceGlobalFilter: require('./js/DataSourceGlobalFilter'),
    DataSourceGroupView: require('./js/DataSourceGroupView'),
    DataSourceAggregator: require('./js/DataSourceAggregator'),
    DataSourceTreeview: require('./js/DataSourceTreeview'),
    DataSourceTreeviewFilter: require('./js/DataSourceTreeviewFilter'),
    DataSourceTreeviewSorter: require('./js/DataSourceTreeviewSorter'),
    DataNodeGroupSorter: require('./js/DataNodeGroupSorter'),
    util: {
        aggregations: require('./js/util/aggregations'),
        Mappy: require('./js/util/Mappy'),
        stableSort: require('./js/util/stableSort'),
        headerify: require('./js/util/headerify')
    }
};

},{"./js/DataNodeGroupSorter":17,"./js/DataSource":20,"./js/DataSourceAggregator":21,"./js/DataSourceGlobalFilter":23,"./js/DataSourceGroupView":24,"./js/DataSourceSorter":26,"./js/DataSourceSorterComposite":27,"./js/DataSourceTreeview":28,"./js/DataSourceTreeviewFilter":29,"./js/DataSourceTreeviewSorter":30,"./js/util/Mappy":31,"./js/util/aggregations":32,"./js/util/headerify":33,"./js/util/stableSort":34}],10:[function(require,module,exports){
'use strict';


var AggregatorNodeBaseMixin = {
    getRowData: function(aggregator) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = Number(aggregator.hasGroups());

            // redimension the data
            var data = this.data;
            data.length = groupsOffset + aggregator.aggregates.length;

            var sorter = aggregator.sorterInstance;
            sorter.index = index;

            aggregator.aggregates.forEach(function(aggregate, i) {
                data[groupsOffset + i] = aggregate(sorter);
            });
        }
    }
};

module.exports = AggregatorNodeBaseMixin;

},{}],11:[function(require,module,exports){
'use strict';

var AggregatorNodeBaseMixin = require('./AggregatorNodeBaseMixin');
var DataNodeGroup = require('./DataNodeGroup');

/**
 * @constructor
 * @extends DataNodeBase
 */
var AggregatorNodeGroup = DataNodeGroup.extend('AggregatorNodeGroup', {
    getRowData: function (drillDown) {
        AggregatorNodeBaseMixin.getRowData.apply(this, arguments);
        if (this.expanded) {
            this.children.forEach(function (child) {
                child.getRowData(drillDown);
            });
        }
    }
});

module.exports = AggregatorNodeGroup;

},{"./AggregatorNodeBaseMixin":10,"./DataNodeGroup":16}],12:[function(require,module,exports){
'use strict';

var AggregatorNodeBaseMixin = require('./AggregatorNodeBaseMixin');
var DataNodeLeaf = require('./DataNodeLeaf');

/**
 * @constructor
 * @extends DataNodeBase
 */
var AggregatorNodeLeaf = DataNodeLeaf.extend('AggregatorNodeLeaf', AggregatorNodeBaseMixin);

module.exports = AggregatorNodeLeaf;

},{"./AggregatorNodeBaseMixin":10,"./DataNodeLeaf":18}],13:[function(require,module,exports){
'use strict';

var AggregatorNodeBaseMixin = require('./AggregatorNodeBaseMixin');
var DataNodeTree = require('./DataNodeTree');

/**
 * @constructor
 * @extends DataNodeBase
 */
var AggregatorNodeTree = DataNodeTree.extend('AggregatorNodeTree', {
    getRowData: function (drillDown) {
        AggregatorNodeBaseMixin.getRowData.apply(this, arguments);
        if (this.expanded) {
            this.children.forEach(function (child) {
                child.getRowData(drillDown);
            });
        }
    }
});

module.exports = AggregatorNodeTree;

},{"./AggregatorNodeBaseMixin":10,"./DataNodeTree":19}],14:[function(require,module,exports){
'use strict';

var Base = require('fin-hypergrid-data-source-base');

// Following are for legacy methods

Base.prototype.getFields = function() {
    if (this.dataSource) {
        return this.dataSource.getFields();
    }
};

Base.prototype.getHeaders = function() {
    if (this.dataSource) {
        return this.dataSource.getHeaders();
    }
};

Base.prototype.getCalculators = function() {
    if (this.dataSource) {
        return this.dataSource.revealRow();
    }
};

Base.prototype.setFields = function(arr) {
    if (this.dataSource) {
        return this.dataSource.setFields.call(this.dataSource, arr);
    }
};

Base.prototype.setHeaders = function(arr) {
    if (this.dataSource) {
        return this.dataSource.setHeaders.call(this.dataSource, arr);
    }
};

module.exports = Base;

},{"fin-hypergrid-data-source-base":7}],15:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/**
 * See {@link DataBaseNode#initialize|initialize()} method for parameters.
 * @constructor
 */
var DataNodeBase = Base.extend('DataNodeBase', {

    isNullObject: false,

    INDENT: '   ', // 3 spaces

    /**
     * @memberOf DataNodeBase#
     * @param {string} key
     */
    initialize: function(key) {
        /**
         * @memberOf DataNodeBase#
         * @type {string}
         */

        this.label = key;

        /**
         * @memberOf DataNodeBase#
         * @type {string[]}
         * @default false
         */
        this.data = [''];

        /**
         * @memberOf DataNodeBase#
         * @type {number[]}
         * @default ['']
         */
        this.index = []; // formerly rowIndex

        /**
         * @memberOf DataNodeBase#
         * @type {boolean}
         * @default false
         */
        this.hasChildren = true;

        /**
         * @memberOf DataNodeBase#
         * @type {number}
         * @default 0
         */
        this.depth = 0;

        /**
         * @memberOf DataNodeBase#
         * @type {number}
         * @default 1
         */
        this.height = 1;

        /**
         * @memberOf DataNodeBase#
         * @type {boolean}
         * @default false
         */
        this.expanded = false;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param x
     * @returns {*}
     */
    getValue: function(x) {
        return this.data[x];
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {string}
     */
    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) + '  ' + this.label;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {Array}
     */
    getIndex: function() { // TODO: formerly getAllRowIndexes
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param drillDown
     */
    getRowData: function(drillDown) {
        var index = this.getIndex();

        if (index.length) {
            // Group and Tree nodes will have no data besides the tree column
            this.data.length = drillDown.getColumnCount();
        }
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param drillDown
     */
    buildView: function(drillDown) {
        drillDown.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf#
     */
    toggleExpansionState: function() {
        //do nothing by default
    },

    sortGroups: function(groupSorter) {
    }
});


module.exports = DataNodeBase;

},{"./Base":14}],16:[function(require,module,exports){
'use strict';

var Map = require('./util/Mappy');
var DataNodeBase = require('./DataNodeBase');

/**
 * > See {@link DataNodeGroup#initialize|initialize()} method for constructor parameters.
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeGroup = DataNodeBase.extend('DataNodeGroup', {

    extendable: true,

    /**
     * @memberOf DataNodeGroup#
     * @param key
     */
    initialize: function(key) {
        this.children = new Map();
    },

    /**
     * @memberOf DataNodeGroup#
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(depth + 1);
        });
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {string}
     */
    computeDepthString: function() {
        var string = Array(this.depth + 1).join(this.INDENT) +
            this.drillDownCharMap[this.expanded ? 'OPEN' : 'CLOSE'] + ' ' +
            this.label;
        return string;
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {*}
     */
    getIndex: function() {
        if (this.index.length === 0) {
            this.index = this.computeIndex();
        }
        return this.index;
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {Array}
     */
    computeIndex: function() { // TODO: formerly computeAllRowIndexes
        var result = [];
        result.append = append;
        this.children.forEach(function(child) {
            result.append(child.getIndex());
        });
        return result;
    },

    /**
     * @memberOf DataNodeGroup#
     * @param drillDown
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @returns {boolean} If this call resulted in a state change.
     */
    toggleExpansionState: function(drillDown, expand) { /* aggregator */
        if (expand === undefined) {
            expand = !this.expanded;
        }
        var changed = this.expanded ^ expand;
        this.expanded = expand;
        this.data[0] = this.computeDepthString();
        if (this.expanded) {
            this.getRowData(drillDown);
        }
        return !!changed;
    },

    /**
     * @memberOf DataNodeGroup#
     * @param drillDown
     */
    getRowData: function(drillDown) {
        DataNodeBase.prototype.getRowData.call(this, drillDown); // call base class's version
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.getRowData(drillDown);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup#
     * @param aggregator
     */
    buildView: function(drillDown) {
        drillDown.view.push(this);
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.buildView(drillDown);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        if (this.expanded) {
            this.children.forEach(function(child) {
                height = height + child.computeHeight();
            });
        }

        return (this.height = height);
    },

    sortWith: function(sorter) {
        if (this.expanded) {
            sorter.sortGroup(this);
            this.children.forEach(function(child) {
                child.sortWith(sorter);
            });
        }
    },
    clearGroupSorts: function() {
        if (this.originalOrder) {
            for (var i = 0; i < this.originalOrder.length; i++) {
                this.children[i] = this.originalOrder[i];
            }
        }
        this.children.forEach(function(child) {
            child.clearGroupSorts();
        });
    }

});

/**
 * @private
 * @summary Array mixin to append another array to end of `this` one.
 * @desc Appends in place, unlike `this.concat()` which creates a new array.
 * Uses less memory than concat, important when `appendix` is huge.
 * > CAUTION: Mutates `this` array!
 * @param {Array} appendix
 * @returns {Array} Reference to `this` (for convenience)
 */
function append(appendix) {
    this.splice.bind(this, this.length, 0).apply(this, appendix);
    return this;
}

module.exports = DataNodeGroup;

},{"./DataNodeBase":15,"./util/Mappy":31}],17:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var stableSort = require('./util/stableSort').sort;

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataNodeGroupSorter = Base.extend('DataNodeGroupSorter', {

    /**
     * @memberOf DataNodeGroupSorter#
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.sorts = [];

    },
    /**
     *  @memberOf DataSourceSorterComposite#
     *  @param columnIndex
     *  @param direction
     */

    sortOn: function(columnIndex, direction) {
        this.sorts.push({ columnIndex: columnIndex, direction: direction });
    },
    /**
     *
     * @memberOf DataNodeGroupSorter#
     * @param {sorterFunction} [sorter] - If undefined, deletes sorter.
     */
    set: function(sorter) {
        if (sorter) {
            /**
             * @implements sorterInterfacei
             * @memberOf DataSourceSorterComposite#
             */
            this.sorter = sorter;
        } else {
            delete this.sorter;
        }
    },

    get: function() {
        return this.sorter;
    },

    /**
     * @memberOf DataNodeGroupSorter#
     */
    apply: function() {
        this.dataSource.sortGroups(this);
    },

    /**
     * @memberOf DataSourceSorterComposite#
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.dataSource.buildView();
    },

    sortGroup: function(group) {
        if (!group.originalOrder) {
            group.originalOrder = group.children.slice(0);
        }

        // get list of sorts from either API or use existing
        this.sorts = (this.sorter && this.sorter.prop('sorts')) || this.sorts;
        for (var i = this.sorts.length - 1; i >= 0; i--) {
            this.sortGroupOnEach(group, this.sorts[this.sorts.length - i - 1]);
        }
    },

    sortGroupOnEach: function(group, sortSpec) {
        // we actually sort the children here....
        var children = group.children.slice(0);
        var indexVector = [];

        for (var i = 0; i < children.length; i++) {
            indexVector[i] = i;
        }

        stableSort(indexVector, function(rowNumber) {
            var child = children[rowNumber];
            if (sortSpec.columnIndex === 0) {
                return child.label;
            }
            return child.data[sortSpec.columnIndex];
        }, sortSpec.direction);

        for (i = 0; i < children.length; i++) {
            group.children[i] = children[indexVector[i]];
        }
    }

});

DataNodeGroupSorter.prototype.applySorts = function() {
    (console.warn || console.log).call(console, 'applySorts deprecated; use apply');
    this.apply();
};

Object.defineProperty(DataNodeGroupSorter.prototype, 'type', { value: 'sorter' }); // read-only property

module.exports = DataNodeGroupSorter;

},{"./Base":14,"./util/stableSort":34}],18:[function(require,module,exports){
'use strict';

var DataNodeBase = require('./DataNodeBase');

/**
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeLeaf = DataNodeBase.extend('DataNodeLeaf', {

    /**
     * @memberOf DataNodeLeaf#
     * @param {string} key
     */
    initialize: function(key) {
        this.hasChildren = false;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {numer[]}
     */
    getIndex: function() {
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param drillDown
     */
    buildView: function(drillDown) {
        drillDown.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param aggregator
     */
    getRowData: function(drillDown) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = drillDown.hasGroups() ? 1 : 0,
                data = this.data,
                dataLen = drillDown.getColumnCount() - groupsOffset,
                i = 0,
                sorter = drillDown.sorterInstance;

            sorter.index = index;

            for (i; i < dataLen; i++) {
                data[groupsOffset + i] = sorter.getValue(i, 0);
            }
        }
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    sortWith: function(sorter) {
      // do nothing we have no children to sort
    },

    clearGroupSorts: function() {
      // do nothing we have no children to sort
    }

});

module.exports = DataNodeLeaf;

},{"./DataNodeBase":15}],19:[function(require,module,exports){
'use strict';

var DataNodeGroup = require('./DataNodeGroup');

/**
 * See {@link DataNodeGroup#initialize|initialize()} method for parameters.
 * @constructor
 * @extends DataNodeGroup
 */
var DataNodeTree = DataNodeGroup.extend('DataNodeTree', {

    /**
     * @memberOf DataNodeGroup#
     * @param {string} key
     */
    initialize: function(key) {
        this.height = 0;
        this.expanded = true;
    },

    /**
     * @memberOf DataNodeGroup#
     */
    toArray: function() {
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(0);
        });
    },

    /**
     * @memberOf DataNodeGroup#
     * @param drillDown
     */
    buildView: function(drillDown) {
        this.children.forEach(function(child) {
            child.buildView(drillDown);
        });
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        this.children.forEach(function(child) {
            height = height + child.computeHeight();
        });

        return (this.height = height);
    }

});

module.exports = DataNodeTree;

},{"./DataNodeGroup":16}],20:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {object[]} data
 * @param {string[]} fields
 */
var DataSource = Base.extend('DataSource', {
    initialize: function(data, fields, calculators) {
        /**
         * @summary The array of data row objects.
         * @desc Access through {@link DataSource#getRow|getRow()}.
         * @name data
         * @type {object[]}
         * @memberOf DataSource#
         */
        this.data = data;

        /**
         * @summary The list of field names.
         * @desc These are all the members of the data row objects visible to Hypergrid.
         *
         * Access through {@link DataSource#getFields|getFields()}.
         * @name fields
         * @type {string[]}
         * @memberOf DataSource#
         */
        this.fields = fields || computeFieldNames(data[0]);

        /**
         * @summary The list of calculators that implement computed columns.
         * @desc Congruent to {@link DataSource#fields|fields}.
         *
         * Elements representing regular (non-computed) fields should contain `undefined`.
         * @name calculators
         * @type {function[]}
         * @memberOf DataSource#
         */
        this.calculators = calculators || Array(this.fields.length);

        // Following code added purely to satisfy tests of other modules that have this DataSourceOrigin (form Hypergrid) in their pipeline instead of this DataSource. The former defines `schema` but the this object does not, so we define it here.
        delete this.dataSource;
        Object.defineProperty(this, 'schema', {
            value: this.fields.map(function(field, index) {
                return {
                    name: field,
                    calculator: this.calculators[index]
                };
            }, this)
        });
    },

    isNullObject: false,

    getDataIndex: function(y) {
        return y;
    },

    /**
     * @memberOf DataSource#
     * @param y
     * @returns {object[]}
     */
    getRow: function(y) {
        return this.data[y];
    },

        /**
     * @summary Find, replace, or update a row by it's primary key column.
     * @param {string|object} columnName - One of:
     * * _string_ - Column name. See `value`.
     * * _object_ - Hash of 0 or more key-value pairs to search for.
     * @param {string[]|*} [value] - One of:
     * _omitted_ - When `columnName` is a hash and you want to search all its keys.
     * _string[]_ - When `columnName` is a hash but you only want to search certain keys.
     * _otherwise_ - When `columnName` is a string. Value to search for.
     * Note that `null` is a valid search value.
     * @param {object|null|undefined} [replacement] - One of:
     * * _omitted_ - Ignored.
     * * _object_ - Replacement for the data row if found.
     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
     * * `undefined` - Flag to return index of found row instead of row object itself.
     * @returns {object|number|undefined} One of:
     * * `undefined` - data row not found
     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
     * * _number_ - index of found data row object in `this.data` (if `replacement` was `undefined`)
     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
     * @memberOf DataSource#
     */
    findRow: function findRow(columnName, value, replacement) {
        var result, index, keys, hash, args;

        if (typeof columnName === 'object') {
            hash = columnName;

            if (value instanceof Array) {
                args = 2;
                keys = value;
                if (keys.reduce(function(sum, key) {
                    if (key in hash) {
                        sum++;
                    }
                    return sum;
                }, 0) !== keys.length) {
                    throw 'Expected all keys given in 2nd arg to be found in hash given in 1st arg.';
                }
            } else {
                args = 1;
                keys = Object.keys(hash);
                replacement = value; // promote
            }

            if (keys.length === 1) {
                columnName = keys[0];
                value = hash[columnName];
                hash = undefined;
            } else if (keys.length) {
                result = this.data.find(function(row, idx) {
                    if (!row) {
                        return;
                    }
                    index = idx;
                    for (var key in keys) {
                        columnName = keys[key];
                        if (row[columnName] !== hash[columnName]) {
                            return; // bail
                        }
                    }
                    return true; // found!
                });
            }
        } else {
            if (arguments.length < 2) {
                throw 'Expected at least 2 arguments when first argument not object but found ' + arguments.length + '.';
            }
            args = 2;
        }

        if (!hash) {
            result = this.data.find(function(row, idx) {
                if (!row) { return; }
                index = idx;
                return row[columnName] === value;
            });
        }

        if (result) {
            this.foundRowIndex = index;
            if (replacement === null) {
                this.data.splice(index, 1);
            } else if (typeof replacement === 'object') {
                this.data[index] = replacement;
            } else if (replacement === undefined) {
                if (arguments.length > args) {
                    delete this.data[index];
                }
            } else {
                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
            }
        } else {
            this.foundRowIndex = undefined;
        }

        return result;
    },

    /**
     * @memberOf DataSource#
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.fields[x]];
    },

    /**
     * @memberOf DataSource#
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.getRow(y)[this.fields[x]] = value;
    },

    /**
     * @memberOf DataSource#
     * @returns {number}
     */
    getRowCount: function() {
        return this.data.length;
    },

    /**
     * @memberOf DataSource#
     * @returns {number}
     */
    getColumnCount: function() {
        return this.getFields().length;
    },

    /**
     * @memberOf DataSource#
     * @returns {number[]}
     */
    getFields: function() {
        return this.fields;
    },

    /**
     * @memberOf DataSource#
     * @returns {string[]}
     */
    getHeaders: function() {
        return (
            /**
             * @summary The list of header strings.
             * @desc Congruent to {@link DataSource#fields|fields}.
             *
             * Access through {@link DataSource#getHeaders|getHeaders()}.
             * @name headers
             * @type {string[]}
             * @memberOf DataSource#
             */
            this.headers = this.headers || this.getDefaultHeaders().map(function(each) {
                return headerify.transform(each);
            })
        );
    },

    /**
     * @memberOf DataSource#
     * @returns {string[]}
     */
    getDefaultHeaders: function() {
        return this.getFields();
    },

    /**
     * @memberOf DataSource#
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.fields = fields;
    },

    /**
     * @memberOf DataSource#
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        if (!(headers instanceof Array)) {
            error('setHeaders', 'param #1 `headers` not array');
        }
        this.headers = headers;
    },

    /**
     * @memberOf DataSource#
     */
    getGrandTotals: function() {
        //nothing here
    },

    /**
     * @memberOf DataSource#
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.data = arrayOfUniformObjects;
    }
});

function error(methodName, message) {
    throw new Error('DataSource.' + methodName + ': ' + message);
}

/**
 * @private
 * @param {object} object
 * @returns {string[]}
 */
function computeFieldNames(object) {
    if (!object) {
        return [];
    }
    return Object.getOwnPropertyNames(object || []).filter(function(e) {
        return e.substr(0, 2) !== '__';
    });
}

module.exports = DataSource;

},{"./Base":14,"./util/headerify":33}],21:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./AggregatorNodeTree');
var DataNodeGroup = require('./AggregatorNodeGroup');
var DataNodeLeaf = require('./AggregatorNodeLeaf');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {DataSource} dataSource
 */
var DataSourceAggregator = Base.extend('DataSourceAggregator', {
    initialize: function(dataSource) {

        /**
         * @memberOf DataSourceAggregator#
         * @type {DataSource}
         */
        this.dataSource = dataSource;

        /**
         * @memberOf DataSourceAggregator#
         * @type {DataSource}
         */
        this.treeColumnIndex = 0;

        /**
         * @memberOf DataSourceAggregator#
         * @type {DataNodeTree}
         */
        this.tree = new DataNodeTree('Totals');

        /**
         * @memberOf DataSourceAggregator#
         * @type {number[]}
         * @default []
         */
        this.index = [];

        /**
         * @memberOf DataSourceAggregator#
         * @type {Array}
         * @default []
         */
        this.aggregates = [];

        /**
         * @memberOf DataSourceAggregator#
         * @type {Array}
         * @default []
         */
        this.groupBys = [];

        /**
         * @memberOf DataSourceAggregator#
         * @type {Array}
         * @default []
         */
        this.view = [];

        /**
         * @memberOf DataSourceAggregator#
         * @type {object}
         * @default {}
         */
        this.sorterInstance = {};

        /**
         * @memberOf DataSourceAggregator#
         * @type {boolean}
         * @default true
         */
        this.presortGroups = true;

        /**
         * @memberOf DataSourceAggregator#
         * @type {object}
         * @default {}
         */
        this.lastAggregate = {};

        this._schema = [];

        this.setAggregates({});

    },

    get schema() {
        if (this.viewMakesSense()){
            return this._schema;
        } else if (this.dataSource) {
            return this.dataSource.schema;
        }
    },
    set schema(schema) {
        if (this.viewMakesSense()){
            this._schema = schema;
        } else if (this.dataSource) {
            this.dataSource.schema = schema;
        }
    },

    isNullObject: false,

    /**
     * @memberOf DataSourceAggregator#
     * @param aggregations, groups
     */
    setAggregateGroups: function(aggregations, groups) {
        this.setGroupBys(groups);
        this.setAggregates(aggregations);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.lastAggregate = aggregations;
        this.clearAggregations();
        this._schema = [{name: 'Tree'}];

        for (var key in aggregations) {
            this.addAggregate(key, aggregations[key]);
        }

    },

    getFields: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getFields();
        }
        var fields = this.getHeaders().map(function(e) {
            return e.toLowerCase().split(' ').join('_');
        });
        return fields;
    },

    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        var headers = this.schema.map(function(columnSchema) {
            return columnSchema.name;
        });

        return headers;
    },
    /**
     * @memberOf DataSourceAggregator#
     * @param label
     * @param func
     */
    addAggregate: function(label, func) {
        func.header = headerify.transform(label);
        this.aggregates.push(func);
        this.schema.push({
            name: label,
            header: func.header
        });
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param columnIndexArray
     */
    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
        this.setAggregates(this.lastAggregate);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param index
     */
    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {boolean}
     */
    hasGroups: function() {
        return !!this.groupBys.length;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {boolean}
     */
    hasAggregates: function() {
        return !!this.aggregates.length;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @params [options]
     */
    apply: function(options) {
        options  = options || {};
        if (!options.rowClick && !options.columnSort){
            this.buildGroupTree();
        }
    },

    /**
     * @memberOf DataSourceAggregator#
     */
    clearGroups: function() {
        this.groupBys.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator#
     */
    clearAggregations: function() {
        this.aggregates.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator#
     */
    buildGroupTree: function() {
        var reversedGroupBys = this.groupBys.slice(0).reverse(),
            leafDepth = this.groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Totals');

        // first sort data
        if (this.presortGroups) {
            reversedGroupBys.forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            this.groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    factoryDataNode = (c === leafDepth) ? factoryDataNodeLeaf : factoryDataNodeGroup;
                path = path.children.getIfUndefined(key, factoryDataNode);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.toArray();
        tree.getRowData(this);
        this.buildView();
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param dataNode
     */
    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    /**
     * @memberOf DataSourceAggregator#
     */
    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {*|boolean}
     */
    viewMakesSense: function() {
        return this.hasAggregates() && this.hasGroups();
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param {number} columnIndex
     * @returns {*|boolean}
     */
    isDrillDown: function(columnIndex) {
        var result = this.viewMakesSense();
        if (result && columnIndex) {
            result = columnIndex === this.treeColumnIndex;
        }
        return result;
    },

    getDataIndex: function(y) {
        return this.viewMakesSense() ? y : this.dataSource.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }
        var row = this.view[y];
        return row ? row.getValue(x) : null;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param x
     * @param y
     * @param value
     * @returns {*}
     */
    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {*}
     */
    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.schema.length;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {*}
     */
    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param y
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @param {number} [depth=Infinity] - One of:
     * * number > 0 - Apply only if row depth is above the given depth.
     * * number <= 0 - Apply only if row depth is below the given depth.
     * @returns {undefined|boolean} One of:
     * * `undefined` - row was not expandable
     * * `true` - row was expandable _and_ state changed
     * * `false` - row was expandable _but_ state did _not_ change
     */
    click: function(y, expand, depth) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }
        var group = this.view[y], expandable, changed;
        if (
            group && (
                depth === undefined ||
                depth > 0 && group.depth < depth ||
                depth <= 0 && group.depth >= -depth
            )
        ) {
            changed = group.toggleExpansionState(this, expand);
            if ((expandable = group.children)) {
                this.buildView();
            }
        }

        return expandable ? changed : undefined;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {object[]}
     */
    getGrandTotals: function() {
        var view = this.tree;
        return [view.data];
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param y
     * @returns {*}
     */
    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var rollups = this.view[y];

        return rollups ? rollups : this.tree;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    },

    sortGroups: function(groupSorter) {
        this.tree.clearGroupSorts();
        this.tree.sortWith(groupSorter);
        this.buildView();
    }
});

function factoryDataNodeLeaf(key) {
    return new DataNodeLeaf(key);
}

function factoryDataNodeGroup(key) {
    return new DataNodeGroup(key);
}

Object.defineProperty(DataSourceAggregator.prototype, 'type', { value: 'aggregator' }); // read-only property

module.exports = DataSourceAggregator;

},{"./AggregatorNodeGroup":11,"./AggregatorNodeLeaf":12,"./AggregatorNodeTree":13,"./Base":14,"./DataSourceSorter":26,"./util/headerify":33}],22:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

/**
 * @classdesc Sorts on non-terminal tree node rows only (_i.e.,_ expandable rows with children).
 *
 * One of these sorters is created by {@link DataSourceTreeviewSorter} for each grouping level, starting with the maximum group level depth, and then one for each group level through the top level (0) sort depth.
 * @constructor
 * @param dataSource
 * @extends DataSourceIndexed
 */
var DataSourceDepthSorter = DataSourceIndexed.extend('DataSourceDepthSorter', {
    initialize: function(dataSource, treeView) {
        this.idColumnName = treeView.idColumn.name;
        this.parentIdColumnName = treeView.parentIdColumn.name;
    },

    /**
     * @desc Stable-sorts non-terminal tree node rows. Terminal (leaf) rows remain stable.
     * @param {number} groupLevel - If greater than row depth, sorts on an _edge value_ value, which is a value lexically inferior to (ascending sort) or superior to (descending sort) the row value.
     * Otherwise sorts on value of ancestor of this depth.
     *
     * @param {number} [direction=1] - One of:
     * `1` - Sort ascending.
     * `-1` - Sort descending.
     * @param {number} [columnIndex] - Sorts on the values in this column. Otherwise sorts on the row index.
     * @memberOf DataSourceDepthSorter#
     */
    sortOn: function(groupLevel, direction, columnIndex) {
        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                if (this.dataSource.getRowCount()) {
                    var getValue;

                    this.buildIndex();

                    // used in getValue:
                    this.depth = 0;
                    this.edge = direction === -1 ? +Infinity : -Infinity; // for numbers, date objects

                    if (columnIndex === undefined) {
                        getValue = getRowIndex.bind(this);
                    } else {
                        getValue = getColumnValue.bind(this);
                        this.columnName = this.dataSource.getFields()[columnIndex];
                        this.calculator = this.dataSource.getProperty('calculators')[columnIndex];
                        if (typeof getValue(0) === 'string') {
                            this.edge = direction === -1 ? '\uffff' : ''; // for strings
                        }
                    }

                    this.depth = groupLevel;
                    stableSort.sort(this.index, getValue, direction);
                }
                break;
        }
    }
});

function getRowIndex(rowIdx) {
    var parentID,
        dataRow = this.dataSource.getRow(rowIdx);

    if (dataRow.__DEPTH < this.depth) {
        return this.edge;
    }

    rowIdx = this.getDataIndex(rowIdx);

    // bubble up to group label of requested depth while either...
    while (
        // ...this is a leaf row
        dataRow.__EXPANDED === undefined ||
        // ...or: still deeper than the requested depth
        dataRow.__DEPTH > this.depth
    ) {
        parentID = dataRow[this.parentIdColumnName];
        if (parentID == null) { break; }
        dataRow = this.findRow(this.idColumnName, parentID);
        rowIdx = this.getProperty('foundRowIndex');
    }

    return rowIdx;
}

function getColumnValue(rowIdx) {
    var parentID,
        dataRow = this.dataSource.getRow(rowIdx);

    if (dataRow.__DEPTH < this.depth) {
        return this.edge;
    }

    // bubble up to group label of requested depth while either...
    while (
        // ...this is a leaf row
        dataRow.__EXPANDED === undefined ||
        // ...or: still deeper than the requested depth
        dataRow.__DEPTH > this.depth
    ) {
        parentID = dataRow[this.parentIdColumnName];
        if (parentID == null) { break; }
        dataRow = this.findRow(this.idColumnName, parentID);
    }

    return DataSourceIndexed.valOrFunc.call(dataRow, this.columnName, this.calculator);
}

module.exports = DataSourceDepthSorter;

},{"./DataSourceIndexed":25,"./util/stableSort":34}],23:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

/**
 * @interface filterInterface
 */

/**
 * @name filterInterface#test
 * @method
 * @param {object} dataRow - Object representing a row in the grid containing all the fields listed in {@link DataSource#fields|fields}.
 * @returns {boolean}
 * * `true` - include in grid (row passes through filter)
 * * `false` - exclude from grid (row is blocked by filter)
 */

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceGlobalFilter = DataSourceIndexed.extend('DataSourceGlobalFilter', {

    /**
     *
     * @memberOf DataSourceGlobalFilter#
     * @param {filterFunction} [filter] - If undefined, deletes filter.
     */
    set: function(filter) {
        if (filter) {
            /**
             * @implements filterInterface
             * @memberOf DataSourceGlobalFilter#
             */
            this.filter = filter;
        } else {
            delete this.filter;
        }
    },

    get: function(filter) {
        return this.filter;
    },

    sortGroups: function(sorter){
        this.dataSource.sortGroups(sorter);
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter#
     */
    apply: function() {
        if (this.filter && this.filter.test) {
            this.buildIndex(this.filterTest);
        } else {
            this.clearIndex();
        }
    },

    /**
     * @implements filterPredicate
     * @memberOf DataSourceGlobalFilter#
     */
    filterTest: function(r, rowObject) {
        return this.filter.test(rowObject);
    },


    /**
     *
     * @memberOf DataSourceGlobalFilter#
     * @returns {number}
     */
    getRowCount: function() {
        return this.filter && this.filter.test ? this.index.length : this.dataSource.getRowCount();
    }
});

Object.defineProperty(DataSourceGlobalFilter.prototype, 'type', { value: 'filter' }); // read-only property

module.exports = DataSourceGlobalFilter;

},{"./DataSourceIndexed":25}],24:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./DataNodeTree');
var DataNodeGroup = require('./DataNodeGroup');
var DataNodeLeaf = require('./DataNodeLeaf');

/**
 * @constructor
 * @param {DataSource} dataSource
 */
var DataSourceGroupView = Base.extend('DataSourceGroupView', {
    initialize: function(dataSource) {

        /**
         * @memberOf DataSourceGroupView#
         * @type {DataSource}
         */
        this.dataSource = dataSource;

        /**
         * @memberOf DataSourceGroupView#
         * @type {DataNodeTree}
         */
        this.tree = new DataNodeTree('Group');

        /**
         * @memberOf DataSourceGroupView#
         * @type {number[]}
         * @default []
         */
        this.index = [];

        /**
         * @memberOf DataSourceGroupView#
         * @type {Array}
         * @default []
         */
        this.groupBys = [];

        /**
         * @memberOf DataSourceGroupView#
         * @type {Array}
         * @default []
         */
        this.view = [];

        /**
         * @memberOf DataSourceGroupView#
         * @type {object}
         * @default {}
         */
        this.treeColumnIndex = 0;

        /**
         * @memberOf DataSourceGroupView#
         * @type {object}
         * @default {}
         */
        this.sorterInstance = {};

        /**
         * @memberOf DataSourceGroupView#
         * @type {boolean}
         * @default true
         */
        this.presortGroups = true;

        this._schema = [];

    },

    get schema() {
        if (this.viewMakesSense()){
            return this._schema;
        } else if (this.dataSource) {
            return this.dataSource.schema;
        }
    },
    set schema(schema) {
        if (this.viewMakesSense()){
            this._schema = schema;
        } else if (this.dataSource) {
            this.dataSource.schema = schema;
        }
    },

    isNullObject: false,

    getFields: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getFields();
        }
        var fields = this.getHeaders().map(function(e) {
            return e.toLowerCase().split(' ').join('_');
        });
        return fields;
    },

    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        var headers = this.schema.map(function(columnSchema) {
            return columnSchema.name;
        });

        return headers;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param columnIndexArray
     */
    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
        var parentSchema = this.dataSource.schema.slice(0);
        parentSchema.unshift({name: 'Tree'});
        this._schema = parentSchema;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param index
     */
    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @returns {boolean}
     */
    hasGroups: function() {
        return !!this.groupBys.length;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @params [options]
     */
    apply: function(options) {
        options  = options || {};
        if (!options.rowClick && !options.columnSort){
            this.buildGroupTree();
        }
    },

    /**
     * @memberOf DataSourceGroupView#
     */
    clearGroups: function() {
        this.groupBys.length = 0;
    },

    /**
     * @memberOf DataSourceGroupView#
     */
    buildGroupTree: function() {
        var reversedGroupBys = this.groupBys.slice(0).reverse(),
            leafDepth = this.groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Group');

        // first sort data
        if (this.presortGroups) {
            reversedGroupBys.forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            this.groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    factoryDataNode = (c === leafDepth) ? factoryDataNodeLeaf : factoryDataNodeGroup;
                path = path.children.getIfUndefined(key, factoryDataNode);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.toArray();
        tree.getRowData(this);
        this.buildView();
        //this.dump();
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param dataNode
     */
    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    /**
     * @memberOf DataSourceGroupView#
     */
    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @returns {*|boolean}
     */
    viewMakesSense: function() {
        return this.hasGroups();
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param {number} columnIndex
     * @returns {*|boolean}
     */
    isDrillDown: function(columnIndex) {
        var result = this.viewMakesSense();
        if (result && columnIndex) {
            result = columnIndex === this.treeColumnIndex;
        }
        return result;
    },

    getDataIndex: function(y) {
        return this.viewMakesSense() ? y : this.dataSource.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }
        var row = this.view[y];
        return row ? row.getValue(x) : null;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param x
     * @param y
     * @param value
     * @returns {*}
     */
    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    /**
     * @memberOf DataSourceGroupView#
     * @returns {*}
     */
    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.getHeaders().length;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @returns {*}
     */
    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param y
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @param {number} [depth=Infinity] - One of:
     * * number > 0 - Apply only if row depth is above the given depth.
     * * number <= 0 - Apply only if row depth is below the given depth.
     * @returns {undefined|boolean} One of:
     * * `undefined` - row was not expandable
     * * `true` - row was expandable _and_ state changed
     * * `false` - row was expandable _but_ state did _not_ change
     */
    click: function(y, expand, depth) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }
        var group = this.view[y], expandable, changed;
        if (
            group && (
                depth === undefined ||
                depth > 0 && group.depth < depth ||
                depth <= 0 && group.depth >= -depth
            )
        ) {
            changed = group.toggleExpansionState(this, expand);
            if ((expandable = group.children)) {
                this.buildView();
            }
        }

        return expandable ? changed : undefined;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param headers
     */
    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param fields
     * @returns {*}
     */
    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param y
     * @returns {*}
     */
    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var groups = this.view[y];

        return groups ? groups : this.tree;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    },

    sortGroups: function(groupSorter) {
        this.tree.clearGroupSorts();
        this.tree.sortWith(groupSorter);
        this.buildView();
    }
});

function factoryDataNodeLeaf(key) {
    return new DataNodeLeaf(key);
}

function factoryDataNodeGroup(key) {
    return new DataNodeGroup(key);
}

Object.defineProperty(DataSourceGroupView.prototype, 'type', { value: 'groupviewer' }); // read-only property

module.exports = DataSourceGroupView;

},{"./Base":14,"./DataNodeGroup":16,"./DataNodeLeaf":18,"./DataNodeTree":19,"./DataSourceSorter":26}],25:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/**
 * @param dataSource
 * @constructor
 */
var DataSourceIndexed = Base.extend('DataSourceIndexed', {

    isNullObject: false,

    /**
     * @memberOf DataSourceIndexed#
     * @param dataSource
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.index = [];
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param y
     * @returns {*}
     */
    transposeY: function(y) {
        return this.index.length ? this.index[y] : y;
    },

    getDataIndex: function(y) {
        return this.dataSource.getDataIndex(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param y
     * @returns {object}
     */
    getRow: function(y) {
        return this.dataSource.getRow(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param x
     * @param y
     * @returns {*|Mixed}
     */
    getValue: function(x, y) {
        return this.dataSource.getValue(x, this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.dataSource.setValue(x, this.transposeY(y), value);
    },

    /**
     * @memberOf DataSourceIndexed#
     * @returns {Number|*}
     */
    getRowCount: function() {
        return this.index.length || this.dataSource.getRowCount();
    },

    /**
     * @memberOf DataSourceIndexed#
     */
    clearIndex: function() {
        this.index.length = 0;
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param {filterPredicate} predicate
     * @returns {number[]}
     */
    buildIndex: function(predicate) {
        var rowCount = this.dataSource.getRowCount(),
            index = this.index;

        this.clearIndex();

        for (var r = 0; r < rowCount; r++) {
            if (!predicate || predicate.call(this, r, this.dataSource.getRow(r))) {
                index.push(r);
            }
        }

        return index;
    }
});

/** @typedef {function} filterPredicate
 * @summary Applies filter to given row.
 * @this {DataSourceGlobalFilter}
 * @param {nubmer} r - Row index of row data within rows array `this.dataSource.data[]`.
 * @param {object} rowObject - Row data; element of `this.dataSource.data[]`.
 * @returns {boolean} Row qualifies (passes through filter).
 */

/**
 * Used by the sorters (`DataSourceSorter` and `DataSourceTreeviewSorter`).
 * @this {dataRowObject}
 * @param {string} columnName
 * @returns {*}
 */
DataSourceIndexed.valOrFunc = function(columnName, calculator) {
    var result;
    if (this) {
        result = this[columnName];
        calculator = (typeof result)[0] === 'f' && result || calculator;
        if (calculator) {
            result = calculator.call(this, columnName);
        }
    }
    return result;
};

module.exports = DataSourceIndexed;

},{"./Base":14}],26:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorter = DataSourceIndexed.extend('DataSourceSorter', {
    /**
     * @memberOf DataSourceSorter#
     * @param {number} columnIndex
     * @param {number} [direction=1]
     */
    sortOn: function(columnIndex, direction, type) {
        var dataSource = this.dataSource,
            columnSchema = dataSource.schema.find(function(columnSchema, i) {
                return i === columnIndex;
            }),
            columnName = columnSchema && columnSchema.name,
            calculator = dataSource.schema[columnIndex].calculator;

        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                stableSort.sort(this.buildIndex(), getValue, direction, type || dataSource.schema[columnIndex].type);
                break;
        }

        function getValue(rowIdx) {
            var dataRow = dataSource.getRow(rowIdx);
            return DataSourceIndexed.valOrFunc.call(dataRow, columnName, calculator);
        }
    }
});

module.exports = DataSourceSorter;

},{"./DataSourceIndexed":25,"./util/stableSort":34}],27:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var DataSourceSorter = require('./DataSourceSorter');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorterComposite = DataSourceIndexed.extend('DataSourceSorterComposite', {

    /**
     * @memberOf DataSourceSorterComposite#
     */
    initialize: function() {
        /**
         * Caveats:
         *
         * 1. Columns should be uniquely represented (i.e., no repeats with same columnIndex)
         * 2. Columns should be added low- to high-order (i.e., most grouped columns come last)
         *
         * @type {number[]}
         * @memberOf DataSourceSorterComposite#
         */
        this.sorts = [];

        /**
         * @type {DataSource}
         * @memberOf DataSourceSorterComposite#
         */
        this.last = this.dataSource;
    },

    /**
     * @memberOf DataSourceSorterComposite#
     * @param {number} y
     * @returns {Object}
     */
    getRow: function(y) {
        return this.last.getRow(y);
    },

    /**
     * @memberOf DataSourceSorterComposite#
     * @param columnIndex
     * @param direction
     */
    sortOn: function(columnIndex, direction) {
        this.sorts.push({ columnIndex: columnIndex, direction: direction });
    },

    /**
     *
     * @memberOf DataSourceSorterComposite#
     * @param {sorterFunction} [sorter] - If undefined, deletes sorter.
     */
    set: function(sorter) {
        if (sorter) {
            /**
             * @implements sorterInterfacei
             * @memberOf DataSourceSorterComposite#
             */
            this.sorter = sorter;
        } else {
            delete this.sorter;
        }
    },

    get: function() {
        return this.sorter;
    },

    /**
     * @memberOf DataSourceSorterComposite#
     */
    apply: function() {
        var each = this.dataSource;
        // get list of sorts from either API or use existing
        this.sorts = (this.sorter && this.sorter.prop('sorts')) || this.sorts;

        if (this.sorts) {
            this.sorts.forEach(function(sortSpec) {
                each = new DataSourceSorter(each);
                each.sortOn(sortSpec.columnIndex, sortSpec.direction, sortSpec.type);
            });
            this.last = each;
        }
    },

    /**
     * @memberOf DataSourceSorterComposite#
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.last = this.dataSource;
    },

    getDataIndex: function(y) {
        return this.last.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceSorterComposite#
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        return this.last.getValue(x, y);
    },

    /**
     * @memberOf DataSourceSorterComposite#
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.last.setValue(x, y, value);
    }
});

DataSourceSorterComposite.prototype.applySorts = function() {
    (console.warn || console.log).call(console, 'applySorts deprecated; use apply');
    this.apply();
};

Object.defineProperty(DataSourceSorterComposite.prototype, 'type', { value: 'sorter' }); // read-only property

module.exports = DataSourceSorterComposite;

},{"./DataSourceIndexed":25,"./DataSourceSorter":26}],28:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

/** @typedef columnAddress
 * @property {string} name - The name of a column listed in the fields array. See the {@link DataSourceTreeview#getFields|getFields()} method.
 * @property {number} index - The index of the column in the fields array. See the {@link DataSourceTreeview#getFields|getFields()} method.
 */


/**
 * @classdesc For proper sorting, include `DataSourceTreeviewSorter` in your data source pipeline, _ahead of_ (closer to the data than) this data source.
 *
 * For proper filtering, include `DataSourceTreeviewFilter` in your data source pipeline, _ahead of_ `DataSourceTreeviewSorter`, if included; or at any rate ahead of this data source.
 * @constructor
 * @param dataSource
 * @extends DataSourceIndexed
 */
var DataSourceTreeview = DataSourceIndexed.extend('DataSourceTreeview', {

    /** @summary Initialize a new instance.
     * @desc Set up {@link DataSourceTreeviewSorter} access to this object. Access is provided to the whole object although only instance variables `joined`, `idColumn`, and `parentIdColumn` are needed by the sorter. The two ID columns are passed to the {@link DataSourceDepthSorter} constructor. (If dataSource is not the sorter, this is not used but harmless.)
     *
     * Note that all ancestor classes' `initialize` methods are called (top-down) before this one. See {@link http://npmjs.org/extend-me} for more info.
     * @param dataSource
     * @memberOf DataSourceTreeview#
     */
    initialize: function(dataSource) {
        while (dataSource) {
            if (/treeview/i.test(dataSource.$$CLASS_NAME)) {
                dataSource.treeview = this;
            }
            dataSource = dataSource.dataSource;
        }
    },

    /** @summary Reference to the primary key column address object.
     * @desc The primary key column uniquely identifies a data row.
     * Used to relate a child row to a parent row.
     *
     * Redefined each time tree-view is turned *ON* by a call to {@link DataSourceTreeview#setRelation|setRelation()}.
     * @param {number|string} indexOrName
     * @returns {columnAddress} Getter returns column address object; setter however always returns its input.
     */
    set idColumn(indexOrName) {
        this._idColumn = this.getColumnInfo(indexOrName || 'ID');
    },
    get idColumn() {
        return this._idColumn;
    },

    /** @summary Reference to the foreign key column address object.
     * @desc The foreign key column defines grouping; it relates this tree node row to its parent tree node row. Top-level tree nodes have no parent. In that case the value in the column is `null`.
     *
     * Redefined each time tree-view is turned *ON* by a call to {@link DataSourceTreeview#setRelation|setRelation()}.
     * @param {number|string} indexOrName
     * @returns {columnAddress} Getter returns column address object; setter however always returns its input.
     */
    set parentIdColumn(indexOrName) {
        this._parentIdColumn = this.getColumnInfo(indexOrName || 'parentID');
    },
    get parentIdColumn() {
        return this._parentIdColumn;
    },

    /** @summary Reference to the drill-down column address object.
     * @desc The drill-down column is the column that is indented and decorated with drill-down controls (triangles). A column with the given index or name must exist.
     *
     * Redefined each time tree-view is turned *ON* by a call to {@link DataSourceTreeview#setRelation|setRelation()}.
     * @param {number|string} indexOrName
     * @returns {columnAddress} Getter returns column address object; setter however always returns its input.
     */
    set treeColumn(indexOrName) {
        this._treeColumn = this.getColumnInfo(indexOrName || 'name');
    },
    get treeColumn() {
        return this._treeColumn;
    },

    /**
     /** @summary Reference to the group name column address object.
     * @desc The group name column is the column whose content describes the group. A column with the given index or name must exist.
     *
     * The treeview sorter treats the group name column differently than other columns,
     * apply a "group sort" to it, which means only the group rows (rows with children)
     * are sorted and the leaves are left alone (stable sorted).
     *
     * Normally refers to the same column as {@link DataSourceTreeview#treeColumn|treeColumn}.
     *
     * Redefined each time tree-view is turned *ON* by a call to {@link DataSourceTreeview#setRelation|setRelation()}.
     * @param {number|string} indexOrName
     * @returns {columnAddress} Getter returns column address object; setter however always returns its input.
     */
    set groupColumn(indexOrName) {
        this._groupColumn = this.getColumnInfo(indexOrName || this._treeColumn.name);
    },
    get groupColumn() {
        return this._groupColumn;
    },

    /**
     * TEMPORARY. This function included here until next version of base is published.
     * The change was to use schema rather than getFields().
     * (The current version in base is not in use because it's only used from here.)
     *
     * Get new object with name and index given the name or the index.
     * @param {string|number} columnOrIndex - Column name or index.
     * @returns {{name: string, index: number}}
     */
    getColumnInfo: function(columnOrIndex) {
        var name, index, result;

        if (typeof columnOrIndex === 'number') {
            index = columnOrIndex;
            name = this.schema[index].name;
        } else {
            name = columnOrIndex;
            index = this.schema.findIndex(function(columnSchema) {
                return columnSchema.name === name;
            });
        }

        if (name && index >= 0) {
            result = {
                name: name,
                index: index
            };
        }

        return result;
    },

    /**
     * @summary Toggle the tree-view.
     * @desc Calculates or recalculates nesting depth of each row and marks it as "expandable" iff it has children.
     *
     * If resetting previously set data, the state of expansion of all rows that still have children is retained. (All expanded rows will still be expanded when tree-view is turned back *ON*.)
     *
     * All of the columns referenced by the `options` properties `idColumn`, `parentIdColumn`, `treeColumn`, and `groupColumn` must exist. These four columns have default references (names) as listed below. The references may be overridden in `options` by supplying alternate column names or indexes.
     *
     * @param {boolean|object} [options] - Falsy value (or omitted) turns tree-view **OFF**. Truthy value turns tree-view **ON** using following options:
     * @param {number|string} [options.idColumn='ID'] - Name or index of the primary key column.
     * @param {number|string} [options.parentIdColumn='parentID'] - Name or index of the foreign key column for grouping.
     * @param {number|string} [options.treeColumn='name'] - Name or index of the drill-down column to decorate with triangles.
     * @param {number|string} [options.groupColumn=this._treeColumn.name] - Name or index of the column that contains the group names. This is normally the same as the drill-down column. You only need to specify a different value when you want the drill down to this column, such as when the drill-down is in a column of its own. See {@link http://openfin.github.io/fin-hypergrid/tree-view-separate-drill-down.html} for an example.
     * @returns {boolean} Joined state.
     *
     * @memberOf DataSourceTreeview#
     */
    setRelation: function(options) {
        var r, parentID, depth, leafRow, row, ID;

        // successful join requires that options object be given and that all columns exist
        if (!options) {
            this.joined = false;
        } else {
            this.idColumn = options.idColumn;
            this.parentIdColumn = options.parentIdColumn;
            this.treeColumn = options.treeColumn;
            this.groupColumn = options.groupColumn;
            this.joined = !!(this.idColumn && this.parentIdColumn && this.treeColumn && this.groupColumn);
        }

        this.buildIndex(); // make all rows visible to getRow()

        r = this.getRowCount();
        if (this.joined) {
            // mutate data row with __DEPTH (all rows) and __EXPANDED (all "parent" rows)
            var idColumnName = this.idColumn.name,
                parentIdColumnName = this.parentIdColumn.name;

            this.maxDepth = 0;

            while (r--) {
                depth = 0;
                leafRow = this.getRow(r);
                row = leafRow;
                ID = row[idColumnName];

                while ((parentID = row[parentIdColumnName]) != null) {
                    row = this.findRow(idColumnName, parentID);
                    ++depth;
                }

                if (this.maxDepth < depth) {
                    this.maxDepth = depth;
                }

                leafRow.__DEPTH = depth;

                if (!this.findRow(parentIdColumnName, ID)) {
                    delete leafRow.__EXPANDED; // no longer expandable
                } else if (leafRow.__EXPANDED === undefined) { // retain previous setting for old rows
                    leafRow.__EXPANDED = false; // default for new row is unexpanded
                }
            }
        } else {
            // flatten the tree so group sorter sees it as a single group
            while (r--) {
                this.getRow(r).__DEPTH = 0;
            }
        }

        // look for DataSourceTreeviewFilter

        return this.joined;
    },

    /**
     * @summary Rebuild the index.
     * @desc Rebuild the index to show only "revealed" rows. (Rows that are not inside a collapsed parent node row.)
     * @memberOf DataSourceTreeview#
     */
    apply: function() {
        if (!this.viewMakesSense()) {
            this.clearIndex();
        } else {
            this.buildIndex(this.joined && rowIsRevealed);
        }
    },

    /**
     * @summary Get the value for the specified cell.
     * @desc Intercepts tree column values and indents and decorates them.
     * @param x
     * @param y
     * @returns {*}
     * @memberOf DataSourceTreeview#
     */
    getValue: function(x, y) {
        var value = DataSourceIndexed.prototype.getValue.call(this, x, y);

        if (this.viewMakesSense() && x === this._treeColumn.index) {
            var row = this.getRow(y);

            if (!(value === '' && row.__EXPANDED === undefined)) {
                value = Array(row.__DEPTH + 1).join('   ') + this.drillDownCharMap[row.__EXPANDED ? 'OPEN' : 'CLOSE'] + value;
            }
        }

        return value;
    },

    viewMakesSense: function() {
        return this.joined;
    },
    /**
     * @memberOf DataSourceTreeview#
     * @param {number} columnIndex
     * @returns {*|boolean}
     */
    isDrillDown: function(columnIndex) {
        var result = this.viewMakesSense();
        if (result && columnIndex) {
            result = columnIndex === this.treeColumnIndex;
        }
        return result;
    },

    /**
     * @summary Handle a click event in the drill-down column.
     * @desc Operates only on the following rows:
     * * Expandable rows - Rows with a drill-down control.
     * * Revealed rows - Rows not hidden inside of collapsed drill-downs.
     * @param y - Revealed row number. (This is not the row ID.)
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @param {number} [depth=Infinity] - One of:
     * * number > 0 - Apply only if row depth is above the given depth.
     * * number <= 0 - Apply only if row depth is below the given depth.
     * @returns {undefined|boolean} One of:
     * * `undefined` - Row was not expandable.
     * * `true` - Row had drill-down _and_ state changed.
     * * `false` - Row had drill-down _but_ state did _not_ change.
     * @memberOf DataSourceTreeview#
     */
    click: function(y, expand, depth) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }

        var changed, row = this.getRow(y);
        if (row && row.__EXPANDED !== undefined) {
            if (depth !== undefined && (
                depth > 0 && row.__DEPTH >= depth ||
                depth <= 0 && row.__DEPTH < -depth
            )) {
                changed = false;
            } else {
                if (expand === undefined) {
                    expand = !row.__EXPANDED;
                }
                changed = row.__EXPANDED && !expand || !row.__EXPANDED && expand;
                row.__EXPANDED = expand;
            }
        }
        return changed;
    },

    /**
     * @summary Expand nested drill-downs containing this row.
     * @param ID - The unique row ID.
     * @returns {boolean} If any rows expanded.
     * @memberOf DataSourceTreeview#
     */
    revealRow: function(ID) {
        if (!this.viewMakesSense()) {
            return this.dataSource.revealRow.apply(this.dataSource, arguments);
        }

        var row, parent, changed = false;
        while ((row = this.findRow(this._idColumn.name, ID))) {
            if (parent && row.__EXPANDED === false) {
                row.__EXPANDED = changed = true;
            }
            parent = true;
            ID = row[this._parentIdColumn.name];
        }
        return changed;
    }
});

function rowIsRevealed(r, row) {
    var parentID;

    // are any of the row's ancestors collapsed?
    while ((parentID = row[this._parentIdColumn.name]) != null) {
        // walk up through each parent...
        row = this.findRow(this._idColumn.name, parentID);
        if (row.__EXPANDED === false) { // an ancestor is collapsed
            return false; // exclude row from build
        }
    }

    // no ancestors were collapsed
    return true; // include row in build
}

Object.defineProperty(DataSourceTreeview.prototype, 'type', { value: 'treeviewer' }); // read-only property

module.exports = DataSourceTreeview;

},{"./DataSourceIndexed":25}],29:[function(require,module,exports){
'use strict';

var DataSourceGlobalFilter = require('./DataSourceGlobalFilter');

/**
 * @classdesc Should be positioned in the data source pipeline _ahead of_ (closer to the data than) the optional `DataSourceTreeviewSorter` and the required `DataSourceTreeview` (which sets `this.treeview`).
 * @constructor
 * @param dataSource
 * @extends DataSourceSorterComposite
 * @extends DataSourceGlobalFilter
 */
var DataSourceTreeviewFilter = DataSourceGlobalFilter.extend('DataSourceTreeviewFilter', {

    /**
     * @implements filterPredicate
     * @memberOf DataSourceGlobalFilter#
     */
    filterTest: function(r, rowObject) {
        return this.treeview.viewMakesSense() && rowObject.__EXPANDED !== undefined || this.filter.test(rowObject);
    }

});

module.exports = DataSourceTreeviewFilter;

},{"./DataSourceGlobalFilter":23}],30:[function(require,module,exports){
'use strict';

var DataSourceSorterComposite = require('./DataSourceSorterComposite');
var DataSourceDepthSorter = require('./DataSourceDepthSorter');
var DataSourceSorter = require('./DataSourceSorter');

/**
 * @classdesc Should be positioned in the data source pipeline _ahead of_ (closer to the data than) the required `DataSourceTreeview` (which sets `this.treeview`) but _behind_ the optional `DataSourceTreeviewFilter`.
 * @constructor
 * @param dataSource
 * @extends DataSourceSorterComposite
 */
var DataSourceTreeviewSorter = DataSourceSorterComposite.extend('DataSourceTreeviewSorter', {

    /**
     * @summary Rebuild the index.
     * @memberOf DataSourceSorterComposite#
     */
    apply: function() {
        var joined = this.treeview.viewMakesSense(),
            each = this.dataSource,
            last, // last sort spec ("first" sort) when and only when joined AND it is the group column
            lastIsGroup, columnIndex, direction;
        // get list of sorts from either API or use existing
        this.sorts = (this.sorter && this.sorter.prop('sorts')) || this.sorts;

        if (this.sorts.length) {
            if (joined) {
                last = this.sorts[this.sorts.length - 1];
                lastIsGroup = last.columnIndex === this.treeview.groupColumn.index;
            }

            this.sorts.forEach(function(sortSpec) {
                if (!(lastIsGroup && sortSpec === last)) {
                    each = new DataSourceSorter(each);
                    each.sortOn(sortSpec.columnIndex, sortSpec.direction);
                }
            });
        }

        if (joined) {
            if (lastIsGroup || this.sorts.length === 1) {
                columnIndex = last.columnIndex;
                direction = last.direction;
            } else {
                columnIndex = undefined;
                direction = 1;
            }

            // Finally, apply a "depth sort" to either the group column (if last) or the ID column to group it properly
            for (var depth = this.treeview.maxDepth; depth >= 0; --depth) {
                each = new DataSourceDepthSorter(each, this.treeview);
                each.sortOn(depth, direction, columnIndex);
            }
        }

        this.last = each;
    }

});

module.exports = DataSourceTreeviewSorter;

},{"./DataSourceDepthSorter":22,"./DataSourceSorter":26,"./DataSourceSorterComposite":27}],31:[function(require,module,exports){
'use strict';

/**
 * @constructor
 */
function Mappy() {
    this.keys = [];
    this.data = {};
    this.values = [];
}

Mappy.prototype = {

    constructor: Mappy.prototype.constructor, // preserve constructor

    /**
     * @memberOf Mappy#
     * @param key
     * @param value
     */
    set: function(key, value) {
        var hashCode = hash(key);
        if (!(hashCode in this.data)) {
            this.keys.push(key);
            this.values.push(value);
        }
        this.data[hashCode] = value;
    },

    /**
     * @memberOf Mappy#
     * @param key
     * @returns {*}
     */
    get: function(key) {
        var hashCode = hash(key);
        return this.data[hashCode];
    },

    /**
     *
     * @memberOf Mappy#
     * @param key
     * @param {function} ifUndefinedFunc - Value getter when value is otherwise undefined.
     * @returns {*}
     */
    getIfUndefined: function(key, ifUndefinedFunc) {
        var value = this.get(key);
        if (value === undefined) {
            value = ifUndefinedFunc(key);
            this.set(key, value);
        }
        return value;
    },

    size: function() {
        return this.keys.length;
    },

    /**
     * @memberOf Mappy#
     */
    clear: function() {
        this.keys.length = 0;
        this.values.length = 0;
        this.data = {};
    },

    /**
     * @memberOf Mappy#
     * @param key
     */
    delete: function(key) {
        var hashCode = hash(key);
        if (this.data[hashCode] !== undefined) {
            var index = betterIndexOf(this.keys, key);
            this.keys.splice(index, 1);
            this.values.splice(index, 1);
            delete this.data[hashCode];
        }
    },

    /**
     * @memberOf Mappy#
     * @param {function} iteratee
     */
    forEach: function(iteratee) {
        if (typeof iteratee === 'function') {
            var keys = this.keys,
                self = this;
            keys.forEach(function(key) {
                var value = self.get(key);
                iteratee(value, key, self);
            });
        }
    },

    /**
     * @memberOf Mappy#
     * @param {function} iteratee
     * @returns {Mappy}
     */
    map: function(iteratee) {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;

        if (!(typeof iteratee === 'function')) {
            iteratee = reflection;
        }

        keys.forEach(function(key) {
            var value = self.get(key),
                transformed = iteratee(value, key, self);
            newMap.set(key, transformed);
        });
        return newMap;
    },

    /**
     * @memberOf Mappy#
     * @returns {Mappy}
     */
    copy: function() {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            newMap.set(key, value);
        });
        return newMap;
    }

};

var OID_PREFIX = '.~.#%_'; //this should be something we never will see at the beginning of a string
var counter = 0;

function hash(key) {
    var typeOf = typeof key;

    switch (typeOf) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'symbol':
            return OID_PREFIX + typeOf + '_' + key;

        case 'undefined':
            return 'UNDEFINED';

        case 'object':
            if (key === null) {
                return 'NULL';
            }
            // fall through when not null:
        case 'function':
            return (key.___finhash = key.___finhash || OID_PREFIX + counter++);
    }
}

// Object.is polyfill, courtesy of @WebReflection
var is = Object.is || function(a, b) {
    return a === b ? a !== 0 || 1 / a == 1 / b : a != a && b != b; // eslint-disable-line eqeqeq
};

function reflection(val) {
    return val;
}

// More reliable indexOf, courtesy of @WebReflection
function betterIndexOf(arr, value) {
    if (value != value || value === 0) { // eslint-disable-line eqeqeq
        var i = arr.length;
        while (i-- && !is(arr[i], value)) {
            // eslint-disable-line no-empty
        }
    } else {
        i = [].indexOf.call(arr, value);
    }
    return i;
}

module.exports = Mappy;

},{}],32:[function(require,module,exports){
'use strict';

/**
 * @module aggregations
 */

/**
 * @typedef {function} aggregationFunction
 * @summary A bound function.
 * @desc An aggregation function bound to the `columnIndex` value supplied to one of the above factory functions.
 * @param {object} group
 * @returns {*} Aggregated value.
 */

module.exports = {
    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    count: function(columnIndex) {
        return count;
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    sum: function(columnIndex) {
        return sum.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    min: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.min, Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    max: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.max, -Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    avg: function(columnIndex) {
        return avg.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    first: function(columnIndex) {
        return first.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    last: function(columnIndex) {
        return last.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    stddev: function(columnIndex) {
        return stddev.bind(this, columnIndex);
    }
};

function count(group) {
    return group.getRowCount();
}

function sum(columnIndex, group) {
    var r = group.getRowCount(),
        n = 0;

    while (r--) {
        n += group.getValue(columnIndex, r);
    }

    return n;
}

function minmax(columnIndex, method, n, group) {
    var r = group.getRowCount();

    while (r--) {
        n = method(n, group.getValue(columnIndex, r));
    }

    return n;
}

function avg(columnIndex, group) {
    return sum(columnIndex, group) / group.getRowCount();
}

function first(columnIndex, group) {
    return group.getValue(columnIndex, 0);
}

function last(columnIndex, group) {
    return group.getValue(columnIndex, group.getRowCount() - 1);
}

function stddev(columnIndex, group) {
    var rows = group.getRowCount(),
        mean = avg(columnIndex, group);

    for (var dev, r = rows, variance = 0; r--; variance += dev * dev) {
        dev = group.getValue(columnIndex, r) - mean;
    }

    return Math.sqrt(variance / rows);
}

},{}],33:[function(require,module,exports){
'use strict';

// NOTE: For backwards compatibility, `capitalize` is still a function, doubling now as the API.

function capitalize(string) {
    return (/[a-z]/.test(string) ? string : string.toLowerCase())
        .replace(/[\s\-_]*([^\s\-_])([^\s\-_]+)/g, replacer)
        .replace(/[A-Z]/g, ' $&')
        .trim();
}

function replacer(a, b, c) {
    return b.toUpperCase() + c;
}

function set(methodName) {
    capitalize.transform = capitalize[methodName];
}

function passthrough(string) {
    return string;
}

capitalize.transform = passthrough;
capitalize.set = set;
capitalize.passthrough = passthrough;
capitalize.capitalize = capitalize;

module.exports = capitalize;

},{}],34:[function(require,module,exports){
'use strict';

/**
 * Note that {@link module:stableSort#sort|sort()} is the only exposed method.
 * @module stableSort
 */

/**
 * @private
 * @instance
 * @param {function} comparator
 * @param {boolean} descending
 * @param {Array} arr1
 * @param {Array} arr2
 * @returns {function}
 */
function stabilize(comparator, descending, arr1, arr2) { // eslint-disable-line no-shadow
    var x = arr1[0];
    var y = arr2[0];

    if (x === y) {
        x = descending ? arr2[1] : arr1[1];
        y = descending ? arr1[1] : arr2[1];
    } else {
        if (y === null) {
            return -1;
        }
        if (x === null) {
            return 1;
        }
    }

    return comparator(x, y);
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingNumbers(x, y) {
    return x - y;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingNumbers(x, y) {
    return y - x;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingAllOthers(x, y) {
    return x < y ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingAllOthers(x, y) {
    return y < x ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:ascending)}
 */
function ascending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? ascendingNumbers : ascendingAllOthers, false);
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:descending)}
 */
function descending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? descendingNumbers : descendingAllOthers, true);
}

/**
 * @instance
 * @param {number} index
 * @param {function} getValue
 * @param {number} [direction=1]
 */
function sort(index, getValue, direction, type) {

    var compare, i;

    // apply defaults
    if (direction === undefined) {
        direction = 1;
    }

    if (index.length) { // something to do
        switch (direction) {
            case 0:
                return; // bail: nothing to sort

            case undefined: // eslint-disable-line no-fallthrough
                direction = 1;
            case 1:  // eslint-disable-line no-fallthrough
                compare = ascending(type || typeof getValue(0));
                break;

            case -1:
                compare = descending(type || typeof getValue(0));
                break;
        }

        // set up the sort.....
        var tmp = new Array(index.length);

        // add the index for "stability"
        for (i = 0; i < index.length; i++) {
            tmp[i] = [getValue(i), i];
        }

        // do the actual sort
        tmp.sort(compare);

        // copy the sorted values into our index vector
        for (i = 0; i < index.length; i++) {
            index[i] = tmp[i][1];
        }
    }

}

exports.sort = sort;

},{}],35:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
      case '#':
      case '^':
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case '/':
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
    case -1:
      match = this.tail;
      this.tail = '';
      break;
    case 0:
      match = '';
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.2.0';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],36:[function(require,module,exports){
/* object-iterators.js - Mini Underscore library
 * by Jonathan Eiten
 *
 * The methods below operate on objects (but not arrays) similarly
 * to Underscore (http://underscorejs.org/#collections).
 *
 * For more information:
 * https://github.com/joneit/object-iterators
 */

'use strict';

/**
 * @constructor
 * @summary Wrap an object for one method call.
 * @Desc Note that the `new` keyword is not necessary.
 * @param {object|null|undefined} object - `null` or `undefined` is treated as an empty plain object.
 * @return {Wrapper} The wrapped object.
 */
function Wrapper(object) {
    if (object instanceof Wrapper) {
        return object;
    }
    if (!(this instanceof Wrapper)) {
        return new Wrapper(object);
    }
    this.originalValue = object;
    this.o = object || {};
}

/**
 * @name Wrapper.chain
 * @summary Wrap an object for a chain of method calls.
 * @Desc Calls the constructor `Wrapper()` and modifies the wrapper for chaining.
 * @param {object} object
 * @return {Wrapper} The wrapped object.
 */
Wrapper.chain = function (object) {
    var wrapped = Wrapper(object); // eslint-disable-line new-cap
    wrapped.chaining = true;
    return wrapped;
};

Wrapper.prototype = {
    /**
     * Unwrap an object wrapped with {@link Wrapper.chain|Wrapper.chain()}.
     * @return {object|null|undefined} The value originally wrapped by the constructor.
     * @memberOf Wrapper.prototype
     */
    value: function () {
        return this.originalValue;
    },

    /**
     * @desc Mimics Underscore's [each](http://underscorejs.org/#each) method: Iterate over the members of the wrapped object, calling `iteratee()` with each.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is undefined; an `.each` loop cannot be broken out of (use {@link Wrapper#find|.find} instead).
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {Wrapper} The wrapped object for chaining.
     * @memberOf Wrapper.prototype
     */
    each: function (iteratee, context) {
        var o = this.o;
        Object.keys(o).forEach(function (key) {
            iteratee.call(this, o[key], key, o);
        }, context || o);
        return this;
    },

    /**
     * @desc Mimics Underscore's [find](http://underscorejs.org/#find) method: Look through each member of the wrapped object, returning the first one that passes a truth test (`predicate`), or `undefined` if no value passes the test. The function returns the value of the first acceptable member, and doesn't necessarily traverse the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The found property's value, or undefined if not found.
     * @memberOf Wrapper.prototype
     */
    find: function (predicate, context) {
        var o = this.o;
        var result;
        if (o) {
            result = Object.keys(o).find(function (key) {
                return predicate.call(this, o[key], key, o);
            }, context || o);
            if (result !== undefined) {
                result = o[result];
            }
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [filter](http://underscorejs.org/#filter) method: Look through each member of the wrapped object, returning the values of all members that pass a truth test (`predicate`), or empty array if no value passes the test. The function always traverses the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    filter: function (predicate, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                if (predicate.call(this, o[key], key, o)) {
                    result.push(o[key]);
                }
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [map](http://underscorejs.org/#map) method: Produces a new array of values by mapping each value in list through a transformation function (`iteratee`). The function always traverses the entire object.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is concatenated to the end of the new array.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    map: function (iteratee, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                result.push(iteratee.call(this, o[key], key, o));
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [reduce](http://underscorejs.org/#reduce) method: Boil down the values of all the members of the wrapped object into a single value. `memo` is the initial state of the reduction, and each successive step of it should be returned by `iteratee()`.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with four arguments: `(memo, value, key, object)`. The return value of this function becomes the new value of `memo` for the next iteration.
     * @param {*} [memo] - If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The value of `memo` "reduced" as per `iteratee`.
     * @memberOf Wrapper.prototype
     */
    reduce: function (iteratee, memo, context) {
        var o = this.o;
        if (o) {
            Object.keys(o).forEach(function (key, idx) {
                memo = (!idx && memo === undefined) ? o[key] : iteratee(memo, o[key], key, o);
            }, context || o);
        }
        return memo;
    },

    /**
     * @desc Mimics Underscore's [extend](http://underscorejs.org/#extend) method: Copy all of the properties in each of the `source` object parameter(s) over to the (wrapped) destination object (thus mutating it). It's in-order, so the properties of the last `source` object will override properties with the same name in previous arguments or in the destination object.
     * > This method copies own members as well as members inherited from prototype chain.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extend: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            if (object) {
                for (var key in object) {
                    o[key] = object[key];
                }
            }
        });
        return this.chaining ? this : o;
    },

    /**
     * @desc Mimics Underscore's [extendOwn](http://underscorejs.org/#extendOwn) method: Like {@link Wrapper#extend|extend}, but only copies its "own" properties over to the destination object.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extendOwn: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            Wrapper(object).each(function (val, key) { // eslint-disable-line new-cap
                o[key] = val;
            });
        });
        return this.chaining ? this : o;
    }
};

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
if (!Array.prototype.find) {
    Array.prototype.find = function (predicate) { // eslint-disable-line no-extend-native
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

module.exports = Wrapper;

},{}],37:[function(require,module,exports){
'use strict';

/** @module overrider */

/**
 * Mixes members of all `sources` into `target`, handling getters and setters properly.
 *
 * Any number of `sources` objects may be given and each is copied in turn.
 *
 * @example
 * var overrider = require('overrider');
 * var target = { a: 1 }, source1 = { b: 2 }, source2 = { c: 3 };
 * target === overrider(target, source1, source2); // true
 * // target object now has a, b, and c; source objects untouched
 *
 * @param {object} object - The target object to receive sources.
 * @param {...object} [sources] - Object(s) containing members to copy to `target`. (Omitting is a no-op.)
 * @returns {object} The target object (`target`)
 */
function overrider(target, sources) { // eslint-disable-line no-unused-vars
    for (var i = 1; i < arguments.length; ++i) {
        mixIn.call(target, arguments[i]);
    }

    return target;
}

/**
 * Mix `this` members into `target`.
 *
 * @example
 * // A. Simple usage (using .call):
 * var mixInTo = require('overrider').mixInTo;
 * var target = { a: 1 }, source = { b: 2 };
 * target === overrider.mixInTo.call(source, target); // true
 * // target object now has both a and b; source object untouched
 *
 * @example
 * // B. Semantic usage (when the source hosts the method):
 * var mixInTo = require('overrider').mixInTo;
 * var target = { a: 1 }, source = { b: 2, mixInTo: mixInTo };
 * target === source.mixInTo(target); // true
 * // target object now has both a and b; source object untouched
 *
 * @this {object} Target.
 * @param target
 * @returns {object} The target object (`target`)
 * @memberOf module:overrider
 */
function mixInTo(target) {
    var descriptor;
    for (var key in this) {
        if ((descriptor = Object.getOwnPropertyDescriptor(this, key))) {
            Object.defineProperty(target, key, descriptor);
        }
    }
    return target;
}

/**
 * Mix `source` members into `this`.
 *
 * @example
 * // A. Simple usage (using .call):
 * var mixIn = require('overrider').mixIn;
 * var target = { a: 1 }, source = { b: 2 };
 * target === overrider.mixIn.call(target, source) // true
 * // target object now has both a and b; source object untouched
 *
 * @example
 * // B. Semantic usage (when the target hosts the method):
 * var mixIn = require('overrider').mixIn;
 * var target = { a: 1, mixIn: mixIn }, source = { b: 2 };
 * target === target.mixIn(source) // true
 * // target now has both a and b (and mixIn); source untouched
 *
 * @param source
 * @returns {object} The target object (`this`)
 * @memberOf overrider
 * @memberOf module:overrider
 */
function mixIn(source) {
    var descriptor;
    for (var key in source) {
        if ((descriptor = Object.getOwnPropertyDescriptor(source, key))) {
            Object.defineProperty(this, key, descriptor);
        }
    }
    return this;
}

overrider.mixInTo = mixInTo;
overrider.mixIn = mixIn;

module.exports = overrider;

},{}],38:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var REGEXP_INDIRECTION = /^(\w+)\((\w+)\)$/;  // finds complete pattern a(b) where both a and b are regex "words"

/** @typedef {object} valueItem
 * You should supply both `name` and `alias` but you could omit one or the other and whichever you provide will be used for both.
 * > If you only give the `name` property, you might as well just give a string for {@link menuItem} rather than this object.
 * @property {string} [name=alias] - Value of `value` attribute of `<option>...</option>` element.
 * @property {string} [alias=name] - Text of `<option>...</option>` element.
 * @property {string} [type] One of the keys of `this.converters`. If not one of these (including `undefined`), field values will be tested with a string comparison.
 * @property {boolean} [hidden=false]
 */

/** @typedef {object|menuItem[]} submenuItem
 * @summary Hierarchical array of select list items.
 * @desc Data structure representing the list of `<option>...</option>` and `<optgroup>...</optgroup>` elements that make up a `<select>...</select>` element.
 *
 * > Alternate form: Instead of an object with a `menu` property containing an array, may itself be that array. Both forms have the optional `label` property.
 * @property {string} [label] - Defaults to a generated string of the form "Group n[.m]..." where each decimal position represents a level of the optgroup hierarchy.
 * @property {menuItem[]} submenu
 */

/** @typedef {string|valueItem|submenuItem} menuItem
 * May be one of three possible types that specify either an `<option>....</option>` element or an `<optgroup>....</optgroup>` element as follows:
 * * If a `string`, specifies the text of an `<option>....</option>` element with no `value` attribute. (In the absence of a `value` attribute, the `value` property of the element defaults to the text.)
 * * If shaped like a {@link valueItem} object, specifies both the text and value of an `<option....</option>` element.
 * * If shaped like a {@link submenuItem} object (or its alternate array form), specifies an `<optgroup>....</optgroup>` element.
 */

/**
 * @summary Builds a new menu pre-populated with items and groups.
 * @desc This function creates a new pop-up menu (a.k.a. "drop-down"). This is a `<select>...</select>` element, pre-populated with items (`<option>...</option>` elements) and groups (`<optgroup>...</optgroup>` elements).
 * > Bonus: This function also builds `input type=text` elements.
 * > NOTE: This function generates OPTGROUP elements for subtrees. However, note that HTML5 specifies that OPTGROUP elemnents made not nest! This function generates the markup for them but they are not rendered by most browsers, or not completely. Therefore, for now, do not specify more than one level subtrees. Future versions of HTML may support it. I also plan to add here options to avoid OPTGROUPS entirely either by indenting option text, or by creating alternate DOM nodes using `<li>` instead of `<select>`, or both.
 * @memberOf popMenu
 *
 * @param {Element|string} el - Must be one of (case-sensitive):
 * * text box - an `HTMLInputElement` to use an existing element or `'INPUT'` to create a new one
 * * drop-down - an `HTMLSelectElement` to use an existing element or `'SELECT'` to create a new one
 * * submenu - an `HTMLOptGroupElement` to use an existing element or `'OPTGROUP'` to create a new one (meant for internal use only)
 *
 * @param {menuItem[]} [menu] - Hierarchical list of strings to add as `<option>...</option>` or `<optgroup>....</optgroup>` elements. Omitting creates a text box.
 *
 * @param {null|string} [options.prompt=''] - Adds an initial `<option>...</option>` element to the drop-down with this value in parentheses as its `text`; and empty string as its `value`. Default is empty string, which creates a blank prompt; `null` suppresses prompt altogether.
 *
 * @param {boolean} [options.sort] - Whether to alpha sort or not. If truthy, sorts each optgroup on its `label`; and each select option on its text (its `alias` if given; or its `name` if not).
 *
 * @param {string[]} [options.blacklist] - Optional list of menu item names to be ignored.
 *
 * @param {number[]} [options.breadcrumbs] - List of option group section numbers (root is section 0). (For internal use.)
 *
 * @param {boolean} [options.append=false] - When `el` is an existing `<select>` Element, giving truthy value adds the new children without first removing existing children.
 *
 * @returns {Element} Either a `<select>` or `<optgroup>` element.
 */
function build(el, menu, options) {
    options = options || {};

    var prompt = options.prompt,
        blacklist = options.blacklist,
        sort = options.sort,
        breadcrumbs = options.breadcrumbs || [],
        path = breadcrumbs.length ? breadcrumbs.join('.') + '.' : '',
        subtreeName = popMenu.subtree,
        groupIndex = 0,
        tagName;

    if (el instanceof Element) {
        tagName = el.tagName;
        if (!options.append) {
            el.innerHTML = ''; // remove all <option> and <optgroup> elements
        }
    } else {
        tagName = el;
        el = document.createElement(tagName);
    }

    if (menu) {
        var add, newOption;
        if (tagName === 'SELECT') {
            add = el.add;
            if (prompt) {
                newOption = new Option(prompt, '');
                newOption.innerHTML += '&hellip;';
                el.add(newOption);
            } else if (prompt !== null) {
                el.add(new Option());
            }
        } else {
            add = el.appendChild;
            el.label = prompt;
        }

        if (sort) {
            menu = menu.slice().sort(itemComparator); // sorted clone
        }

        menu.forEach(function(item) {
            // if item is of form a(b) and there is an function a in options, then item = options.a(b)
            if (options && typeof item === 'string') {
                var indirection = item.match(REGEXP_INDIRECTION);
                if (indirection) {
                    var a = indirection[1],
                        b = indirection[2],
                        f = options[a];
                    if (typeof f === 'function') {
                        item = f(b);
                    } else {
                        throw 'build: Expected options.' + a + ' to be a function.';
                    }
                }
            }

            var subtree = item[subtreeName] || item;
            if (subtree instanceof Array) {

                var groupOptions = {
                    breadcrumbs: breadcrumbs.concat(++groupIndex),
                    prompt: item.label || 'Group ' + path + groupIndex,
                    options: sort,
                    blacklist: blacklist
                };

                var optgroup = build('OPTGROUP', subtree, groupOptions);

                if (optgroup.childElementCount) {
                    el.appendChild(optgroup);
                }

            } else if (typeof item !== 'object') {

                if (!(blacklist && blacklist.indexOf(item) >= 0)) {
                    add.call(el, new Option(item));
                }

            } else if (!item.hidden) {

                var name = item.name || item.alias;
                if (!(blacklist && blacklist.indexOf(name) >= 0)) {
                    add.call(el, new Option(
                        item.alias || item.name,
                        name
                    ));
                }

            }
        });
    } else {
        el.type = 'text';
    }

    return el;
}

function itemComparator(a, b) {
    a = a.alias || a.name || a.label || a;
    b = b.alias || b.name || b.label || b;
    return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * @summary Recursively searches the context array of `menuItem`s for a named `item`.
 * @memberOf popMenu
 * @this Array
 * @param {object} [options]
 * @param {string} [options.keys=[popMenu.defaultKey]] - Properties to search each menuItem when it is an object.
 * @param {boolean} [options.caseSensitive=false] - Ignore case while searching.
 * @param {string} value - Value to search for.
 * @returns {undefined|menuItem} The found item or `undefined` if not found.
 */
function lookup(options, value) {
    if (arguments.length === 1) {
        value = options;
        options = undefined;
    }

    var shallow, deep, item, prop,
        keys = options && options.keys || [popMenu.defaultKey],
        caseSensitive = options && options.caseSensitive;

    value = toString(value, caseSensitive);

    shallow = this.find(function(item) {
        var subtree = item[popMenu.subtree] || item;

        if (subtree instanceof Array) {
            return (deep = lookup.call(subtree, options, value));
        }

        if (typeof item !== 'object') {
            return toString(item, caseSensitive) === value;
        } else {
            for (var i = 0; i < keys.length; ++i) {
                prop = item[keys[i]];
                if (prop && toString(prop, caseSensitive) === value) {
                    return true;
                }
            }
        }
    });

    item = deep || shallow;

    return item && (item.name ? item : { name: item });
}

function toString(s, caseSensitive) {
    var result = '';
    if (s) {
        result += s; // convert s to string
        if (!caseSensitive) {
            result = result.toUpperCase();
        }
    }
    return result;
}

/**
 * @summary Recursively walks the context array of `menuItem`s and calls `iteratee` on each item therein.
 * @desc `iteratee` is called with each item (terminal node) in the menu tree and a flat 0-based index. Recurses on member with name of `popMenu.subtree`.
 *
 * The node will always be a {@link valueItem} object; when a `string`, it is boxed for you.
 *
 * @memberOf popMenu
 *
 * @this Array
 *
 * @param {function} iteratee - For each item in the menu, `iteratee` is called with:
 * * the `valueItem` (if the item is a primative string, it is wrapped up for you)
 * * a 0-based `ordinal`
 *
 * The `iteratee` return value can be used to replace the item, as follows:
 * * `undefined` - do nothing
 * * `null` - splice out the item; resulting empty submenus are also spliced out (see note)
 * * anything else - replace the item with this value; if value is a subtree (i.e., an array) `iteratee` will then be called to walk it as well (see note)
 *
 * > Note: Returning anything (other than `undefined`) from `iteratee` will (deeply) mutate the original `menu` so you may want to copy it first (deeply, including all levels of array nesting but not the terminal node objects).
 *
 * @returns {number} Number of items (terminal nodes) in the menu tree.
 */
function walk(iteratee) {
    var menu = this,
        ordinal = 0,
        subtreeName = popMenu.subtree,
        i, item, subtree, newVal;

    for (i = menu.length - 1; i >= 0; --i) {
        item = menu[i];
        subtree = item[subtreeName] || item;

        if (!(subtree instanceof Array)) {
            subtree = undefined;
        }

        if (!subtree) {
            newVal = iteratee(item.name ? item : { name: item }, ordinal);
            ordinal += 1;

            if (newVal !== undefined) {
                if (newVal === null) {
                    menu.splice(i, 1);
                    ordinal -= 1;
                } else {
                    menu[i] = item = newVal;
                    subtree = item[subtreeName] || item;
                    if (!(subtree instanceof Array)) {
                        subtree = undefined;
                    }
                }
            }
        }

        if (subtree) {
            ordinal += walk.call(subtree, iteratee);
            if (subtree.length === 0) {
                menu.splice(i, 1);
                ordinal -= 1;
            }
        }
    }

    return ordinal;
}

/**
 * @summary Format item name with it's alias when available.
 * @memberOf popMenu
 * @param {string|valueItem} item
 * @returns {string} The formatted name and alias.
 */
function formatItem(item) {
    var result = item.name || item;
    if (item.alias) {
        result = '"' + item.alias + '" (' + result + ')';
    }
    return result;
}


function isGroupProxy(s) {
    return REGEXP_INDIRECTION.test(s);
}

/**
 * @namespace
 */
var popMenu = {
    build: build,
    walk: walk,
    lookup: lookup,
    formatItem: formatItem,
    isGroupProxy: isGroupProxy,
    subtree: 'submenu',
    defaultKey: 'name'
};

module.exports = popMenu;

},{}],39:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

/**
 * Creates a new read-only property and attaches it to the provided context.
 * @private
 * @param {string} name - Name for new property.
 * @param {*} [value] - Value of new property.
 */
function addReadOnlyProperty(name, value) {
    Object.defineProperty(this, name, {
        value: value,
        writable: false,
        enumerable: true,
        configurable: false
    });
}

/**
 * @constructor Point
 *
 * @desc This object represents a single point in an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} x - the new point's `x` property
 * @param {number} y - the new point's `y` property
 */
function Point(x, y) {

    /**
     * @name x
     * @type {number}
     * @summary This point's horizontal coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'x', Number(x) || 0);

    /**
     * @name y
     * @type {number}
     * @summary This point's vertical coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'y', Number(y) || 0);

}

Point.prototype = {

    /**
     * @returns {Point} A new point which is this point's position increased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to add to this point's coordinates.
     * @memberOf Point.prototype
     */
    plus: function(offset) {
        return new Point(
            this.x + offset.x,
            this.y + offset.y
        );
    },

    /**
     * @returns {Point} A new point which is this point's position increased by given offsets.
     * @param {number} [offsetX=0] - Value to add to this point's horizontal coordinate.
     * @param {number} [offsetY=0] - Value to add to this point's horizontal coordinate.
     * @memberOf Point.prototype
     */
    plusXY: function(offsetX, offsetY) {
        return new Point(
            this.x + (offsetX || 0),
            this.y + (offsetY || 0)
        );
    },

    /**
     * @returns {Point} A new point which is this point's position decreased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to subtract from this point's coordinates.
     * @memberOf Point.prototype
     */
    minus: function(offset) {
        return new Point(
            this.x - offset.x,
            this.y - offset.y
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to least x and least y of this point and given `offset`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    min: function(point) {
        return new Point(
            Math.min(this.x, point.x),
            Math.min(this.y, point.y)
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to greatest x and greatest y of this point and given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    max: function(point) {
        return new Point(
            Math.max(this.x, point.x),
            Math.max(this.y, point.y)
        );
    },

    /**
     * @returns {number} Distance between given `point` and this point using Pythagorean Theorem formula.
     * @param {Point} point - A point from which to compute the distance to this point.
     * @memberOf Point.prototype
     */
    distance: function(point) {
        var deltaX = point.x - this.x,
            deltaY = point.y - this.y;

        return Math.sqrt(
            deltaX * deltaX +
            deltaY * deltaY
        );
    },

    /**
     * _(Formerly: `equal`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are exactly equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    equals: function(point) {
        var result = false;

        if (point) {
            result =
                this.x === point.x &&
                this.y === point.y;
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThan: function(point) {
        return (
            this.x > point.x &&
            this.y > point.y
        );
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    lessThan: function(point) {
        return (
            this.x < point.x &&
            this.y < point.y
        );
    },

    /**
     * _(Formerly `greaterThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThanOrEqualTo: function(point) {
        return (
            this.x >= point.x &&
            this.y >= point.y
        );
    },

    /**
     * _(Formerly `lessThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    lessThanOrEqualTo: function(point) {
        return (
            this.x <= point.x &&
            this.y <= point.y
        );
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @param rect {Rectangle} - Rectangle to test this point against.
     * @returns {boolean} `true` iff this point is within given `rect`.
     * @memberOf Point.prototype
     */
    within: function(rect) {
        var minX = rect.origin.x,
            maxX = minX + rect.extent.x;
        var minY = rect.origin.y,
            maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        return (
            minX <= this.x && this.x < maxX &&
            minY <= this.y && this.y < maxY
        );
    }
};

Point.prototype.EQ = Point.prototype.equals;
Point.prototype.GT = Point.prototype.greaterThan;
Point.prototype.LT = Point.prototype.lessThan;
Point.prototype.GE = Point.prototype.greaterThanOrEqualTo;
Point.prototype.LE = Point.prototype.lessThanOrEqualTo;


/**
 * @constructor Rectangle
 *
 * @desc This object represents a rectangular area within an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Normally, the `x` and `y` parameters to the constructor describe the upper left corner of the rect.
 * However, negative values of `width` and `height` will be added to the given `x` and `y`. That is,
 * a negative value of the `width` parameter will extend the rect to the left of the given `x` and
 * a negative value of the `height` parameter will extend the rect above the given `y`.
 * In any case, after instantiation the following are guaranteed to always be true:
 * * The `extent`, `width`, and `height` properties _always_ give positive values.
 * * The `origin`, `top`, and `left` properties _always_ reflect the upper left corner.
 * * The `corner`, `bottom`, and `right` properties _always_ reflect the lower right corner.
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} [x=0] - Horizontal coordinate of some corner of the rect.
 * @param {number} [y=0] - Vertical coordinate of some corner of the rect.
 * @param {number} [width=0] - Width of the new rect. May be negative (see above).
 * @param {number} [height=0] - Height of the new rect. May be negative (see above).
 */
function Rectangle(x, y, width, height) {

    x = Number(x) || 0;
    y = Number(y) || 0;
    width = Number(width) || 0;
    height = Number(height) || 0;

    if (width < 0) {
        x += width;
        width = -width;
    }

    if (height < 0) {
        y += height;
        height = -height;
    }

    /**
     * @name origin
     * @type {Point}
     * @summary Upper left corner of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'origin', new Point(x, y));

    /**
     * @name extent
     * @type {Point}
     * @summary this rect's width and height.
     * @desc Unlike the other `Point` properties, `extent` is not a global coordinate pair; rather it consists of a _width_ (`x`, always positive) and a _height_ (`y`, always positive).
     *
     * This object might be more legitimately typed as something like `Area` with properties `width` and `height`; however we wanted it to be able to use it efficiently with a point's `plus` and `minus` methods (that is, without those methods having to check and branch on the type of its parameter).
     *
     * Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @see The {@link Rectangle#corner|corner} method.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'extent', new Point(width, height));

    /**
     * @name corner
     * @type {Point}
     * @summary Lower right corner of this rect.
     * @desc This is a calculated value created upon instantiation by the {@linkplain Rectangle|constructor}. It is `origin` offset by `extent`.
     *
     * **Note:** These coordinates actually point to the pixel one below and one to the right of the rect's actual lower right pixel.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'corner', new Point(x + width, y + height));

    /**
     * @name center
     * @type {Point}
     * @summary Center of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'center', new Point(x + (width / 2), y + (height / 2)));

}

Rectangle.prototype = {

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum vertical coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get top() {
        return this.origin.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum horizontal coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get left() {
        return this.origin.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum vertical coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get bottom() {
        return this.corner.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum horizontal coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get right() {
        return this.corner.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Width of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get width() {
        return this.extent.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Height of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get height() {
        return this.extent.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Area of this rect.
     * @memberOf Rectangle.prototype
     */
    get area() {
        return this.width * this.height;
    },

    /**
     * @returns {Rectangle} A copy of this rect but with horizontal position reset to given `x` and no width.
     * @param {number} x - Horizontal coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenXAt: function(x) {
        return new Rectangle(x, this.origin.y, 0, this.extent.y);
    },

    /**
     * @returns {Rectangle} A copy of this rect but with vertical position reset to given `y` and no height.
     * @param {number} y - Vertical coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenYAt: function(y) {
        return new Rectangle(this.origin.x, y, this.extent.x, 0);
    },

    /**
     * @returns {boolean} `true` iff given `point` entirely contained within this rect.
     * @param {Point} pointOrRect - The point or rect to test for containment.
     * @memberOf Rectangle.prototype
     */
    contains: function(pointOrRect) {
        return pointOrRect.within(this);
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @returns {boolean} `true` iff `this` rect is entirely contained within given `rect`.
     * @param {Rectangle} rect - Rectangle to test against this rect.
     * @memberOf Rectangle.prototype
     */
    within: function(rect) {
        return (
            rect.origin.lessThanOrEqualTo(this.origin) &&
            rect.corner.greaterThanOrEqualTo(this.corner)
        );
    },

    /**
     * _(Formerly: `insetBy`.)_
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to increase (+) or decrease (-) this rect
     * @see The {@link Rectangle#shrinkBy|shrinkBy} method.
     * @memberOf Rectangle.prototype
     */
    growBy: function(padding) {
        return new Rectangle(
            this.origin.x + padding,
            this.origin.y + padding,
            this.extent.x - padding - padding,
            this.extent.y - padding - padding);
    },

    /**
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to decrease (+) or increase (-) this rect.
     * @see The {@link Rectangle#growBy|growBy} method.
     * @memberOf Rectangle.prototype
     */
    shrinkBy: function(padding) {
        return this.growBy(-padding);
    },

    /**
     * @returns {Rectangle} Bounding rect that contains both this rect and the given `rect`.
     * @param {Rectangle} rect - The rectangle to union with this rect.
     * @memberOf Rectangle.prototype
     */
    union: function(rect) {
        var origin = this.origin.min(rect.origin),
            corner = this.corner.max(rect.corner),
            extent = corner.minus(origin);

        return new Rectangle(
            origin.x, origin.y,
            extent.x, extent.y
        );
    },

    /**
     * iterate over all points within this rect, invoking `iteratee` for each.
     * @param {function(number,number)} iteratee - Function to call for each point.
     * Bound to `context` when given; otherwise it is bound to this rect.
     * Each invocation of `iteratee` is called with two arguments:
     * the horizontal and vertical coordinates of the point.
     * @param {object} [context=this] - Context to bind to `iteratee` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    forEach: function(iteratee, context) {
        context = context || this;
        for (var x = this.origin.x, x2 = this.corner.x; x < x2; x++) {
            for (var y = this.origin.y, y2 = this.corner.y; y < y2; y++) {
                iteratee.call(context, x, y);
            }
        }
    },

    /**
     * @returns {Rectangle} One of:
     * * _If this rect intersects with the given `rect`:_
     *      a new rect representing that intersection.
     * * _If it doesn't intersect and `ifNoneAction` defined:_
     *      result of calling `ifNoneAction`.
     * * _If it doesn't intersect and `ifNoneAction` undefined:_
     *      `null`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @param {function(Rectangle)} [ifNoneAction] - When no intersection, invoke and return result.
     * Bound to `context` when given; otherwise bound to this rect.
     * Invoked with `rect` as sole parameter.
     * @param {object} [context=this] - Context to bind to `ifNoneAction` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    intersect: function(rect, ifNoneAction, context) {
        var result = null,
            origin = this.origin.max(rect.origin),
            corner = this.corner.min(rect.corner),
            extent = corner.minus(origin);

        if (extent.x > 0 && extent.y > 0) {
            result = new Rectangle(
                origin.x, origin.y,
                extent.x, extent.y
            );
        } else if (typeof ifNoneAction === 'function') {
            result = ifNoneAction.call(context || this, rect);
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff this rect overlaps with given `rect`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @memberOf Rectangle.prototype
     */
    intersects: function(rect) {
        return (
            rect.corner.x > this.origin.x &&
            rect.corner.y > this.origin.y &&
            rect.origin.x < this.corner.x &&
            rect.origin.y < this.corner.y
        );
    }
};

// Interface
exports.Point = Point;
exports.Rectangle = Rectangle;

},{}],40:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @constructor RangeSelectionModel
     *
     * @desc This object models selection of "cells" within an abstract single-dimensional matrix.
     *
     * Disjoint selections can be built with calls to the following methods:
     * * {@link RangeSelectionModel#select|select(start, stop)} - Add a range to the matrix.
     * * {@link RangeSelectionModel#deselect|deselect(start, stop)} - Remove a range from the matrix.
     *
     * Two more methods are available:
     * * Test a cell to see if it {@link RangeSelectionModel#isSelected|isSelected(cell)}
     * * {@link RangeSelectionModel#clear|clear()} the matrix
     *
     * Internally, the selection is run-length-encoded. It is therefore a "sparse" matrix
     * with undefined bounds. A single data property called `selection` is an array that
     * contains all the "runs" (ranges) of selected cells albeit in no particular order.
     * This property should not normally need to be accessed directly.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @returns {RangeSelectionModel} Self (i.e., `this` object).
     */
    function RangeSelectionModel() {
        /**
         * @name selection
         * @type {Array.Array.number}
         * @summary Unordered list of runs.
         * @desc A "run" is defined as an Array(2) where:
         * * element [0] is the beginning of the run
         * * element [1] is the end of the run (inclusive) and is always >= element [0]
         * The order of the runs within is undefined.
         * @memberOf RangeSelectionModel.prototype
         * @abstract
         */
        this.selection = [];

        //we need to be able to go back in time
        //the states field
        this.states = [];

        //clone and store my current state
        //so we can unwind changes if need be
        this.storeState = function () {
            var sels = this.selection;
            var state = [];
            var copy;
            for (var i = 0; i < sels.length; i++) {
                copy = [].concat(sels[i]);
                state.push(copy);
            }
            this.states.push(state);
        };
    }

    RangeSelectionModel.prototype = {

        /**
         * @summary Add a contiguous run of points to the selection.
         * @desc Insert a new run into `this.selection`.
         * The new run will be merged with overlapping and adjacent runs.
         *
         * The two parameters may be given in either order.
         * The start and stop elements in the resulting run will however always be ordered.
         * (However, note that the order of the runs within `this.selection` is itself always unordered.)
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        select: function (start, stop) {
            this.storeState();
            var run = makeRun(start, stop);
            var splicer = [0, 1];
            this.selection.forEach(function (each) {
                if (overlaps(each, run) || abuts(each, run)) {
                    run = merge(each, run);
                } else {
                    splicer.push(each);
                }
            });
            splicer.push(run);
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Remove a contiguous run of points from the selection.
         * @desc Truncate and/or remove run(s) from `this.selection`.
         * Removing part of existing runs will (correctly) shorten them or break them into two fragments.
         *
         * The two parameters may be given in either order.
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        deselect: function (start, stop) {
            var run = makeRun(start, stop);
            var splicer = [0, 0];
            this.selection.forEach(function (each) {
                if (overlaps(each, run)) {
                    var pieces = subtract(each, run);
                    splicer = splicer.concat(pieces);
                } else {
                    splicer.push(each);
                }
            });
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Empties `this.selection`, effectively removing all runs.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        clear: function () {
            this.states.length = 0;
            this.selection.length = 0;
            return this;
        },

        clearMostRecentSelection: function () {
            if (this.states.length === 0) {
                return;
            }
            this.selection = this.states.pop();
        },

        /**
         * @summary Determines if the given `cell` is selected.
         * @returns {boolean} `true` iff given `cell` is within any of the runs in `this.selection`.
         * @param {number} cell - The cell to test for inclusion in the selection.
         * @memberOf RangeSelectionModel.prototype
         */
        isSelected: function (cell) {
            return this.selection.some(function (each) {
                return each[0] <= cell && cell <= each[1];
            });
        },

        isEmpty: function (){
            return this.selection.length === 0;
        },

        /**
         * @summary Return the indexes that are selected.
         * @desc Return the indexes that are selected.
         * @returns {Array.Array.number}
         * @memberOf RangeSelectionModel.prototype
         */
        getSelections: function (){
            var result = [];
            this.selection.forEach(function (each) {
                for (var i = each[0]; i <= each[1]; i++) {
                    result.push(i);
                }
            });
            result.sort(function (a, b){
                return a - b;
            });
            return result;
        }

    };

    /**
     * @private
     * @summary Preps `start` and `stop` params into order array
     * @function makeRun
     * @desc Utility function called by both `select()` and `deselect()`.
     * @param {number|number[]} start - Start of run. if array, `start` and `stop` are taken from first two elements.
     * @param {number} [stop=start] - End of run (inclusive).
     */
    function makeRun(start, stop) {
        return (
            start instanceof Array
                ? makeRun.apply(this, start) // extract params from given array
                : stop === undefined
                ? [ start, start ] // single param is a run that stops where it starts
                : start <= stop
                ? [ start, stop ]
                : [ stop, start ] // reverse descending params into ascending order
        );
    }

    /**
     * @private
     * @function overlaps
     * @returns {boolean} `true` iff `run1` overlaps `run2`
     * @summary Comparison operator that determines if given runs overlap with one another.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Overlap is defined to include the case where one run completely contains the other.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function overlaps(run1, run2) {
        return (
            run1[0] <= run2[0] && run2[0] <= run1[1] || // run2's start is within run1 OR...
            run1[0] <= run2[1] && run2[1] <= run1[1] || // run2's stop is within run1 OR...
            run2[0] <  run1[0] && run1[1] <  run2[1]    // run2 completely contains run1
        );
    }

    /**
     * @private
     * @function abuts
     * @summary Comparison operator that determines if given runs are consecutive with one another.
     * @returns {boolean} `true` iff `run1` is consecutive with `run2`
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function abuts(run1, run2) {
        return (
            run1[1] === run2[0] - 1 || // run1's top immediately precedes run2's start OR...
            run2[1] === run1[0] - 1    // run2's top immediately precedes run1's start
        );
    }

    /**
     * @private
     * @function subtract
     * @summary Operator that subtracts one run from another.
     * @returns {Array.Array.number} The remaining pieces of `minuend` after removing `subtrahend`.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * This function _does not assumes_ that `overlap()` has already been called with the same runs and has returned `true`.
     *
     * Returned array contains 0, 1, or 2 runs which are the portion(s) of `minuend` that do _not_ include `subtrahend`.
     *
     * Caveat: This operator is *not* commutative.
     * @param {number[]} minuend - a run from which to "subtract" `subtrahend`
     * @param {number[]} subtrahend - a run to "subtracted" from `minuend`
     */
    function subtract(minuend, subtrahend) {
        var m0 = minuend[0];
        var m1 = minuend[1];
        var s0 = subtrahend[0];
        var s1 = subtrahend[1];
        var result = [];

        if (s0 <= m0 && s1 < m1) {
            //subtrahend extends before minuend: return remaining piece of `minuend`
            result.push([s1 + 1, m1]);
        } else if (s0 > m0 && s1 >= m1) {
            //subtrahend extends after minuend: return remaining piece of `minuend`
            result.push([m0, s0 - 1]);
        } else if (m0 < s0 && s1 < m1) {
            //completely inside: return 2 smaller pieces resulting from the hole
            result.push([m0, s0 - 1]);
            result.push([s1 + 1, m1]);
        } else if (s1 < m0 || s0 > m1) {
            // completely outside: return `minuend` untouched
            result.push(minuend);
        }

        //else subtrahend must completely overlap minuend so return no pieces

        return result;
    }


    // Local utility functions

    /**
     * @private
     * @function merge
     * @summary Operator that merges given runs.
     * @returns {number[]} A single merged run.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * The runs are assumed to be overlapping or adjacent to one another.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - a run to merge with `run2`
     * @param {number[]} run2 - a run to merge with `run1`
     */
    function merge(run1, run2) {
        var min = Math.min(Math.min.apply(Math, run1), Math.min.apply(Math, run2));
        var max = Math.max(Math.max.apply(Math, run1), Math.max.apply(Math, run2));
        return [min, max];
    }

    // Interface
    module.exports = RangeSelectionModel;
})(
    typeof module === 'object' && module || (window.RangeSelectionModel = {}),
    typeof module === 'object' && module.exports || (window.RangeSelectionModel.exports = {})
) || (
    typeof module === 'object' || (window.RangeSelectionModel = window.RangeSelectionModel.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.RangeSelectionModel`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `RangeSelectionModel` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`RangeSelectionModel` to be the `RangeSelectionModel.exports` object
 */

},{}],41:[function(require,module,exports){
/* globals alert */

'use strict';

/**
 * @constructor
 * @desc Extend from this base class using `Base.extend` per example.
 * @example
 * var prototype = { ... };
 * var descendantClass = Base.extend(prototype};
 * @classdesc This is an abstract base class available for all Hypergrid classes.
 */
var Base = require('extend-me').Base;

Base.prototype.deprecated = require('./lib/deprecated');
Base.prototype.HypergridError = require('./lib/error');

Base.prototype.notify = function(message, onerror) {
    switch (onerror) {
        case 'warn': console.warn(message); break;
        case 'alert': alert(message); break; // eslint-disable-line no-alert
        default: throw new this.HypergridError(message);
    }
};

/**
 * Convenience function for getting the value when that value can be defined as a function that needs to be called to get the actual (primitive) value.
 * @param value
 * @returns {*}
 */
Base.prototype.unwrap = function(value) {
    if ((typeof value)[0] === 'f') {
        value = value();
    }
    return value;
};

/**
 * @method
 * @summary Mixes source members into calling context.
 * @desc Context is typically either an instance or the (shared) prototype of a "class" extended from {@link Base} (see examples).
 *
 * Typically used by plug-ins.
 * @example
 * // define instance members: myGrid.fix(), etc.
 * myGrid.mixIn({ fix: function() {...}, ... });
 * @example
 * // define prototype members: Hypergrid.prototype.fix(), etc.
 * Hypergrid.prototype.mixIn({ fix: function() {...}, ... });
 * @See {@link https://joneit.github.io/overrider/module-overrider.htm#.mixIn}
 * @param {object} source
 */
Base.prototype.mixIn = require('overrider').mixIn;


/**
 * @method
 * @summary Instantiate an object with discrete + variable args.
 * @desc The discrete args are passed first, followed by the variable args.
 * @param {function} Constructor
 * @param {Array} variableArgArray
 * @param {...*} discreteArgs
 * @returns {object} Object of type `Constructor` newly constructor using the arguments in `arrayOfArgs`.
 */
Base.prototype.createApply = function(Constructor, variableArgArray, discreteArgs) {
    var discreteArgArray = Array.prototype.slice.call(arguments, 2),
        args = [null] // null is context for `bind` call below
            .concat(discreteArgArray) // discrete arguments
            .concat(variableArgArray), // variable arguments
        BoundConstructor = Constructor.bind.apply(Constructor, args);

    return new BoundConstructor;
};


module.exports = Base;

},{"./lib/deprecated":99,"./lib/error":101,"extend-me":6,"overrider":37}],42:[function(require,module,exports){
/* eslint-env browser */

'use strict';

require('./lib/polyfills'); // Installs misc. polyfills into global objects, as needed

var FinBar = require('finbars');
var Point = require('rectangular').Point;
var Rectangle = require('rectangular').Rectangle;
var _ = require('object-iterators'); // fyi: installs the Array.prototype.find polyfill, as needed

var Base = require('./Base');
var defaults = require('./defaults');
var dynamicProperties = require('./lib/dynamicProperties');
var Canvas = require('./lib/Canvas');
var Renderer = require('./renderer');
var SelectionModel = require('./lib/SelectionModel');
var stylesheet = require('./lib/stylesheet');
var Localization = require('./lib/Localization');
var behaviors = require('./behaviors');
var CellRenderers = require('./cellRenderers');
var CellEditors = require('./cellEditors');

var EDGE_STYLES = ['top', 'bottom', 'left', 'right'],
    RECT_STYLES = EDGE_STYLES.concat(['width', 'height', 'position']);

/**
 * @constructor
 * @param {string|Element} [container] - CSS selector or Element
 * @param {object} [options]
 * @param {function} [options.Behavior=behaviors.JSON] - A behavior constructor or instance
 * @param {function[]} [options.pipeline] - A list function constructors to use for passing data through a series of transforms to occur on reindex call
 * @param {function|object[]} [options.data] - Passed to behavior constructor. May be:
 * * An array of congruent raw data objects
 * * A function returning same
 * @param {function|menuItem[]} [options.schema=derivedSchema] - Passed to behavior constructor. May be:
 * * A schema array
 * * A function returning a schema array. Called at filter reset time with behavior as context.
 * * Omit to generate a basic schema from `this.behavior.columns`.
 * @param {Behavior} [options.Behavior=JSON] - A grid behavior (descendant of Behavior "class").
 *
 * @param {pluginSpec|pluginSpec[]} [options.plugins]
 *
 * @param {subgridSpec[]} [options.subgrids]
 *
 * @param {string|Element} [options.container] - CSS selector or Element
 *
 * @param {string} [options.localization=Hypergrid.localization]
 * @param {string|string[]} [options.localization.locale=Hypergrid.localization.locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFomrat` and `Intl.DateFomrat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information.
 * @param {string} [options.localization.numberOptions=Hypergrid.localization.numberOptions] - Options passed to `Intl.NumberFormat` for creating the basic "number" localizer.
 * @param {string} [options.localization.dateOptions=Hypergrid.localization.dateOptions] - Options passed to `Intl.DateFomrat` for creating the basic "date" localizer.
 *
 * @param {object} [options.schema]
 *
 * @param {object} [options.margin] - Optional canvas "margins" applied to containing div as .left, .top, .right, .bottom. (Default values actually derive from 'grid' stylesheet's `.hypergrid-container` rule.)
 * @param {string} [options.margin.top='0px']
 * @param {string} [options.margin.right='0px']
 * @param {string} [options.margin.bottom='0px']
 * @param {string} [options.margin.left='0px']
 *
 * @param {object} [options.boundingRect] - Optional grid container size & position. (Default values actually derive from 'grid' stylesheet's `.hypergrid-container > div:first-child` rule.)
 * @param {string} [options.boundingRect.height='500px']
 * @param {string} [options.boundingRect.width='auto']
 * @param {string} [options.boundingRect.left='auto']
 * @param {string} [options.boundingRect.top='auto']
 * @param {string} [options.boundingRect.right='auto']
 * @param {string} [options.boundingRect.bottom='auto']
 * @param {string} [options.boundingRect.position='relative']
 */
var Hypergrid = Base.extend('Hypergrid', {
    initialize: function(container, options) {
        //Optional container argument
        if (!(typeof container === 'string') && !(container instanceof HTMLElement)) {
            options = container;
            container = null;
        }

        this.options = options = options || {};

        this.clearState();

        //Set up the container for a grid instance
        this.setContainer(
            container ||
            options.container ||
            findOrCreateContainer(options.boundingRect)
        );

        // Install shared plug-ins (those with a `preinstall` method)
        Object.getPrototypeOf(this).installPlugins(options.plugins);

        this.lastEdgeSelection = [0, 0];
        this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
        this.selectionModel = new SelectionModel(this);
        this.renderOverridesCache = {};
        this.allowEventHandlers = true;
        this.dragExtent = new Point(0, 0);
        this.numRows = 0;
        this.numColumns = 0;
        this.clearMouseDown();
        this.setFormatter(options.localization);
        this.listeners = {};

        /**
         * @name cellRenderers
         * @type {CellRenderer}
         * @memberOf Hypergrid#
         */
        this.cellRenderers = new CellRenderers();

        /**
         * @name cellEditors
         * @type {CellEditor}
         * @memberOf Hypergrid#
         */
        this.cellEditors = new CellEditors(this);

        if (this.options.Behavior) {
            this.setBehavior(this.options); // also sets this.options.pipeline and this.options.data
        } else if (this.options.data) {
            this.setData(this.options.data, this.options); // if no behavior has yet been set, `setData` sets a default behavior and this.options.pipeline
        }

        /**
         * @name plugins
         * @summary Dictionary of named instance plug-ins.
         * @desc See examples for how to reference (albeit there is normally no need to reference plugins directly).
         *
         * For the dictionary of _shared_ plugins, see {@link Hypergrid.plugins|plugins} (a property of the constructor).
         * @example
         * var instancePlugins = myGrid.plugins;
         * var instancePlugins = this.plugins; // internal use
         * var myInstancePlugin = myGrid.plugins.myInstancePlugin;
         * @type {object}
         * @memberOf Hypergrid#
         */
        this.plugins = {};

        // Install instance plug-ins (those that are constructors OR have an `install` method)
        this.installPlugins(options.plugins);

        // Listen for propagated mouseclicks. Used for aborting edit mode.
        document.addEventListener('mousedown', this.mouseCatcher = function() {
            this.abortEditing();
        }.bind(this));
    },

    terminate: function() {
        document.removeEventListener('mousedown', this.mouseCatcher);
    },

    registerCellEditor: function(Constructor, name) {
        return this.deprecated('registerCellEditor(Constructor, name)', 'cellEditors.add(name, Constructor)', '1.0.6', arguments);
    },
    createCellEditor: function(name) {
        return this.deprecated('createCellEditor(name)', 'cellEditors.create(name)', '1.0.6', arguments);
    },
    getCellProvider: function(name) {
        return this.deprecated('getCellProvider()', 'cellRenderers', '1.0.6', arguments);
    },
    registerLocalizer: function(name, localizer, baseClassName, newClassName) {
        return this.deprecated('registerLocalizer(name, localizer, baseClassName, newClassName)', 'localization.add(name, localizer)', '1.0.6', arguments,
            'STRUCTURAL CHANGE: No longer supports deriving and registering a new cell editor class. Use .cellEditors.get(baseClassName).extend(newClassName || name, {...}) for that.');
    },
    getRenderer: function() {
        return this.deprecated('getRenderer()', 'renderer', '1.1.0');
    },

    /**
     *
     * A null object behavior serves as a place holder.
     * @type {object}
     * @memberOf Hypergrid#
     */
    behavior: null,

    /**
     * Cached resulan}
     * @memberOf Hypergrid#
     */
    isWebkit: true,

    /**
     * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
     * @type {Point}
     * @memberOf Hypergrid#
     */
    mouseDown: [],

    /**
     * The extent from the mousedown point during a drag operation.
     * @type {Point}
     * @memberOf Hypergrid#
     */

    dragExtent: null,

    /**
     * A float value between 0.0 - 1.0 of the vertical scroll position.
     * @type {number}
     * @memberOf Hypergrid#
     */
    vScrollValue: 0,

    /**
     * A float value between 0.0 - 1.0 of the horizontal scroll position.
     * @type {number}
     * @memberOf Hypergrid#
     */
    hScrollValue: 0,

    /**
     * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
     * @memberOf Hypergrid#
     */
    selectionModel: null,

    /**
     * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
     * @memberOf Hypergrid#
     */
    cellEditor: null,

    /**
     * @property {fin-vampire-bar} sbHScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid#
     */
    sbHScroller: null,

    /**
     * @property {fin-vampire-bar} sbVScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid#
     */
    sbVScroller: null,

    /**
     * The previous value of sbVScrollVal.
     * @type {number}
     * @memberOf Hypergrid#
     */
    sbPrevVScrollValue: null,

    /**
     * The previous value of sbHScrollValue.
     * @type {number}
     * @memberOf Hypergrid#
     */
    sbPrevHScrollValue: null,

    /**
     * is the short term memory of what column I might be dragging around
     * @type {object}
     * @memberOf Hypergrid#
     */

    renderOverridesCache: {},

    /**
     * The pixel location of the current hovered cell.
     * @todo Need to detect hovering over bottom totals.
     * @type {Point}
     * @memberOf Hypergrid#
     */
    hoverCell: null,

    scrollingNow: false,

    lastEdgeSelection: null,

    /**
     * @memberOf Hypergrid#
     */
    setAttribute: function(attribute, value) {
        this.div.setAttribute(attribute, value);
    },

    /**
     * @memberOf Hypergrid#
     */
    clearState: function() {
        /**
         * @name properties
         * @type {object}
         * @summary Object containing the properties of the grid.
         * @desc Grid properties objects have the following structure:
         * 1. User-configured properties are in the "own" layer.
         * 2. Extends from (has as its prototype) the {@link module:dynamicProperties|dynamicProperties} object.
         * 3. The dynamic properties object extends from the {@link module:defaults|defaults} object.
         *
         * Note: Any changes the application developer may wish to make to the {@link module:defaults|defaults} object should be made _before_ reaching this point (_i.e.,_ prior to any grid instantiations).
         * @memberOf Hypergrid#
         */
        this.properties = Object.create(dynamicProperties, {
            grid: { value: this },
            var: { value: new Var() }
        });
    },

    /**
     * @desc Clear out all state settings, data (rows), and schema (columns) of a grid instance.
     * @param {object} [options]
     * @param {object} [options.subgrids] - Consumed by {@link Behavior#reset}.
     * If omitted, previously established subgrids list is reused.
     * @param {object} [options.pipeline] - Consumed by {@link dataModels.JSON#reset}.
     * If omitted, previously established pipeline is reused.
     * @param {object} [options.controllers] - Consumed by {@link dataModels.JSON#reset}.
     * If omitted, previously established controllers list is reused.
     * @memberOf Hypergrid#
     */
    reset: function(options) {
        this.clearState();

        this.removeAllEventListeners();

        this.lastEdgeSelection = [0, 0];
        this.selectionModel.reset();
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cancelEditing();

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        options = options || {};
        this.behavior.reset({
            subgrids: options.subgrids,
            pipeline: options.pipeline,
            controllers: options.controllers
        });

        this.renderer.reset();
        this.canvas.resize();
        this.behaviorChanged();

        this.refreshProperties();
    },

    /** @typedef {object|function|Array} pluginSpec
     * @desc One of:
     * * simple API - a plain object with an `install` method
     * * object API - an object constructor
     * * array:
     *    * first element is an optional name for the API or the newly instantiated object
     *    * next element (or first element when not a string) is the simple or object API
     *    * remaining arguments are optional arguments for the object constructor
     * * falsy value such as `undefined` - ignored
     *
     * The API may have a `name` or `$$CLASS_NAME` property.
     */
    /**
     * @summary Install plugins.
     * @desc Plugin installation:
     * * Each simple API is installed by calling it's `install` method with `this` as first arg + any additional args listed in the `pluginSpec` (when it is an array).
     * * Each object API is installed by instantiating it's constructor with `this` as first arg + any additional args listed in the `pluginSpec` (when it is an array).
     *
     * The resulting plain object or instantiated objects may be named by (in priority order):
     * 1. if `pluginSpec` contains an array and first element is a string
     * 2. object has a `name` property
     * 3. object has a `$$CLASS_NAME` property
     *
     * If named, a reference to each object is saved in `this.plugins`. If the plug-in is unnamed, no reference is kept.
     *
     * There are two types of plugin installations:
     * * Preinstalled plugins which are installed on the prototype. These are simple API plugins with a `preinstall` method called with the `installPlugins` calling context as the first argument. Preinstallations are automatically performed whenever a grid is instantiated (at the beginning of the constructor), by calling `installPlugins` with `Hypergrid.prototype` as the calling context.
     * * Regular plugins which are installed on the instance. These are simple API plugins with an `install` method, as well as all object API plugins (constructors), called with the `installPlugins` calling context as the first argument. These installations are automatically performed whenever a grid is instantiated (at the end of the constructor), called with the new grid instance as the calling context.
     *
     * The "`installPlugins` calling context" means either the grid instance or its prototype, depending on how this method is called.
     *
     * Plugins may have both `preinstall` _and_ `install` methods, in which case both will be called. However, note that in any case, `install` methods on object API plugins are ignored.
     *
     * @this {Hypergrid}
     * @param {pluginSpec|pluginSpec[]} [plugins] - The plugins to install. If omitted, the call is a no-op.
     * @memberOf Hypergrid#
     */
    installPlugins: function(plugins) {
        var shared = this === Hypergrid.prototype; // Do shared ("preinstalled") plugins (if any)

        if (!plugins) {
            return;
        } else if (!Array.isArray(plugins)) {
            plugins = [plugins];
        }

        plugins.forEach(function(plugin) {
            var name, args, hash;

            if (!plugin) {
                return; // ignore falsy plugin spec
            }

            // set first arg of constructor to `this` (the grid instance)
            // set first arg of `install` method to `this` (the grid instance)
            // set first two args of `preinstall` method to `this` (the Hypergrid prototype) and the Behavior prototype
            args = [this];
            if (shared) {
                args.push(behaviors.Behavior.prototype);
            }

            if (Array.isArray(plugin)) {
                if (!plugin.length) {
                    plugin = undefined;
                } else if (typeof plugin[0] !== 'string') {
                    args = args.concat(plugin.slice(1));
                    plugin = plugin[0];
                } else if (plugin.length >= 2) {
                    args = args.concat(plugin.slice(2));
                    name = plugin[0];
                    plugin = plugin[1];
                } else {
                    plugin = undefined;
                }
            }

            if (!plugin) {
                return; // ignore empty array or array with single string element
            }

            // Derive API name if not given in pluginSpec
            name = name || plugin.name || plugin.$$CLASS_NAME;
            if (name) {
                // Translate first character to lower case
                name = name.substr(0, 1).toLowerCase() + name.substr(1);
            }

            if (shared) {
                // Execute the `preinstall` method
                hash = this.constructor.plugins;
                if (plugin.preinstall && !hash[name]) {
                    plugin.preinstall.apply(plugin, args);
                }
            } else { // instance plug-ins:
                hash = this.plugins;
                if (typeof plugin === 'function') {
                    // Install "object API" by instantiating
                    plugin = this.createApply(plugin, args);
                } else if (plugin.install) {
                    // Install "simple API" by calling its `install` method
                    plugin.install.apply(plugin, args);
                } else if (!plugin.preinstall) {
                    throw new Base.prototype.HypergridError('Expected plugin (a constructor; or an API with a `preinstall` method and/or an `install` method).');
                }
            }

            if (name) {
                hash[name] = plugin;
            }

        }, this);
    },

    /**
     * @summary Uninstall all uninstallable plugins or just named plugins.
     * @desc Calls `uninstall` on plugins that define such a method.
     *
     * To uninstall "preinstalled" plugins, call with `Hypergrid.prototype` as context.
     *
     * For convenience, the following args are passed to the call:
     * * `this` - the plugin to be uninstalled
     * * `grid` - the hypergrid object
     * * `key` - name of the plugin to be uninstalled (_i.e.,_ key in `plugins`)
     * * `plugins` - the plugins hash (a.k.a. `grid.plugins`)
     * @param {string|stirng[]} [pluginNames] If provided, limit uninstall to the named plugin (string) or plugins (string[]).
     * @memberOf Hypergrid#
     */
    uninstallPlugins: function(pluginNames) {
        if (!pluginNames) {
            pluginNames = [];
        } else if (!Array.isArray(pluginNames)) {
            pluginNames = [pluginNames];
        }
        _(this.plugins).each(function(plugin, key, plugins) {
            if (
                plugins.hasOwnProperty(key) &&
                pluginNames.indexOf(key) >= 0 &&
                plugin.uninstall
            ) {
                plugin.uninstall(this, key, plugins);
            }
        }, this);
    },

    getProperties: function() {
        return this.deprecated('getProperties()', 'properties', '1.2.0');
    },

    computeCellsBounds: function() {
        this.renderer.computeCellsBounds();
    },

    setFormatter: function(options) {
        options = options || {};
        this.localization = new Localization(
            options.locale || Hypergrid.localization.locale,
            options.numberOptions || Hypergrid.localization.numberOptions,
            options.dateOptions || Hypergrid.localization.dateOptions
        );

        this.localization.header = {
            format: headerFormatter.bind(this)
        };
    },

    getFormatter: function(localizerName) {
        return this.localization.get(localizerName).format;
    },

    formatValue: function(localizerName, value) {
        var formatter = this.getFormatter(localizerName);
        return formatter(value);
    },

    isRowResizeable: function() {
        return this.deprecated('isRowResizeable()', 'properties.rowResize', 'v1.2.10');
    },

    isCheckboxOnlyRowSelections: function() {
        return this.deprecated('isCheckboxOnlyRowSelections()', 'properties.checkboxOnlyRowSelections', 'v1.2.10');
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Point} The cell over which the cursor is hovering.
     */
    getHoverCell: function() {
        return this.deprecated('getHoverCell()', 'hoverCell', 'v1.2.0');
    },


    /**
     * @memberOf Hypergrid#
     * @desc Set the cell under the cursor.
     * @param {CellEvent} cellEvent
     */
    setHoverCell: function(cellEvent) {
        var hoverCell = this.hoverCell;
        if (!hoverCell || !hoverCell.equals(cellEvent.gridCell)) {
            this.hoverCell = cellEvent.gridCell;
            if (hoverCell) {
                this.fireSyntheticOnCellExitEvent(cellEvent);
            }
            this.fireSyntheticOnCellEnterEvent(cellEvent);
            this.repaint();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Amend properties for this hypergrid only.
     * @param {object} moreProperties - A simple properties hash.
     */
    addProperties: function(properties) {
        Object.assign(this.properties, properties);
        this.refreshProperties();
    },

    /**
     * @todo deprecate this in favor of making properties dynamic instead (for those that need to be)
     * @memberOf Hypergrid#
     * @desc Utility function to push out properties if we change them.
     * @param {object} properties - An object of various key value pairs.
     */
    refreshProperties: function() {
        this.computeCellsBounds();
        this.checkScrollbarVisibility();
        this.behavior.defaultRowHeight = null;
        this.behavior.autosizeAllColumns();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {object} The state object for remembering our state.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    getPrivateState: function() {
        return this.deprecated('getPrivateState()', 'properties', '1.2.0');
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the state object to return to the given user configuration.
     * @param {object} state - A memento object.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    setState: function(state) {
        var self = this;
        this.behavior.setState(state);
        this.refreshProperties();
        setTimeout(function() {
            self.behaviorChanged();
            self.synchronizeScrollingBoundaries();
        }, 100);
    },

    getState: function() {
        return this.behavior.getState();
    },
    /**
     * @memberOf Hypergrid#
     * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
     * @memberOf Hypergrid#
     */
    getMouseDown: function() {
        if (this.mouseDown.length) {
            return this.mouseDown[this.mouseDown.length - 1];
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Remove the last item from the mouse down stack.
     */
    popMouseDown: function() {
        var result;
        if (this.mouseDown.length) {
            result = this.mouseDown.pop();
        }
        return result;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Empty out the mouse down stack.
     */
    clearMouseDown: function() {
        this.mouseDown = [new Point(-1, -1)];
        this.dragExtent = null;
    },

    /**
     * Set the mouse point that initiated a cell edit or drag operation.
     * @param {Point} point
     * @memberOf Hypergrid#
     */
    setMouseDown: function(point) {
        this.mouseDown.push(point);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Point} The extent point of the current drag selection rectangle.
     */
    getDragExtent: function() {
        return this.dragExtent;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set the extent point of the current drag selection operation.
     * @param {Point} point
     */
    setDragExtent: function(point) {
        this.dragExtent = point;
    },

    /**
     * @memberOf Hypergrid#
     * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        if (this.cellEditor) {
            this.cellEditor.gridRenderedNotification();
        }
        this.checkColumnAutosizing();
        this.fireSyntheticGridRenderedEvent();
    },

    tickNotification: function() {
        this.fireSyntheticTickEvent();
    },

    /**
     * @memberOf Hypergrid#
     * @desc The grid has just been rendered, make sure the column widths are optimal.
     */
    checkColumnAutosizing: function() {
        var behavior = this.behavior;
        behavior.autoSizeRowNumberColumn();
        if (behavior.checkColumnAutosizing(false)) {
            setTimeout(function() {
                behavior.grid.synchronizeScrollingBoundaries();
            });
        }
    },

    /**
     * @memberOf Hypergrid#
     * @summary Conditionally copy to clipboard.
     * @desc If we have focus, copy our current selection data to the system clipboard.
     * @param {event} event - The copy system event.
     */
    checkClipboardCopy: function(event) {
        if (this.hasFocus()) {
            event.preventDefault();
            var csvData = this.getSelectionAsTSV();
            event.clipboardData.setData('text/plain', csvData);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} We have focus.
     */
    hasFocus: function() {
        return this.canvas.hasFocus();
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set the Behavior (model) object for this grid control.
     * @desc This can be done dynamically.
     * @param {object} options - _(See {@link behaviors.JSON#setData}.)_
     * @param {Behavior} [options.behavior=behaviors.JSON] - The behavior (model) can be either a constructor or an instance.
     * @param {dataRowObject[]} [options.data] - _(See {@link behaviors.JSON#setData}.)_
     * @param {pipelineSchema} [options.pipeline] - New pipeline description.
     */
    setBehavior: function(options) {
        if (!this.behavior) {
            // If we get here it means:
            // 1. Called from constructor because behavior included in options object.
            // 2. Called from `setData` _and_ wasn't called explicitly since instantiation
            var Behavior = options.Behavior || behaviors.JSON;
            this.behavior = new Behavior(this, options);
            this.initCanvas();
            this.initScrollbars();
            this.refreshProperties();
            this.behavior.reindex();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set the underlying datasource.
     * @desc This can be done dynamically.
     * @param {function|object[]} dataRows - May be:
     * * An array of congruent raw data objects.
     * * A function returning same.
     * @param {object} [options] - _(See {@link behaviors.JSON#setData}.)_
     */
    setData: function(dataRows, options) {
        // Call `setBehavior` here just in case not previously set by constructor _or_ explicitly since instantiation
        this.setBehavior({
            pipeline: this.options.pipeline
        });
        this.behavior.setData(dataRows, options);
        this.setInfo(dataRows.length ? '' : this.properties.noDataMessage);
        this.behavior.changed();
    },

    setInfo: function(messages) {
        this.renderer.setInfo(messages);
    },

    /**
     * @memberOf Hypergrid#
     * @summary _(See {@link Hypergrid.prototype#setData}.)_
     * @desc Binds the data and reshapes the grid (new column objects created)
     * @param {function|object[]} dataRows - May be:
     * * An array of congruent raw data objects.
     * * A function returning same.
     * @param {object} [options]
     */
    updateData: function(dataRows, options){
        this.deprecated('updateData(dataRows, options)', 'setData(dataRows, options)', 'v1.2.10', arguments,
            'To update data without changing column definitions, call setData _without a schema._');
    },

    /**
     * @memberOf Hypergrid#
     * @param {object} [pipelines] - New pipeline description. _(See {@link dataModels.JSON#setPipeline}.)_
     * @param {object} [options] - _(See {@link dataModels.JSON#setPipeline}.)_
     */
    setPipeline: function(DataSources, options){
        this.behavior.setPipeline(DataSources, options);
    },

    /**
     * @memberOf Hypergrid#
     * @desc I've been notified that the behavior has changed.
     */
    behaviorChanged: function() {
        if (this.divCanvas) {
            if (this.numColumns !== this.getColumnCount() || this.numRows !== this.getRowCount()) {
                this.numColumns = this.getColumnCount();
                this.numRows = this.getRowCount();
                this.behaviorShapeChanged();
            } else {
                this.behaviorStateChanged();
            }
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorShapeChanged: function() {
        if (this.divCanvas) {
            this.synchronizeScrollingBoundaries();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorStateChanged: function() {
        if (this.divCanvas) {
            this.computeCellsBounds();
            this.repaint();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Rectangle} My bounds.
     */
    getBounds: function() {
        return this.renderer.getBounds();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {string} The value of a lnf property.
     * @param {string} key - A look-and-feel key.
     */
    resolveProperty: function(key) {
        // todo: when we remove this method, also remove forwards from Behavior.js and Renderer.js
        this.deprecated('resolveProperty', '.resolveProperty(key) deprecated as of v1.2.0 in favor of .properties dereferenced by [key]. (Will be removed in a future version.)');
        return this.properties[key];
    },

    repaint: function() {
        var now = this.properties.repaintImmediately;
        var canvas = this.canvas;
        if (canvas) {
            if (now === true) {
                canvas.paintNow();
            } else {
                canvas.repaint();
            }
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Paint immediately in this microtask.
     */
    paintNow: function() {
        this.canvas.paintNow();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} In HiDPI mode (has an attribute as such).
     */
    useHiDPI: function() {
        return this.deprecated('useHiDPI()', 'properties.useHiDPI', 'v1.2.10');
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set the container for a grid instance
     * @private
     */
    setContainer: function(div) {
        this.initContainer(div);
        this.initRenderer();
        // injectGridElements.call(this);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Initialize container
     * @private
     */
    initContainer: function(div) {
        if (typeof div === 'string') {
            div = document.querySelector(div);
        }

        //Default Position and height to ensure DnD works
        if (!div.style.position) {
            div.style.position = null; // revert to stylesheet value
        }

        if (div.clientHeight < 1) {
            div.style.height = null; // revert to stylesheet value
        }

        stylesheet.inject('grid');

        //prevent the default context menu for appearing
        div.oncontextmenu = function(event) {
            event.stopPropagation();
            event.preventDefault();
            return false;
        };

        div.removeAttribute('tabindex');

        div.classList.add('hypergrid-container');
        div.id = div.id || 'hypergrid' + (document.querySelectorAll('.hypergrid-container').length - 1 || '');

        this.div = div;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Initialize drawing surface.
     * @private
     */
    initCanvas: function() {
        if (!this.divCanvas) {
            var divCanvas = document.createElement('div');

            setStyles(divCanvas, this.options.margin, EDGE_STYLES);

            this.div.appendChild(divCanvas);

            var canvas = new Canvas(divCanvas, this.renderer, this.options.canvas);
            canvas.canvas.classList.add('hypergrid');

            this.divCanvas = divCanvas;
            this.canvas = canvas;

            this.delegateCanvasEvents();
        }
    },

    convertViewPointToDataPoint: function(unscrolled) {
        return this.behavior.convertViewPointToDataPoint(unscrolled);
    },

    convertDataPointToViewPoint: function(dataPoint) {
        return this.behavior.convertDataPointToViewPoint(dataPoint);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set for `scrollingNow` field.
     * @param {boolean} isItNow - The type of event we are interested in.
     */
    setScrollingNow: function(isItNow) {
        this.scrollingNow = isItNow;
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} The `scrollingNow` field.
     */
    isScrollingNow: function() {
        return this.scrollingNow;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Switch the cursor for a grid instance.
     * @param {string} cursorName - A well know cursor name.
     * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
     */
    beCursor: function(cursorName) {
        if (!cursorName) {
            cursorName = 'default';
        }
        this.div.style.cursor = cursorName;
    },

    /**
     * @summary Shut down the current cell editor and save the edited value.
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid#
     */
    stopEditing: function() {
        return !this.cellEditor || this.cellEditor.stopEditing();
    },

    /**
     * @summary Shut down the current cell editor without saving the edited val
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid#
     */
    cancelEditing: function() {
        return !this.cellEditor || this.cellEditor.cancelEditing();
    },

    /**
     * @summary Give cell editor opportunity to cancel (or something) instead of stop .
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid#
     */
    abortEditing: function() {
        return !this.cellEditor || (
            this.cellEditor.abortEditing ? this.cellEditor.abortEditing() : this.cellEditor.stopEditing()
        );
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
     */
    getDataBounds: function() {
        var b = this.canvas.bounds;
        return new Rectangle(0, 0, b.origin.x + b.extent.x, b.origin.y + b.extent.y);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Canvas} Our fin-canvas instance.
     */
    getCanvas: function() {
        return this.deprecated('getCanvas()', 'canvas', '1.2.2');
    },

    /**
     * @memberOf Hypergrid#
     * @summary Open the cell-editor for the cell at the given coordinates.
     * @param {CellEvent} event - Coordinates of "edit point" (gridCell.x, dataCell.y).
     * @return {undefined|CellEditor} The cellEditor determined from the cell's render properties, which may be modified by logic added by overriding {@link DataModel#getCellEditorAt|getCellEditorAt}.
     */
    editAt: function(event) {
        var cellEditor;

        if (arguments.length === 2) {
            return this.deprecated('editAt(cellEditor, event)', 'editAt(event)', '1.0.6', arguments);
        }

        this.abortEditing(); // if another editor is open, close it first

        if (
            event.isDataColumn &&
            event.properties[event.isDataRow ? 'editable' : 'filterable'] &&
            (cellEditor = this.getCellEditorAt(event))
        ) {
            cellEditor.beginEditing();
        }

        return cellEditor;
    },

    /**
     * @memberOf Hypergrid#
     * @param {number} columnIndex - The column index in question.
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function(columnIndex) {
        return this.renderer.isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid#
     * @param {number} r - The raw row index in question.
     * @returns {boolean} The given row is fully visible.
     */
    isDataRowVisible: function(r) {
        return this.renderer.isRowVisible(r);
    },

    /**
     * @memberOf Hypergrid#
     * @param {number} c - The column index in question.
     * @param {number} rn - The grid row index in question.
     * @returns {boolean} The given cell is fully is visible.
     */
    isDataVisible: function(c, rn) {
        return this.isDataRowVisible(rn) && this.isColumnVisible(c);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
     * @param {number} colIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Column is visible.
     */
    insureModelColIsVisible: function(colIndex, offsetX) {
        var maxCols = this.getColumnCount() - 1, // -1 excludes partially visible columns
            indexToCheck = colIndex + Math.sign(offsetX),
            visible = !this.isColumnVisible(indexToCheck) || colIndex === maxCols;

        if (visible) {
            //the scroll position is the leftmost column
            this.scrollBy(offsetX, 0);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll in the `offsetY` direction if column index c is not visible.
     * @param {number} rowIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Row is visible.
     */
    insureModelRowIsVisible: function(rowIndex, offsetY) {
        var maxRows = this.getRowCount() - 1, // -1 excludes partially visible rows
            indexToCheck = rowIndex + Math.sign(offsetY),
            visible = !this.isDataRowVisible(indexToCheck) || rowIndex === maxRows;

        if (visible) {
            //the scroll position is the topmost row
            this.scrollBy(0, offsetY);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function(offsetX, offsetY) {
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function(offsetY) {
        var max = this.sbVScroller.range.max;
        var oldValue = this.getVScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetY));
        if (newValue !== oldValue) {
            this.setVScrollValue(newValue);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function(offsetX) {
        var max = this.sbHScroller.range.max;
        var oldValue = this.getHScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetX));
        if (newValue !== oldValue) {
            this.setHScrollValue(newValue);
        }
    },

    scrollToMakeVisible: function(c, r) {
        var delta,
            dw = this.renderer.dataWindow,
            fixedColumnCount = this.properties.fixedColumnCount,
            fixedRowCount = this.properties.fixedRowCount;

        if (
            c >= fixedColumnCount && // scroll only if target not in fixed columns
            (
                // target is to left of scrollable columns; negative delta scrolls left
                (delta = c - dw.origin.x) < 0 ||

                // target is to right of scrollable columns; positive delta scrolls right
                // Note: The +1 forces right-most column to scroll left (just in case it was only partially in view)
                (delta = c - dw.corner.x + 1) > 0
            )
        ) {
            this.sbHScroller.index += delta;
        }

        if (
            r >= fixedRowCount && // scroll only if target not in fixed rows
            (
                // target is above scrollable rows; negative delta scrolls up
                (delta = r - dw.origin.y) < 0 ||

                // target is below scrollable rows; positive delta scrolls down
                (delta = r - dw.corner.y) > 0
            )
        ) {
            this.sbVScroller.index += delta;
        }
    },

    selectCellAndScrollToMakeVisible: function(c, r) {
        this.scrollToMakeVisible(c, r);
        this.selectCell(c, r, true);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Answer which data cell is under a pixel value mouse point.
     * @param {mousePoint} mouse - The mouse point to interrogate.
     */

    getGridCellFromMousePoint: function(mouse) {
        return this.renderer.getGridCellFromMousePoint(mouse);
    },

    /**
     * @param {Point} gridCell - The pixel location of the mouse in physical grid coordinates.
     * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
     * @memberOf Hypergrid#
     */
    getBoundsOfCell: function(gridCell) {
        var b = this.renderer.getBoundsOfCell(gridCell.x, gridCell.y);

        //convert to a proper rectangle
        return new Rectangle(b.x, b.y, b.width, b.height);
    },

    /**
     * @memberOf Hypergrid#
     * @desc This is called by the fin-canvas when a resize occurs.
     */
    resized: function() {
        this.synchronizeScrollingBoundaries();
    },

    /**
     * @memberOf Hypergrid#
     * @summary A click event occurred.
     * @desc Determine the cell and delegate to the behavior (model).
     * @param {MouseEvent} event - The mouse event to interrogate.
     * @returns {boolean|undefined} Changed. Specifically, one of:
     * * `undefined` row had no drill-down control
     * * `true` drill-down changed
     * * `false` drill-down unchanged (was already in requested state)
     */
    cellClicked: function(event) {
        var result = this.behavior.cellClicked(event);

        if (result !== undefined) {
            this.behavior.changed();
        }

        return result;
    },

    /**
     * To intercept link clicks, override this method (either on the prototype to apply to all grid instances or on an instance to apply to a specific grid instance).
     * @memberOf Hypergrid#
     */
    windowOpen: function(url, name, features, replace) {
        return window.open.apply(window, arguments);
    },

    /**
     * @param {number} [begin]
     * @param {nubmer} [end]
     * * @returns {Column[]} A copy of the all columns array by passing the params to `Array.prototype.slice`.
     */
    getColumns: function(begin, end) {
        var columns = this.behavior.getColumns();
        return columns.slice.apply(columns, arguments);
    },

    /**
     * @param {number} [begin]
     * @param {nubmer} [end]
     * * @returns {Column[]} A copy of the active columns array by passing the params to `Array.prototype.slice`.
     */
    getActiveColumns: function(begin, end) {
        var columns = this.behavior.getActiveColumns();
        return columns.slice.apply(columns, arguments);
    },

    getHiddenColumns: function(){
        //A non in-memory behavior will be more troublesome
        return this.behavior.getHiddenColumns();
    },

    isViewableButton: function(c, r) {
        return this.renderer.isViewableButton(c, r);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the vertical scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setVScrollValue: function(y) {
        var self = this;
        y = Math.min(this.sbVScroller.range.max, Math.max(0, Math.round(y)));
        if (y !== this.vScrollValue) {
            this.behavior._setScrollPositionY(y);
            var oldY = this.vScrollValue;
            this.vScrollValue = y;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                // self.sbVRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-y', oldY, y);
            });
        }
    },

    /**
     * @memberOf Hypergrid#
     * @return {number} The vertical scroll value.
     */
    getVScrollValue: function() {
        return this.vScrollValue;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the horizontal scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setHScrollValue: function(x) {
        var self = this;
        x = Math.min(this.sbHScroller.range.max, Math.max(0, Math.round(x)));
        if (x !== this.hScrollValue) {
            this.behavior._setScrollPositionX(x);
            var oldX = this.hScrollValue;
            this.hScrollValue = x;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                //self.sbHRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-x', oldX, x);
                //self.synchronizeScrollingBoundries(); // todo: Commented off to prevent the grid from bouncing back, but there may be repurcussions...
            });
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns The vertical scroll value.
     */
    getHScrollValue: function() {
        return this.hScrollValue;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Request input focus.
     */
    takeFocus: function() {
        var wasCellEditor = this.cellEditor;
        this.stopEditing();
        if (!wasCellEditor) {
            this.canvas.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Request focus for our cell editor.
     */
    editorTakeFocus: function() {
        if (this.cellEditor) {
            return this.cellEditor.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function() {
        if (this.sbHScroller && this.sbVScroller){
            return;
        }

        var self = this;

        var horzBar = new FinBar({
            orientation: 'horizontal',
            onchange: self.setHScrollValue.bind(self),
            cssStylesheetReferenceElement: this.div
        });

        var vertBar = new FinBar({
            orientation: 'vertical',
            onchange: self.setVScrollValue.bind(self),
            paging: {
                up: self.pageUp.bind(self),
                down: self.pageDown.bind(self)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.properties.hScrollbarClassPrefix;
        var vPrefix = this.properties.vScrollbarClassPrefix;

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.bar);
        this.div.appendChild(vertBar.bar);

        this.resizeScrollbars();
    },

    resizeScrollbars: function() {
        this.sbHScroller.shortenBy(this.sbVScroller).resize();
        //this.sbVScroller.shortenBy(this.sbHScroller);
        this.sbVScroller.resize();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function() {
        if (
            this.hScrollValue !== this.sbPrevHScrollValue ||
            this.vScrollValue !== this.sbPrevVScrollValue
        ) {
            this.sbPrevHScrollValue = this.hScrollValue;
            this.sbPrevVScrollValue = this.vScrollValue;

            if (this.cellEditor) {
                this.cellEditor.scrollValueChangedNotification();
            }

            this.computeCellsBounds();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @summary Get data value at given cell.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    getValue: function(x, y) {
        return this.behavior.getValue.apply(this.behavior, arguments); // must use .apply (see this.behavior.getValue)
    },

    /**
     * @memberOf Hypergrid#
     * @summary Set a data value of a given cell.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     * @param {*} value - New cell value.
     */
    setValue: function(x, y, value) {
        this.behavior.setValue.apply(this.behavior, arguments); // must use .apply (see this.behavior.setValue)
    },

    /**
     * @memberOf Hypergrid#
     * @desc The data dimensions have changed, or our pixel boundaries have changed.
     * Adjust the scrollbar properties as necessary.
     */
    synchronizeScrollingBoundaries: function() {
        var numFixedColumns = this.getFixedColumnCount();

        var numColumns = this.getColumnCount();
        var numRows = this.getRowCount();

        var bounds = this.getBounds();
        if (!bounds) {
            return;
        }

        var scrollableWidth = bounds.width - this.behavior.getFixedColumnsMaxWidth();
        for (
            var columnsWidth = 0, lastPageColumnCount = 0;
            lastPageColumnCount < numColumns && columnsWidth < scrollableWidth;
            lastPageColumnCount++
        ) {
            columnsWidth += this.getColumnWidth(numColumns - lastPageColumnCount - 1);
        }
        if (columnsWidth > scrollableWidth) {
            lastPageColumnCount--;
        }

        var scrollableHeight = this.renderer.getVisibleScrollHeight();
        for (
            var rowsHeight = 0, lastPageRowCount = 0;
            lastPageRowCount < numRows && rowsHeight < scrollableHeight;
            lastPageRowCount++
        ) {
            rowsHeight += this.getRowHeight(numRows - lastPageRowCount - 1);
        }
        if (rowsHeight > scrollableHeight) {
            lastPageRowCount--;
        }

        // inform scroll bars
        if (this.sbHScroller) {
            var hMax = Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
            this.setHScrollbarValues(hMax);
            this.setHScrollValue(Math.min(this.getHScrollValue(), hMax));
        }
        if (this.sbVScroller) {
            var vMax = Math.max(0, numRows - this.properties.fixedRowCount - lastPageRowCount);
            this.setVScrollbarValues(vMax);
            this.setVScrollValue(Math.min(this.getVScrollValue(), vMax));
        }

        //this.getCanvas().resize();
        this.behaviorStateChanged();

        this.resizeScrollbars();
    },
    synchronizeScrollingBoundries: function() {
        this.deprecated('synchronizeScrollingBoundries()', 'synchronizeScrollingBoundaries()', '1.2.0');
    },

    /**
     * @memberOf Hypergrid#
     * @desc Note that "viewable rows" includes any partially viewable rows.
     * @returns {number} The number of viewable rows.
     */
    getVisibleRows: function() {
        return this.renderer.getVisibleRows();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Note that "viewable columns" includes any partially viewable columns.
     * @returns {number} The number of viewable columns.
     */
    getVisibleColumns: function() {
        return this.renderer.getVisibleColumns();
    },

    /**
     * @memberOf Hypergrid#
     * @summary Initialize the renderer sub-component.
     */
    initRenderer: function() {
        this.renderer = this.renderer || new Renderer(this);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     */
    getColumnWidth: function(columnIndex) {
        return this.behavior.getColumnWidth(columnIndex);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     * @param {number} columnWidth - The width in pixels.
     */
    setColumnWidth: function(columnIndex, columnWidth) {
        if (this.abortEditing()) {
            this.behavior.setColumnWidth(columnIndex, columnWidth);
        }
    },

    getColumnEdge: function(c) {
        return this.behavior.getColumnEdge(c, this.getRenderer());
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The total width of all the fixed columns.
     */
    getFixedColumnsWidth: function() {
        return this.behavior.getFixedColumnsWidth();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The height of the given row
     * @param {number} rowIndex - The untranslated fixed column index.
     */
    getRowHeight: function(rowIndex, dataModel) {
        return this.behavior.getRowHeight(rowIndex, dataModel);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Set the height of the given row.
     * @param {number} rowIndex - The row index.
     * @param {number} rowHeight - The width in pixels.
     */
    setRowHeight: function(rowIndex, rowHeight, dataModel) {
        if (this.abortEditing()) {
            this.behavior.setRowHeight(rowIndex, rowHeight, dataModel);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The total fixed rows height
     */
    getFixedRowsHeight: function() {
        return this.behavior.getFixedRowsHeight();
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Hypergrid#
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.behavior.getActiveColumnCount();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The number of rows.
     */
    getRowCount: function() {
        return this.behavior.getRowCount();
    },

    getUnfilteredRowCount: function() {
        return this.deprecated('getUnfilteredRowCount()', null, '1.2.0', arguments, 'No longer supported');
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.behavior.getFixedColumnCount();
    },

    /**
     * @memberOf Hypergrid#
     * @returns The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.behavior.getFixedRowCount();
    },

    /**
     * @memberOf Hypergrid#
     * @summary The top left area has been clicked on
     * @desc Delegates to the behavior.
     * @param {event} mouse - The event details.
     */
    topLeftClicked: function(mouse) {
        this.behavior.topLeftClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid#
     * @summary A fixed row has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    rowHeaderClicked: function(mouse) {
        this.behavior.rowHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid#
     * @summary A fixed column has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    columnHeaderClicked: function(mouse) {
        this.behavior.columnHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid#
     * @desc An edit event has occurred. Activate the editor at the given coordinates.
     * @param {number} event.gridCell.x - The horizontal coordinate.
     * @param {number} event.gridCell.y - The vertical coordinate.
     * @param {boolean} [event.primitiveEvent.type]
     * @returns {undefined|CellEditor} The editor object or `undefined` if no editor or editor already open.
     */
    onEditorActivate: function(event) {
        return this.editAt(event);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Get the cell editor.
     * @desc Delegates to the behavior.
     * @returns The cell editor at the given coordinates.
     * @param {Point} cellEvent - The grid cell coordinates.
     */
    getCellEditorAt: function(event) {
        return this.behavior.getCellEditorAt(event);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Toggle HiDPI support.
     * @desc HiDPI support is now *on* by default.
     * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
     */
    toggleHiDPI: function() {
        if (this.properties.useHiDPI) {
            this.removeAttribute('hidpi');
        } else {
            this.setAttribute('hidpi', null);
        }
        this.canvas.resize();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The HiDPI ratio.
     */
    getHiDPI: function(ctx) {
        if (window.devicePixelRatio && this.properties.useHiDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1,
                backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1,
                result = devicePixelRatio / backingStoreRatio;
        } else {
            result = 1;
        }
        return result;
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The width of the given (recently rendered) column.
     * @param {number} colIndex - The column index.
     */
    getRenderedWidth: function(colIndex) {
        return this.renderer.getRenderedWidth(colIndex);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The height of the given (recently rendered) row.
     * @param {number} rowIndex - The row index.
     */
    getRenderedHeight: function(rowIndex) {
        return this.renderer.getRenderedHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Update the cursor under the hover cell.
     */
    updateCursor: function() {
        var cursor = this.behavior.getCursorAt(-1, -1);
        var hoverCell = this.hoverCell;
        if (
            hoverCell &&
            hoverCell.x > -1 &&
            hoverCell.y > -1
        ) {
            var x = hoverCell.x + this.getHScrollValue();
            cursor = this.behavior.getCursorAt(x, hoverCell.y + this.getVScrollValue());
        }
        this.beCursor(cursor);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Repaint the given cell.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    repaintCell: function(x, y) {
        this.renderer.repaintCell(x, y);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} The user is currently dragging a column to reorder it.
     */
    isDraggingColumn: function() {
        return !!this.renderOverridesCache.dragger;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Scroll up one full page.
     * @returns {number}
     */
    pageUp: function() {
        var rowNum = this.renderer.getPageUpRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Scroll down one full page.
     * @returns {number}
     */
    pageDown: function() {
        var rowNum = this.renderer.getPageDownRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Not yet implemented.
     */
    pageLeft: function() {
        throw 'page left not yet implemented';
    },

    /**
     * @memberOf Hypergrid#
     * @desc Not yet implemented.
     */
    pageRight: function() {
        throw 'page right not yet implemented';
    },

    /**
     * @memberOf Hypergrid#
     * @returns {object[]} Objects with the values that were just rendered.
     */
    getRenderedData: function() {
        // assumes one row of headers
        var behavior = this.behavior,
            colCount = this.getColumnCount().length,
            rowCount = this.renderer.visibleRows.length,
            headers = new Array(colCount),
            results = new Array(rowCount),
            row;

        headers.forEach(function(header, c) {
            headers[c] = behavior.getActiveColumn(c).header;
        });

        results.forEach(function(result, r) {
            row = results[r] = {
                hierarchy: behavior.getFixedColumnValue(0, r)
            };
            headers.forEach(function(field, c) {
                row[field] = behavior.getValue(c, r);
            });
        });

        return results;
    },

    /**
     * @summary Autosize a column for best fit.
     * @param {Column|number} columnOrIndex - The column or active column index.
     * @memberOf Hypergrid#
     */
    autosizeColumn: function(columnOrIndex) {
        var column = columnOrIndex >= -2 ? this.behavior.getActiveColumn(columnOrIndex) : columnOrIndex;
        column.checkColumnAutosizing(true);
        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Enable/disable if this component can receive the focus.
     * @param {boolean} - canReceiveFocus
     */
    setFocusable: function(canReceiveFocus) {
        this.canvas.setFocusable(canReceiveFocus);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The number of columns that were just rendered
     */
    getVisibleColumnsCount: function() {
        return this.renderer.getVisibleColumnsCount();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {number} The number of rows that were just rendered
     */
    getVisibleRowsCount: function() {
        return this.renderer.getVisibleRowsCount();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Update the size of a grid instance.
     */
    updateSize: function() {
        this.canvas.checksize();
    },


    /**
     * @memberOf Hypergrid#
     * @desc Stop the global repainting flag thread.
     */
    stopPaintThread: function() {
        this.canvas.stopPaintThread();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Stop the global resize check flag thread.
     */
    stopResizeThread: function() {
        this.canvas.stopResizeThread();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Restart the global resize check flag thread.
     */
    restartResizeThread: function() {
        this.canvas.restartResizeThread();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Restart the global repainting check flag thread.
     */
    restartPaintThread: function() {
        this.canvas.restartPaintThread();
    },

    swapColumns: function(source, target) {
        //Turns out this is called during dragged 'i.e' when the floater column is reshuffled
        //by the currently dragged column. The column positions are constantly reshuffled
        this.behavior.swapColumns(source, target);
    },

    endDragColumnNotification: function() {
        this.behavior.endDragColumnNotification();
    },

    getFixedColumnsMaxWidth: function() {
        return this.behavior.getFixedColumnsMaxWidth();
    },

    isMouseDownInHeaderArea: function() {
        var headerRowCount = this.getHeaderRowCount();
        var mouseDown = this.getMouseDown();
        return mouseDown.x < 0 || mouseDown.y < headerRowCount;
    },

    _getBoundsOfCell: function(x, y) {
        return this.deprecated('_getBoundsOfCell()', 'getBoundsOfCell()', '1.2.0', arguments);
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Hypergrid#
     */
    getColumnProperties: function(x) {
        return this.behavior.getColumnProperties(x);
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Hypergrid#
     */
    setColumnProperties: function(x, properties) {
        this.behavior.setColumnProperties(x, properties);
    },

    /**
     * Clears all cell properties of given column or of all columns.
     * @param {number} [x] - Omit for all columns.
     * @memberOf Behavior#
     */
    clearAllCellProperties: function(x) {
        this.behavior.clearAllCellProperties(x);
        this.renderer.resetAllCellPropertiesCaches();
    },

    isShowRowNumbers: function() {
        return this.deprecated('isShowRowNumbers()', 'properties.showRowNumbers', 'v1.2.10');
    },
    isEditable: function() {
        return this.deprecated('isEditable()', 'properties.editable', 'v1.2.10');
    },

    /**
     * @param {integerRowIndex|sectionPoint} rn
     * @returns {boolean}
     * @memberOf Hypergrid#
     */
    isGridRow: function(y) {
        return new this.beahvior.CellEvent(0, y).isDataRow;
    },

    isShowHeaderRow: function() {
        return this.deprecated('isShowHeaderRow()', 'properties.showHeaderRow', 'v1.2.10');
    },

    /**
     * @returns {number} The total number of rows of all subgrids preceding the data subgrid.
     * @memberOf Hypergrid#
     */
    getHeaderRowCount: function() {
        return this.behavior.getHeaderRowCount();
    },

    isShowFilterRow: function() {
        return this.deprecated('isShowFilterRow()', 'properties.showFilterRow', 'v1.2.10');
    },

    hasHierarchyColumn: function() {
        return this.behavior.hasHierarchyColumn();
    },
    isHierarchyColumn: function(x) {
        return this.hasHierarchyColumn() && x === 0;
    },
    checkScrollbarVisibility: function() {
        // var hoverClassOver = this.properties.scrollbarHoverOver;
        // var hoverClassOff = this.properties.scrollbarHoverOff;

        // if (hoverClassOff === 'visible') {
        //     this.sbHScroller.classList.remove(hoverClassOver);
        //     this.sbVScroller.classList.remove(hoverClassOff);
        //     this.sbHScroller.classList.add('visible');
        //     this.sbVScroller.classList.add('visible');
        // }
    },
    isRowNumberAutosizing: function() {
        return this.deprecated('isRowNumberAutosizing()', 'properties.rowNumberAutosizing', 'v1.2.10');
    },
    lookupFeature: function(key) {
        return this.behavior.lookupFeature(key);
    },
    getRow: function(y) {
        return this.behavior.getRow(y);
    },

    isColumnAutosizing: function() {
        return this.deprecated('isColumnAutosizing()', 'columnAutosizing', 'v1.2.2', arguments, 'Note however that as of v1.2.2 columnAutosizing grid property no longer has the global meaning it had previously and should no longer be referred to directly. Refer to each column\'s `columnAutosizing` property instead.');
    },

    newPoint: function(x, y) {
        return new Point(x, y);
    },
    newRectangle: function(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    },

    /**
     * @summary Get the given data controller.
     * @param {string} type
     * @returns {null|undefined|*} The data controller or:
     * * `null` means unknown data controller.
     * * `undefined` means the data source handles this data controller but the data controller is undefined.
     * @memberOf Hypergrid#
     */
    getController: function(type) {
        return this.behavior.getController(type);
    },

    /**
     * @summary Set the given data controller(s).
     * @desc The data model needs to be able to accept the specified data controller type(s). If it fails to accept the specified data controller(s), an error condition is raised.
     *
     * (To ignore the error, place the call in a `try...catch`. From there you could call {@link Base#notify|notify} to report it as a warning or an alert instead.)
     *
     * Setting data controller(s) triggers a shape change.
     * @param {string} typeOrHashOfTypes - One of:
     * * **object** - Hash of multiple data controllers, by type.
     * * **string** - Type of the single data controller given in `controller`.
     * @param {dataControlInterface} [controller] - Only required when 'hash' is a string; omit when `hash` is an object.
     * @returns {object} - Hash of all results, by type. Each member will be:
     * * The given data controller for that type when defined.
     * * A new "null" data controller, generated by the data model when the given data controller for that type was `undefined`.
     * * `undefined` - The data controller was unknown to the data model.
     * @memberOf Hypergrid#
     */
    setController: function(typeOrHashOfTypes, controller) {
        var results = this.behavior.setController(typeOrHashOfTypes, controller),
            rejections = Object.keys(results).filter(function(name) {
                return !results[name];
            }).toString();

        if (rejections) {
            throw 'Unexpected data controller(s): ' + rejections;
        }

        return results;
    },

    prop: function(type, columnIndex, keyOrHash, value) {
        return this.behavior.prop.apply(this.behavior, arguments);
    },

    get charMap() {
        return this.behavior.charMap;
    }
});

var VAR = '.var.';
function hasVar(descriptor) {
    return (
        descriptor.get && descriptor.get.toString().indexOf(VAR) >= 0 ||
        descriptor.set && descriptor.set.toString().indexOf(VAR) >= 0
    );
}
/**
 * Creates an instance variable backer for use by the getters and setters in {@link dynamicProperties}.
 * @constructor
 * @memberOf Hypergrid~
 * @private
 */
function Var() {
    Object.getOwnPropertyNames(dynamicProperties).forEach(function(name) {
        if (hasVar(Object.getOwnPropertyDescriptor(dynamicProperties, name))) {
            this[name] = defaults[name];
        }
    }, this);
}

function findOrCreateContainer(boundingRect) {
    var div = document.getElementById('hypergrid'),
        used = div && !div.firstElementChild;

    if (!used) {
        div = document.createElement('div');
        setStyles(div, boundingRect, RECT_STYLES);
        document.body.appendChild(div);
    }

    return div;
}

function setStyles(el, style, keys) {
    if (style) {
        var elStyle = el.style;
        keys.forEach(function(key) {
            if (style[key] !== undefined) {
                elStyle[key] = style[key];
            }
        });
    }
}

function headerFormatter(value, config) {
    var colIndex = config.dataCell.x,
        sortString = this.behavior.dataModel.getSortImageForColumn(colIndex);

    if (sortString) {
        var groups = value.lastIndexOf(this.behavior.groupHeaderDelimiter) + 1;

        // if grouped header, prepend group headers to sort direction indicator
        if (groups) {
            sortString = value.substr(0, groups) + sortString;
            value = value.substr(groups);
        }

        // prepend sort direction indicator to column header
        value = sortString + value;
    }

    return value;
}

/**
 * @name plugins
 * @memberOf Hypergrid
 * @type {object}
 * @summary Hash of references to shared plug-ins.
 * @desc Dictionary of shared (pre-installed) plug-ins. Used internally, primarily to avoid reinstallations. See examples for how to reference (albeit there is normally no need to reference plugins directly).
 *
 * For the dictionary of _instance_ plugins, see {@link Hypergrid#plugins|plugins} (defined in the {@link Hypergrid#intialize|Hypergrid constructor}).
 *
 * To force reinstallation of a shared plugin delete it first:
 * ```javascript
 * delete Hypergrid.plugins.mySharedPlugin;
 * ```
 * To force reinstallation of all shared plugins:
 * ```javascript
 * Hypergrid.plugins = {};
 * ```
 * @example
 * var allSharedPlugins = Hypergrid.plugins;
 * var mySharedPlugin = Hypergrid.plugins.mySharedPlugin;
 */
Hypergrid.plugins = {};

/**
 * @name localization
 * @memberOf Hypergrid
 * @type {object}
 * @summary Shared localization defaults for all grid instances.
 * @desc These property values are overridden by those supplied in the `Hypergrid` constructor's `options.localization`.
 * @property {string|string[]} [locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFormat` and `Intl.DateFormat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information. Omitting will use the runtime's local language and region.
 * @property {object} [numberOptions] - Options passed to `Intl.NumberFormat` for creating the basic "number" localizer.
 * @property {object} [dateOptions] - Options passed to `Intl.DateFormat` for creating the basic "date" localizer.
 */
Hypergrid.localization = {
    locale: 'en-US',
    numberOptions: { maximumFractionDigits: 0 }
};


Hypergrid.prototype.setController.onerror = 'warn';

Hypergrid.prototype.mixIn(require('./lib/events'));
Hypergrid.prototype.mixIn(require('./lib/selection'));

Hypergrid.defaults = Hypergrid.properties = defaults;


module.exports = Hypergrid;

},{"./Base":41,"./behaviors":48,"./cellEditors":59,"./cellRenderers":69,"./defaults":74,"./lib/Canvas":90,"./lib/Localization":95,"./lib/SelectionModel":96,"./lib/dynamicProperties":100,"./lib/events":102,"./lib/polyfills":106,"./lib/selection":107,"./lib/stylesheet":108,"./renderer":117,"finbars":8,"object-iterators":36,"rectangular":39}],43:[function(require,module,exports){
'use strict';

var Point = require('rectangular').Point;

var Base = require('../Base');
var Column = require('./Column');
var cellEventFactory = require('./../lib/cellEventFactory');
var noExportProperties = [
    'columnHeader',
    'columnHeaderColumnSelection',
    'filterProperties',
    'rowHeader',
    'rowHeaderRowSelection',
    'rowNumbersProperties',
    'treeColumnProperties',
    'treeColumnPropertiesColumnSelection',
];

/**
 * @constructor
 * @abstract
 * @desc A sort of "model++." It contains all code/data that's necessary for easily implementing a virtual data source and its manipulation/analytics.
 *
 */
var Behavior = Base.extend('Behavior', {

    /**
     * @desc this is the callback for the plugin pattern of nested tags
     * @param {Hypergrid} grid
     * @param {object} [options] - _(See {@link behaviors.JSON#setData} for additional options.)_
     * @param {DataModels[]} [options.subgrids]
     * @memberOf Behavior#
     */
    initialize: function(grid, options) {
        /**
         * @type {Hypergrid}
         * @memberOf Behavior#
         */
        this.grid = grid;

        this.initializeFeatureChain(grid);

        this.grid.behavior = this;
        this.reset(options);
    },

    /**
     * @desc create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
     * @param {Hypergrid} grid
     * @memberOf Behavior#
     */
    initializeFeatureChain: function(grid) {
        var self = this;

        /**
         * @summary Hash of feature class names.
         * @desc Built here but otherwise not in use.
         * @type {object}
         * @memberOf Behavior#
         */
        this.featureMap = {};

        this.features.forEach(function(FeatureConstructor) {
            var newFeature = new FeatureConstructor;
            self.featureMap[newFeature.$$CLASS_NAME] = newFeature;
            if (self.featureChain) {
                self.featureChain.setNext(newFeature);
            } else {
                /**
                 * @summary Controller chain of command.
                 * @desc Each feature is linked to the next feature.
                 * @type {Feature}
                 * @memberOf Behavior#
                 */
                self.featureChain = newFeature;
            }
        });
        if (this.featureChain) {
            this.featureChain.initializeOn(grid);
        }
    },

    features: [], // override in implementing class unless no features

    /**
     * @param {object} [options]
     * @param {object} [options.pipeline] - Consumed by {@link dataModels.JSON#reset}.
     *
     * If omitted, previously established pipeline is reused.
     * @param {object} [options.controllers] - Consumed by {@link dataModels.JSON#reset}.
     *
     * If omitted, previously established controllers list is reused.
     * @memberOf Behavior#
     */
    reset: function(options) {
        if (this.dataModel) {
            options = options || {};
            this.dataModel.reset({
                pipeline: options.pipeline,
                controllers: options.controllers
            });
        } else {
            /**
             * @type {dataModelAPI}
             * @memberOf Behavior#
             */
            this.dataModel = this.getNewDataModel(options);

            // recreate `CellEvent` class so it can set up its internal `grid`, `behavior`, and `dataModel` convenience properties
            this.CellEvent = cellEventFactory(this.grid);
        }

        this.scrollPositionX = this.scrollPositionY = 0;

        this.clearColumns();
        this.createColumns();

        /**
         * Ordered list of subgrids to render.
         * @type {subgridSpec[]}
         * @memberOf Hypergrid#
         */
        this.subgrids = options.subgrids || this.subgrids || this.defaultSubgridSpecs;
    },

    get renderedColumnCount() {
        return this.grid.renderer.visibleColumns.length;
    },

    get renderedRowCount() {
        return this.grid.renderer.visibleRows.length;
    },

    clearColumns: function() {
        /**
         * @type {Column[]}
         * @memberOf Behavior#
         */
        this.columns = [];

        /**
         * @type {Column[]}
         * @memberOf Behavior#
         */
        this.allColumns = [];

        this.allColumns[-1] = this.columns[-1] = this.newColumn({ index: -1 });
        this.allColumns[-2] = this.columns[-2] = this.newColumn({ index: -2 });

        this.columnEnum = {};
    },

    getActiveColumn: function(x) {
        return this.columns[x];
    },

    /**
     * The "grid index" given a "data index" (or column object)
     * @param {Column|number} columnOrIndex
     * @returns {undefined|number} The grid index of the column or undefined if column not in grid.
     * @memberOf Hypergrid#
     */
    getActiveColumnIndex: function(columnOrIndex) {
        var index = columnOrIndex instanceof Column ? columnOrIndex.index : columnOrIndex;
        for (var i = 0; i < this.columns.length; ++i) {
            if (this.columns[i].index === index) {
                return i;
            }
        }
    },

    getVisibleColumn: function() {
        return this.deprecated('getVisibleColumn(x)', 'getActiveColumn(x)', '1.0.6', arguments);
    },
    getVisibleColumnName: function() {
        return this.deprecated('getVisibleColumnName(x)', 'getActiveColumn(x).name', '1.0.6', arguments);
    },
    getColumnId: function() {
        return this.deprecated('getColumnId(x)', 'getActiveColumn(x).header', '1.0.6', arguments);
    },
    getHeader: function() {
        return this.deprecated('getHeader(x)', 'getActiveColumn(x).header', '1.0.6', arguments);
    },

    getColumn: function(x) {
        return this.allColumns[x];
    },

    newColumn: function(options) {
        return new Column(this, options);
    },

    addColumn: function(options) {
        var column = this.newColumn(options);
        this.columns.push(column);
        this.allColumns.push(column);
        return column;
    },

    createColumns: function() {
        this.clearColumns();
        this.clearAllCellProperties();
        //concrete implementation here
    },

    getColumnWidth: function(x) {
        var column = this.getActiveColumn(x);
        if (!column) {
            return this.grid.properties.defaultColumnWidth;
        }
        var width = column.getWidth();
        return width;
    },

    /**
     * @param {Column|number} columnOrIndex - The column or active column index.
     * @param width
     * @memberOf Hypergrid#
     */
    setColumnWidth: function(columnOrIndex, width) {
        var column = columnOrIndex >= -2 ? this.getActiveColumn(columnOrIndex) : columnOrIndex;
        column.setWidth(width);
        this.stateChanged();
    },

    getCellProvider: function(name) {
        return this.deprecated('getCellProvider()', 'grid.cellRenderers', '1.0.6', arguments);
    },
    createCellProvider: function(name) {
        console.error('getCellProvider() is deprecated as of v1.0.6. No replacement; do not call. Previously called by `Behavior` constructor; `new CellRenderers()` is now called by `Hypergrid` constructor instead.', arguments);
    },

    /**
     * @memberOf Behavior#
     */
    reindex: function() {
        this.dataModel.reindex();
        this.shapeChanged();
    },

    /**
     * @memberOf Behavior#
     * @desc utility function to empty an object of its members
     * @param {object} obj - the object to empty
     * @param {boolean} [exportProps]
     * * `undefined` (omitted) - delete *all* properties
     * * **falsy** - delete *only* the export properties
     * * **truthy** - delete all properties *except* the export properties
     */
    clearObjectProperties: function(obj, exportProps) {
        for (var key in obj) {
            if (
                obj.hasOwnProperty(key) && (
                    exportProps === undefined ||
                    !exportProps && noExportProperties.indexOf(key) >= 0 ||
                    exportProps && noExportProperties.indexOf(key) < 0
                )
            ) {
                delete obj[key];
            }
        }
    },

    /**
     * @memberOf Behavior#
     * @desc getter for a [Memento](http://c2.com/cgi/wiki?MementoPattern) Object
     * @returns {object}
     */
    getPrivateState: function() {
        return this.deprecated('getPrivateState()', 'grid.properties', '1.2.0');
    },

    //this is effectively a clone, with certain things removed....
    getState: function() {
        var copy = JSON.parse(JSON.stringify(this.grid.properties));
        this.clearObjectProperties(copy.columnProperties, false);
        return copy;
    },
    /**
     * @memberOf Behavior#
     * @desc clear all table state
     */
    clearState: function() {
       this.grid.clearState();
    },

    /**
     * @memberOf Behavior#
     * @desc Restore this table to a previous state.
     * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
     * @param {Object} memento - an encapsulated representation of table state
     */
    setState: function(memento) {

        if (memento.rowHeights) {
            this.deprecated('rowHeights', 'rowHeights, the hash of row heights you provided to setState method, is no longer supported as of v1.2.0 and will be ignored. Instead use individual calls to setRowHeight(y, height, dataModel) for each row height you wish to set, where y is local zero-based row index within dataModel. The dataModel arg is optional and defaults to this.dataModel; specify to set row heights in other data models, such as header row, filter cell row, individual summary rows, etc.');
        }

        this.createColumns();

        var state = this.grid.properties;
        for (var key in memento) {
            if (memento.hasOwnProperty(key)) {
                state[key] = memento[key];
            }
        }

        this.setAllColumnProperties(memento.columnProperties);

        this.dataModel.reindex();
    },

    setAllColumnProperties: function(columnProperties) {
        if (columnProperties) {
            columnProperties.forEach(function(properties, i) {
                this.getColumn(i).properties = properties;
            }, this);
        }
    },

    setColumnOrder: function(columnIndexes) {
        if (Array.isArray(columnIndexes)){
            this.columns.length = columnIndexes.length;
            columnIndexes.forEach(function(index, i) {
                this.columns[i] = this.allColumns[index];
            }, this);
        }
    },

    _setColumnOrder: function(columnIndexes) {
        this.deprecated('_setColumnOrder(columnIndexes)', 'setColumnOrder(columnIndexes)', '1.2.10', arguments);
    },

    /**
     * @memberOf Behavior#
     * @desc Rebuild the column order indexes
     * @param {Array} columnIndexes - list of column indexes
     * @param {Boolean} [silent=false] - whether to trigger column changed event
     */
    setColumnIndexes: function(columnIndexes, silent) {
        this.grid.properties.columnIndexes = columnIndexes;
        if (!silent) {
            this.grid.fireSyntheticOnColumnsChangedEvent();
        }
    },

    /**
     * @summary Show inactive column(s) or move active column(s).
     *
     * @desc Adds one or several columns to the "active" column list.
     *
     * @param {boolean} [isActiveColumnIndexes=false] - Which list `columnIndexes` refers to:
     * * `true` - The active column list. This can only move columns around within the active column list; it cannot add inactive columns (because it can only refer to columns in the active column list).
     * * `false` - The full column list (as per column schema array). This inserts columns from the "inactive" column list, moving columns that are already active.
     *
     * @param {number|number[]} columnIndexes - Column index(es) into list as determined by `isActiveColumnIndexes`. One of:
     * * **Scalar column index** - Adds single column at insertion point.
     * * **Array of column indexes** - Adds multiple consecutive columns at insertion point.
     *
     * _This required parameter is promoted left one arg position when `isActiveColumnIndexes` omitted._
     *
     * @param {number} [referenceIndex=this.columns.length] - Insertion point, _i.e.,_ the element to insert before. A negative values skips the reinsert. Default is to insert new columns at end of active column list.
     *
     * _Promoted left one arg position when `isActiveColumnIndexes` omitted._
     *
     * @param {boolean} [allowDuplicateColumns=false] - Unless true, already visible columns are removed first.
     *
     * _Promoted left one arg position when `isActiveColumnIndexes` omitted + one position when `referenceIndex` omitted._
     *
     * @memberOf Behavior#
     */
    showColumns: function(isActiveColumnIndexes, columnIndexes, referenceIndex, allowDuplicateColumns) {
        // Promote args when isActiveColumnIndexes omitted
        if (typeof isActiveColumnIndexes === 'number' || Array.isArray(isActiveColumnIndexes)) {
            allowDuplicateColumns = referenceIndex;
            referenceIndex = columnIndexes;
            columnIndexes = isActiveColumnIndexes;
            isActiveColumnIndexes = false;
        }

        var activeColumns = this.columns,
            sourceColumnList = isActiveColumnIndexes ? activeColumns : this.allColumns;

        // Nest scalar index
        if (typeof columnIndexes === 'number') {
            columnIndexes = [columnIndexes];
        }

        var newColumns = columnIndexes
            // Look up columns using provided indexes
            .map(function(index) { return sourceColumnList[index]; })
            // Remove any undefined columns
            .filter(function(column) { return column; });

        // Default insertion point is end (i.e., before (last+1)th element)
        if (typeof referenceIndex !== 'number') {
            allowDuplicateColumns = referenceIndex; // assume reference index was omitted when not a number
            referenceIndex = activeColumns.length;
        }

        // Remove already visible columns and adjust insertion point
        if (!allowDuplicateColumns) {
            newColumns.forEach(function(column) {
                var i = activeColumns.indexOf(column);
                if (i >= 0) {
                    activeColumns.splice(i, 1);
                    if (referenceIndex > i) {
                        --referenceIndex;
                    }
                }
            });
        }

        // Insert the new columns at the insertion point
        if (referenceIndex >= 0) {
            activeColumns.splice.apply(activeColumns, [referenceIndex, 0].concat(newColumns));
        }

        this.grid.properties.columnIndexes = activeColumns.map(function(column) { return column.index; });
    },

    /**
     * @summary Hide active column(s).
     * @desc Removes one or several columns from the "active" column list.
     * @param {boolean} [isActiveColumnIndexes=false] - Which list `columnIndexes` refers to:
     * * `true` - The active column list.
     * * `false` - The full column list (as per column schema array).
     * @param {number|number[]} columnIndexes - Column index(es) into list as determined by `isActiveColumnIndexes`. One of:
     * * **Scalar column index** - Adds single column at insertion point.
     * * **Array of column indexes** - Adds multiple consecutive columns at insertion point.
     *
     * _This required parameter is promoted left one arg position when `isActiveColumnIndexes` omitted._
     * @memberOf Behavior#
     */
    hideColumns: function(isActiveColumnIndexes, columnIndexes) {
        var args = Array.prototype.slice.call(arguments); // Convert to array so we can add an argument (element)
        args.push(-1); // Remove only; do not reinsert.
        this.showColumns.apply(this, args);
    },

    /**
     * @memberOf Behavior#
     * @desc fetch the value for a property key
     * @returns {*} The value of the given property.
     * @param {string} key - a property name
     */
    resolveProperty: function(key) {
        // todo: remove when we remove the deprecated grid.resolveProperty
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Behavior#
     * @desc A specific cell was clicked; you've been notified.
     * @param {Object} event - all event information
     * @return {boolean} Clicked in a drill-down column.
     */
    cellClicked: function(event) {
        if (arguments.length === 2) {
            return this.deprecated('cellClicked(cell, event)', 'cellClicked(event)', '1.2.0', arguments);
        }
        return this.dataModel.cellClicked(event);
    },

    /**
     * @memberOf Behavior#
     * @desc A specific cell was le double-clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellDoubleClicked: function(cell, event) {

    },

    lookupFeature: function(key) {
        return this.featureMap[key];
    },

    /**
     * @param {CellEvent|number} xOrCellEvent - Grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @memberOf Behavior#
     */
    getValue: function(xOrCellEvent, y) {
        switch (arguments.length) {
            case 1:
                return xOrCellEvent.value;
            case 2:
                return new this.CellEvent(xOrCellEvent, y).value;
        }
    },

    /**
     * @summary Gets the number of rows in the data subgrid.
     * @memberOf Behavior.prototype
     */
    getRowCount: function() {
        return this.dataModel.getRowCount();
    },

    getUnfilteredValue: function(x, y) {
        var column = this.getActiveColumn(x);
        return column && column.getUnfilteredValue(y);
    },

    /**
     * @memberOf Behavior#
     * @desc update the data at point x, y with value
     * @return The data.
     * @param {CellEvent|number} xOrCellEvent - Grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @param {Object} value - The value to use. _When `y` omitted, promoted to 2nd arg._
     * @return {boolean} Consumed.
     */
    setValue: function(xOrCellEvent, y, value) {
        switch (arguments.length) {
            case 3: xOrCellEvent = new this.CellEvent(xOrCellEvent, y); break;
            case 2: value = y; break;
        }

        xOrCellEvent.value = value;
    },

    getDataValue: function(x, y) {
        return this.deprecated('getDataValue(x, y)', 'dataModel.getValue(x, y)', '1.1.0', arguments);
    },

    setDataValue: function(x, y, value) {
        return this.deprecated('setDataValue(x, y, value)', 'dataModel.setValue(x, y, value)', '1.1.0', arguments);
    },

    /**
     * @summary Get the cell's own properties object.
     * @desc May be undefined because cells only have their own properties object when at lest one own property has been set.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @returns {undefined|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `undefined`.
     * @memberOf Behavior#
     */
    getCellOwnProperties: function(xOrCellEvent, y) {
        switch (arguments.length) {
            case 1:
                return xOrCellEvent.column // xOrCellEvent is cellEvent
                    .getCellOwnProperties(xOrCellEvent.dataCell.y, xOrCellEvent.visibleRow.subgrid);
            case 2:
                return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                    .getCellOwnProperties(y);
        }
    },

    /**
     * @summary Get the properties object for cell.
     * @desc This is the cell's own properties object if found else the column object.
     *
     * If you are seeking a single specific property, consider calling {@link Behavior#getCellProperty} instead.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @return {object} The properties of the cell at x,y in the grid.
     * @memberOf Behavior#
     */
    getCellProperties: function(xOrCellEvent, y) {
        switch (arguments.length) {
            case 1:
                return xOrCellEvent.properties; // xOrCellEvent is cellEvent
            case 2:
                return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                    .getCellProperties(y);
        }
    },

    /**
     * @summary Return a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate._ Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {string} key - Name of property to get. _When `y` omitted, this param promoted to 2nd arg._
     * @return {object} The specified property for the cell at x,y in the grid.
     * @memberOf Behavior#
     */
    getCellProperty: function(xOrCellEvent, y, key) {
        switch (arguments.length) {
            case 2:
                return xOrCellEvent.properties[y]; // xOrCellEvent is cellEvent and y omitted so y here is actually key
            case 3:
                return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                    .getCellProperty(y, key);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc update the data at point x, y with value
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {Object} properties - Hash of cell properties. _When `y` omitted, this param promoted to 2nd arg._
     */
    setCellProperties: function(xOrCellEvent, y, properties) {
        if (typeof y === 'object') {
            xOrCellEvent.column // xOrCellEvent is cellEvent
                .setCellProperties(xOrCellEvent.dataCell.y, y, xOrCellEvent.visibleRow.subgrid); // y omitted so y here is actually properties
        } else {
            this.getColumn(xOrCellEvent) // xOrCellEvent is x
                .setCellProperties(y, properties);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc update the data at point x, y with value
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {Object} properties - Hash of cell properties. _When `y` omitted, this param promoted to 2nd arg._
     */
    addCellProperties: function(xOrCellEvent, y, properties) {
        if (typeof y === 'object') {
            xOrCellEvent.column // xOrCellEvent is cellEvent
                .addCellProperties(xOrCellEvent.dataCell.y, y, xOrCellEvent.visibleRow.subgrid); // y omitted so y here is actually properties
        } else {
            this.getColumn(xOrCellEvent) // xOrCellEvent is x
                .addCellProperties(y, properties);
        }
    },

    /**
     * @summary Set a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     *
     * NOTE: For performance reasons, renderer's cell event objects cache their respective cell properties objects. This method accepts a `CellEvent` overload. Whenever possible, use the `CellEvent` from the renderer's cell event pool. Doing so will reset the cell properties object cache.
     *
     * If you use some other `CellEvent`, the renderer's `CellEvent` properties cache will not be automatically reset until the whole cell event pool is reset on the next call to {@link Renderer#computeCellBoundaries}. If necessary, you can "manually" reset it by calling {@link Renderer#resetCellPropertiesCache|resetCellPropertiesCache(yourCellEvent)} which searches the cell event pool for one with matching coordinates and resets the cache.
     *
     * The raw coordinates overload calls the `resetCellPropertiesCache(x, y)` overload for you.
     * @param {CellEvent|number} xOrCellEvent - `CellEvent` or data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {string} key - Name of property to get. _When `y` omitted, this param promoted to 2nd arg._
     * @param value
     * @parsam {dataModelAPI} [dataModel=this.subgrids.lookup.data] - For use only when `xOrCellEvent` is _not_ a `CellEvent`: Provide a subgrid.
     * @memberOf Behavior#
     */
    setCellProperty: function(xOrCellEvent, y, key, value, dataModel) {
        var cellOwnProperties;
        switch (arguments.length) {
            case 3:
                // xOrCellEvent is cellEvent, y is key, key is value
                cellOwnProperties = xOrCellEvent.setCellProperty(y, key);
                break;
            case 4:
            case 5:
                cellOwnProperties = this.getColumn(xOrCellEvent) // xOrCellEvent is x
                    .setCellProperty(y, key, value, dataModel);
                this.grid.renderer.resetCellPropertiesCache(xOrCellEvent, y, dataModel);
        }
        return cellOwnProperties;
    },

    getUnfilteredRowCount: function() {
        return this.deprecated('getUnfilteredRowCount()', null, '1.2.0', arguments, 'No longer supported');
    },

    /**
     * @summary The total height of the "fixed rows."
     * @desc The total height of all (non-scrollable) rows preceding the (scrollable) data subgrid.
     * @memberOf Behavior#
     * @return {number} The height in pixels of the fixed rows area of the hypergrid, the total height of:
     * 1. All rows of all subgrids preceding the data subgrid.
     * 2. The first `fixedRowCount` rows of the data subgrid.
     */
    getFixedRowsHeight: function() {
        var dataModel, isData, r, R,
            subgrids = this.subgrids,
            height = 0;

        for (var i = 0; i < subgrids.length && !isData; ++i) {
            dataModel = subgrids[i];
            isData = dataModel.isData;
            R = isData ? this.grid.properties.fixedRowCount : dataModel.getRowCount();
            for (r = 0; r < R; ++r) {
                height += this.getRowHeight(r, dataModel);
            }
        }

        return height;
    },

    /**
     * @memberOf Behavior#
     * @param {number} rowIndex - Data row coordinate local to datsModel.
     * @param {dataModelAPI} [dataModel=this.dataModel]
     */
    getRowHeight: function(rowIndex, dataModel) {
        var rowData = (dataModel || this.dataModel).getRow(rowIndex);
        return rowData && rowData.__ROW_HEIGHT || this.grid.properties.defaultRowHeight;
    },

    /**
     * @memberOf Behavior#
     * @desc The value is lazily initialized and comes from the properties mechanism for '`defaultRowHeight`', which should be ~20px.
     * @returns {number} The row height in pixels.
     */
    getDefaultRowHeight: function() {
        return this.deprecated('getDefaultRowHeight()', 'grid.properties.defaultRowHeight', '1.2.0');
    },

    /**
     * @memberOf Behavior#
     * @desc set the pixel height of a specific row
     * @param {number} rowIndex - Data row coordinate local to datsModel.
     * @param {number} height - pixel height
     * @param {dataModelAPI} [dataModel=this.dataModel]
     */
    setRowHeight: function(rowIndex, height, dataModel) {
        var rowData = (dataModel || this.dataModel).getRow(rowIndex);
        if (rowData) {
            rowData.__ROW_HEIGHT = Math.max(5, Math.ceil(height));
            this.stateChanged();
        }
    },

    /**
     * @memberOf Behavior#
     * @return {number} The width of the fixed column area in the hypergrid.
     */
    getFixedColumnsWidth: function() {
        var count = this.getFixedColumnCount();
        var total = 0;
        for (var i = this.grid.properties.showRowNumbers ? -1 : 0; i < count; i++) {
            total += this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior#
     * @desc This exists to support "floating" columns.
     * @return {number} The total width of the fixed columns area.
     */
    getFixedColumnsMaxWidth: function() {
        return this.getFixedColumnsWidth();
    },

    /**
     * @memberOf Behavior#
     * @desc Set the scroll position in vertical dimension and notify listeners.
     * @param {number} y - the new y value
     */
    _setScrollPositionY: function(y) {
        this.setScrollPositionY(y);
        this.changed();
    },

    /**
     * @memberOf Behavior#
     * @desc Set the scroll position in horizontal dimension and notify listeners.
     * @param {number} x - the new x value
     */
    _setScrollPositionX: function(x) {
        this.setScrollPositionX(x);
        this.changed();
    },

    /**
     * @memberOf Behavior#
     * @desc The fixed row area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedRowClicked: function(grid, mouse) {
        var x = this.translateColumnIndex(this.getScrollPositionX() + mouse.gridCell.x - this.getFixedColumnCount());
        var translatedPoint = new Point(x, mouse.gridCell.y);
        mouse.gridCell = translatedPoint;
        this.fixedRowClicked(grid, mouse);
    },

    /**
     * @memberOf Behavior#
     * @desc The fixed column area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedColumnClicked: function(grid, mouse) {
        var translatedPoint = new Point(mouse.gridCell.x, this.getScrollPositionY() + mouse.gridCell.y - this.getFixedRowCount());
        mouse.gridCell = translatedPoint;
        this.fixedColumnClicked(grid, mouse);
    },

    /**
     * @memberOf Behavior#
     * @desc delegate setting the cursor up the feature chain of responsibility
     * @param {Hypergrid} grid
     */
    setCursor: function(grid) {
        grid.updateCursor();
        this.featureChain.setCursor(grid);
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse move to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseMove: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseMove(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onContextMenu: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleContextMenu(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling wheel moved to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onWheelMoved: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleWheelMoved(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse drag to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseDrag: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDrag(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling key down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling key up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDoubleClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDoubleClick(grid, event);
            this.setCursor(grid);
        }
    },
    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc delegate handling mouse exit to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseExit(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior#
     * @desc I've been notified that the behavior has changed.
     */
    changed: function() { this.grid.behaviorChanged(); },

    /**
     * @memberOf Behavior#
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    shapeChanged: function() { this.grid.behaviorShapeChanged(); },

    /**
     * @memberOf Behavior#
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    stateChanged: function() { this.grid.behaviorStateChanged(); },

    /**
     * @memberOf Behavior#
     * @return {boolean} Can re-order columns.
     */
    isColumnReorderable: function() {
        return this.grid.properties.columnsReorderable;
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Behavior#
     */
    getColumnProperties: function(x) {
        var column = this.getColumn(x);
        return column && column.properties;
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Behavior#
     */
    setColumnProperties: function(x, properties) {
        var column = this.getColumn(x);
        if (!column) {
            throw 'Expected column.';
        }
        var result = Object.assign(column.properties, properties);
        this.changed();
        return result;
    },

    /**
     * Clears all cell properties of given column or of all columns.
     * @param {number} [x] - Omit for all columns.
     * @memberOf Behavior#
     */
    clearAllCellProperties: function(x) {
        if (x !== undefined) {
            var column = this.getColumn(x);
            if (column) {
                column.clearAllCellProperties();
            }
        } else if (this.subgrids) {
            this.subgrids.forEach(function(dataModel) {
                for (var i = dataModel.getRowCount(); i--;) {
                    delete dataModel.getRow(i).__META;
                    // todo: test if optimizer wants following instead
                    // dataRow = dataModel.getRow(i);
                    // if (dataRow.__META !== undefined) { dataRow.__META = undefined; }
                }
            });
        }
    },

    /**
     * @memberOf Behavior#
     * @return {string[]} All the currently hidden column header labels.
     */
    getHiddenColumnDescriptors: function() {
        var tableState = this.grid.properties;
        var indexes = tableState.columnIndexes;
        var labels = [];
        var columnCount = this.getActiveColumnCount();
        for (var i = 0; i < columnCount; i++) {
            if (indexes.indexOf(i) === -1) {
                var column = this.getActiveColumn(i);
                labels.push({
                    id: i,
                    header: column.header,
                    field: column.name
                });
            }
        }
        return labels;
    },

    /**
     * @memberOf Behavior#
     * @return {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.grid.properties.fixedColumnCount;
    },

    /**
     * @memberOf Behavior#
     * @desc set the number of fixed columns
     * @param {number} n - the integer count of how many columns to be fixed
     */
    setFixedColumnCount: function(n) {
        this.grid.properties.fixedColumnCount = n;
    },

    /**
     * @summary The number of "fixed rows."
     * @desc The number of (non-scrollable) rows preceding the (scrollable) data subgrid.
     * @memberOf Behavior#
     * @return {number} The sum of:
     * 1. All rows of all subgrids preceding the data subgrid.
     * 2. The first `fixedRowCount` rows of the data subgrid.
     */
    getFixedRowCount: function() {
        return (
            this.grid.getHeaderRowCount() +
            this.grid.properties.fixedRowCount
        );
    },

    /**
     * @memberOf Behavior#
     * @desc Set the number of fixed rows, which includes (top to bottom order):
     * 1. The header rows
     *    1. The header labels row (optional)
     *    2. The filter row (optional)
     *    3. The top total rows (0 or more)
     * 2. The non-scrolling rows (externally called "the fixed rows")
     *
     * @returns {number} Sum of the above or 0 if none of the above are in use.
     *
     * @param {number} The number of rows.
     */
    setFixedRowCount: function(n) {
        this.grid.properties.fixedRowCount = n;
    },

    /**
     * @memberOf Behavior#
     * @desc a dnd column has just been dropped, we've been notified
     */
    endDragColumnNotification: function() {},

    /**
     * @memberOf Behavior#
     * @return {null} the cursor at a specific x,y coordinate
     * @param {number} x - the x coordinate
     * @param {number} y - the y coordinate
     */
    getCursorAt: function(x, y) {
        return null;
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Behavior#
     * @return {number} The total number of columns.
     */
    getActiveColumnCount: function() {
        return this.columns.length;
    },
    getColumnCount: function() {
        return this.deprecated('getColumnCount()', 'getActiveColumnCount()', '1.0.6', arguments);
    },

    /**
     * @summary Column alignment of given grid column.
     * @desc One of:
     * * `'left'`
     * * `'center'`
     * * `'right'`
     *
     * Cascades to grid.
     * @memberOf Behavior#
     * @desc Quietly set the horizontal scroll position.
     * @param {number} x - The new position in pixels.
     */
    setScrollPositionX: function(x) {
        /**
         * @memberOf Behavior#
         * @type {number}
         */
        this.scrollPositionX = x;
    },

    getScrollPositionX: function() {
        return this.scrollPositionX;
    },

    /**
     * @memberOf Behavior#
     * @desc Quietly set the vertical scroll position.
     * @param {number} y - The new position in pixels.
     */
    setScrollPositionY: function(y) {
        /**
         * @memberOf Behavior#
         * @type {number}
         */
        this.scrollPositionY = y;
    },

    getScrollPositionY: function() {
        return this.scrollPositionY;
    },

    /**
     * @memberOf Behavior#
     * @return {cellEditor} The cell editor for the cell at the given coordinates.
     * @param {CellEvent} editPoint - The grid cell coordinates.
     */
    getCellEditorAt: function(event) {
        return event.isDataColumn && (
            event.isFilterCell
                ? this.grid.cellEditors.create('filterbox', event)
                : event.column.getCellEditorAt(event)
        );
    },

    /**
     * @memberOf Behavior#
     * @return {boolean} `true` if we should highlight on hover
     * @param {boolean} isColumnHovered - the column is hovered or not
     * @param {boolean} isRowHovered - the row is hovered or not
     */
    highlightCellOnHover: function(isColumnHovered, isRowHovered) {
        return isColumnHovered && isRowHovered;
    },

    /**
     * @memberOf Behavior#
     * @desc this function is a hook and is called just before the painting of a cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellPropertiesPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior#
     * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedRowPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior#
     * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedColumnPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior#
     * @desc this function is a hook and is called just before the painting of a top left cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellTopLeftPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior#
     * @desc swap src and tar columns
     * @param {number} src - column index
     * @param {number} tar - column index
     */
    swapColumns: function(source, target) {
        var columns = this.columns;
        var tmp = columns[source];
        columns[source] = columns[target];
        columns[target] = tmp;
        this.changed();
    },

    getColumnEdge: function(c, renderer) {
        return this.dataModel.getColumnEdge(c, renderer);
    },

    /**
     * @memberOf Behavior#
     * @return {object} The object at y index.
     * @param {number} y - the row index of interest
     */
    getRow: function(y) {
        return this.dataModel.getRow(y);
    },

    convertViewPointToDataPoint: function(unscrolled) {
        return new Point(
            this.getActiveColumn(unscrolled.x).index,
            unscrolled.y
        );
    },

    hasHierarchyColumn: function() {
        return false;
    },

    getSelectionMatrixFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    autosizeAllColumns: function() {
        this.checkColumnAutosizing(true);
        this.changed();
    },

    checkColumnAutosizing: function(force) {
        force = force === true;
        var autoSized = this.autoSizeRowNumberColumn() ||
            this.hasHierarchyColumn() && this.allColumns[-2].checkColumnAutosizing(force);
        this.allColumns.forEach(function(column) {
            autoSized = column.checkColumnAutosizing(force) || autoSized;
        });
        return autoSized;
    },

    autoSizeRowNumberColumn: function() {
        if (this.grid.properties.showRowNumbers && this.grid.properties.rowNumberAutosizing) {
            return this.allColumns[-1].checkColumnAutosizing(true);
        }
    },

    /**
     * @summary Get the given data controller.
     * @param {string} type
     * @returns {undefined|*} The data controller; or `undefined` if data controller unknown to data model.
     * @memberOf Behavior#
     */
    getController: function(type) {
        return this.dataModel.getController(type);
    },

    /**
     * @summary Set the given data controller(s).
     * @desc Triggers a shape change.
     * @param {string} typeOrHashOfTypes - One of:
     * * **object** - Hash of multiple data controllers, by type.
     * * **string** - Type of the single data controller given in `controller`.
     * @param {dataControlInterface} [controller] - Only required when 'hash' is a string; omit when `hash` is an object.
     * @returns {object} - Hash of all results, by type. Each member will be:
     * * The given data controller for that type when defined.
     * * A new "null" data controller, generated by the data model when the given data controller for that type was `undefined`.
     * * `undefined` - The data controller was unknown to the data model..
     * @memberOf Behavior#
     */
    setController: function(typeOrHashOfTypes, controller) {
        var results = this.dataModel.setController(typeOrHashOfTypes, controller);
        this.changed();
        return results;
    },

    prop: function(type, columnIndex, keyOrHash, value) {
        var result = this.dataModel.prop.apply(this.dataModel, arguments);
        if (!result.GETTER) {
            this.changed();
        }
        return result;
    },

    get charMap() {
        return this.dataModel.charMap;
    },

    getColumns: function() {
        return this.allColumns;
    },

    getActiveColumns: function() {
        return this.columns;
    },

    getHiddenColumns: function() {
        var visible = this.columns;
        var all = this.allColumns;
        var hidden = [];
        for (var i = 0; i < all.length; i++) {
            if (visible.indexOf(all[i]) === -1) {
                hidden.push(all[i]);
            }
        }
        hidden.sort(function(a, b) {
            return a.header < b.header;
        });
        return hidden;
    },

    getSelectedRows: function() {
        return this.grid.selectionModel.getSelectedRows();
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },

    getData: function() {
        return this.dataModel.getData();
    },

    getFilteredData: function() {
        return this.deprecated('getIndexedData()', 'getIndexedData', '1.2.0', arguments);
    },
    getIndexedData: function() {
       this.dataModel.getIndexedData();
    }
});

// synonyms

/**
 * Synonym of {@link Behavior#reindex}.
 * @name applyAnalytics
 * @deprecated
 * @memberOf Behavior#
 */
Behavior.prototype.applyAnalytics = Behavior.prototype.reindex;


// mix-ins
Behavior.prototype.mixIn(require('./subgrids'));


module.exports = Behavior;

},{"../Base":41,"./../lib/cellEventFactory":98,"./Column":44,"./subgrids":49,"rectangular":39}],44:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var overrider = require('overrider');

var deprecated = require('../lib/deprecated');
var HypergridError = require('../lib/error');
var images = require('../../images/index');

/** @summary Create a new `Column` object.
 * @see {@link module:Cell} is mixed into Column.prototype.
 * @constructor
 * @param behavior
 * @param {number|string|object} indexOrOptions - One of:
 * * If a positive number, valid index into `fields` array.
 * * If a string, a name in the `fields` array.
 * * If an object, must contain either an `index` or a `name` property.
 *
 * Positive values of `index` are "real" fields; see also {@link Column#setProperties|setProperties} which is called to set the remaining properties specified in `options`.
 *
 * Negative values of `index` are special cases:
 * `index` | Meaning
 * :-----: | --------
 *    -1   | Row header column
 *    -2   | Tree (drill-down) column
 */
function Column(behavior, indexOrOptions) {
    var index, schema, options;

    this.behavior = behavior;
    this.dataModel = behavior.dataModel;

    schema = this.behavior.dataModel.schema;

    switch (typeof indexOrOptions) {
        case 'number':
            index = indexOrOptions;
            options = {};
            break;
        case 'string':
            index = getIndexFromName(indexOrOptions);
            options = {};
            break;
        case 'object':
            options = indexOrOptions;
            index = options.index !== undefined
                ? options.index
                : getIndexFromName(options.name);
    }

    function getIndexFromName(name) {
        return schema.findIndex(function(columnSchema, i) {
            return columnSchema.name === name;
        });
    }

    if (index === undefined) {
        throw 'Column not found in data.';
    }

    this._index = index;

    this.properties = options;

    switch (index) {
        case -1:
            // Width of icon + 3-pixel spacer (checked and unchecked should be same width)
            this.properties.minimumColumnWidth = (images.unchecked && images.unchecked.width)
                ?  images.unchecked.width + 3 : 0;
            break;
        case -2:
            // This case avoids the "out of range" error.
            break;
        default:
            if (index < 0) {
                throw '`index` out of range';
            }
    }
}

Column.prototype = {
    constructor: Column.prototype.constructor,
    $$CLASS_NAME: 'Column',
    deprecated: deprecated,

    HypergridError: HypergridError,

    mixIn: overrider.mixIn,

    set: function(options) {
        return this.deprecated('set(options)', 'setProperties(options)', '1.2.0', arguments);
    },

    /**
     * @summary Index of this column in the `fields` array.
     * @returns {number}
     */
    get index() { // read-only (no setter)
        return this._index;
    },

    /**
     * @summary Name of this column from the `fields` array.
     * @returns {string|undefined} Returns `undefined` if the column is not in the schema (such as for handle column).
     */
    get name() { // read-only (no setter)
        var columnSchema = this.dataModel.schema[this._index];
        return columnSchema && columnSchema.name;
    },

    /**
     * @summary Get or set the text of the column's header.
     * @desc The _header_ is the label at the top of the column.
     *
     * Setting the header updates both:
     * * the `fields` (aka, header) array in the underlying data source; and
     * * the filter.
     * @type {string}
     */
    set header(headerText) {
        this.dataModel.schema[this.index].header = headerText;
        this.dataModel.prop(null, this.index, 'header', headerText);
        this.behavior.grid.repaint();
    },
    get header() {
        return this.dataModel.schema[this.index].header;
    },

    /**
     * @summary Get or set the computed column's calculator function.
     * @desc Setting the value here updates the calculator in both:
     * * the `calculator` array in the underlying data source; and
     * * the filter.
     *
     * The results of the new calculations will appear in the column cells on the next repaint.
     * @type {string}
     */
    set calculator(calculator) {
        var schema = this.dataModel.schema;
        if (calculator !== schema[this.index].calculator) {
            if (calculator === undefined) {
                delete schema[this.index].calculator;
            } else {
                schema[this.index].calculator = calculator;
            }
            this.behavior.prop(null, this.index, 'calculator', calculator);
            this.behavior.applyAnalytics();
        }
    },
    get calculator() {
        return this.dataModel.schema[this.index].calculator;
    },

    /**
     * @summary Get or set the type of the column's header.
     * @desc Setting the type updates the filter which typically uses this information for proper collation.
     *
     * @todo: Instead of using `this._type`, put on data source like the other essential properties. In this case, sorter could use the info to choose a comparator more intelligently and efficiently.
     * @type {string}
     */
    set type(type) {
        this._type = type;
        //TODO: This is calling reindex for every column during grid init. Maybe defer all reindex calls until after an grid 'ready' event
        this.dataModel.prop(null, this.index, 'type', type);
        this.behavior.reindex();
    },
    get type() {
        return this._type;
    },

    getUnfilteredValue: function(y) {
        return this.deprecated('getUnfilteredValue(y)', null, '1.2.0', arguments, 'No longer supported');
    },

    getValue: function(y) {
        return this.dataModel.getValue(this.index, y);
    },

    setValue: function(y, value) {
        return this.dataModel.setValue(this.index, y, value);
    },

    getWidth: function() {
        return this.properties.width || this.behavior.grid.properties.defaultColumnWidth;
    },

    setWidth: function(width) {
        width = Math.max(this.properties.minimumColumnWidth, width);
        if (width !== this.properties.width) {
            this.properties.width = width;
            this.properties.columnAutosizing = false;
        }
    },

    checkColumnAutosizing: function(force) {
        var properties = this.properties,
            width, preferredWidth, autoSized;

        if (properties.columnAutosizing) {
            width = properties.width;
            preferredWidth = properties.preferredWidth || width;
            force = force || !properties.columnAutosized;
            if (width !== preferredWidth || force && preferredWidth !== undefined) {
                properties.width = force ? preferredWidth : Math.max(width, preferredWidth);
                properties.columnAutosized = !isNaN(properties.width);
                autoSized = properties.width !== width;
            }
        }

        return autoSized;
    },

    getCellType: function(y) {
        var value = this.getValue(y);
        return this.typeOf(value);
    },

    getType: function() {
        var props = this.properties;
        var type = props.type;
        if (!type) {
            type = this.computeColumnType();
            if (type !== 'unknown') {
                props.type = type;
            }
        }
        return type;
    },

    computeColumnType: function() {
        var headerRowCount = this.behavior.getHeaderRowCount();
        var height = this.behavior.getRowCount();
        var value = this.getValue(headerRowCount);
        var eachType = this.typeOf(value);
        if (!eachType) {
            return 'unknown';
        }
        var type = this.typeOf(value);
        //var isNumber = ((typeof value) === 'number');
        for (var y = headerRowCount; y < height; y++) {
            value = this.getValue(y);
            eachType = this.typeOf(value);
            // if (type !== eachType) {
            //     if (isNumber && (typeof value === 'number')) {
            //         type = 'float';
            //     } else {
            //         return 'mixed';
            //     }
            // }
        }
        return type;
    },

    typeOf: function(something) {
        if (something == null) {
            return null;
        }
        var typeOf = typeof something;
        switch (typeOf) {
            case 'object':
                return something.constructor.name.toLowerCase();
            case 'number':
                return parseInt(something) === something ? 'int' : 'float';
            default:
                return typeOf;
        }
    },

    get properties() {
        return this._properties;
    },
    set properties(ownProperties) {
        this._properties = this.createColumnProperties();
        this.addProperties(ownProperties);
    },

    getProperties: function() {
        return this.deprecated('getProperties()', 'properties', '1.2.0');
    },

    /** This method is provided because some grid renderer optimizations require that the grid renderer be informed when column colors change. Due to performance concerns, they cannot take the time to figure it out for themselves. Along the same lines, making the property a getter/setter (in columnProperties.js), though doable, might present performance concerns as this property is possibly the most accessed of all column properties.
     * @param color
     */
    setBackgroundColor: function(color) {
        if (this.properties.backgroundColor !== color) {
            this.properties.backgroundColor = color;
            this.behavior.grid.renderer.rebundleGridRenderers();
        }
    },

    /**
     * @param {object} properties
     * @param {boolean} [preserve=false]
     */
    setProperties: function(properties, preserve) {
        if (!preserve) {
            this.deprecated('setProperties', 'setProperties(properties) has been deprecated in favor of properties (setter) as of v1.2.0. (Will be removed in a future version.) This advice only pertains to usages of setProperties when called with a single parameter. When called with a truthy second parameter, use the new addProperties(properties) call instead.');
            this.properties = properties;
        } else {
            this.deprecated('setPropertiesPreserve', 'setProperties(properties, preserve)', 'addProperties(properties)', '1.2.0', arguments, 'This warning pertains to setProperties only when preserve is truthy. When preserve is faulty, use the new properties setter.');
        }
    },

    addProperties: function(properties) {
        var key, descriptor, obj = this.properties;

        for (key in properties) {
            if (properties.hasOwnProperty(key)) {
                descriptor = Object.getOwnPropertyDescriptor(obj, key);
                if (!descriptor || descriptor.writable || descriptor.set) {
                    obj[key] = properties[key];
                }
            }
        }
    },

    /**
     * @summary Get a new cell editor.
     * @desc The cell editor to use must be registered with the key in the cell's `editor` property.
     *
     * The cell's `format` property is mixed into the provided cellEvent for possible overriding by developer's override of {@link DataModel.prototype.getCellEditorAt} before being used by {@link CellEditor} to parse and format the cell value.
     *
     * @param {CellEvent} cellEvent
     *
     * @returns {undefined|CellEditor} Falsy value means either no declared cell editor _or_ instantiation aborted by falsy return from `fireRequestCellEdit`.
     */
    getCellEditorAt: function(cellEvent) {
        var columnIndex = this.index,
            rowIndex = cellEvent.gridCell.y,
            editorName = cellEvent.properties.editor,
            options = Object.create(cellEvent, {
                format: {
                    // `options.format` is a copy of the cell's `format` property which is:
                    // 1. Subject to adjustment by the `getCellEditorAt` override.
                    // 2. Then used by the cell editor to reference the predefined localizer.
                    writable: true,
                    enumerable: true, // so cell editor will copy it to self
                    value: cellEvent.properties.format
                }
            }),
            cellEditor = this.dataModel.getCellEditorAt(columnIndex, rowIndex, editorName, options);

        if (cellEditor && !cellEditor.grid) {
            // cell editor returned but not fully instantiated (aborted by falsy return from fireRequestCellEdit)
            cellEditor = undefined;
        }

        return cellEditor;
    },

    getFormatter: function() {
        var localizerName = this.properties.format;
        return this.behavior.grid.localization.get(localizerName).format;
    }
};

Column.prototype.mixIn(require('./cellProperties'));
Column.prototype.mixIn(require('./columnProperties'));

module.exports = Column;

},{"../../images/index":3,"../lib/deprecated":99,"../lib/error":101,"./cellProperties":46,"./columnProperties":47,"overrider":37}],45:[function(require,module,exports){
'use strict';

var Behavior = require('./Behavior');
var DataModelJSON = require('../dataModels/JSON');
var features = require('../features');

var REGEX_CAMEL_CASE = /([^_A-Z])([A-Z]+)/g; // all instances of xX or _X within a "word"

/**
 * @name behaviors.JSON
 * @desc > Same parameters as {@link behaviors.Behavior#initialize|initialize}, which is called by this constructor.
 * @constructor
 * @extends Behavior
 */
var JSON = Behavior.extend('behaviors.JSON', {

    /**
     * @summary Constructor logic, called _after_{@link Behavior#initialize|Behavior.initialize()}.
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     *
     * @memberOf behaviors.JSON.prototype
     */
    initialize: function(grid, options) {
        this.setData(options);
        if (options.pipeline) {
            this.setPipeline(options.pipeline);
        }
    },

    features: [
        features.Filters,
        features.CellSelection,
        features.KeyPaging,
        features.ColumnResizing,
        // features.RowResizing,
        features.RowSelection,
        features.ColumnSelection,
        features.ColumnMoving,
        features.ColumnSorting,
        features.CellClick,
        features.CellEditing,
        features.OnHover
    ],

    createColumns: function() {
        Behavior.prototype.createColumns.call(this);

        this.dataModel.schema.forEach(function(columnSchema, index) {
            this.addColumn({
                index: index,
                header: columnSchema.header,
                calculator: columnSchema.calculator
            });

            this.columnEnum[this.columnEnumKey(columnSchema.name)] = index; // todo: move columnEnum code from core to demo
        }, this);
    },

    /**
     * @summary Style enum keys.
     * @desc Override this method to style your keys to your liking.
     * @param key
     * @todo move columnEnum code from core to demo
     * @returns {string}
     * @memberOf behaviors.JSON.prototype
     */
    columnEnumKey: function(key) {
        return key.replace(REGEX_CAMEL_CASE, '$1_$2').toUpperCase();
    },

    getNewDataModel: function(options) {
        return new DataModelJSON(this.grid, options);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the header labels.
     * @param {string[]|object} headers - The header labels. One of:
     * * _If an array:_ Must contain all headers in column order.
     * * _If a hash:_ May contain any headers, keyed by field name, in any order.
     */
    setHeaders: function(headers) {
        if (headers instanceof Array) {
            // Reset all headers
            var allColumns = this.allColumns;
            headers.forEach(function(header, index) {
                allColumns[index].header = header; // setter updates header in both column and data source objects
            });
        } else if (typeof headers === 'object') {
            // Adjust just the headers in the hash
            this.allColumns.forEach(function(column) {
                if (headers[column.name]) {
                    column.header = headers[column.name];
                }
            });
        }
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the fields array.
     * @param {string[]} fieldNames - The field names.
     */
    setFields: function(fieldNames) {
        //were defining the columns based on field names....
        //we must rebuild the column definitions
        this.dataModel.setFields(fieldNames);
        this.createColumns();
    },

    /**
     * @see {@link dataModels.JSON#setPipeline}
     * @param {object} [DataSources] - New pipeline description. _(See {@link dataModels.JSON#setPipeline}.)_
     * @param {object} [options] - Takes first argument position when `DataSources` omitted. _(See {@link dataModels.JSON#setPipeline}.)_
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     * @memberOf behaviors.JSON.prototype
     */
    setPipeline: function(DataSources, options) {
        this.dataModel.setPipeline.apply(this.dataModel, arguments);

        if (!Array.isArray(DataSources)) {
            options = DataSources;
        }

        if (!options || options.apply === undefined || options.apply) {
            this.reindex();
        }
    },

    /**
     * Pop pipeline stack.
     * @see {@link dataModels.JSON#unstashPipeline}
     * @param {string} [whichStash]
     * @param {object} [options] - Takes first argument position when `DataSources` omitted.
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     * @memberOf behaviors.JSON.prototype
     */
    unstashPipeline: function(stash, options) {
        if (typeof stash === 'object') {
            options = stash;
            stash = undefined;
        }

        this.dataModel.unstashPipeline(stash);

        if (!options || options.apply === undefined || options.apply) {
            this.reindex();
        }
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the data field.
     * @param {function|object[]} [dataRows=options.data] - Array of uniform data row objects or function returning same.
     * @param {object} [options] - Takes first argument position when `dataRows` omitted.
     * @param {function|object} [options.data] - Array of uniform data row objects or function returning same.
     * Passed as 1st param to {@link dataModel.JSON#setData}. If falsy, method aborted.
     * @param {function|object} [options.fields] - Array of field names or function returning same.
     * Passed as 2nd param to {@link dataModel.JSON#setData}.
     * @param {function|object} [options.calculators] - Array of calculators or function returning same.
     * Passed as 3rd param to {@link dataModel.JSON#setData}.
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     */
    setData: function(dataRows, options) {
        if (!(Array.isArray(dataRows) || typeof dataRows === 'function')) {
            options = dataRows;
            dataRows = options && options.data;
        }

        dataRows = this.unwrap(dataRows);

        if (dataRows === undefined) {
            return;
        }

        if (!Array.isArray(dataRows)) {
            throw 'Expected data to be an array (of data row objects).';
        }

        options = options || {};

        var grid = this.grid,
            schema = this.unwrap(options.schema), // *always* define a new schema on reset
            schemaChanged = schema || !this.subgrids.lookup.data.schema.length, // schema will change if a new schema was provided OR data model has an empty schema now, which triggers schema generation on setData below
            reindex = options.apply === undefined || options.apply; // defaults to true

        // Inform interested data models of data.
        this.subgrids.forEach(function(dataModel) {
            if (dataModel.setData && !dataModel.hasOwnData) {
                dataModel.setData(dataRows, schema);
            }
        });

        if (grid.cellEditor) {
            grid.cellEditor.cancelEditing();
        }

        if (reindex) {
            this.reindex();
        }

        if (schemaChanged) {
            this.createColumns();
        }

        grid.allowEvents(this.dataModel.getRowCount() > 0);
    },

    /**
     * @summary Rebinds the data without reshaping it.
     * @desc See {@link behaviors.JSON#setData|setData}'s parameter descriptions.
     * @param dataRows
     * @param options
     * @memberOf behaviors.JSON.prototype
     */
    updateData: function(dataRows, options) {
        this.deprecated('updateData(dataRows, options)', 'setData(dataRows, options)', 'v1.2.10', arguments,
            'To update data without changing column definitions, call setData _without a schema._');
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Build the fields and headers from the supplied column definitions.
     * ```javascript
     * myJsonBehavior.setColumns([
     *     { header: 'Stock Name', name: 'short_description' },
     *     { header: 'Status', name: 'trading_phase' },
     *     { header: 'Reference Price', name: 'reference_price' }
     * ]);
     * ```
     * @param {Array} columnDefinitions - an array of objects with fields 'title', and 'field'
     */
    setColumns: function(columnDefinitions) {
        console.warn('This function does not do anything');
    },

    //Not being used. Should be repurposed??
    setDataProvider: function(dataProvider) {
        this.dataModel.setDataProvider(dataProvider);
    },

    hasHierarchyColumn: function() {
        return this.dataModel.hasHierarchyColumn();
    },

    getVisibleColumns: function() {
        return this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },
});

module.exports = JSON;

},{"../dataModels/JSON":72,"../features":89,"./Behavior":43}],46:[function(require,module,exports){
/* eslint-env bro wser */

'use strict';

/**
 * Column.js mixes this module into its prototype.
 * @module
 */
var cell = {

    /**
     * @summary Get the properties object for cell.
     * @desc This is the cell's own properties object if found; else the column object.
     *
     * If you are seeking a single specific property, consider calling {@link Column#getCellProperty} instead (which calls this method).
     * @param {number} rowIndex - Data row coordinate.
     * @return {object} The properties of the cell at x,y in the grid.
     * @memberOf Column#
     */
    getCellProperties: function(rowIndex, dataModel) {
        return this.getCellOwnProperties(rowIndex, dataModel) || this.properties;
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {Object} properties - Hash of cell properties.
     * @returns {*}
     * @memberOf Column#
     */
    setCellProperties: function(rowIndex, properties, dataModel) {
        return Object.assign(newCellPropertiesObject.call(this, rowIndex, dataModel), properties);
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {Object} properties - Hash of cell properties.
     * @param {boolean} [preserve=false] - Falsy creates new object; truthy copies `properties` members into existing object.
     * @returns {*}
     * @memberOf Column#
     */
    addCellProperties: function(rowIndex, properties, dataModel) {
        return Object.assign(getCellPropertiesObject.call(this, rowIndex, dataModel), properties);
    },

    /**
     * @summary Get the cell's own properties object.
     * @desc Due to memory constraints, we don't create a cell options properties object for every cell.
     *
     * If the cell has its own properties object, it:
     * * was created by a previous call to `setCellProperties` or `setCellProperty`
     * * has the column properties object as its prototype
     * * is returned
     *
     * If the cell does not have its own properties object, this method simply returns `undefined`.
     *
     * Call this method only when you need to know if the the cell has its own properties object; otherwise call {@link Column#getCellProperties|getCellProperties}.
     * @param {number} rowIndex - Data row coordinate.
     * @returns {null|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `undefined`.
     * @memberOf Column#
     */
    getCellOwnProperties: function(rowIndex, dataModel) {
        var rowData;
        return (
            // this.index >= 0 && // no cell props on row handle cells
            (rowData = (dataModel || this.dataModel).getRow(rowIndex)) && // no cell props on non-existent rows
            rowData.__META && rowData.__META[this.name] ||
            null // null means not previously created
        );
    },

    deleteCellOwnProperties: function(rowIndex, dataModel) {
        var rowData = (dataModel || this.dataModel).getRow(rowIndex);
        if (rowData.__META) {
            delete rowData.__META[this.name];
        }
    },

    /**
     * @summary Return a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     * @param {number} rowIndex - Data row coordinate.
     * @param {string} key
     * @return {object} The specified property for the cell at x,y in the grid.
     * @memberOf Column#
     */
    getCellProperty: function(rowIndex, key, dataModel) {
        return this.getCellProperties(rowIndex, dataModel)[key];
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {string} key
     * @param value
     * @returns {object}
     * @memberOf Column#
     */
    setCellProperty: function(rowIndex, key, value, dataModel) {
        var cellProps = getCellPropertiesObject.call(this, rowIndex, dataModel);
        cellProps[key] = value;
        return cellProps;
    },

    deleteCellProperty: function(rowIndex, key, dataModel) {
        var cellProps = this.getCellOwnProperties(rowIndex, dataModel);
        if (cellProps) {
            delete cellProps[key];
        }
    },

    clearAllCellProperties: function() {
        var key = this.name;
        this.behavior.subgrids.forEach(function(dataModel) {
            for (var i = dataModel.getRowCount(); i--;) {
                var rowData = dataModel.getRow(i),
                    meta = rowData.__META;
                if (meta) {
                    if (Object.keys(meta).length === 1) {
                        delete rowData.__META;
                    }
                    if (meta) {
                        delete meta[key];
                    }
                }
            }
        });
    }
};

/**
 * @this {Column}
 * @param {number} rowIndex - Data row coordinate.
 * @returns {object}
 * @private
 */
function getCellPropertiesObject(rowIndex, dataModel) {
    return this.getCellOwnProperties(rowIndex, dataModel) || newCellPropertiesObject.call(this, rowIndex, dataModel);
}

/**
 * @todo: For v8 optimization, consider setting the new `__META` object to a "regularly shaped object" (i.e., with all the columns) instead of simply to `{}`. Considerations include how many of these objects are there, how often are they referenced, etc.
 * @todo: We need a function to reset the prototypes of pre-existing __META members to their respective column properties objects.
 * @this {Column}
 * @param {number} rowIndex - Data row coordinate.
 * @returns {object}
 * @private
 */
function newCellPropertiesObject(rowIndex, dataModel) {
    var rowData = (dataModel || this.dataModel).getRow(rowIndex),
        metaData = rowData.__META = rowData.__META || {};
    return (metaData[this.name] = Object.create(this._index >= 0 ? this.properties : this.properties.rowHeader));
}

module.exports = cell;

},{}],47:[function(require,module,exports){
'use strict';

var toFunction = require('../lib/toFunction');

var FIELD = 'columnProperties.field is deprecated as of v1.1.0 in favor of columnProperties.name. (Will be removed in a future release.)',
    COLUMN_NAME = 'columnProperties.columnName is deprecated as of v1.1.0 in favor of columnProperties.name. (Will be removed in a future release.)';

/**
 * @this {Column}
 * @returns {object}
 * @memberOf Column#
 */
function createColumnProperties() {
    var column = this,
        tableState = column.behavior.grid.properties,
        properties;

    properties = Object.create(tableState, {

        index: { // read-only (no setter)
            enumerable: true,
            get: function() {
                return column.index;
            }
        },

        name: { // read-only (no setter)
            enumerable: true,
            get: function() {
                return column.name;
            }
        },

        field: { // read-only (no setter)
            enumerable: true,
            get: function() {
                if (FIELD) { console.warn(FIELD); FIELD = undefined; }
                return column.name;
            }
        },

        columnName: { // read-only (no setter)
            enumerable: true,
            get: function() {
                if (COLUMN_NAME) { console.warn(COLUMN_NAME); COLUMN_NAME = undefined; }
                return column.name;
            }
        },

        header: {
            enumerable: true,
            get: function() {
                return column.header;
            },
            set: function(header) {
                column.header = header;
            }
        },

        type: {
            enumerable: true,
            get: function() {
                return column.type;
            },
            set: function(type) {
                column.type = type;
            }
        },

        calculator: {
            enumerable: true,
            get: function() {
                return column.calculator;
            },
            set: function(calculator) {
                column.calculator = toFunction(calculator);
            }
        }

    });

    Object.defineProperty(properties, 'rowHeader', {
        value: Object.create(properties, createColumnProperties.rowHeaderDescriptors)
    });

    Object.defineProperty(properties, 'columnHeader', {
        value: Object.create(properties, createColumnProperties.columnHeaderDescriptors)
    });

    Object.defineProperty(properties, 'filterProperties', {
        value: Object.create(properties, createColumnProperties.filterDescriptors)
    });

    return properties;
}

createColumnProperties.rowHeaderDescriptors = {
    font: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.rowHeaderFont;
        },
        set: function(value) {
            this.rowHeaderFont = value;
        }
    },
    color: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.rowHeaderColor;
        },
        set: function(value) {
            this.rowHeaderColor = value;
        }
    },
    backgroundColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.rowHeaderBackgroundColor;
        },
        set: function(value) {
            this.rowHeaderBackgroundColor = value;
        }
    },
    foregroundSelectionFont: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.rowHeaderForegroundSelectionFont;
        },
        set: function(value) {
            this.rowHeaderForegroundSelectionFont = value;
        }
    },
    foregroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.rowHeaderForegroundSelectionColor;
        },
        set: function(value) {
            this.rowHeaderForegroundSelectionColor = value;
        }
    },
    backgroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.rowHeaderBackgroundSelectionColor;
        },
        set: function(value) {
            this.rowHeaderBackgroundSelectionColor = value;
        }
    }
};

createColumnProperties.filterDescriptors = {
    font: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.filterFont;
        },
        set: function(value) {
            this.filterFont = value;
        }
    },
    color: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.filterColor;
        },
        set: function(value) {
            this.filterColor = value;
        }
    },
    backgroundColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.filterBackgroundColor;
        },
        set: function(value) {
            this.filterBackgroundColor = value;
        }
    },
    foregroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.filterForegroundSelectionColor;
        },
        set: function(value) {
            this.filterForegroundSelectionColor = value;
        }
    },
    backgroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.filterBackgroundSelectionColor;
        },
        set: function(value) {
            this.filterBackgroundSelectionColor = value;
        }
    },
    halign: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.filterHalign;
        },
        set: function(value) {
            this.filterHalign = value;
        }
    },
    renderer: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.filterRenderer;
        },
        set: function(value) {
            this.filterRenderer = value;
        }
    }
};

createColumnProperties.columnHeaderDescriptors = {
    font: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.columnHeaderFont;
        },
        set: function(value) {
            this.columnHeaderFont = value;
        }
    },
    color: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.columnHeaderColor;
        },
        set: function(value) {
            this.columnHeaderColor = value;
        }
    },
    backgroundColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.columnHeaderBackgroundColor;
        },
        set: function(value) {
            this.columnHeaderBackgroundColor = value;
        }
    },
    foregroundSelectionFont: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.columnHeaderForegroundSelectionFont;
        },
        set: function(value) {
            this.columnHeaderForegroundSelectionFont = value;
        }
    },
    foregroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.columnHeaderForegroundSelectionColor;
        },
        set: function(value) {
            this.columnHeaderForegroundSelectionColor = value;
        }
    },
    backgroundSelectionColor: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.columnHeaderBackgroundSelectionColor;
        },
        set: function(value) {
            this.columnHeaderBackgroundSelectionColor = value;
        }
    },
    halign: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.columnHeaderHalign;
        },
        set: function(value) {
            this.columnHeaderHalign = value;
        }
    },
    renderer: {
        configurable: true,
        enumerable: true,
        get: function() {
            return this.columnHeaderRenderer;
        },
        set: function(value) {
            this.columnHeaderRenderer = value;
        }
    },
    leftIcon: { writable: true, value: undefined},
    centerIcon: { writable: true, value: undefined},
    rightIcon: { writable: true, value: undefined},
};

module.exports.createColumnProperties = createColumnProperties;

},{"../lib/toFunction":109}],48:[function(require,module,exports){
'use strict';

module.exports = {
    Behavior: require('./Behavior'),
    JSON: require('./JSON'),
    Column: require('./Column')
};

},{"./Behavior":43,"./Column":44,"./JSON":45}],49:[function(require,module,exports){
'use strict';

var dataModels = require('../dataModels');

/** @typedef subgridConstructorRef
 * @summary Type definition.
 * @desc One of:
 * * **`function` type** - Assumed to already be a data model constructor.
 * * **`string` type** - The name of a data model "class" (constructor) registered in the {@link src/dataModels} namespace. Used to look up the constructor in the namespace.
 */

/** @typedef subgridSpec
 * @summary Type definition.
 * @desc One of:
 * * **`object` type** _(except when an array)_ - Assumed to be a reference to an already-instantiated data model. Used as is.
 * * **`'data'` special value** - Set to the data subgrid (_i.e.,_ the behavior's already-instantiated data model).
 * * **{@link subgridConstructorRef}** _(see)_ - The constructor ref is resolved and called with the `new` keyword + a reference to the grid as the sole parameter.
 * * **`Array` object** — Accommodates data model constructor arguments. The constructor ref is resolved and called with the `new` keyword + a reference to the grid as the first parameter + the remaining elements as additional parameters. (If you don't have remaining elements, don't give an array here; just provide a simple `subgridConstructorRef` instead.) The array should have two or more elements:
 *   * The first element is a {@link subgridConstructorRef}.
 *   * Remaining elements are used as additional parameters to the constructor.
 */

module.exports = {
    dataModels: {
        HeaderSubgrid: dataModels.HeaderSubgrid
    },

    defaultSubgridSpecs: [
        'HeaderSubgrid',
        'data'
    ],

    /**
     * An array where each element represents a subgrid to be rendered in the hypergrid.
     *
     * The list should always include at least one "data" subgrid, typically {@link Behavior#dataModel|dataModel}.
     * It may also include zero or more other types of subgrids such as header, filter, and summary subgrids.
     *
     * This object also sports a dictionary of subgrids in `lookup` property where each dictionary key is one of:
     * * **`subgrid.name`** (for those that have a defined name, which is presumed to be unique)
     * * **`subgrid.type`** (not unique, so if you plan on having multiple, name them!)
     * * **`'data'`** for the (one and only) data subgrid when unnamed (note that data subgrids have no `type`)
     *
     * The setter:
     * * "Enlivens" any constructors (see {@link Behavior~createSubgrid|createSubgrid} for details).
     * * Reconstructs the dictionary.
     * * Calls {@link Behavior#shapeChanged|shapeChanged()}.
     *
     * @param {subgridSpec[]} subgridSpecs
     *
     * @type {dataModelAPI[]}
     *
     * @memberOf Behavior#
     */
    set subgrids(subgridSpecs) {
        var subgrids = this._subgrids = [];

        subgrids.lookup = {};

        subgridSpecs.forEach(function(spec) {
            if (spec) {
                subgrids.push(this.createSubgrid(spec));
            }
        }, this);

        this.shapeChanged();
    },
    get subgrids() {
        return this._subgrids;
    },

    /**
     * @summary Maps a `subgridSpec` to a data model.
     * @desc The spec may describe either an existing data model, or a constructor for a new data model.
     * @param {subgridSpec} spec
     * @returns {dataModelAPI} A data model.
     * @memberOf Behavior#
     */
    createSubgrid: function(spec, args) {
        var subgrid, Constructor, variableArgArray;

        if (spec === 'data') {
            subgrid = this.dataModel;
        } else if (spec instanceof Array && spec.length) {
            Constructor = derefSubgridRef.call(this, spec[0]);
            variableArgArray = spec.slice(1);
            subgrid = this.createApply(Constructor, variableArgArray, this.grid);
        } else if (typeof spec === 'object') {
            subgrid = spec;
        } else {
            Constructor = derefSubgridRef.call(this, spec);
            variableArgArray = Array.prototype.slice.call(arguments, 1);
            subgrid = this.createApply(Constructor, variableArgArray, this.grid);
        }

        // undefined type is data
        subgrid.type = subgrid.type || 'data';

        // make dictionary lookup entry
        var key = subgrid.name || subgrid.type;
        this._subgrids.lookup[key] = this._subgrids.lookup[key] || subgrid; // only save first with this key

        // make isType boolean
        subgrid['is' + subgrid.type[0].toUpperCase() + subgrid.type.substr(1)] = true;

        return subgrid;
    },

    /**
     * @summary Gets the number of "header rows".
     * @desc Defined as the sum of all rows of all subgrids before the (first) data subgrid.
     * @memberOf behaviors.JSON.prototype
     */
    getHeaderRowCount: function() {
        var result = 0;

        this.subgrids.find(function(subgrid) {
            if (subgrid.isData) {
                return true; // stop
            }
            result += subgrid.getRowCount();
        });

        return result;
    }
};

/**
 * @summary Resolves a subgrid constructor reference.
 * @desc The ref is resolved to a data model constructor.
 * @this {Behavior}
 * @param {subgridConstructorRef} ref
 * @returns {DataModel} A data model constructor.
 * @memberOf Behavior~
 */
function derefSubgridRef(ref) {
    var Constructor;
    switch (typeof ref) {
        case 'string':
            Constructor = this.dataModels[ref];
            break;
        case 'function':
            Constructor = ref;
            break;
        default:
            throw new this.HypergridError('Expected subgrid ref to be registered name or constructor, but found ' + typeof ref + '.');
    }
    return Constructor;
}

},{"../dataModels":73}],50:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var mustache = require('mustache');

var Base = require('../Base');
var effects = require('../lib/DOM/effects');
var Localization = require('../lib/Localization');

/**
 * @constructor
 */
var CellEditor = Base.extend('CellEditor', {

    /**
     * @param grid
     * @param {CellEvent} options - Properties listed below + arbitrary mustache "variables" for merging into template.
     * @param {Point} options.editPoint - Deprecated; use `options.gridCell`.
     * @param {string} [options.format] - Name of a localizer with which to override prototype's `localizer` property.
     */
    initialize: function(grid, options) {
        // Mix in all enumerable properties for mustache use, typically `column` and `format`.
        for (var key in options) {
            this[key] = options[key];
        }

        this.event = options;

        var value = grid.behavior.getValue(this.event);
        if (value instanceof Array) {
            value = value[1]; //it's a nested object
        }

        /**
         * my instance of hypergrid
         * @type {Hypergrid}
         * @memberOf CellEditor.prototype
         */
        this.grid = grid;

        this.grid.cellEditor = this;

        this.locale = grid.localization.locale; // for template's `lang` attribute

        // override native localizer with localizer named in format if defined (from instantiation options)
        if (options.format) {
            this.localizer = this.grid.localization.get(options.format);
        }

        this.initialValue = value;

        var container = document.createElement('DIV');
        container.innerHTML = mustache.render(this.template, this);

        /**
         * This object's input control, one of:
         * * *input element* - an `HTMLElement` that has a `value` attribute, such as `HTMLInputElement`, `HTMLButtonElement`, etc.
         * * *container element* - an `HTMLElement` containing one or more input elements, only one of which contains the editor value.
         *
         * For access to the input control itself (which may or may not be the same as `this.el`), see `this.input`.
         *
         * @type {HTMLElement}
         * @default null
         * @memberOf CellEditor.prototype
         */
        this.el = container.firstChild;

        this.input = this.el;

        this.errors = 0;

        var self = this;
        this.el.addEventListener('keyup', this.keyup.bind(this));
        this.el.addEventListener('keydown', function(e) {
            if (e.keyCode === 9) {
                // prevent TAB from leaving input control
                e.preventDefault();
            }
            grid.fireSyntheticEditorKeyDownEvent(self, e);
        });
        this.el.addEventListener('keypress', function(e) {
            grid.fireSyntheticEditorKeyPressEvent(self, e);
        });
        this.el.addEventListener('mousedown', function(e) {
            self.onmousedown(e);
        });
    },

    // If you override this method, be sure to call it as a final step (or call stopPropagation yourself).
    onmousedown: function(event) {
        event.stopPropagation(); // Catch mousedown here before it gets to the document listener defined in Hypergrid().
    },

    localizer: Localization.prototype.null,

    specialKeyups: {
        //0x08: 'clearStopEditing', // backspace
        0x09: 'stopEditing', // tab
        0x0d: 'stopEditing', // return/enter
        0x1b: 'cancelEditing' // escape
    },

    keyup: function(e) {
        var grid = this.grid,
            cellProps = this.event.properties,
            feedbackCount = cellProps.feedbackCount,
            keyChar = grid.canvas.getKeyChar(e),
            specialKeyup,
            stopped;

        // STEP 1: Call the special key handler as needed
        if (
            (specialKeyup = this.specialKeyups[e.keyCode]) &&
            (stopped = this[specialKeyup](feedbackCount))
        ) {
            grid.repaint();
        }

        // STEP 2: If this is a possible "nav key" consumable by CellSelection#handleKeyDown, try to stop editing and send it along
        if (cellProps.mappedNavKey(keyChar, e.ctrlKey)) {
            if (
                !specialKeyup &&
                // We didn't try to stop editing above so try to stop it now
                (stopped = this.stopEditing(feedbackCount))
            ) {
                grid.repaint();
            }

            if (stopped) {
                // Editing successfully stopped
                // -> send the event down the feature chain
                var finEvent = grid.canvas.newEvent(e, 'fin-editor-keydown', {
                    alt: e.altKey,
                    ctrl: e.ctrlKey,
                    char: keyChar,
                    code: e.charCode,
                    key: e.keyCode,
                    meta: e.metaKey,
                    shift: e.shiftKey,
                    identifier: e.key,
                    editor: this
                });
                grid.delegateKeyDown(finEvent);
            }
        }

        this.grid.fireSyntheticEditorKeyUpEvent(this, e);

        return stopped;
    },

    /**
     * if true, check that the editor is in the right location
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    checkEditorPositionFlag: false,

    /**
     * @memberOf CellEditor.prototype
     * @desc This function is a callback from the fin-hypergrid.   It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc scroll values have changed, we've been notified
     */
    scrollValueChangedNotification: function() {
        this.checkEditorPositionFlag = true;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc move the editor to the current editor point
     */
    moveEditor: function() {
        this.setBounds(this.event.bounds);
    },

    beginEditing: function() {
        if (this.grid.fireRequestCellEdit(this.event, this.initialValue)) {
            this.checkEditorPositionFlag = true;
            this.checkEditor();
        }
    },
    beginEditAt: function(Constructor, name) {
        return this.deprecated('beginEditAt(point)', 'beginEditing()', '1.0.6');
    },

    /**
     * @summary Put the value into our editor.
     * @desc Formats the value and displays it.
     * The localizer's {@link localizerInterface#format|format} method will be called.
     *
     * Override this method if your editor has additional or alternative GUI elements.
     *
     * @param {object} value - The raw unformatted value from the data source that we want to edit.
     * @memberOf CellEditor.prototype
     */
    setEditorValue: function(value) {
        this.input.value = this.localizer.format(value);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc display the editor
     */
    showEditor: function() {
        this.el.style.display = 'inline';
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc hide the editor
     */
    hideEditor: function() {
        this.el.style.display = 'none';
    },

    /** @summary Stops editing.
     * @desc Before saving, validates the edited value in two phases as follows:
     * 1. Call `validateEditorValue`. (Calls the localizer's `invalid()` function, if available.)
     * 2. Catch any errors thrown by the {@link CellEditor#getEditorValue|getEditorValue} method.
     *
     * **If the edited value passes both phases of the validation:**
     * Saves the edited value by calling the {@link CellEditor#saveEditorValue|saveEditorValue} method.
     *
     * **On validation failure:**
     * 1. If `feedback` was omitted, cancels editing, discarding the edited value.
     * 2. If `feedback` was provided, gives the user some feedback (see `feedback`, below).
     *
     * @param {number} [feedback] What to do on validation failure. One of:
     * * **`undefined`** - Do not show the error effect or the end effect. Just discard the value and close the editor (as if `ESC` had been typed).
     * * **`0`** - Just shows the error effect (see the {@link CellEditor#errorEffect|errorEffect} property).
     * * **`1`** - Shows the error feedback effect followed by the detailed explanation.
     * * `2` or more:
     *   1. Shows the error feedback effect
     *   2. On every `feedback` tries, shows the detailed explanation.
     * * If `undefined` (omitted), simply cancels editing without saving edited value.
     * * If 0, shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
     * * If > 0, shows the error feedback effect _and_ calls the {@link CellEditor#errorEffectEnd|errorEffectEnd} method) every `feedback` call(s) to `stopEditing`.
     * @returns {boolean} Truthy means successful stop. Falsy means syntax error prevented stop. Note that editing is canceled when no feedback requested and successful stop includes (successful) cancel.
     * @memberOf CellEditor.prototype
     */
    stopEditing: function(feedback) {
        /**
         * @type {boolean|string|Error}
         */
        var error = this.validateEditorValue();

        if (!error) {
            try {
                var value = this.getEditorValue();
            } catch (err) {
                error = err;
            }
        }

        if (!error && this.grid.fireSyntheticEditorDataChangeEvent(this, this.initialValue, value)) {
            try {
                this.saveEditorValue(value);
            } catch (err) {
                error = err;
            }
        }

        if (!error) {
            this.hideEditor();
            this.grid.cellEditor = null;
            this.el.remove();
        } else if (feedback >= 0) { // false when `feedback` undefined
            this.errorEffectBegin(++this.errors % feedback === 0 && error);
        } else { // invalid but no feedback
            this.cancelEditing();
        }

        return !error;
    },

    /** @summary Cancels editing.
     * @returns {boolean} Successful. (Cancel is always successful.)
     */
    cancelEditing: function() {
        this.setEditorValue(this.initialValue);
        this.hideEditor();
        this.grid.cellEditor = null;
        this.el.remove();

        return true;
    },

    /**
     * Calls the effect function indicated in the {@link module:defaults.feedbackEffect|feedbackEffect} property, which triggers a series of CSS transitions.
     * @param {boolean|string|Error} [error] - If defined, call the {@link CellEditor#errorEffectEnd|errorEffectEnd} method at the end of the last effect transition with this error.
     * @memberOf CellEditor.prototype
     */
    errorEffectBegin: function(error) {
        var spec = this.grid.properties.feedbackEffect, // spec may e a string or an object with name and options props
            options = Object.assign({}, spec.options), // if spec is a string, spec.options will be undefined
            effect = effects[spec.name || spec]; // if spec is a string, spec.name will be undefined

        if (error) {
            options.callback = this.errorEffectEnd.bind(this, error);
        }

        if (effect) {
            effect.call(this, options);
        }
    },

    /**
     * This function expects to be passed an error. There is no point in calling this function if there is no error. Nevertheless, if called with a falsy `error`, returns without doing anything.
     * @this {CellEditor}
     * @param {boolean|string|Error} [error]
     */
    errorEffectEnd: function(error, options) {
        if (error) {
            var msg =
                'Invalid value. To resolve, do one of the following:\n\n' +
                '   * Correct the error and try again.\n' +
                '         - or -\n' +
                '   * Cancel editing by pressing the "esc" (escape) key.';

            error = error.message || error;

            if (typeof error !== 'string') {
                error = '';
            }

            if (this.localizer.expectation) {
                error = error ? error + '\n' + this.localizer.expectation : this.localizer.expectation;
            }

            if (error) {
                if (/[\n\r]/.test(error)) {
                    error = '\n' + error;
                    error = error.replace(/[\n\r]+/g, '\n\n   * ');
                }
                msg += '\n\nAdditional information about this error: ' + error;
            }

            setTimeout(function() { // allow animation to complete
                alert(msg); // eslint-disable-line no-alert
            });
        }
    },

    /**
     * @desc save the new value into the behavior (model)
     * @returns {boolean} Data changed and pre-cell-edit event was not canceled.
     * @memberOf CellEditor.prototype
     */
    saveEditorValue: function(value) {
        var save = (
            !(value && value === this.initialValue) && // data changed
            this.grid.fireBeforeCellEdit(this.event.gridCell, this.initialValue, value, this) // proceed
        );

        if (save) {
            this.grid.behavior.setValue(this.event, value);
            this.grid.fireAfterCellEdit(this.event.gridCell, this.initialValue, value, this);
        }

        return save;
    },

    /**
     * @summary Extract the edited value from the editor.
     * @desc De-format the edited string back into a primitive value.
     *
     * The localizer's {@link localizerInterface#parse|parse} method will be called on the text box contents.
     *
     * Override this method if your editor has additional or alternative GUI elements. The GUI elements will influence the primitive value, either by altering the edited string before it is parsed, or by transforming the parsed value before returning it.
     * @returns {object} the current editor's value
     * @memberOf CellEditor.prototype
     */
    getEditorValue: function() {
        return this.localizer.parse(this.input.value);
    },

    /**
     * If there is no validator on the localizer, returns falsy (not invalid; possibly valid).
     * @returns {boolean|string} Truthy value means invalid. If a string, this will be an error message. If not a string, it merely indicates a generic invalid result.
     */
    validateEditorValue: function() {
        return this.localizer.invalid && this.localizer.invalid(this.input.value);
    },

    /**
     * @summary Request focus for my input control.
     * @desc See GRID-95 "Scrollbar moves inward" for issue and work-around explanation.
     * @memberOf CellEditor.prototype
     */
    takeFocus: function() {
        var el = this.el,
            leftWas = el.style.left,
            topWas = el.style.top;

        el.style.left = el.style.top = 0; // work-around: move to upper left

        var x = window.scrollX, y = window.scrollY;
        this.input.focus();
        window.scrollTo(x, y);
        this.selectAll();

        el.style.left = leftWas;
        el.style.top = topWas;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc select everything
     */
    selectAll: nullPattern,

    /**
     * @memberOf CellEditor.prototype
     * @desc set the bounds of my input control
     * @param {rectangle} rectangle - the bounds to move to
     */
    setBounds: function(cellBounds) {
        var style = this.el.style;

        style.left = px(cellBounds.x);
        style.top = px(cellBounds.y);
        style.width = px(cellBounds.width);
        style.height = px(cellBounds.height);
    },

    /**
     * @desc check that the editor is in the correct location, and is showing/hidden appropriately
     * @memberOf CellEditor.prototype
     */
    checkEditor: function() {
        if (this.checkEditorPositionFlag) {
            this.checkEditorPositionFlag = false;
            if (this.event.isCellVisible) {
                this.setEditorValue(this.initialValue);
                this.attachEditor();
                this.moveEditor();
                this.showEditor();
                this.takeFocus();
            } else {
                this.hideEditor();
            }
        }
    },

    attachEditor: function() {
        this.grid.div.appendChild(this.el);
    },

    template: ''

});

function nullPattern() {}
function px(n) { return n + 'px'; }


CellEditor.abstract = true; // don't instantiate directly


module.exports = CellEditor;

},{"../Base":41,"../lib/DOM/effects":91,"../lib/Localization":95,"mustache":35}],51:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * As of spring 2016:
 * Functions well in Chrome and Firefox; unimplemented in Safari.
 * @constructor
 * @extends CellEditor
 */
var Color = CellEditor.extend('Color', {

    template: '<input type="color" lang="{{locale}}" style="{{style}}">'

});

module.exports = Color;

},{"./CellEditor":50}],52:[function(require,module,exports){
// ComboBox.js - A combo-box is a combination of a text-box and a drop-down.
// User may type into it and/or select an item from the drop-down (by clicking on the triangle at the right).
// The drop-down has sections which are toggled from a control area between the text-box and the drop-down.

/* eslint-env browser */

'use strict';

var Textfield = require('./Textfield');
var prototype = require('./CellEditor').prototype;
var Queueless = require('../lib/DOM/queueless');
var elfor = require('../lib/DOM/elfor');

/*********************************/
/* eslint-disable no-unused-vars */
/*********************************/

var TOGGLE_MODE_PREFIX = 'toggle-mode-';

var stateToActionMap = {
    hidden: slideDown,
    visible: slideUp
};

/**
 * A combo box is a text box that also has a drop-down containing options. The drop-down consists of an actual drop-down list (a `<select>` list) plus a _control area_ above it containing toggles. The toggles control the visibility of the various "mode lists."
 *
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends Textfield
 */
var ComboBox = Textfield.extend('ComboBox', {

    initialize: function() {
        var el = this.el;

        this.input = el.querySelector('input');
        this.dropper = el.querySelector('span');
        this.options = el.querySelector('div');
        this.controls = this.options.querySelector('div');
        this.dropdown = this.options.querySelector('select');

        this.controllable = this.modes.length > 1;

        // set up a transition end controller
        this.optionsTransition = new Queueless(this.options, this);

        this.menuModesSource = this.column.menuModes || { distinctValues: true };

        // wire-ups
        this.dropper.addEventListener('mousedown', this.toggleDropDown.bind(this));
        this.dropdown.addEventListener('mousewheel', function(e) { e.stopPropagation(); });
        this.dropdown.addEventListener('change', this.insertText.bind(this));
    },

    template: [
'<div class="hypergrid-combobox" title="">',
'    <input type="text" lang="{{locale}}" style="{{style}}">',
'    <span title="Click for options"></span>',
'    <div>',
'        <div></div>',
'        <select size="15" lang="{{locale}}"></select>',
'    </div>',
'</div>'
    ].join('\n'),

    modes: [
        {
            name: 'distinctValues',
            appendOptions: function(optgroup) {
                // get the distinct column values and sort them
                var distinct = {},
                    d = [],
                    columnName = this.column.name,
                    formatter = this.column.getFormatter();

                this.grid.behavior.getData().forEach(function(dataRow) {
                    var val = formatter(dataRow[columnName]);
                    distinct[val] = (distinct[val] || 0) + 1;
                });

                for (var key in distinct) {
                    d.push(key);
                }

                while (optgroup.firstElementChild) {
                    optgroup.firstElementChild.remove();
                }

                d.sort().forEach(function(val) {
                    var option = new Option(val + ' (' + distinct[val] + ')', val);
                    optgroup.appendChild(option);
                });

                return d.length;
            }
        }
    ],

    showEditor: function() {
        // set the initial state of the mode toggles
        if (!this.built) {
            var menuModesSource = this.menuModesSource,
                menuModes = this.menuModes = {};

            // build the proxy
            this.modes.forEach(function(mode) {
                var modeName = mode.name;
                if (modeName in menuModesSource) {
                    menuModes[modeName] = menuModesSource[modeName];
                }
            });

            // wire-ups
            if (this.controllable) {
                this.controls.addEventListener('click', onModeIconClick.bind(this));
            }

            this.modes.forEach(function(mode) {
                // create a toggle
                var toggle = document.createElement('span');
                if (this.controllable) {
                    toggle.className = TOGGLE_MODE_PREFIX + mode.name;
                    toggle.title = 'Toggle ' + (mode.label || mode.name).toLowerCase();
                    if (mode.tooltip) {
                        toggle.title += '\n' + mode.tooltip;
                    }
                    toggle.textContent = mode.symbol;
                }

                this.controls.appendChild(toggle);

                // create and label a new optgroup
                if (mode.selector) {
                    var optgroup = document.createElement('optgroup');
                    optgroup.label = mode.label;
                    optgroup.className = 'submenu-' + mode.name;
                    optgroup.style.backgroundColor = mode.backgroundColor;
                    this.dropdown.add(optgroup);
                }

                setModeIconAndOptgroup.call(this, toggle, mode.name, menuModes[mode.name]);
            }, this);

            this.built = true;
        }

        prototype.showEditor.call(this);
    },

    hideEditor: function() {
        // this is where you would persist this.menuModes
        prototype.hideEditor.call(this);
    },

    toggleDropDown: function() {
        if (!this.optionsTransition.transitioning) {
            var state = window.getComputedStyle(this.dropdown).visibility;
            stateToActionMap[state].call(this);
        }
    },

    insertText: function(e) {
        // replace the input text with the drop-down text
        this.input.focus();
        this.input.value = this.dropdown.value;
        this.input.setSelectionRange(0, this.input.value.length);

        // close the drop-down
        this.toggleDropDown();
    }
});

function onModeIconClick(e) {
    var ctrl = e.target;

    if (ctrl.tagName === 'SPAN') {
        // extra ct the mode name from the toggle control's class name
        var modeClassName = Array.prototype.find.call(ctrl.classList, function(className) {
                return className.indexOf(TOGGLE_MODE_PREFIX) === 0;
            }),
            modeName = modeClassName.substr(TOGGLE_MODE_PREFIX.length);

        // toggle mode in the filter
        var modeState = this.menuModes[modeName] ^= 1;

        setModeIconAndOptgroup.call(this, ctrl, modeName, modeState);
    }
}

function setModeIconAndOptgroup(ctrl, name, state) {
    var style, optgroup, sum, display,
        dropdown = this.dropdown,
        mode = this.modes.find(function(mode) { return mode.name === name; }), // eslint-disable-line no-shadow
        selector = mode.selector;

    // set icon state (color)
    ctrl.classList.toggle('active', !!state);

    // empty the optgroup if hiding; rebuild it if showing
    if (state) { // rebuild it
        // show progress cursor for (at least) 1/3 second
        style = this.el.style;
        style.cursor = 'progress';
        setTimeout(function() { style.cursor = null; }, 333);

        if (selector) {
            optgroup = dropdown.querySelector(selector);
            sum = mode.appendOptions.call(this, optgroup);

            // update sum
            optgroup.label = optgroup.label.replace(/ \(\d+\)$/, ''); // remove old sum
            optgroup.label += ' (' + sum + ')';
        } else {
            sum = mode.appendOptions.call(this, dropdown);
            if (!this.controllable) {
                ctrl.textContent = sum + ' values';
            }
        }

        display = null;
    } else {
        display = 'none';
    }

    // hide/show the group
    if (!selector) {
        selector = 'option,optgroup:not([class])';
        var mustBeChildren = true; // work-around for ':scope>option,...' not avail in IE11
    }
    elfor.each(selector, iteratee, dropdown);

    function iteratee(el) {
        if (!mustBeChildren || el.parentElement === dropdown) {
            el.style.display = display;
        }
    }

    // TODO: Reset the width of this.options to the natural width of this.dropdown. To do this, we need to remove the latter's "width: 100%" from the CSS and then set an explicit this.options.style.width based on the computed width of this.dropdown. This is complicated by the fact that it cannot be done before it is in the DOM.
}

function slideDown() {
    // preserve the text box's current text selection, which is about to be lost
    this.selectionStart = this.input.selectionStart;
    this.selectionEnd = this.input.selectionEnd;

    // clean up the select list from last usage
    this.dropdown.selectedIndex = -1; // be kind (remove previous selection)
    this.dropdown.style.scrollTop = 0; // rewind

    // show the drop-down slide down effect
    this.options.style.visibility = 'visible';
    var dropDownTopMargin = getFloat(this.dropdown, 'marginTop'),
        dropDownRows = this.dropdown.size,
        optionHeight = Math.ceil((this.dropdown.length && getFloat(this.dropdown[0], 'height') || 13.1875) * 2) / 2 + 1;
    this.options.style.height = dropDownTopMargin + optionHeight * dropDownRows + 'px'; // starts the slide down effect

    // while in drop-down, listen for clicks in text box which means abprt
    this.input.addEventListener('mousedown', this.slideUpBound = slideUp.bind(this));

    // wait for transition to end
    this.optionsTransition.begin();
}

function slideUp() {
    // stop listening to input clicks
    this.input.removeEventListener('mousedown', this.slideUpBound);

    // start the slide up effect
    this.options.style.height = 0;

    // schedule the hide to occur after the slide up effect
    this.optionsTransition.begin(function(event) {
        this.style.visibility = 'hidden';
    });
}

function getFloat(el, style) {
    return parseFloat(window.getComputedStyle(el)[style]);
}


module.exports = ComboBox;

},{"../lib/DOM/elfor":92,"../lib/DOM/queueless":93,"./CellEditor":50,"./Textfield":58}],53:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var CellEditor = require('./CellEditor');

var isChromium = window.chrome,
    winNav = window.navigator,
    vendorName = winNav.vendor,
    isOpera = winNav.userAgent.indexOf('OPR') > -1,
    isIEedge = winNav.userAgent.indexOf('Edge') > -1,
    isIOSChrome = winNav.userAgent.match('CriOS'),
    isChrome = !isIOSChrome &&
        isChromium !== null &&
        isChromium !== undefined &&
        vendorName === 'Google Inc.' &&
        isOpera == false && isIEedge == false; // eslint-disable-line eqeqeq

/**
 * As of spring 2016:
 * Functions well in Chrome except no localization (day, month names; date format).
 * Unimplemented in Safari, Firefox, Internet Explorer.
 * This is a "snmart" control. It detects Chrome:
 * * If Chrome, uses chromeDate overrides format to that required by the value attribute, yyyy-mm-dd. (Note that this is not the format displayed in the control, which is always mm/dd/yyyy.)
 * * Otherwise uses localized date format _but_ falls back to a regular text box.
 * @constructor
 * @extends CellEditor
 */
var Date = CellEditor.extend('Date', {

    initialize: function(grid) {

        var localizerName,
            usesDateInputControl = isChrome;

        if (usesDateInputControl) {
            localizerName = 'chromeDate';
            this.template = '<input type="date">';
        } else {
            localizerName = 'date';
            this.template = '<input type="text" lang="{{locale}}">';

            this.selectAll = function() {
                var lastCharPlusOne = this.getEditorValue().length;
                this.input.setSelectionRange(0, lastCharPlusOne);
            };
        }

        this.localizer = grid.localization.get(localizerName);
    }
});


module.exports = Date;

},{"./CellEditor":50}],54:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var popMenu = require('pop-menu');

var ComboBox = require('./ComboBox');
var CellEditor = require('./CellEditor');


/**
 * The select list consists of the following sets of drop-down items:
 * * `operators` (icon *&lt;*) The particular selection of operators for this column. Comes from the filter tree.
 * * `distinctValues` (icon *#*) List of distinct column values. Calculated from inspection of column values on _and_ on icon click.
 * * `columnNames` (icon *T*) List other column names. Calculated from inspection of column values on _and_ on icon click.
 *
 * The control area reflects the `this.modes` array (above). It is modeled by a 'menuModes` object, a hash with boolean properties representing the state of each of the sets of menu items outlined above. Missing properties are falsy by implication. The state semantics are:
 *   * `1` or `true` means adds CSS class `active` to icon _and_ shows set's items in drop-down.
 *   * `0` or `false` means removes (CSS class `active` from icon _and_ hides set's items in drop-down.
 *
 * *Persisting changes:* The only change this UI supports (besides the filter text itself) is the menu mode states, which are expected to be "sticky." That is, they are "persisted" (written back) to the filter. However, there is a problem: When the column filter is blank it doesn't actually exist yet in the filter, so there is nowhere to save it. The solution is to read the `menuModes` hash _from_ the filter tree but don't modify it until end of editing. Reading it from the filter tree picks up previous setting if there was an extant column filter or the default if there was not. But then, rather than modifying this structure (because it might be the default and we don't want to overwrite that), we hang a proxy copy off the behavior's column object for this column. This will persist it for the duration of the app session. At end of editing, if and only if there is now a column filter (text is not blank), we copy it to the column filter's subtree node in the filter tree.
 *
 * @constructor
 * @extends ComboBox
 */
var FilterBox = ComboBox.extend('FilterBox', {

    initialize: function() {

        // look in the filter, under column filters, for a column filter for this column
        var root = this.grid.behavior.filter,
            columnFilters = root && root.columnFilters;

        if (!columnFilters) {
            throw 'Column filters not available.';
        }

        var columnName = this.column.name,
            columnFilterSubtree = root.getColumnFilter(columnName) || {},
            columnSchema = root.schema.lookup(columnName) || {};


        // get the operator list from the node, schema, typeOpMap, or root:
        // (This mimics the code in FilterLeaf.js's `getOpMenu` function because the node may not exist yet.)
        this.opMenu =

            // pull operator list from column schema if available
            columnSchema.opMenu ||

            // operator list for the column's type if available
            root.typeOpMap && root.typeOpMap[columnSchema.type || columnFilterSubtree.type] ||

            // default operator list (which itself defaults to `Conditionals.defaultOpMenu`)
            root.opMenu;


        // get the column filter's `menuModes` object -- contains the states of the drop-down option icons:
        this.menuModesSource =

            // first try proxy from last time (because editing may have ended without a column filter to put in the filter tree)
            this.column.menuModes ||

            // ELSE try column filter's `menuModes` WHEN available
            columnFilterSubtree.menuModes ||

            // try use column schema's `menuModes` when defined
            columnSchema.menuModes ||

            // ELSE try the filter default (which itself defaults to operators ON, others OFF; see definition at top of DefaultFilter.js)
            columnFilters.menuModes;

    },

    abortEditing: CellEditor.prototype.cancelEditing,

    /**
     * When there's only one mode defined here, the control area portion of the UI is hidden.
     */
    modes: [
        {
            name: 'operators',
            symbol: '<',
            appendOptions: function(dropdown) {
                if (!dropdown.length) {
                    // Various  operator options and/or optgroups vary per column based on `opMenu`.
                    var opMenuGroups = this.grid.behavior.filter.opMenuGroups;
                    popMenu.build(dropdown, this.opMenu, {
                        group: function(groupName) {
                            return opMenuGroups[groupName];
                        },
                        prompt: null
                    });
                    // This list of conjunctions is an extra and is for all columns. All operator optgroups are classless.
                    var optgroup = document.createElement('optgroup');
                    optgroup.label = 'Conjunctions';
                    optgroup.appendChild(new Option('and', ' and '));
                    optgroup.appendChild(new Option('or', ' or '));
                    optgroup.appendChild(new Option('nor', ' nor '));
                }
            }
        }, {
            name: 'columnNames',
            label: 'Column Names',
            selector: 'optgroup.submenu-columnNames',
            tooltip: '(Hold down alt/option key while clicking to include hidden column names.)',
            symbol: 'A',
            backgroundColor: '#eff',
            appendOptions: function(optgroup) {
                var columns = window.event.altKey
                        ? this.grid.behavior.getColumns()
                        : this.grid.behavior.getActiveColumns(),
                    x = this.event.gridCell.x;

                while (optgroup.firstElementChild) {
                    optgroup.firstElementChild.remove();
                }

                columns.forEach(function(column, index) {
                    if (index !== x) {
                        var name = column.name,
                            option = new Option(name);
                        option.title = '[' + name + ']\r"' + column.header + '"';
                        optgroup.appendChild(option);
                    }
                });
                return columns.length;
            }
        }, {
            name: 'distinctValues',
            label: 'Distinct Values',
            selector: 'optgroup.submenu-distinctValues',
            symbol: '#',
            backgroundColor: '#fef',
            appendOptions: ComboBox.prototype.modes[0].appendOptions
        }
    ],

    /**
     * Write the `menuModes` proxy to the filter tree's column filter subtree node.
     * We look up the node again here because it might be new; or may have been deleted & recreated during editing.
     */
    hideEditor: function() {
        // look in the filter, under column filters, for a column filter for this column
        var filter = this.grid.behavior.filter,
            columnName = this.column.name,
            columnFilterSubtree = filter.getColumnFilter(columnName);

        if (columnFilterSubtree) {
            // write back to filter-tree node for persisting with getState
            columnFilterSubtree.menuModes = this.menuModes;
        }

        this.column.menuModes = this.menuModes;

        ComboBox.prototype.hideEditor.call(this);
    },

    keyup: function(event) {
        if (
            !CellEditor.prototype.keyup.call(this, event) &&
            this.grid.properties.filteringMode === 'immediate'
        ) {
            try {
                this.saveEditorValue(this.getEditorValue());
            } catch (err) {
                // ignore syntax errors in immediate mode
            }
        }
    },

    insertText: function(e) {
        var start = this.selectionStart,
            end = this.selectionEnd,
            dropdown = this.dropdown,
            operator = dropdown.value,
            option = dropdown.options[dropdown.selectedIndex],
            optgroup = option.parentElement,
            isOperator = !(optgroup.tagName === 'OPTGROUP' && optgroup.className);

        this.input.focus();

        if (start === end && isOperator) {
            var parser = this.grid.behavior.filter.parserCQL,
                cql = this.input.value,
                position = parser.getOperatorPosition(cql, this.selectionStart, operator);

            start = position.start;
            end = position.end;

            // prepend space to operator as needed
            if (
                start > 0 && // not at very beginning? and...
                !/\s/.test(cql[start - 1]) // no white space before operator?
            ) {
                operator = ' ' + operator;
            }

            // append space to operator as needed
            if (
                end === cql.length || // at very end? or...
                !/\s/.test(cql[end]) // no white space after operator?
            ) {
                operator += ' ';
            }
        }

        // insert the drop-down text at the insertion point or over the selected text
        this.input.setRangeText(operator, start, end, 'end');

        // close the drop-down
        this.toggleDropDown();
    },

    saveEditorValue: function(value) {
        CellEditor.prototype.saveEditorValue.call(this, value);
        this.grid.behavior.reindex();
    },

    stopEditing: function(feedbackCount) {
        var result = CellEditor.prototype.stopEditing.call(this, feedbackCount);

        if (result) {
            this.grid.clearSelections();
        }

        return result;
    }

});

module.exports = FilterBox;

},{"./CellEditor":50,"./ComboBox":52,"pop-menu":38}],55:[function(require,module,exports){
'use strict';

var Textfield = require('./Textfield');

/**
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends Textfield
 */
var Number = Textfield.extend('Number', {

    initialize: function(grid) {
        this.localizer = grid.localization.get('number');
    }

});

module.exports = Number;

},{"./Textfield":58}],56:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 * @extends CellEditor
 */
var Slider = CellEditor.extend('Slider', {

    template: '<input type="range" lang="{{locale}}" style="{{style}}">'

});

module.exports = Slider;

},{"./CellEditor":50}],57:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 * @extends CellEditor
 */
var Spinner = CellEditor.extend('Spinner', {

    template: '<input type="number" lang="{{locale}}" style="{{style}}">'

});

module.exports = Spinner;

},{"./CellEditor":50}],58:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');
var Localization = require('../lib/Localization');


/**
 * As of spring 2016:
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends CellEditor
 */
var Textfield = CellEditor.extend('Textfield', {

    template: '<input type="text" lang="{{locale}}" class="hypergrid-textfield" style="{{style}}">',

    initialize: function() {
        this.input.style.textAlign = this.event.properties.halign;
    },

    localizer: Localization.prototype.string,

    selectAll: function() {
        this.input.setSelectionRange(0, this.input.value.length);
    }
});

module.exports = Textfield;

},{"../lib/Localization":95,"./CellEditor":50}],59:[function(require,module,exports){
'use strict';

/**
 *
 * @param {Hypergrid} grid
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
function CellEditors(grid, privateRegistry) {
    this.grid = grid;

    if (privateRegistry) {
        this.editors = {};
    }

    // preregister the standard cell editors
    if (privateRegistry || !this.get('celleditor')) {
        this.add(require('./CellEditor'));
        this.add(require('./ComboBox'));
        this.add(require('./Color'));
        this.add(require('./Date'));
        this.add(require('./FilterBox'));
        this.add(require('./Number'));
        this.add(require('./Slider'));
        this.add(require('./Spinner'));
        this.add(require('./Textfield'));
    }
}

CellEditors.prototype = {
    constructor: CellEditors.prototype.constructor, // preserve constructor

    /**
     * @summary Register a cell editor constructor.
     * @desc Adds a custom cell editor constructor to the `editors` hash using the provided name (or the class name), converted to all lower case.
     *
     * > All native cell editors are "preregistered" in `editors`..
     *
     * @param {string} [name] - Case-insensitive editor key. If not given, `YourCellEditor.prototype.$$CLASS_NAME` is used.
     *
     * @param {YourCellEditor.prototype.constructor} Constructor - A constructor, typically extended from `CellEditor` (or a descendant therefrom).
     *
     * > Note: `$$CLASS_NAME` can be easily set up by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|CellEditor.extend} call.
     *
     * @returns {CellEditor} A newly registered constructor extended from {@link CellEditor}.
     *
     * @memberOf CellEditors#
     */
    add: function(name, Constructor) {
        if (typeof name === 'function') {
            Constructor = name;
            name = undefined;
        }

        name = name || Constructor.prototype.$$CLASS_NAME;
        name = name && name.toLowerCase();
        this.editors[name] = Constructor;
        return Constructor;
    },

    /**
     * @summary Register a synonym for an existing cell editor constructor.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {CellEditor} The previously registered constructor this new synonym points to.
     * @memberOf CellEditors#
     */
    addSynonym: function(synonymName, existingName) {
        var cellEditor = this.get(existingName);
        return (this.editors[synonymName] = cellEditor);
    },

    /**
     * @param {string} name - Name of a registered editor.
     * @returns {CellEditor} A registered constructor extended from {@link CellEditor}.
     * @memberOf CellEditors#
     */
    get: function(name) {
        return this.editors[name && name.toLowerCase()];
    },

    /**
     * @summary Lookup registered cell editor and return a new instance thereof.
     * @desc Note: Must be called with the Hypergrid object as context!
     * @returns {CellEditor} New instance of the named cell editor.
     * @param {string} name - Name of a registered editor.
     * @param {string} [options] - Properties to add to the instantiated editor primarily for mustache's use.
     * @memberOf CellEditors#
     */
    create: function(name, options) {
        var cellEditor,
            Constructor = this.get(name);

        if (Constructor) {
            if (Constructor.abstract) {
                throw 'Attempt to instantiate an "abstract" cell editor class.';
            }
            cellEditor = new Constructor(this.grid, options);
        }

        return cellEditor;
    },

    /**
     * The cell editor registry containing all the "preregistered" cell editor constructors.
     * @private
     * @memberOf CellEditors#
     */
    editors: {}
};

module.exports = CellEditors;

},{"./CellEditor":50,"./Color":51,"./ComboBox":52,"./Date":53,"./FilterBox":54,"./Number":55,"./Slider":56,"./Spinner":57,"./Textfield":58}],60:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var Button = CellRenderer.extend('Button', {

    /**
     * @summary The default cell rendering function for a button cell.
     * @implements paintFunction
     * @memberOf Button.prototype
     */
    paint: function(gc, config) {
        var val = config.value,
            c = config.dataCell.x,
            r = config.gridCell.y,
            bounds = config.bounds,
            x = bounds.x + 1,
            y = bounds.y + 1,
            width = bounds.width - 1 - config.lineWidth,
            height = bounds.height - 1 - config.lineWidth,
            radius = height / 2,
            arcGradient = gc.createLinearGradient(x, y, x, y + height);

        if (config.mouseDown) {
            arcGradient.addColorStop(0, '#B5CBED');
            arcGradient.addColorStop(1, '#4d74ea');
        } else {
            arcGradient.addColorStop(0, '#ffffff');
            arcGradient.addColorStop(1, '#aaaaaa');
        }

        // draw the background
        gc.cache.fillStyle = config.backgroundColor;
        gc.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

        // draw the capsule
        gc.cache.fillStyle = arcGradient;
        gc.cache.strokeStyle = '#000000';
        this.roundRect(gc, x, y, width, height, radius, arcGradient, true);

        var ox = (width - gc.getTextWidth(val)) / 2;
        var oy = (height - gc.getTextHeight(gc.cache.font).descent) / 2;

        // draw the text
        gc.cache.textBaseline = 'middle';
        gc.cache.fillStyle = '#333333';
        gc.cache.font = height - 2 + 'px sans-serif';
        config.backgroundColor = 'rgba(0,0,0,0)';
        gc.fillText(val, x + ox, y + oy);

        //identify that we are a button
        config.buttonCells[c + ',' + r] = true;
    }
});

module.exports = Button;



},{"./CellRenderer":61}],61:[function(require,module,exports){
'use strict';

var Base = require('../Base');

/** @typedef paintFunction
 * @type {function}
 * @this {CellEditor}
 * @param {CanvasRenderingContext2D} gc
 * @param {object} config
 * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
 * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
 * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
 * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
 * @param {number} config.y - the vertical grid coordinate measured from top header row
 */

/** @constructor
 * @desc Instances of `CellRenderer` are used to render the 2D graphics context within the bound of a cell. Extend this base class to implement your own cell renderer
 *
 *
 * See also {@tutorial cell-renderer}.
 */
var CellRenderer = Base.extend('CellRenderer', {
    /**
     * @desc An empty implementation of a cell renderer, see [the null object pattern](http://c2.com/cgi/wiki?NullObject).
     * @implements paintFunction
     * @memberOf CellRenderer.prototype
     */
    paint: function(gc, config) {},

    /**
     * @desc A simple implementation of rounding a cell.
     * @param {CanvasRenderingContext2D} gc
     * @param {number} x - the x grid coordinate of my origin
     * @param {number} y - the y grid coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {number} radius
     * @param {number} fill
     * @param {number} stroke
     * @memberOf CellRenderer.prototype
     */
    roundRect: function(gc, x, y, width, height, radius, fill, stroke) {

        if (!stroke) {
            stroke = true;
        }
        if (!radius) {
            radius = 5;
        }
        gc.beginPath();
        gc.moveTo(x + radius, y);
        gc.lineTo(x + width - radius, y);
        gc.quadraticCurveTo(x + width, y, x + width, y + radius);
        gc.lineTo(x + width, y + height - radius);
        gc.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        gc.lineTo(x + radius, y + height);
        gc.quadraticCurveTo(x, y + height, x, y + height - radius);
        gc.lineTo(x, y + radius);
        gc.quadraticCurveTo(x, y, x + radius, y);
        gc.closePath();
        if (stroke) {
            gc.stroke();
        }
        if (fill) {
            gc.fill();
        }
        gc.closePath();
    }
});

CellRenderer.abstract = true; // don't instantiate directly

module.exports = CellRenderer;

},{"../Base":41}],62:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var ErrorCell = CellRenderer.extend('ErrorCell', {

    /**
     * @summary Writes error message into cell.
     *
     * @desc This function is guaranteed to be called as follows:
     *
     * ```javascript
     * gc.save();
     * gc.beginPath();
     * gc.rect(x, y, width, height);
     * gc.clip();
     * behavior.getCellProvider().renderCellError(gc, message, x, y, width, height);
     * gc.restore();
     * ```
     *
     * Before doing anything else, this function should clear the cell by setting `gc.fillStyle` and calling `gc.fill()`.
     *
     * @param {CanvasRenderingContext2D} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @memberOf ErrorCell.prototype
     */
    paint: function(gc, config, message) {
        //var images = require('../../images/index');
        var x = config.bounds.x,
            y = config.bounds.y,
            // width = config.bounds.width,
            height = config.bounds.height;

        // clear the cell
        // (this makes use of the rect path defined by the caller)
        gc.cache.fillStyle = '#FFD500';
        gc.fill();

        // render message text
        gc.cache.fillStyle = '#A00';
        gc.cache.textAlign = 'start';
        gc.cache.textBaseline = 'middle';
        gc.cache.font = 'bold 6pt "arial narrow", verdana, geneva';
        gc.fillText(message, x + 4, y + height / 2 + 0.5);
    }
});

module.exports = ErrorCell;

},{"./CellRenderer":61}],63:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var LastSelection = CellRenderer.extend('LastSelection', {

    /**
     * @desc A rendering of the last Selection Model
     * @implements paintFunction
     * @memberOf LastSelection.prototype
     */
    paint: function(gc, config) {
        var visOverlay = gc.alpha(config.selectionRegionOverlayColor) > 0,
            visOutline = gc.alpha(config.selectionRegionOutlineColor) > 0;

        if (visOverlay || visOutline) {
            var x = config.bounds.x,
                y = config.bounds.y,
                width = config.bounds.width,
                height = config.bounds.height;

            gc.beginPath();

            gc.rect(x, y, width, height);

            if (visOverlay) {
                gc.cache.fillStyle = config.selectionRegionOverlayColor;
                gc.fill();
            }

            if (visOutline) {
                gc.cache.lineWidth = 1;
                gc.cache.strokeStyle = config.selectionRegionOutlineColor;
                gc.stroke();
            }

            gc.closePath();
        }
    }
});

module.exports = LastSelection;



},{"./CellRenderer":61}],64:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');
var images = require('../../images/index');

var WHITESPACE = /\s\s+/g;

/**
 * @constructor
 * @extends CellRenderer
 */
var SimpleCell = CellRenderer.extend('SimpleCell', {

    /**
     * @summary The default cell rendering function for rendering a vanilla cell.
     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border rendering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
     * @implements paintFunction
     * @memberOf SimpleCell.prototype
     */
    paint: function(gc, config) {
        var val = config.value,
            bounds = config.bounds,
            x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height,
            iconPadding = config.iconPadding,
            partialRender = config.prefillColor === undefined, // signifies abort before rendering if same
            snapshot = config.snapshot,
            same = snapshot && partialRender,
            valWidth = 0,
            textColor, textFont,
            ixoffset, iyoffset,
            leftIcon, rightIcon, centerIcon,
            leftPadding, rightPadding,
            hover, hoverColor, selectColor, foundationColor, inheritsBackgroundColor,
            c, colors;

        // setting gc properties are expensive, let's not do it needlessly

        if (val && val.constructor === Array) {
            leftIcon = val[0];
            rightIcon = val[2];
            val = config.exec(val[1]);
            if (val && val.naturalWidth !== undefined) { // must be an image (much faster than instanceof HTMLImageElement)
                centerIcon = val;
                val = null;
            }
        } else if (config.isFilterRow) {
            if (config.filterable) {
                rightIcon = images[config.isHandleColumn || !val.length ? 'filter-off' : 'filter-on'];
                config.renderFalsy = false;
            }
        } else if (!config.isHandleColumn) {
            leftIcon = images[config.leftIcon];
            centerIcon = images[config.centerIcon];
            rightIcon = images[config.rightIcon];
        } else if (config.isDataRow) {
            leftIcon = images[config.leftIcon != undefined ? config.leftIcon : config.isRowSelected ? 'checked' : 'unchecked']; // eslint-disable-line eqeqeq
        } else if (config.isHeaderRow) {
            leftIcon = images[config.leftIcon != undefined ? config.leftIcon : config.allRowsSelected ? 'checked' : 'unchecked']; // eslint-disable-line eqeqeq
        } else {
            // row handles for "summary" or other subgrids' rows: empty
            val = '';
        }

        // Note: vf == 0 is fastest equivalent of vf === 0 || vf === false which excludes NaN, null, undefined
        var renderValue = val || config.renderFalsy && val == 0; // eslint-disable-line eqeqeq

        if (renderValue) {
            val = config.formatValue(val, config);

            textFont = config.isSelected ? config.foregroundSelectionFont : config.font;

            textColor = gc.cache.strokeStyle = config.isSelected
                ? config.foregroundSelectionColor
                : config.color;
        } else {
            val = '';
        }

        same = same &&
            val === snapshot.value &&
            textFont === snapshot.textFont &&
            textColor === snapshot.textColor;

        // fill background only if our bgColor is populated or we are a selected cell
        colors = [];
        c = 0;
        if (config.isCellHovered && config.hoverCellHighlight.enabled) {
            hoverColor = config.hoverCellHighlight.backgroundColor;
        } else if (config.isRowHovered && (hover = config.hoverRowHighlight).enabled) {
            hoverColor = config.isDataColumn || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        } else if (config.isColumnHovered && (hover = config.hoverColumnHighlight).enabled) {
            hoverColor = config.isDataRow || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        }
        if (gc.alpha(hoverColor) < 1) {
            if (config.isSelected) {
                selectColor = config.backgroundSelectionColor;
            }

            if (gc.alpha(selectColor) < 1) {
                inheritsBackgroundColor = (config.backgroundColor === config.prefillColor);
                if (!inheritsBackgroundColor) {
                    foundationColor = true;
                    colors.push(config.backgroundColor);
                    same = same &&  foundationColor === snapshot.foundationColor &&
                        config.backgroundColor === snapshot.colors[c++];
                }
            }

            if (selectColor !== undefined) {
                colors.push(selectColor);
                same = same && selectColor === snapshot.colors[c++];
            }
        }
        if (hoverColor !== undefined) {
            colors.push(hoverColor);
            same = same && hoverColor === snapshot.colors[c++];
        }

        // todo check if icons have changed
        if (same && c === snapshot.colors.length) {
            return;
        }

        // return a snapshot to save in cellEvent for future comparisons by partial renderer
        config.snapshot = {
            value: val,
            textColor: textColor,
            textFont: textFont,
            foundationColor: foundationColor,
            colors: colors
        };

        layerColors(gc, colors, x, y, width, height, foundationColor);

        // Measure left and right icons, needed for rendering and for return value (min width)
        leftPadding = leftIcon ? iconPadding + leftIcon.width + iconPadding : config.cellPadding;
        rightPadding = rightIcon ? iconPadding + rightIcon.width + iconPadding : config.cellPadding;

        if (renderValue) {
            // draw text
            gc.cache.fillStyle = textColor;
            gc.cache.font = textFont;
            valWidth = config.isHeaderRow && config.headerTextWrapping
                ? renderMultiLineText(gc, config, val, leftPadding, rightPadding)
                : renderSingleLineText(gc, config, val, leftPadding, rightPadding);
        } else if (centerIcon) {
            // Measure & draw center icon
            iyoffset = Math.round((height - centerIcon.height) / 2);
            ixoffset = Math.round((width - centerIcon.width) / 2);
            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
            valWidth = iconPadding + centerIcon.width + iconPadding;
        }

        if (leftIcon) {
            // Draw left icon
            iyoffset = Math.round((height - leftIcon.height) / 2);
            gc.drawImage(leftIcon, x + iconPadding, y + iyoffset);
        }

        if (rightIcon) {
            // Repaint background before painting right icon, because text may have flowed under where it will be.
            // This is a work-around to clipping which is too expensive to perform here.
            var rightX = x + width - (rightIcon.width + iconPadding);
            if (inheritsBackgroundColor) {
                foundationColor = true;
                colors.unshift(config.backgroundColor);
            }
            layerColors(gc, colors, rightX, y, rightPadding, height, foundationColor);

            // Draw right icon
            iyoffset = Math.round((height - rightIcon.height) / 2);
            gc.drawImage(rightIcon, rightX, y + iyoffset);
        }

        if (config.cellBorderThickness) {
            gc.beginPath();
            gc.rect(x, y, width, height);
            gc.cache.lineWidth = config.cellBorderThickness;
            gc.cache.strokeStyle = config.cellBorderStyle;
            gc.stroke();
            gc.closePath();
        }

        config.minWidth = leftPadding + valWidth + rightPadding;
    }
});

/**
 * @summary Renders single line text.
 * @param {CanvasRenderingContext2D} gc
 * @param {object} config
 * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
 * @param {*} val - The text to render in the cell.
 * @memberOf SimpleCell.prototype
 */
function renderMultiLineText(gc, config, val, leftPadding, rightPadding) {
    var x = config.bounds.x,
        y = config.bounds.y,
        width = config.bounds.width,
        height = config.bounds.height,
        cleanVal = (val + '').trim().replace(WHITESPACE, ' '), // trim and squeeze whitespace
        lines = findLines(gc, config, cleanVal.split(' '), width);

    if (lines.length === 1) {
        return renderSingleLineText(gc, config, cleanVal, leftPadding, rightPadding);
    }

    var halignOffset = leftPadding,
        valignOffset = config.voffset,
        halign = config.halign,
        textHeight = gc.getTextHeight(config.font).height;

    switch (halign) {
        case 'right':
            halignOffset = width - rightPadding;
            break;
        case 'center':
            halignOffset = width / 2;
            break;
    }

    var hMin = 0, vMin = Math.ceil(textHeight / 2);

    valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);

    halignOffset = Math.max(hMin, halignOffset);
    valignOffset = Math.max(vMin, valignOffset);

    gc.cache.save(); // define a clipping region for cell
    gc.beginPath();
    gc.rect(x, y, width, height);
    gc.clip();

    gc.cache.textAlign = halign;
    gc.cache.textBaseline = 'middle';

    for (var i = 0; i < lines.length; i++) {
        gc.fillText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
    }

    gc.cache.restore(); // discard clipping region

    return width;
}

/**
 * @summary Renders single line text.
 * @param {CanvasRenderingContext2D} gc
 * @param {object} config
 * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
 * @param {*} val - The text to render in the cell.
 * @memberOf SimpleCell.prototype
 */
function renderSingleLineText(gc, config, val, leftPadding, rightPadding) {
    var x = config.bounds.x,
        y = config.bounds.y,
        width = config.bounds.width,
        halignOffset = leftPadding,
        halign = config.halign,
        minWidth,
        metrics;

    if (config.columnAutosizing) {
        metrics = gc.getTextWidthTruncated(val, width - leftPadding, config.truncateTextWithEllipsis);
        minWidth = metrics.width;
        val = metrics.string || val;
        switch (halign) {
            case 'right':
                halignOffset = width - rightPadding - metrics.width;
                break;
            case 'center':
                halignOffset = (width - metrics.width) / 2;
                break;
        }
    } else {
        metrics = gc.getTextWidthTruncated(val, width - leftPadding, config.truncateTextWithEllipsis, true);
        minWidth = 0;
        if (metrics.string !== undefined) {
            val = metrics.string;
        } else {
            switch (halign) {
                case 'right':
                    halignOffset = width - rightPadding - metrics.width;
                    break;
                case 'center':
                    halignOffset = (width - metrics.width) / 2;
                    break;
            }
        }
    }

    if (val !== null) {
        x += Math.max(leftPadding, halignOffset);
        y += config.bounds.height / 2;

        if (config.isUserDataArea) {
            if (config.link) {
                if (config.isCellHovered || !config.linkOnHover) {
                    if (config.linkColor) {
                        gc.cache.strokeStyle = config.linkColor;
                    }
                    gc.beginPath();
                    underline(config, gc, val, x, y, 1);
                    gc.stroke();
                    gc.closePath();
                }
                if (config.linkColor && (config.isCellHovered || !config.linkColorOnHover)) {
                    gc.cache.fillStyle = config.linkColor;
                }
            }

            if (config.strikeThrough === true) {
                gc.beginPath();
                strikeThrough(config, gc, val, x, y, 1);
                gc.stroke();
                gc.closePath();
            }
        }

        gc.cache.textAlign = 'left';
        gc.cache.textBaseline = 'middle';
        gc.fillText(val, x, y);
    }

    return minWidth;
}

function findLines(gc, config, words, width) {

    if (words.length === 1) {
        return words;
    }

    // starting with just the first word...
    var stillFits, line = [words.shift()];
    while (
        // so lone as line still fits within current column...
    (stillFits = gc.getTextWidth(line.join(' ')) < width)
    // ...AND there are more words available...
    && words.length
        ) {
        // ...add another word to end of line and retest
        line.push(words.shift());
    }

    if (
        !stillFits // if line is now too long...
        && line.length > 1 // ...AND is multiple words...
    ) {
        words.unshift(line.pop()); // ...back off by (i.e., remove) one word
    }

    line = [line.join(' ')];

    if (words.length) { // if there's anything left...
        line = line.concat(findLines(gc, config, words, width)); // ...break it up as well
    }

    return line;
}

function strikeThrough(config, gc, text, x, y, thickness) {
    var textWidth = gc.getTextWidth(text);

    switch (gc.cache.textAlign) {
        case 'center':
            x -= textWidth / 2;
            break;
        case 'right':
            x -= textWidth;
            break;
    }

    y = Math.round(y + 0.5) - 0.5;

    gc.cache.lineWidth = thickness;
    gc.moveTo(x - 1, y);
    gc.lineTo(x + textWidth + 1, y);
}

function underline(config, gc, text, x, y, thickness) {
    var textHeight = gc.getTextHeight(config.font).height,
        textWidth = gc.getTextWidth(text);

    switch (gc.cache.textAlign) {
        case 'center':
            x -= textWidth / 2;
            break;
        case 'right':
            x -= textWidth;
            break;
    }

    y = Math.round(y + textHeight / 2) - 0.5;

    //gc.beginPath();
    gc.cache.lineWidth = thickness;
    gc.moveTo(x, y);
    gc.lineTo(x + textWidth, y);
}

function layerColors(gc, colors, x, y, width, height, foundationColor) {
    for (var i = 0; i < colors.length; i++) {
        if (foundationColor && !i) {
            gc.clearFill(x, y, width, height, colors[i]);
        } else {
            gc.cache.fillStyle = colors[i];
            gc.fillRect(x, y, width, height);
        }
    }
}

module.exports = SimpleCell;

},{"../../images/index":3,"./CellRenderer":61}],65:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var Slider = CellRenderer.extend('Slider', {

    /**
     * @desc Emerson's paint function for a slider button. currently the user cannot interact with it
     * @implements paintFunction
     * @memberOf Slider.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        gc.cache.strokeStyle = 'white';
        var val = config.value;
        var radius = height / 2;
        var offset = width * val;
        var bgColor = config.isSelected ? config.backgroundColor : '#333333';
        var btnGradient = gc.createLinearGradient(x, y, x, y + height);
        btnGradient.addColorStop(0, bgColor);
        btnGradient.addColorStop(1, '#666666');
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        arcGradient.addColorStop(0, '#aaaaaa');
        arcGradient.addColorStop(1, '#777777');
        gc.cache.fillStyle = btnGradient;
        this.roundRect(gc, x, y, width, height, radius, btnGradient);
        if (val < 1.0) {
            gc.cache.fillStyle = arcGradient;
        } else {
            gc.cache.fillStyle = '#eeeeee';
        }
        gc.beginPath();
        gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
        gc.fill();
        gc.closePath();
        config.minWidth = 100;
    }
});

module.exports = Slider;

},{"./CellRenderer":61}],66:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var SparkBar = CellRenderer.extend('SparkBar', {

    /**
     * @desc A simple implementation of a sparkline, because it's a barchart we've changed the name ;).
     * @implements paintFunction
     * @memberOf SparkBar.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;
        var fgColor = config.isSelected ? config.foregroundSelectionColor : config.color;
        if (config.backgroundColor || config.isSelected) {
            gc.cache.fillStyle = config.isSelected ? 'blue' : config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.cache.fillStyle = fgColor;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
            x += eWidth;
        }
        gc.closePath();
        config.minWidth = count * 10;
    }
});

module.exports = SparkBar;

},{"./CellRenderer":61}],67:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var SparkLine = CellRenderer.extend('SparkLine', {

    /**
     * @desc A simple implementation of a sparkline.  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
     * @implements paintFunction
     * @memberOf SparkLine.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;

        var fgColor = config.isSelected ? config.foregroundSelectionColor : config.color;
        if (config.backgroundColor || config.isSelected) {
            gc.cache.fillStyle = config.isSelected ? config.backgroundSelectionColor : config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.cache.strokeStyle = fgColor;
        gc.cache.fillStyle = fgColor;
        gc.beginPath();
        var prev;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            if (!prev) {
                prev = barheight;
            }
            gc.lineTo(x + 5, y + height - barheight);
            gc.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
            x += eWidth;
        }
        config.minWidth = count * 10;
        gc.stroke();
        gc.closePath();
    }
});

module.exports = SparkLine;

},{"./CellRenderer":61}],68:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var TreeCell = CellRenderer.extend('TreeCell', {

    /**
     * @desc A simple implementation of a tree cell renderer for use mainly with the qtree.
     * @implements paintFunction
     * @memberOf TreeCell.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        var val = config.value.data;
        var indent = config.value.indent;
        var icon = config.value.icon;

        //fill background only if our bgColor is populated or we are a selected cell
        if (config.backgroundColor || config.isSelected) {
            gc.cache.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }

        if (!val || !val.length) {
            return;
        }
        var valignOffset = Math.ceil(height / 2);

        gc.cache.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
        gc.fillText(icon + val, x + indent, y + valignOffset);

        var textWidth = gc.getTextWidth(icon + val);
        var minWidth = x + indent + textWidth + 10;
        config.minWidth = minWidth;
    }
});

module.exports = TreeCell;

},{"./CellRenderer":61}],69:[function(require,module,exports){
'use strict';

/**
 * @classdesc API of cell renderer object constructors, plus some access methods.
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
function CellRenderers(privateRegistry) {
    if (privateRegistry) {
        this.singletons = {};
    }

    // preregister the standard cell renderers
    if (privateRegistry || !this.get('emptycell')) {
        this.add('EmptyCell', require('./CellRenderer'));
        this.add(require('./Button'));
        this.add(require('./SimpleCell'));
        this.add(require('./SliderCell'));
        this.add(require('./SparkBar'));
        this.add(require('./LastSelection'));
        this.add(require('./SparkLine'));
        this.add(require('./ErrorCell'));
        this.add(require('./TreeCell'));
    }
}

CellRenderers.prototype = {
    constructor: CellRenderers.prototype.constructor, // preserve constructor

    /**
     * @summary Register and instantiate a cell renderer singleton.
     * @desc Adds a custom cell renderer to the `singletons` hash using the provided name (or the class name), converted to all lower case.
     *
     * > All native cell renderers are "preregistered" in `singletons`. Add more by calling `add`.
     *
     * @param {string} [name] - Case-insensitive renderer key. If not given, `YourCellRenderer.prototype.$$CLASS_NAME` is used.
     *
     * @param {CellRenderer} Constructor - A constructor, typically extended from `CellRenderer` (or a descendant therefrom).
     *
     * > Note: `$$CLASS_NAME` can be easily set up by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|CellEditor.extend} call.
     *
     * @returns {CellRenderers} A newly registered constructor extended from {@link CellRenderers}.
     *
     * @memberOf CellRenderers.prototype
     */
    add: function(name, Constructor) {
        if (typeof name === 'function') {
            Constructor = name;
            name = undefined;
        }

        name = name || Constructor.prototype.$$CLASS_NAME;
        name = name && name.toLowerCase();
        return (this.singletons[name] = new Constructor);
    },

    /**
     * @summary Register a synonym for an existing cell renderer singleton.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {CellRenderers} The previously registered constructor this new synonym points to.
     * @memberOf CellRenderers.prototype
     */
    addSynonym: function(synonymName, existingName) {
        var cellRenderer = this.get(existingName);
        return (this.singletons[synonymName] = cellRenderer);
    },

    /**
     * Fetch a registered cell renderer singleton.
     * @param {string} name
     * @returns {CellRenderers} A registered constructor extended from {@link CellRenderers}.
     * @memberOf CellRenderers.prototype
     */
    get: function(name) {
        var result = this.singletons[name]; // for performance reasons, do not convert to lower case
        if (!result) {
            result = this.singletons[name.toLowerCase()]; // name may differ in case only
            if (result) {
                this.singletons[name] = result; // register found name as a synonym
            }
        }
        return result;
    },

    /**
     * The cell editor registry containing all the "preregistered" cell renderer singletons.
     * @private
     * @memberOf CellRenderers.prototype
     */
    singletons: {}
};


module.exports = CellRenderers;

},{"./Button":60,"./CellRenderer":61,"./ErrorCell":62,"./LastSelection":63,"./SimpleCell":64,"./SliderCell":65,"./SparkBar":66,"./SparkLine":67,"./TreeCell":68}],70:[function(require,module,exports){
'use strict';

var Base = require('../Base');

/**
 * @constructor
 */
var DataModel = Base.extend('DataModel', {
    grid: null,
    initialize: function(grid, options) {
        this.grid = grid;
    },

    changed: function() {
        this.deprecated('changed()', 'grid.behavior.changed()', '1.1.0');
    },

    getPrivateState: function() {
        return this.deprecated('getPrivateState()', 'grid.properties', '1.2.0');
    },

    /**
     * @param {object} config
     * @param {string} declaredRendererName - The proposed cell renderer name (form the render properties).
     * @returns {CellRenderer}
     * @memberOf DataModel.prototype
     */
    getCell: function(config, declaredRendererName) {
        return this.grid.cellRenderers.get(declaredRendererName);
    },

    /**
     * @summary Instantiate a new cell editor.
     * @desc The application developer may override this method to:
     * * Instantiate and return an arbitrary cell editor. The generic implementation here simply returns the declared cell editor. This is `undefined` when there was no such declaration, or if the named cell editor was not registered.
     * * Return `undefined` for no cell editor at all. The cell will not be editable.
     * * Set properties on the instance by passing them in the `options` object. These are applied to the new cell editor object after instantiation but before rendering.
     * * Manipulate the cell editor object (including its DOM elements) after rendering but before DOM insertion.
     *
     * Overriding this method with a null function (that always returns `undefined`) will have the effect of making all cells uneditable.
     *
     * @param {number} columnIndex - Absolute column index. I.e., the position of the column in the data source's original `fields` array, as echoed in `behavior.allColumns[]`.
     *
     * @param {number} rowIndex - Row index of the data row in the currently filtered and sorted list of rows, regardless of vertical scroll position, offset by the number of header rows (all the rows above the first data row including the filter row). I.e., after subtracting out the number of header rows, this is the position of the data row in the `index` array of the data source (i.e., the last data source pipeline).
     *
     * @param {string} declaredEditorName - The proposed cell editor name (from the render properties).
     *
     * @param {CellEvent} cellEvent - All enumerable properties of this object will be copied to the new cell editor object for two purposes:
     * * Used in cell editor logic.
     * * For access from the cell editor's HTML template (via mustache).
     *
     * {@link CellEditor} requires both of the following:
     * * **`format`** - The cell's `format` render prop (name of localizer to use to format the editor preload and parse the edited value). May be `undefined` (no formatting or parsing). Added by calling {@link Column#getCellEditorAt|getCellEditorAt} method. Developer's override is free to alter this property.
     * * _CellEvent props_ - `column` ({@link Column} object) is the only enumerable property of the native `CellEvent` object. Read-only.
     * * _Custom props_ - Developer's override of this method may add additional properties, for both purposes listed above.
     *
     * Note that the `editPoint` property previously available to cell editors has been deprecated in favor of options.gridCell. `editPoint` will still work for the time being but with a deprecation warning in the console to use `cellEvent.gridCell` instead.
     *
     * @returns {undefined|CellEditor} An object instantiated from the registered cell editor constructor named in `declaredEditorName`. A falsy return means the cell is not editable because the `declaredEditorName` was not registered.
     *
     * @memberOf DataModel.prototype
     */
    getCellEditorAt: function(columnIndex, rowIndex, declaredEditorName, cellEvent) {
        return this.grid.cellEditors.create(declaredEditorName, cellEvent);
    }

});

module.exports = DataModel;

},{"../Base":41}],71:[function(require,module,exports){
'use strict';

/**
 * @implements dataModelAPI
 * @param {Hypergrid} grid
 * @param {object} [options]
 * @param {string} [options.name]
 * @constructor
 */
function HeaderSubgrid(grid, options) {
    this.grid = grid;
    this.behavior = grid.behavior;

    /**
     * @type {dataRowObject}
     */
    this.dataRow = {}; // for meta data (__HEIGHT)

    if (options && options.name) {
        this.name = options.name;
    }
}

HeaderSubgrid.prototype = {
    constructor: HeaderSubgrid.prototype.constructor,

    type: 'header',

    format: 'header', // override column format

    getRowCount: function() {
        return this.grid.properties.showHeaderRow ? 1 : 0;
    },

    getValue: function(x, y) {
        var column = this.behavior.getColumn(x);
        return column.header || column.name; // use field name when header undefined
    },

    setValue: function(x, y, value) {
        if (y < this.getRowCount()) {
            this.behavior.getColumn(x).header = value;
        }
    },

    getRow: function(y) {
        return this.dataRow;
    }
};

module.exports = HeaderSubgrid;

},{}],72:[function(require,module,exports){
'use strict';

var DataModel = require('./DataModel');
var DataSourceOrigin = require('../lib/DataSourceOrigin');

/** @typedef {object} dataSourcePipelineObject
 * @property {string} type - A "DataSourceOrigin" style constructor name.
 * @property {*} [options] - When defined, passed as 2nd argument to constructor.
 * @property {string} [parent] - Defines a branch off the main sequence.
 */

/**
 * @name dataModels.JSON
 * @constructor
 * @extends DataModel
 */
var JSON = DataModel.extend('dataModels.JSON', {

    initialize: function(grid, options) {
        /**
         * @summary Hash of controllers.
         * @desc Keyed by data source type.
         * Data controller are only accepted by data sources that have a defined `type` property.
         * @see {@link dataControlInterface}
         * @type {object}
         * @memberOf dataModels.JSON.prototype
         */
        this.controllers = {};

        this.charMap = new CharMap(this);

        this.reset(options);
    },

    /**
     * Override to use a different origin.
     * @type(DataSourceBase}
     * @memberOf dataModels.JSON.prototype
     */
    DataSourceOrigin: DataSourceOrigin,

    /**
     * @type {dataSourcePipelineObject[][]}
     * @summary Pipeline stash push-down list.
     * @desc The pipeline stash may be shared or instanced. This is the shared stash. An instance may override this with an instance stash variable (of the same name). See {@link dataModels.JSON#getPipelineSchemaStash}.
     * @memberOf dataModels.JSON.prototype
     */
    pipelineSchemaStash: [],

    /**
     * @param {object} [options]
     * @param {object} [options.pipeline] - Consumed by {@link dataModels.JSON#setPipeline}.
     * If omitted, previously established pipeline is reused.
     * @param {object} [options.controllers] - Consumed by {@link dataModels.JSON#setPipeline}.
     * If omitted, previously established controllers.
     * * @memberOf dataModels.JSON.prototype
     */
    reset: function(options) {
        this.selectedData = [];

        delete this.pipelineSchemaStash; // remove existing "own" version if any

        options = options || {};
        this.source = new this.DataSourceOrigin(
            options.data,
            options.schema
        );

        this.setPipeline({
            pipeline: options.pipeline,
            controllers: options.controllers
        });
    },

    /**
     * Application developer should override to set up a default pipeline.
     * @type {pipelineSchema}
     * @memberOf dataModels.JSON.prototype
     */
    defaultPipelineSchema: [],

    clearSelectedData: function() {
        this.selectedData.length = 0;
    },

    /**
     * @deprecated As of v1.0.7, reference the `dataSource` property instead.
     * @returns {*}
     * @memberOf dataModels.JSON.prototype
     */
    getDataSource: function() {
        return this.deprecated('getDataSource()', 'dataSource', '1.0.7');
    },

    getData: function() {
        return this.source.data;
    },

    /**
     * @deprecated As of v1.1.0, use `getIndexedData()` instead.
     * @memberOf dataModels.JSON.prototype
     */
    getFilteredData: function() {
        return this.deprecated('getFilteredData()', 'getIndexedData()', '1.2.0', arguments);
    },

    getIndexedData: function() {
        var ds = this.dataSource;
        var count = ds.getRowCount();
        var result = new Array(count);
        for (var y = 0; y < count; y++) {
            result[y] = ds.getRow(y);
        }
        return result;
    },

    /**
     * @param {number} x - Data column coordinate.
     * @param {number} y - Data row coordinate.
     * @memberOf dataModels.JSON.prototype
     */
    getValue: function(x, y) {
        if (this.hasHierarchyColumn()) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.isDrillDown()) {
            x += 1;
        }
        return this.dataSource.getValue(x, y);
    },

    /**
     * @param {number} y - Data row coordinate.
     * @returns {nunber} Row index in raw data array after dereferencing all data source indexing.
     * @memberOf dataModels.JSON.prototype
     */
    getDataIndex: function(y) {
        return this.dataSource.getDataIndex(y);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x - Data column coordinate.
     * @param {number} r - Grid row coordinate.
     * @param value
     */
    setValue: function(x, r, value) {
        if (this.hasHierarchyColumn()) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.isDrillDown()) {
            x += 1;
        }
        this.dataSource.setValue(x, r, value);
    },

    /**
     * @deprecated As of v1.1.0, use `this.grid.behavior.getColumnProperties(x)` instead.
     * @memberOf dataModels.JSON.prototype
     * @param {number} x - Data column coordinate.
     * @returns {*}
     */
    getColumnProperties: function(x) {
        //access directly because we want it ordered
        return this.deprecated('getColumnProperties(x)', 'grid.behavior.getColumnProperties(x)', '1.2.0', arguments);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        var showTree = this.grid.properties.showTreeColumn === true;
        var offset = (this.isDrillDown() && !showTree) ? -1 : 0;
        return this.dataSource.getColumnCount() + offset;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getRowCount: function() {
        return this.dataSource.getRowCount();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return getSchemaPropArr.call(this, 'header', 'getHeaders');
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.dataSource.setFields(fields);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getFields: function() {
        return getSchemaPropArr.call(this, 'name', 'getFields');
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getCalculators: function() {
        return getSchemaPropArr.call(this, 'calculator', 'getCalculators');
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    reindex: function(options) {
        selectedDataRowsBackingSelectedGridRows.call(this);

        this.pipeline.forEach(function(dataSource) {
            if (dataSource) {
                if (dataSource.apply) {
                    dataSource.apply(options);
                }
            }
        });

        reselectGridRowsBackedBySelectedDataRows.call(this);
    },

    /**
     * @summary Set or reset grid data.
     * See {@link DataSourceOrigin#setData} for details.
     * @memberOf dataModels.JSON.prototype
     */
    setData: function(dataSource, schema) {
        this.source.setData(dataSource, schema);
    },

    /** @typedef {DataSourceBase[]} pipelineSchema
     * @summary Describes a new pipeline.
     * @desc Consists of an ordered list of data source constructors, descendants of `DataSourceBase`.
     * May contain `undefined` elements, which are ignored.
     */

    /**
     * @summary Instantiates the data source pipeline.
     * @desc Each new pipe is created from the list of supplied constructors, each taking a reference to the previous data source in the pipeline.
     *
     * A reference to each new pipe is added to `this.sources` dataModel using the pipe's derived name.
     *
     * Will clear out any filtering and sorting state.
     *
     * The last pipe is assigned the synonym `this.dataSource`.
     * @param {pipelineSchema} [DataSources] - New pipeline description. If not given, uses the default {@link dataModels.JSON#DataSources|this.defaultPipelineSchema}.
     * @param {object} [options] - Takes first argument position when `DataSources` omitted.
     * @param {string} [options.stash] - See {@link dataModels.JSON#getPipelineSchemaStash}. If given, saves the currently defined pipeline onto the indicated stash stack and then resets it with the given `DataSources`.
     * @memberOf dataModels.JSON.prototype
     */
    setPipeline: function(DataSources, options) {
        if (!Array.isArray(DataSources)) {
            options = DataSources;
            DataSources = options.pipeline;
        }

        options = options || {};

        if (DataSources) {
            DataSources = DataSources.slice();
        } else if (this.DataSources) {
            DataSources = this.DataSources;
        } else {
            DataSources = this.defaultPipelineSchema.slice();
        }

        this.DataSources = DataSources;

        var pipeline = [],
            dataSource = this.source;
        if (DataSources.length) {
            if (options.stash) {
                this.getPipelineSchemaStash(options.stash).push(DataSources);
            }

            DataSources.forEach(function(DataSource) {
                if (DataSource) {
                    dataSource = new DataSource(dataSource);
                    pipeline.push(dataSource);
                }
            }, this);
        }
        this.dataSource = dataSource;

        /**
         * @summary Currently defined pipeline.
         * @desc Each instance has its own pipeline.
         * (Pipelines cannot be shared because they contain indexes specific to the data in the grid.)
         * @name pipeline
         * @type {dataSourcePipelineObject[]}
         * @memberOf dataModels.JSON.prototype
         */
        this.pipeline = pipeline;

        this.setController(options.controllers || this.controllers); // set the new or previously set data controller(s) on the new pipeline
    },

    /**
     * Find the last data source in the pipeline of specified type.
     * @param {string} type
     * @returns {DataSourceBase}
     * @memberOf dataModels.JSON.prototype
     */
    findDataSourceByType: function(type) {
        var dataSource;
        for (var i = this.pipeline.length - 1; i >= 0; i--) {
            dataSource = this.pipeline[i];
            if (dataSource.type === type) {
                return dataSource;
            }
        }
    },

    /**
     * @summary The pipeline stash currently in use (either shared or instance).
     * @desc Instance stash is created here when requested and instance doesn't yet have its "own" version.
     * @param {string} [whichStash='default'] - One of:
     * * `'shared'` - Use shared stash.
     * * `'own'' or `'instance'` - Use instance stash, creating it if it does not exist.
     * * `'default'` - Use instance stash if previously created; otherwise use shared stash.
     * @returns The pipeline stash push-down list.
     * @memberOf dataModels.JSON.prototype
     */
    getPipelineSchemaStash: function(whichStash) {
        var stash;
        switch (whichStash) {

            case 'shared':
                stash = DataModel.prototype.stash;
                break;

            case 'own':
            case 'instance':
                if (!this.hasOwnProperty('pipelineSchemaStash')) {
                    this.pipelineSchemaStash = [];
                }
            // disable eslint no-fallthrough
            case 'default':
            case undefined:
                stash = this.pipelineSchemaStash;
                break;

        }
        return stash;
    },

    /**
     * Pops the last stashed pipeline off the stash stack, making it the currently defined pipeline.
     * @param {string} [whichStash] - See {@link dataModels.JSON#getPipelineSchemaStash}.
     * @memberOf dataModels.JSON.prototype
     */
    unstashPipeline: function(whichStash) {
        var pipelineSchemaStash = this.getPipelineSchemaStash(whichStash);
        if (pipelineSchemaStash.length) {
            this.setPipeline(pipelineSchemaStash.pop());
        }
    },

    /**
     * @deprecated
     * @param {number} [newLength=0]
     * @memberOf dataModels.JSON.prototype
     */
    truncatePipeline: function(newLength) {
        return this.deprecated('truncatePipeline(newLength)', 'setPipeline()', '1.2.0', arguments, 'Build a local pipeline (array of data source constructors) and pass it to setPipeline.');
    },

    isDrillDown: function(event) {
        var colIndex = event && event.gridCell && event.gridCell.x;
        return this.dataSource.isDrillDown(colIndex);
    },

    /**
     * @deprecated As pf v1.1.0, use `this.grid.behavior.setTopTotals()` instead.
     * @summary Set the top total row(s).
     * @param {dataRowObject[]} totalRows - Array of 0 or more rows containing summary data. Omit to set to empty array.
     * @memberOf dataModels.JSON.prototype
     */
    setTopTotals: function(totalRows) {
        return this.deprecated('setTopTotals(rows)', 'grid.behavior.setTopTotals(rows)', '1.1.0', arguments);
    },

    /**
     * @deprecated As pf v1.1.0, use `this.grid.behavior.getTopTotals()` instead.
     * @summary Get the top total row(s).
     * @returns {dataRowObject[]}
     * @memberOf dataModels.JSON.prototype
     */
    getTopTotals: function() {
        return this.deprecated('getTopTotals(rows)', 'grid.behavior.getTopTotals(rows)', '1.1.0', arguments);
    },

    /**
     * @deprecated
     * @summary Set the bottom total row(s).
     * @param {dataRowObject[]} totalRows - Array of 0 or more rows containing summary data. Omit to set to empty array.
     * @memberOf dataModels.JSON.prototype
     */
    setBottomTotals: function(totalRows) {
        return this.deprecated('setBottomTotals(rows)', 'grid.behavior.setBottomTotals(rows)', '1.1.0', arguments);
    },

    /**
     * @summary Get the bottom total row(s).
     * @deprecated As pf v1.1.0, use `this.grid.behavior.getBottomTotals()` instead.
     * @returns {dataRowObject[]}
     * @memberOf dataModels.JSON.prototype
     */
    getBottomTotals: function() {
        return this.deprecated('getBottomTotals()', 'grid.behavior.getBottomTotals()', '1.1.0');
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {Column[]}
     */
    getActiveColumns: function() {
        return this.deprecated('getActiveColumns()', 'grid.behavior.getActiveColumns()', '1.2.14', arguments);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @deprecated As of v1.0.6, use `this.getActiveColumns` instead.
     * @returns {Column[]}
     */
    getVisibleColumns: function() {
        return this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getHiddenColumns: function() {
        return this.deprecated('getHiddenColumns()', 'grid.behavior.getHiddenColumns()', '1.2.14', arguments);
    },
    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasHierarchyColumn: function() {
        var showTree = this.grid.properties.showTreeColumn === true;
        return this.isDrillDown() && showTree;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param index
     * @param returnAsString
     * @desc Provides the unicode character used to denote visually if a column is a sorted state
     * @returns {*}
     */
    getSortImageForColumn: function(columnIndex) {
        //Not implemented
    },

    /**
     * @param cell
     * @param event
     * @return {boolean} Clicked in a drill-down column.
     * @memberOf dataModels.JSON.prototype
     */
    cellClicked: function(event) {
        if (arguments.length === 2) {
            return this.deprecated('cellClicked(cell, event)', 'cellClicked(event)', '1.2.0', arguments);
        }
        return this.toggleRow(event.dataCell.y);
    },

    /**
     * @summary Toggle the drill-down control of a the specified row.
     * @desc Operates only on the following rows:
     * * Expandable rows - Rows with a drill-down control.
     * * Revealed rows - Rows not hidden inside of collapsed drill-downs.
     * @param y - Revealed row number. (This is not the row ID.)
     * @param {boolean} [expand] - One of:
     * * `true` - Expand row.
     * * `false` - Collapse row.
     * * `undefined` (or omitted) - Toggle state of row.
     * @returns {boolean|undefined} Changed. Specifically, one of:
     * * `undefined` row had no drill-down control
     * * `true` drill-down changed
     * * `false` drill-down unchanged (was already in requested state)
     * @memberOf dataModels.JSON.prototype
     */
    toggleRow: function(y, expand) {
        //TODO: fire a row toggle event
        var changed;
        if (this.isDrillDown()) {
            changed = this.dataSource.click(y, expand);
            if (changed) {
                this.reindex({rowClick: true});
                this.grid.behavior.changed();
            }
        }
        return changed;
    },

    /**
     * @param {number} r - Data row coordinate.
     * @returns {object|undefined} Returns data row object or `undefined` if a header row.
     * @memberOf dataModels.JSON.prototype
     */
    getRow: function(r) {
        return this.dataSource.getRow(r);
    },

    /**
     * @summary Get the given data controller.
     * @param {string} type
     * @returns {undefined|*} The data controller; or `undefined` if data controller unknown to data model.
     * @memberOf dataModels.JSON#
     */
    getController: function(type) {
        return this.controllers[type]; // alternatively: this.dataSource.getController(type)
    },

    /**
     * @summary Set the given data controller(s).
     * @param {string} typeOrHashOfTypes - One of:
     * * **object** - Hash of multiple data controllers, by type.
     * * **string** - Type of the single data controller given in `controller`.
     * @param {dataControlInterface} [controller] - Only required when 'hash' is a string; omit when `hash` is an object.
     * @returns {object} - Hash of all results, by type. Each member will be:
     * * The given data controller for that type when defined.
     * * A new "null" data controller, generated by the data model when the given data controller for that type was `undefined`.
     * * `undefined` - The data controller was unknown to the data model.
     * @memberOf dataModels.JSON#
     */
    setController: function(typeOrHashOfTypes, controller) {
        var dataSource = this.dataSource,
            controllers = this.controllers,
            result, results = {},
            atLeastOneAccepted,
            hash;

        if (typeof typeOrHashOfTypes === 'string') {
            var type = typeOrHashOfTypes;
            hash = {};
            hash[type] = controller;
        } else {
            hash = typeOrHashOfTypes;
        }

        Object.keys(hash).forEach(function(type) {
            result = dataSource.setController(type, hash[type]);
            atLeastOneAccepted = atLeastOneAccepted || result;
            results[type] = result;
        });

        // add in the results to the active list including rejections
        Object.assign(controllers, results);

        // prune rejections from the active list
        Object.keys(controllers).forEach(function(type) {
            if (!controllers[type]) {
                delete controllers[type];
            }
        });

        if (atLeastOneAccepted) {
            this.reindex();
        }

        return results;
    },

    /**
     * @summary Digests `(columnIndex, propName, value)` and calls specified data controllers `properties()` method.
     * @desc Digests the three parameters `(columnIndex, propName, value)` detailed below, creating a single {@link dataControlInterface} object with which it then calls the `properties` method of the data controller specified by `type`.
     *
     * This method is overloaded in the jQuery style: You can both set a data controller prop (when value give) and a get a data controller prop (when value omitted); or you can give a hash in place of the property name to set several properties at once. Whichever way you use it, you can in addition specify a column index for column-specific properties.
     *
     * @param {null|string} type - The controller type from which to get or to which to set the given property value(s). `null` in a setter operation applies the value(s) to all data controllers; `null` has questionable usefulness in a getter operation.
     *
     * @param {number} [columnIndex] - If given, this is a property on a specific column. If omitted, this is a property on the whole data controller properties object.
     *
     * @param {string|object} propNameOrPropHash - _If `columnIndex` is omitted, this arg takes its place._
     *
     * One of these types:
     * * **string** - Property name. The name of the explicit property to either get or (if `value` also given) set on the properties object.
     * * **object** - Hash of properties to set on the properties object.
     *
     * @param [value] - _If `columnIndex` is omitted, this arg takes its place._
     *
     * One of:
     * * If omitted when `propNameOrPropHash` is a string, this is the "getter" action:
     * Return the value from the properties object of the key in `property`.
     * * Provided when `propNameOrPropHash` is a string, this is the "setter" action:
     * Copy this value to properties object using the key in `property`.
     * * When `propNameOrPropHash` is a hash and `value` is given: Unexpected; throws an error.
     *
     * @returns {propObject}
     *
     * @memberOf dataModels.JSON#
     */
    prop: function(type, columnIndex, propNameOrPropHash, value) {
        var result, invalid,
            properties = {},
            argCount = arguments.length,
            controllers = this.controllers,
            types = (type !== null) ? [type] : Object.keys(controllers);

        controllers = types
            .map(function(type) { return controllers[type]; })
            .filter(function(controller) { return controller; });

        if (controllers.length) {
            if (typeof columnIndex === 'number') {
                argCount--;
            } else {
                value = propNameOrPropHash;
                propNameOrPropHash = columnIndex;
                columnIndex = undefined;
            }

            switch (argCount) {

                case 2: // getter propName name or setter hash
                    if (typeof propNameOrPropHash === 'object') {
                        properties = propNameOrPropHash; // prop is object
                    } else {
                        properties.GETTER = propNameOrPropHash; // prop is name
                    }
                    break;

                case 3: // setter for value
                    if (typeof propNameOrPropHash === 'string') {
                        properties[propNameOrPropHash] = value; // prop is name
                    } else {
                        invalid = true;
                    }
                    break;

                default: // too few or too many args
                    invalid = true;

            }

            if (invalid) {
                throw 'Invalid overload.';
            }

            if (columnIndex !== undefined) {
                // non-enumerable propName:
                Object.defineProperty(properties, 'COLUMN', {
                    value: {
                        index: columnIndex,
                        name: this.source.schema[columnIndex].name
                    }
                });
            }

            // Use the prepared propObject to get or set the properties on the controller
            controllers.forEach(function(controller) {
                result = controller.properties(properties);
            });
        }

        return result;
    },

    /**
     * @deprecated As of v1.1.0, use `this.reindex` instead.
     * @memberOf dataModels.JSON.prototype
     */
    applyState: function() {
        return this.deprecated('applyState()', 'reindex()', '1.2.0', arguments);
    },

    getUnfilteredValue: function(x, y) {
        return this.deprecated('getUnfilteredValue(x, y)', null, '1.2.0', arguments, 'No longer supported');
    },

    getUnfilteredRowCount: function() {
        return this.deprecated('getUnfilteredValue(x, y)', null, '1.2.0', arguments, 'No longer supported');
    },

    /**
     * @summary Add a new data row to the grid.
     * @desc If data source pipeline in use, to see the new row in the grid, you must eventually call:
     * ```javascript
     * this.grid.behavior.reindex();
     * this.grid.behaviorChanged();
     * ```
     * @param {object} newDataRow
     * @returns {object} The new row object.
     * @memberOf dataModels.JSON.prototype
     */
    addRow: function(newDataRow) {
        this.getData().push(newDataRow);
        return newDataRow;
    },

    get schema() { return this.dataSource.schema; },

    set schema(schema) {
        this.dataSource.setSchema(schema);
    }
});

// LOCAL METHODS -- to be called with `.call(this`

/**
 * Accumulate actual data row objects backing current grid row selections.
 * This call should be paired with a subsequent call to `reselectGridRowsBackedBySelectedDataRows`.
 * @private
 * @this {dataModels.JSON}
 * @memberOf dataModels.JSON.prototype
 */
function selectedDataRowsBackingSelectedGridRows() {
    var selectedData = this.selectedData,
        hasRowSelections = this.grid.selectionModel.hasRowSelections(),
        needIndexedDataList = selectedData.length || hasRowSelections;

    if (needIndexedDataList) {
        var indexedData = this.getIndexedData();
    }

    // STEP 1: Remove any filtered data rows from the recently selected list.
    selectedData.forEach(function(dataRow, index) {
        if (indexedData.indexOf(dataRow) >= 0) {
            delete selectedData[index];
        }
    });

    // STEP 2: Accumulate the data rows backing any currently selected grid rows in `this.selectedData`.
    if (hasRowSelections) { // any current grid row selections?
        this.grid.getSelectedRows().forEach(function(selectedRowIndex) {
            var dataRow = indexedData[selectedRowIndex];
            if (selectedData.indexOf(dataRow) < 0) {
                selectedData.push(dataRow);
            }
        });
    }
}

/**
 * Re-establish grid row selections based on actual data row objects accumulated by `selectedDataRowsBackingSelectedGridRows` which should be called first.
 * @private
 * @this {dataModels.JSON}
 * @memberOf dataModels.JSON.prototype
 */
function reselectGridRowsBackedBySelectedDataRows() {
    if (this.selectedData.length) { // any data row objects added from previous grid row selections?
        var selectionModel = this.grid.selectionModel,
            offset = this.grid.getHeaderRowCount(),
            filteredData = this.getIndexedData();

        selectionModel.clearRowSelection();

        this.selectedData.forEach(function(dataRow) {
            var index = filteredData.indexOf(dataRow);
            if (index >= 0) {
                selectionModel.selectRow(offset + index);
            }
        });
    }
}

/**
 * @private
 * @param {string} propName
 * @this DataSourceOrigin#
 * @returns {Array}
 * @memberOf dataModels.JSON~
 */
function getSchemaPropArr(propName, deprecatedMethodName) {
    this.deprecated(deprecatedMethodName, deprecatedMethodName + '() has been deprecated as of v1.2.0 and will be removed in a future release. Constructs like ' + deprecatedMethodName + '()[i] should be changed to schema[i]. (This deprecated method now returns a new array derived from schema.)');
    return this.schema.map(function(columnSchema) {
        return columnSchema[propName];
    }, this);
}

function CharMap(dataModel) {
    this.dataModel = dataModel;
}
CharMap.prototype = {
    mixIn: require('overrider').mixIn,

    get OPEN() { return this.dataModel.dataSource.drillDownCharMap.OPEN; },
    set OPEN(s) { this.dataModel.dataSource.drillDownCharMap.OPEN = s; },

    get CLOSE() { return this.dataModel.dataSource.drillDownCharMap.CLOSE; },
    set CLOSE(s) { this.dataModel.dataSource.drillDownCharMap.CLOSE = s; },
};

/**
 * Synonym of {@link JSON.prototype.reindex}.
 * @name applyAnalytics
 * @deprecated
 * @memberOf dataModels.JSON.prototype
 */
JSON.prototype.applyAnalytics = JSON.prototype.reindex; // eslint-disable-line no-extend-native

module.exports = JSON;

},{"../lib/DataSourceOrigin":94,"./DataModel":70,"overrider":37}],73:[function(require,module,exports){
'use strict';

var dataModels = {
    DataModel: require('./DataModel'),
    JSON: require('./JSON'),
    HeaderSubgrid: require('./HeaderSubgrid')
};

module.exports = dataModels;

},{"./DataModel":70,"./HeaderSubgrid":71,"./JSON":72}],74:[function(require,module,exports){
'use strict';

var graphics = require('./lib/graphics');

var warned = {};

/**
 * This module lists the properties that can be set on a {@link Hypergrid} along with their default values.
 * Edit this file to override the defaults.
 * @module defaults
 */

var defaults = {

    mixIn: require('overrider').mixIn,

    /**
     * The default message to display in front of the canvas when there are no grid rows.
     * Format is HTML.
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    noDataMessage: '',


    /**
     * The font for data cells.
     * @default
     * @type {cssFont}
     * @memberOf module:defaults
     */
    font: '13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for data cells.
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    color: 'rgb(25, 25, 25)',

    /**
     * Background color for data cells.
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    backgroundColor: 'rgb(241, 241, 241)',

    /**
     * Font style for selected cell(s).
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    foregroundSelectionFont: 'bold 13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for selected cell(s).
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    foregroundSelectionColor: 'rgb(0, 0, 128)',
    /**
     * Background color for selected cell(s).
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    backgroundSelectionColor: 'rgba(147, 185, 255, 0.625)',


    /********** SECTION: COLUMN HEADER COLORS **********/

    // IMPORTANT CAVEAT: The code is inconsistent regarding the terminology. Is the "column header" section _the row_ of cells at the top (that act as headers for each column) or is it _the column_ of cells (that act as headers for each row)? Oh my.

    /**
     * @default
     * @type {cssFont}
     * @memberOf module:defaults
     */
    columnHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    columnHeaderColor: 'rgb(25, 25, 25)',

    /**
     * Font style for selected columns' headers.
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    columnHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    columnHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    columnHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    columnHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    columnHeaderHalign: 'center',

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    columnHeaderRenderer: 'SimpleCell',


    /********** SECTION: ROW HEADER COLORS **********/

    /**
     * @default
     * @type {cssFont}
     * @memberOf module:defaults
     */
    rowHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    rowHeaderColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    rowHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    rowHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * Font style for selected rows' headers.
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    rowHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    rowHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',


    /********** SECTION: FILTER ROW COLORS **********/

    /**
     * @default
     * @type {cssFont}
     * @memberOf module:defaults
     */
    filterFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    filterColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    filterBackgroundColor: 'white',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    filterForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    filterBackgroundSelectionColor: 'rgb(255, 220, 97)',

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    filterHalign: 'center',

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    filterRenderer: 'SimpleCell',

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    backgroundColor2: 'rgb(201, 201, 201)',

    /**
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    voffset: 0,

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    scrollbarHoverOver: 'visible',

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    scrollbarHoverOff: 'hidden',

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    scrollingEnabled: true,

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    vScrollbarClassPrefix: '',

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    hScrollbarClassPrefix: '',

    /**
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    halign: 'center',

    /**
     * Padding to left and right of cell value.
     *
     * NOTE: Right padding may not be visible if column is not sized wide enough.
     *
     * See also {@link module:defaults.iconPadding|iconPadding}.
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    cellPadding: 5,

    /**
     * Padding to left and right of cell icons.
     *
     * Overrides {@link module:defaults.cellPadding|cellPadding}:
     * * Left icon + `iconPadding` overrides left {@link module:defaults.cellPddingg|cellPddingg}.
     * * Right icon + `iconPadding` overrides right {@link module:defaults.cellPddingg|cellPddingg}.
     * @see {@link module:defaults.leftIcon|leftIcon}
     * @see {@link module:defaults.centerIcon|centerIcon}
     * @see {@link module:defaults.rightIcon|rightIcon}
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    iconPadding: 3,

    /**
     * @summary Name of image to appear at right of cell.
     * Must be a key from {@link module:images|images}.
     * @desc Used by {@link SimpleCell} cell renderer.
     * @see {@link module:defaults.centerIcon|centerIcon}
     * @see {@link module:defaults.rightIcon|rightIcon}
     * @see {@link module:defaults.iconPadding|iconPadding}
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    leftIcon: undefined,

    /**
     * @summary Name of image to appear at right of cell.
     * Must be a key from {@link module:images|images}.
     * @desc Used by {@link SimpleCell} cell renderer.
     * @see {@link module:defaults.leftIcon|leftIcon}
     * @see {@link module:defaults.rightIcon|rightIcon}
     * @see {@link module:defaults.iconPadding|iconPadding}
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    centerIcon: undefined,

    /**
     * @summary Name of image to appear at right of cell.
     * Must be a key from {@link module:images|images}.
     * @desc Used by {@link SimpleCell} cell renderer.
     * @see {@link module:defaults.leftIcon|leftIcon}
     * @see {@link module:defaults.centerIcon|centerIcon}
     * @see {@link module:defaults.iconPadding|iconPadding}
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    rightIcon: undefined,

    /**
     * Set to `true` to render `0` and `false`. Otherwise these value appear as blank cells.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    renderFalsy: false,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    gridLinesH: true,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    gridLinesV: true,

    /**
     * Draw horizontal grid line before first rendered column.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    gridBorderLeft: false,

    /**
     * Draw horizontal grid line after last rendered column.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    gridBorderRight: false,

    /**
     * Draw horizontal grid line above first rendered row.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    gridBorderTop: false,

    /**
     * Draw horizontal grid line below last rendered row.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    gridBorderBottom: true,

    /**
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    lineColor: 'rgb(199, 199, 199)',

    /**
     * Caveat: `lineWidth` should be an integer (whole pixel)
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    lineWidth: 1,


    /**
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    defaultRowHeight: 15,

    /**
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    defaultColumnWidth: 100,

    /**
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    minimumColumnWidth: 5,

    //for immediate painting, set these values to 0, true respectively

    /**
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    repaintIntervalRate: 60,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    repaintImmediately: false,

    //enable or disable double buffering

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    useBitBlit: false,


    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    useHiDPI: true,

    /**
     * @summary Mappings for cell navigation keys.
     * @desc Cell navigation is handled in the {@link CellSelection} "feature". This property gives you control over which keypresses the built-in mechanism will respond to.
     *
     * (If this built-in cell selection logic is insufficient for your needs, you can also listen for the various "fin-key" events and carry out more complex operations in your listeners.)
     *
     * The keypress names used here are defined in Canvas.js. Note that all keypresses actually have two names, a normal name and a shifted name. The latter name is used when either **shift** is depressed.
     *
     * The built-in nav keypresses are as follows:
     * * **`UP`** _(up-arrow key)_ - Replace all selections with a single cell, one row up from the last selection.
     * * **`DOWN`** _(down-arrow key)_ - Replace all selections with a single cell, one row down from the last selection.
     * * **`LEFT`** _(left-arrow key)_ - Replace all selections with a single cell, one column to the left of the last selection.
     * * **`RIGHT`** _(right-arrow key)_ - Replace all selections with a single cell, one column to the right of the last selection.
     * * **`UPSHIFT`** _(shift + up-arrow)_ - Extend the last selection up one row.
     * * **`DOWNSHIFT`** _(shift + down-arrow)_ - Extend the last selection down one row.
     * * **`LEFTSHIFT`** _(shift + left-arrow)_ - Extend the last selection left one column.
     * * **`RIGHTSHIFT`** _(shift + right-arrow)_ - Extend the last selection right one column.
     *
     * To alter these or add other mappings see the examples below.
     *
     * A note regarding the other meta keys (**trl**, **option**, and **command**): Although these meta keys can be detected, they do not modify the key names as **shift** does. This is because they are more for system use and generally (with the possibly exception fo **ctrl**) should not be depended upon, as system functions will take priority and your app will never see these key presses.
     *
     * A special accommodation has been made to the {@link module:defaults.editOnKeydown|editOnKeydown} property:
     * * If `editOnKeydown` truthy AND mapped character is an actual (non-white-space) character (as opposed to say **tab** or **return**), then navigation requires **ctrl** key to distinguish between nav and data.
     * * If `editOnKeydown` falsy, the **ctrl** key is ignored.
     *
     * So in the last example, if `editOnKeydown` is ON, then `a` (without **ctrl**) would start editing the cell and **ctrl** + `a` would move the selection one column to the left.
     *
     * @example
     * // To void the above build-ins:
     * navKeyMap: {
     *     UP: undefined,
     *     UPSHIFT: undefined,
     *     DOWN: undefined,
     *     ...
     * }
     *
     * @example
     * // To map alternative nav keypresses to RETURN and TAB (default mapping):
     * navKeyMap: {
     *     RETURN: 'DOWN',
     *     RETURNSHIFT: 'UP',
     *     TAB: 'RIGHT',
     *     TABSHIFT: 'LEFT'
     * }
     *
     * @example
     * // To map alternative nav keypresses to a/w/d/s and extend select to A/W/D/S:
     * navKeyMap: {
     *     a: 'LEFT', A: 'LEFTSHIFT',
     *     w: 'UP', W: 'UPSHIFT',
     *     s: 'DOWN', S: 'DOWNSHIFT',
     *     d: 'RIGHT', D: 'RIGHTSHIFT'
     * }
     *
     * @default
     * @type {object|undefined}
     * @memberOf module:defaults
     */
    navKeyMap: {
        RETURN: 'DOWN',
        RETURNSHIFT: 'UP',
        TAB: 'RIGHT',
        TABSHIFT: 'LEFT'
    },

    /**
     * Returns any value of `keyChar` that passes the following logic test:
     * 1. If a non-printable, white-space character, then nav key.
     * 2. If not (i.e., a normal character), can still be a nav key if not editing on key down.
     * 3. If not, can still be a nav key if CTRL key is down.
     *
     * Note: Callers are typcially only interested in the following values of `keyChar` and will ignore all others:
     * * `'LEFT'` and `'LEFTSHIFT'`
     * * `'RIGHT'` and `'RIGHTSHIFT'`
     * * `'UP'` and `'UPSHIFT'`
     * * `'DOWN'` and `'DOWNSHIFT'`
     *
     * @param {string} keyChar - A value from Canvas's `charMap`.
     * @param {boolean} [ctrlKey=false] - The CTRL key was down.
     * @returns {undefined|string} `undefined` means not a nav key; otherwise returns `keyChar`.
     * @memberOf module:defaults
     */
    navKey: function(keyChar, ctrlKey) {
        var result;
        if (keyChar.length > 1 || !this.editOnKeydown || ctrlKey) {
            result = keyChar; // return the mapped value
        }
        return result;
    },

    /**
     * Returns only values of `keyChar` that, when run through {@link module:defaults.navKeyMap|navKeyMap}, pass the {@link module:defaults.navKey|navKey} logic test.
     *
     * @param {string} keyChar - A value from Canvas's `charMap`, to be remapped through {@link module:defaults.navKeyMap|navKeyMap}.
     * @param {boolean} [ctrlKey=false] - The CTRL key was down.
     * @returns {undefined|string} `undefined` means not a nav key; otherwise returns `keyChar`.
     * @memberOf module:defaults
     */
    mappedNavKey: function(keyChar, ctrlKey) {
        keyChar = this.navKeyMap[keyChar];
        return keyChar && this.navKey(keyChar);
    },

    /** @summary Validation failure feedback.
     * @desc Validation occurs on {@link CellEditor#stopEditing}, normally called on commit (`TAB`, `ENTER`, or any other keys listed in `navKeyMap`).
     *
     * On successful validation, the value is saved back to the data source and the editor is closed.
     *
     * On validation failure, feedback is shown to the user in the form of an "error effect" possibly followed by an "end effect" containing a detailed explanation.
     *
     * The error effect to use is named in `feedbackEffect
     *
     * The value of this property is the number of times to show the "error effect" on validation failure before showing the detailed explanation.
     *
     * `feedback` may be set to one of:
     * * **`undefined`** - Do not show the error effect or the alert. Just discard the value and close the editor (as if `ESC` had been typed).
     * * **`0`** - Just shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
     * * **`1`** - Shows the error feedback effect followed by the detailed explanation.
     * * `2` or more:
     *   1. Shows the error feedback effect
     *   2. On every `feedback` tries, shows the detailed explanation.
     * @default
     * @type {number|undefined}
     * @memberOf module:defaults
     */
    feedbackCount: 3,

    /**
     * @default
     * @type {{name:string,options:object}|string}
     * @memberOf module:defaults
     */
    feedbackEffect: 'shaker',

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    readOnly: false,

    // inherited by cell renderers

    /**
     * This function is referenced here so it will be available to the renderer and cell renderers.
     * @default {@link module:defaults.getTextWidth|getTextWidth}
     * @type {function}
     * @memberOf module:defaults
     */
    getTextWidth: function(gc, string) {
        if (!warned.getTextWidth) {
            warned.getTextWidth = true;
            console.warn('getTextWidth(gc, string) has been deprecated on the properties (or config) object as of v1.2.4 in favor of the graphics context (aka gc) object and will be removed from the properties object in a future release. Please change your calling context to gc.getTextWidth(string), excluding the first parameter (gc) from your call.');
        }
        return graphics.getTextWidth.apply(gc, string);
    },

    /**
     * This function is referenced here so it will be available to the renderer and cell renderers.
     * @default {@link module:defaults.getTextHeight|getTextHeight}
     * @type {function}
     * @memberOf module:defaults
     */
    getTextHeight: function(font) {
        if (!warned.getTextHeight) {
            warned.getTextHeight = true;
            console.warn('getTextHeight(font) has been deprecated on the properties (or config) object as of v1.2.4 in favor of the graphics context (aka gc) object and will be removed from the properties object in a future release. Please change your calling context to gc.getTextHeight(font).');
        }
        return graphics.getTextHeight(font);
    },

    get x() {
        if (!warned.x) {
            warned.x = true;
            console.warn('config.x has been deprecated as of v1.2.10 in favor of config.dataCell.x. (Will be removed in a future release.)');
        }
        return this.dataCell.x;
    },

    get untranslatedX() {
        if (!warned.untranslatedX) {
            warned.untranslatedX = true;
            console.warn('config.untranslatedX has been deprecated as of v1.2.10 in favor of config.gridCell.x. (Will be removed in a future release.)');
        }
        return this.gridCell.x;
    },

    get y() {
        if (!warned.y) {
            warned.y = true;
            console.warn('config.y has been deprecated as of v1.2.10 in favor of config.gridCell.y. (Will be removed in a future release.)');
        }
        return this.gridCell.y;
    },

    get normalizedY() {
        if (!warned.normalizedY) {
            warned.normalizedY = true;
            console.warn('config.normalizedY has been deprecated as of v1.2.10 in favor of config.dataCell.y. (Will be removed in a future release.)');
        }
        return this.dataCell.y;
    },

    /**
     * This function is referenced here so it will be available to the cell renderers.
     * @default {@link module:defaults.exec|exec}
     * @type {function}
     * @memberOf module:defaults
     */
    exec: exec,

    /**
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    fixedColumnCount: 0,

    /**
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    fixedRowCount: 0,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    showRowNumbers: true,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    showTreeColumn: true,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    showHeaderRow: true,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    showFilterRow: false,


    /** Clicking in a cell "selects" it; it is added to the select region and repainted with "cell selection" colors.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    cellSelection: true,

    /** Clicking in a column header (top row) "selects" the column; the entire column is added to the select region and repainted with "column selection" colors.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    columnSelection: true,

    /** Clicking in a row header (leftmost column) "selects" the row; the entire row is added to the select region and repainted with "row selection" colors.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    rowSelection: true,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    singleRowSelectionMode: true,

    /**
     * @summary Fill color for last selection overlay.
     * @desc The color should be translucent (or transparent). Note that "Partial" grid renderers (such as the {@link paintCellsAsNeeded} renderer) do not draw overlay because it just gets darker and darker for non-updated cells.
     * @default
     * @type {cssColor}
     * @memberOf module:defaults
     */
    selectionRegionOverlayColor: 'transparent', // 'rgba(0, 0, 48, 0.2)',

    /**
     * @summary Stroke color for last selection overlay.
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    selectionRegionOutlineColor: 'rgb(69, 69, 69)',

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    columnAutosizing: true,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    rowNumberAutosizing: true,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    headerTextWrapping: false,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    rowResize: false,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    editable: true,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    filterable: true,

    /**
     * This is used only by FilterBox cell editor.
     * One of:
     * * **`'onCommit'`** - Column filter state not set until keyup === `\r` (return/enter key)
     * * **`'immediate'`** - Column filter state set on each key press
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    filteringMode: 'onCommit',

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    editOnDoubleClick: true,

    /**
     * @default
     * @type {number}
     * @memberOf module:defaults
     */
    doubleClickDelay: 325,

    /**
     * Grid-level property.
     * When user presses a "printable" keyboard character _or_ BACKSPACE _or_ DELETE:
     * 1. Activate cell editor on current cell (i.e., origin of most recent selection).
     * 2. If cell editor is a text editor:
     *    1. Replace current value with the character the user typed; or
     *    2. Clear it on BACKSPACE, DELETE, or other invalid character (_e.g._ when user types a letter but the cell editor only accepts digits).
     *
     * > In invoked, user has the option to back out by pressing the ESCAPE key.
     *
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    editOnKeydown: true,

    /**
     * @summary Open cell editor when cell selected via keyboard navigation.
     * @desc Keyboard navigation always includes:
     * 1. The four arrow keys -- but only when there is no active text cell editor open
     * 2. Additional keys mapped to the four directs in {@link module:defaults.navKeyMap}
     *
     * Generally set at the grid level. If set at the column (or cell) level, note that the property pertains to the cell navigated _to,_ not the cell navigated _away from._
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    editOnNextCell: false,

    /**
     * @summary Retain row selections.
     * @desc When falsy, row selections are cleared when selecting cells; when truthy, row selections are kept as is when selecting cells.
     * @todo Deprecate in favor of something simpler like `keepRowSelections`. (The current name is misleading and has caused some confusion among both developers and users. At the very least it should have been called `checkboxOnlyRowDeselections`.)
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    checkboxOnlyRowSelections: false,

    /**
     * @summary Select cell's entire row.
     * @desc When truthy, selecting a cell will also select the entire row it is in, subject to note #1 below.
     *
     * Notes:
     * 1. Ineffectual unless `checkboxOnlyRowSelections` is set to `false`.
     * 2. To allow auto-selection of _multiple rows,_ set `singleRowSelectionMode` to `false`.
     *
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    autoSelectRows: false,

    /**
     * @summary Select cell's entire column.
     * @desc When truthy, selecting a cell will also select the entire column it is in.
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    autoSelectColumns: false,

    /** @summary Name of a formatter for cell text.
     * @desc The default (`undefined`) falls back to `column.type`.
     * The value `null` does no formatting.
     * @default undefined
     * @type {undefined|null|string}
     * @memberOf module:defaults
     * @tutorial localization
     */
    format: undefined,

    /** @summary Name of a cell editor from the {@link module:cellEditors|cellEditors API}..
     * @desc Not editable if named editor is does not exist.
     * @default undefined
     * @type {undefined|null|string}
     * @memberOf module:defaults
     * @tutorial cell-editors
     */
    editor: undefined,

    /**
     * Name of cell renderer from the {@link module:cellRenderers|cellRenderers API}.
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    renderer: 'SimpleCell',

    /**
     * Name of grid renderer.
     * Renderer must have been registered.
     * @see {@link Renderer#registerGridRenderer}.
     * @default
     * @type {string}
     * @memberOf module:defaults
     */
    gridRenderer: 'by-columns-and-rows',

    /********** HOVER COLORS **********/

    /** @typedef hoverColors
     * @property {boolean} [enable=false] - `false` means not hilite on hover
     * @property {cssColor} backgroundColor - cell, row, or column background color. Alpha channel will be respected and if given will be painted over the cells predetermined color.
     * @property {cssColor} [header.backgroundColor=backgroundColor] - for columns and rows, this is the background color of the column or row "handle" (header rows or columns, respectively). (Not used for cells.)
     */

    /** On mouse hover, whether to repaint the cell background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(160, 160, 40, 0.30) }'
     * @memberOf module:defaults
     */
    hoverCellHighlight: {
        enabled: true,
        backgroundColor: 'rgba(160, 160, 40, 0.45)'
    },

    /** On mouse hover, whether to repaint the row background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(100, 100, 25, 0.15) }'
     * @memberOf module:defaults
     */
    hoverRowHighlight: {
        enabled: true,
        backgroundColor: 'rgba(100, 100, 25, 0.30)'

    },

    /** On mouse hover, whether to repaint the column background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(60, 60, 15, 0.15) }'
     * @memberOf module:defaults
     */
    hoverColumnHighlight: {
        enabled: true,
        backgroundColor: 'rgba(60, 60, 15, 0.15)'
    },

    /** @summary Display cell value as a link (with underline).
     * @desc One of:
     * * `boolean` - No action occurs on click; you would need to attach a 'fin-click' listener to the hypergrid object.
     *   * `true` - Displays the cell as a link.
     *   * _falsy_ - Displays the cell normally.
     * * `string` -  The URL is decorated (see {}) and then opened in a separate window/tab. See also {@link module:defaults.linkTarget|linkTarget}.
     *   * `'*'` - Use the cell value as the URL, ready for decorating (see {CellClick#openLink|openLink)).
     *   * _field name_ - Fetches the string from the named field in the same row, assumed to be a URL ready for decorating. (May contain only alphanumerics and underscore; no spaces or other punctuation.)
     *   * _otherwise_ Assumed to contains a URL ready for decorating.
     * * `function` - A function to execute to get the URL ready for decorating. The function is passed a single parameter, `cellEvent`, from which you can get the field `name`, `dataRow`, _etc._
     * * `Array` - An array to "apply" to {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/open window.open} in its entirety. The first element is interpreted as above for `string` or `function`.
     *
     * In the case of `string` or `Array`, the link is further unpacked by {@link module:CellClick.openLink|openLink} and then sent to `grid.windowOpen`.
     *
     * @example
     * // following affect upper-left data cell:
     * grid.behavior.setCellProperty(0, 0, 'https://nytimes.com'); // absolute address using specific protocol
     * grid.behavior.setCellProperty(0, 0, '//nytimes.com'); // absolute address using current protocol
     * grid.behavior.setCellProperty(0, 0, '/page2.com'); // relative to current site
     * grid.behavior.setCellProperty(0, 0, 'mypage.com'); // relative to current page
     * grid.behavior.setCellProperty(0, 0, 'mypage.com?id=%value'); // cell's value will replace %value
     * grid.behavior.setCellProperty(0, 0, ['//www.newyorker.com', 'ny', undefined, true]) // target='ny', replace=true
     * @type {boolean|string|Array}
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    link: false,

    /** @summary The window (or tab) in which to open the link.
     * @desc The default ('_blank'`) will open a new window for every click.
     *
     * To have the first click open a new window and all subsequent clicks reuse that same window, set this to an arbitrary string.
     *
     * Otherwise, specific columns or cells can be set to open their links in their own window by setting the appropriate column's or cell's `linkTarget` property.
     * @default
     * @memberOf module:defaults
     */
    linkTarget: '_blank',

    /** @summary Underline link on hover only.
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    linkOnHover: false,

    /** @summary Color for link.
     * @desc Falsy means defer to foreground color.
     * @type {string}
     * @default
     * @memberOf module:defaults
     */
    linkColor: 'blue',

    /** @summary Color for visited link.
     * @desc Falsy means defer to foreground color.
     * @type {string}
     * @default
     * @memberOf module:defaults
     */
    linkVisitedColor: 'purple',

    /** @summary Color link on hover only.
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    linkColorOnHover: false,

    /** Display cell font with strike-through line drawn over it.
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    strikeThrough: false,

    /** Ignore sort interaction (double-click).
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    unsortable: false,

    /**
     * @default
     * @type {boolean}
     * @memberOf module:defaults
     */
    sortOnHiddenColumns: true,

    /** Allow multiple cell region selections.
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    multipleSelections: false,

    /** @summary Re-render grid at maximum speed.
     * @desc In this mode:
     * * The "dirty" flag, set by calling `grid.repaint()`, is ignored.
     * * `grid.getCanvas().currentFPS` is a measure of the number times the grid is being re-rendered each second.
     * * The Hypergrid renderer gobbles up CPU time even when the grid appears idle (the very scenario `repaint()` is designed to avoid). For this reason, we emphatically advise against shipping applications using this mode.
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    enableContinuousRepaint: false,

    /** @summary Allow user to move columns .
     * @desc Columns can be reordered through either of two interfaces:
     * * Column Dragging feature
     * * behavior.columns API
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    columnsReorderable: true,

    /** @summary Apply cell properties before `getCell`.
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    applyCellProperties: true,

    /** @summary Reapply cell properties after `getCell`.
     * @type {boolean}
     * @default
     * @memberOf module:defaults
     */
    reapplyCellProperties: false,

    /** @summary Column grab within this number of pixels from top of cell.
     * @type {number}
     * @default
     * @memberOf module:defaults
     */
    columnGrabMargin: 5,

    /** @summary Set up a clipping region around each column before painting cells.
     * @desc One of:
     * * `true` - Clip column.
     * * `false` - Do not clip column.
     * * `null` - Clip iff last active column.
     *
     * Clipping prevents text that overflows to the right of the cell from being rendered.
     * If you can guarantee that none of your text will overflow, turn column clipping off
     * for better performance. If not, you may still be able to get away without clipping.
     * If the background color of the next column is opaque, you don't really need to clip,
     * although text can leak out to the right of the last column. Clipping the last column
     * only can help this but not solve it since the leaked text from (say) the column before
     * the last column could stretch across the entire last column and leak out anyway.
     * The solution to this is to clip the rendered string so at most only a partial character
     * will overflow.
     * @type {boolean|undefined}
     * @default
     * @memberOf module:defaults
     */
    columnClip: true,

    /**
     * @summary Repeating pattern of property overrides for grid rows.
     * @desc Notes:
     * * "Grid row" refers to data rows.
     * * Row index modulo is applied when dereferencing this array. In other words, this array represents a _repeating pattern_ of properties to be applied to the data rows.
     * * For no row properties, specify a falsy value in place of the array.
     * * Do not specify an empty array (will throw an error).
     * * Each element of the array may be either:
     *   * An object containing property overrides to be applied to every cell of the row; or
     *   * A falsy value signifying that there are no row properties for this specific row.
     * * Caveat: Row properties use `Object.assign()` to copy properties and therefore are not as performant as column properties which use prototype chain.
     * * `Object.assign()` is a polyfill in older versions of Chrome (<45) and in all Internet Explorer (through 11).
     * @type {undefined|object[]}
     * @default
     * @memberOf module:defaults
     */
    rowProperties: undefined,

    /** @summary How to truncate text.
     * @desc A "quaternary" value, one of:
     * * `undefined` - Text is not truncated.
     * * `true` (default) - Truncate sufficient characters to fit ellipsis if possible. Most acceptable option that avoids need for clipping.
     * * `false` - Truncate *before* last partially visible character. Visibly annoying; semantically jarring.
     * * `null` - Truncate *after* partially visible character. Less visibly annoying; still semantically confusing. Best solution when combined with either column clipping or painting over with next column's background.
     * @type {boolean|null|undefined}
     * @default
     * @memberOf module:defaults
     */
    truncateTextWithEllipsis: true
};

/** @typedef {string} cssColor
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 */
/** @typedef {string} cssFont
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font
 */

function exec(vf) {
    if (this.dataRow) {
        var calculator = (typeof vf)[0] === 'f' && vf || this.calculator;
        if (calculator) {
            vf = calculator(this.dataRow, this.name);
        }
    }
    return vf;
}

module.exports = defaults;

},{"./lib/graphics":104,"overrider":37}],75:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/* NOTE
 *
 * What this file is:
 * * This file is browserify's entry point.
 * * This file creates the `window.fin.Hypergrid` object.
 *
 * What this file is not:
 * * This file is not a node module; it has no reference to `module.exports` or `exports`; it cannot be "required" by any other file.
 * * This file is blacklisted in .npmignore and is not published to npm.
 *
 * Note: The npm "main" entry point is undefined in package.json implying /index.js.
 */

var Hypergrid = require('./Hypergrid');

Hypergrid.analytics = require('hyper-analytics'); // npm
// Hypergrid.analytics = require('../../hyper-analytics'); // developer

// Expose some namespaces to users of the hypergrid.js file through `fin.Hypergrid`:
Hypergrid.images = require('../images');
Hypergrid.behaviors = require('./behaviors');
Hypergrid.dataModels = require('./dataModels');
Hypergrid.features = require('./features');
Hypergrid.rectangular = require('rectangular');
Hypergrid.lib = require('./lib');
Hypergrid.stylesheet = require('./lib/stylesheet');
Hypergrid.base = require('./Base');

// Create the `fin` namespace and the `fin.Hypergrid` objects:
(window.fin = window.fin || {}).Hypergrid = Hypergrid;

// Note users of the npm module do not have this object.
// THey have access to any namespace through `require`, for example:
// var behaviorJSON = require('fin-hypergrid/src/behaviors/JSON');

},{"../images":3,"./Base":41,"./Hypergrid":42,"./behaviors":48,"./dataModels":73,"./features":89,"./lib":105,"./lib/stylesheet":108,"hyper-analytics":9,"rectangular":39}],76:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var CellClick = Feature.extend('CellClick', {

    handleMouseMove: function(grid, event) {
        var link = event.properties.link,
            isActionableLink = link && typeof link !== 'boolean'; // actionable with truthy other than `true`

        this.cursor = isActionableLink ? 'pointer' : null;

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @param {CellEvent} event - the event details
     * @memberOf CellClick#
     */
    handleClick: function(grid, event) {
        var consumed = event.isDataCell && (
            this.openLink(grid, event) !== undefined ||
            grid.cellClicked(event)
        );

        if (!consumed && this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @summary Open the cell's URL.
     *
     * @desc The URL is found in the cell's {@link module:defaults.link|link} property, which serves two functions:
     * 1. **Renders as a link.** When truthy causes {@link SimpleCell} cell renderer to render the cell underlined with {@link module:defaults.linkColor|linkColor}. (See also {@link module:defaults.linkOnHover|linkOnHover} and {@link module:defaults.linkColorOnHover|linkColorOnHover}.) Therefore, setting this property to `true` will render as a link, although clicking on it will have no effect. This is useful if you wish to handle the click yourself by attaching a `'fin-click'` listener to your hypergrid.
     * 2. **Fetch the URL.** The value of the link property is interpreted as per {@link module:defaults.link|link}.
     * 3. **Decorate the URL.** The cell name (_i.e.,_ the data column name) and cell value are merged into the URL wherever the respective substrings `'%name'` and `'%value'` are found. For example, if the column name is "age" and the cell value is 6 (or a function returning 25), and the link is `'http://www.abc.com?%name=%value'`, then the actual link (first argument given to `grid.windowOpen`) would be `'http://www.abc.com?age=25'`.
     * 4. **Open the URL.** The link is then opened by {@link Hypergrid#windowOpen|grid.windowOpen}. If `link` is an array, it is "applied" to `grid.windowOpen` in its entirety; otherwise, `grid.windowOpen` is called with the link as the first argument and {@link module:defaults.linkTarget|linkTarget} as the second.
     * 5. **Decorate the link.** On successful return from `windowOpen()`, the text is colored as "visited" as per the cell's {@link module:defaults.linkVisitedColor|linkVisitedColor} property (by setting the cell's `linkColor` property to its `linkVisitedColor` property).

     * @param {Hypergrid} grid
     * @param {CellEvent} cellEvent - Event details.
     *
     * @returns {boolean|window|null|undefined} One of:
     *
     * | Value | Meaning |
     * | :---- | :------ |
     * | `undefined` | no link to open |
     * | `null` | `grid.windowOpen` failed to open a window |
     * | _otherwise_ | A `window` reference returned by a successful call to `grid.windowOpen`. |
     *
     * @memberOf CellClick#
     */
    openLink: function(grid, cellEvent) {
        var result, url,
            dataRow = cellEvent.dataRow,
            config = Object.create(cellEvent.properties, { dataRow: { value: dataRow } }),
            value = config.exec(cellEvent.value),
            linkProp = cellEvent.properties.link,
            isArray = linkProp instanceof Array,
            link = isArray ? linkProp[0] : linkProp;

        // STEP 2: Fetch the URL
        switch (typeof link) {
            case 'string':
                if (link === '*') {
                    url = value;
                } else if (/^\w+$/.test(link)) {
                    url = dataRow[link];
                }
                break;

            case 'function':
                url = link(cellEvent);
                break;
        }

        if (url) {
            // STEP 3: Decorate the URL
            url = url.toString().replace(/%name/g, config.name).replace(/%value/g, value);

            // STEP 4: Open the URL
            if (isArray) {
                linkProp = linkProp.slice();
                linkProp[0] = url;
                result = grid.windowOpen.apply(grid, linkProp);
            } else {
                result = grid.windowOpen(url, cellEvent.properties.linkTarget);
            }
        }

        // STEP 5: Decorate the link as "visited"
        if (result) {
            cellEvent.setCellProperty('linkColor', grid.properties.linkVisitedColor);
            grid.renderer.resetCellPropertiesCache(cellEvent);
            grid.repaint();
        }

        return result;
    }

});

module.exports = CellClick;

},{"./Feature":83}],77:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');
var CellEditor = require('../cellEditors/CellEditor');

/**
 * @constructor
 * @extends Feature
 */
var CellEditing = Feature.extend('CellEditing', {

    /**
     * @memberOf CellEditing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        if (
            grid.properties.editOnDoubleClick &&
            event.isDataCell
        ) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function(grid, event) {
        if (
            !grid.properties.editOnDoubleClick &&
            event.isDataCell
        ) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var char, isVisibleChar, isDeleteChar, editor, cellEvent;

        if (
            (cellEvent = grid.getGridCellFromLastSelection()) &&
            cellEvent.properties.editOnKeydown &&
            !grid.cellEditor &&
            (
                (char = event.detail.char) === 'F2' ||
                (isVisibleChar = char.length === 1 && !(event.detail.meta || event.detail.ctrl)) ||
                (isDeleteChar = char === 'DELETE' || char === 'BACKSPACE')
            )
        ) {
            editor = grid.onEditorActivate(cellEvent);

            if (editor instanceof CellEditor) {
                if (isVisibleChar) {
                    editor.input.value = char;
                } else if (isDeleteChar) {
                    editor.setEditorValue('');
                }
                event.detail.primitiveEvent.preventDefault();
            }
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = CellEditing;

},{"../cellEditors/CellEditor":50,"./Feature":83}],78:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var CellSelection = Feature.extend('CellSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @memberOf CellSelection.prototype
     */
    currentDrag: null,

    /**
     * the cell coordinates of the where the mouse pointer is during a drag operation
     * @type {Object}
     * @memberOf CellSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var dx = event.gridCell.x,
            dy = event.dataCell.y,
            isSelectable = grid.behavior.getCellProperty(event.dataCell.x, event.gridCell.y, 'cellSelection');

        if (isSelectable && event.isDataCell && !event.primitiveEvent.detail.isRightClick) {
            var dCell = grid.newPoint(dx, dy),
                primEvent = event.primitiveEvent,
                keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragging && grid.properties.cellSelection && !event.primitiveEvent.detail.isRightClick) {
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.lastDragCell = grid.newPoint(event.gridCell.x, event.dataCell.y);
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragCell, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var detail = event.detail,
            cellEvent = grid.getGridCellFromLastSelection(),
            navKey = cellEvent && (
                cellEvent.properties.mappedNavKey(detail.char, detail.ctrl) ||
                cellEvent.properties.navKey(detail.char, detail.ctrl)
            ),
            handler = this['handle' + navKey];

        // STEP 1: Move the selection
        if (handler) {
            handler.call(this, grid, detail);

            // STEP 2: Open the cell editor at the new position if it has `editOnNextCell` and is `editable`
            cellEvent = grid.getGridCellFromLastSelection(); // new cell
            if (cellEvent.properties.editOnNextCell) {
                grid.editAt(cellEvent); // succeeds only if `editable`
            }

            // STEP 3: If editor not opened on new cell, take focus
            if (!grid.cellEditor) {
                grid.takeFocus();
            }
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle a mousedrag selection.
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {
        var x = Math.max(0, gridCell.x),
            y = Math.max(0, gridCell.y),
            previousDragExtent = grid.getDragExtent(),
            mouseDown = grid.getMouseDown(),
            newX = x - mouseDown.x,
            newY = y - mouseDown.y;

        if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
            return;
        }

        grid.clearMostRecentSelection();

        grid.select(mouseDown.x, mouseDown.y, newX, newY);
        grid.setDragExtent(grid.newPoint(newX, newY));

        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.properties.scrollingEnabled) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var dragStartedInHeaderArea = grid.isMouseDownInHeaderArea(),
            lastDragCell = this.lastDragCell,
            b = grid.getDataBounds(),

            xOffset = 0,
            yOffset = 0,

            numFixedColumns = grid.getFixedColumnCount(),
            numFixedRows = grid.getFixedRowCount(),

            dragEndInFixedAreaX = lastDragCell.x < numFixedColumns,
            dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (!dragStartedInHeaderArea) {
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
        }
        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }
        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }
        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        var hasCTRL = keys.indexOf('CTRL') >= 0,
            hasSHIFT = keys.indexOf('SHIFT') >= 0,
            mousePoint = grid.getMouseDown(),
            x = gridCell.x, // - numFixedColumns + scrollLeft;
            y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        if (
            hasCTRL &&
            x === mousePoint.x &&
            y === mousePoint.y
        ) {
            grid.clearMostRecentSelection();
            grid.popMouseDown();
            grid.repaint();
            return;
        }

        if (!hasCTRL && !hasSHIFT) {
            grid.clearSelections();
        }

        if (hasSHIFT) {
            grid.clearMostRecentSelection();
            grid.select(mousePoint.x, mousePoint.y, x - mousePoint.x, y - mousePoint.y);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x, y - mousePoint.y));
        } else {
            grid.select(x, y, 0, 0);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, 1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, -1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        grid.moveSingleSelect(0, count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        grid.moveSingleSelect(0, -count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        grid.moveSingleSelect(-1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        grid.moveSingleSelect(1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX, offsetY) {
        if (grid.extendSelect(offsetX, offsetY)) {
            this.pingAutoScroll();
        }
    }

});

module.exports = CellSelection;

},{"./Feature":83}],79:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

// This feature is responsible for column drag and drop reordering.
// This object is a mess and desperately needs a complete rewrite.....

var Feature = require('./Feature');

var canDragCursorName = '-webkit-grab',
    draggingCursorName = '-webkit-grabbing';

var columnAnimationTime = 150;
var dragger;
var draggerCTX;
var floatColumn;
var floatColumnCTX;

/**
 * @constructor
 * @extends Feature
 */
var ColumnMoving = Feature.extend('ColumnMoving', {

    /**
     * queue up the animations that need to play so they are done synchronously
     * @type {Array}
     * @memberOf CellMoving.prototype
     */
    floaterAnimationQueue: [],

    /**
     * am I currently auto scrolling right
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingRight: false,

    /**
     * am I currently auto scrolling left
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingLeft: false,

    /**
     * is the drag mechanism currently enabled ("armed")
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragArmed: false,

    /**
     * am I dragging right now
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragging: false,

    /**
     * the column index of the currently dragged column
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragCol: -1,

    /**
     * an offset to position the dragged item from the cursor
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragOffset: 0,

    /**
     * @memberOf CellMoving.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.isFloatingNow = false;
        this.initializeAnimationSupport(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function(grid) {
        if (!dragger) {
            dragger = document.createElement('canvas');
            dragger.setAttribute('width', '0px');
            dragger.setAttribute('height', '0px');
            dragger.style.position = 'fixed';

            document.body.appendChild(dragger);
            draggerCTX = dragger.getContext('2d');
        }
        if (!floatColumn) {
            floatColumn = document.createElement('canvas');
            floatColumn.setAttribute('width', '0px');
            floatColumn.setAttribute('height', '0px');
            floatColumn.style.position = 'fixed';

            document.body.appendChild(floatColumn);
            floatColumnCTX = floatColumn.getContext('2d');
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        var gridCell = event.gridCell;
        var x;
        //var y;

        var distance = Math.abs(event.primitiveEvent.detail.dragstart.x - event.primitiveEvent.detail.mouse.x);

        if (distance < 10 || event.isColumnFixed) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
            return;
        }

        if (event.isHeaderCell && this.dragArmed && !this.dragging) {
            this.dragging = true;
            this.dragCol = gridCell.x;
            this.dragOffset = event.mousePoint.x;
            this.detachChain();
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.createDragColumn(grid, x, this.dragCol);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }

        if (this.dragging) {
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.dragColumn(grid, x);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (
            grid.behavior.isColumnReorderable() &&
            !event.isColumnFixed
        ) {
            if (event.isHeaderCell) {
                this.dragArmed = true;
                this.cursor = draggingCursorName;
                grid.clearSelections();
            }
        }
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        //var col = event.gridCell.x;
        if (this.dragging) {
            this.cursor = null;
            //delay here to give other events a chance to be dropped
            var self = this;
            this.endDragColumn(grid);
            setTimeout(function() {
                self.attachChain();
            }, 200);
        }
        this.dragCol = -1;
        this.dragging = false;
        this.dragArmed = false;
        this.cursor = null;
        grid.repaint();

        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (
            grid.behavior.isColumnReorderable() &&
            !event.isColumnFixed &&
            !this.dragging &&
            event.isHeaderCell &&
            event.mousePoint.y < grid.properties.columnGrabMargin
        ) {
            this.cursor = canDragCursorName;
        } else {
            this.cursor = null;
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }

        if (event.isHeaderCell && this.dragging) {
            this.cursor = draggingCursorName; //move';
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this is the main event handler that manages the dragging of the column
     * @param {Hypergrid} grid
     * @param {boolean} draggedToTheRight - are we moving to the right
     */
    floatColumnTo: function(grid, draggedToTheRight) {
        this.floatingNow = true;

        var visibleColumns = grid.renderer.visibleColumns;
        var scrollLeft = grid.getHScrollValue();
        var floaterIndex = grid.renderOverridesCache.floater.columnIndex;
        var draggerIndex = grid.renderOverridesCache.dragger.columnIndex;
        var hdpiratio = grid.renderOverridesCache.dragger.hdpiratio;

        var draggerStartX;
        var floaterStartX;
        var fixedColumnCount = grid.getFixedColumnCount();
        var draggerWidth = grid.getColumnWidth(draggerIndex);
        var floaterWidth = grid.getColumnWidth(floaterIndex);

        var max = grid.getVisibleColumnsCount();

        var doffset = 0;
        var foffset = 0;

        if (draggerIndex >= fixedColumnCount) {
            doffset = scrollLeft;
        }
        if (floaterIndex >= fixedColumnCount) {
            foffset = scrollLeft;
        }

        if (draggedToTheRight) {
            draggerStartX = visibleColumns[Math.min(max, draggerIndex - doffset)].left;
            floaterStartX = visibleColumns[Math.min(max, floaterIndex - foffset)].left;

            grid.renderOverridesCache.dragger.startX = (draggerStartX + floaterWidth) * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;

        } else {
            floaterStartX = visibleColumns[Math.min(max, floaterIndex - foffset)].left;
            draggerStartX = floaterStartX + draggerWidth;

            grid.renderOverridesCache.dragger.startX = floaterStartX * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;
        }
        grid.swapColumns(draggerIndex, floaterIndex);
        grid.renderOverridesCache.dragger.columnIndex = floaterIndex;
        grid.renderOverridesCache.floater.columnIndex = draggerIndex;


        this.floaterAnimationQueue.unshift(this.doColumnMoveAnimation(grid, floaterStartX, draggerStartX));

        this.doFloaterAnimation(grid);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the column drag and drop animation
     * @param {Hypergrid} grid
     * @param {number} floaterStartX - the x start coordinate of the column underneath that floats behind the dragged column
     * @param {number} draggerStartX - the x start coordinate of the dragged column
     */
    doColumnMoveAnimation: function(grid, floaterStartX, draggerStartX) {
        var self = this;
        return function() {
            var d = floatColumn;
            d.style.display = 'inline';
            self.setCrossBrowserProperty(d, 'transform', 'translate(' + floaterStartX + 'px, ' + 0 + 'px)');

            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';
            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';

            requestAnimationFrame(function() {
                self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease');
                self.setCrossBrowserProperty(d, 'transform', 'translate(' + draggerStartX + 'px, ' + -2 + 'px)');
            });
            grid.repaint();
            //need to change this to key frames

            setTimeout(function() {
                self.setCrossBrowserProperty(d, 'transition', '');
                grid.renderOverridesCache.floater = null;
                grid.repaint();
                self.doFloaterAnimation(grid);
                requestAnimationFrame(function() {
                    d.style.display = 'none';
                    self.isFloatingNow = false;
                });
            }, columnAnimationTime + 50);
        };
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the floater animation
     * @param {Hypergrid} grid
     */
    doFloaterAnimation: function(grid) {
        if (this.floaterAnimationQueue.length === 0) {
            this.floatingNow = false;
            grid.repaint();
            return;
        }
        var animation = this.floaterAnimationQueue.pop();
        animation();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the float column at columnIndex underneath the dragged column
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createFloatColumn: function(grid, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = floatColumn;
        var style = d.style;
        var location = grid.div.getBoundingClientRect();

        style.top = (location.top - 2) + 'px';
        style.left = location.left + 'px';

        var hdpiRatio = grid.getHiDPI(floatColumnCTX);

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');
        style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';
        style.borderTop = '1px solid ' + grid.properties.lineColor;
        style.backgroundColor = grid.properties.backgroundColor;

        var startX = grid.renderer.visibleColumns[columnIndex - scrollLeft].left * hdpiRatio;

        floatColumnCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.floater = {
            columnIndex: columnIndex,
            ctx: floatColumnCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        style.zIndex = '4';
        this.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -2 + 'px)');
        style.cursor = draggingCursorName;
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting properties on HTMLElements
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setProp: function(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the dragged column at columnIndex above the floated column
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createDragColumn: function(grid, x, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = dragger;
        var location = grid.div.getBoundingClientRect();
        var style = d.style;

        style.top = location.top + 'px';
        style.left = location.left + 'px';
        style.opacity = 0.85;
        style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        //style.zIndex = 100;
        style.borderTop = '1px solid ' + grid.properties.lineColor;
        style.backgroundColor = grid.properties.backgroundColor;

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');

        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';

        var startX = grid.renderer.visibleColumns[columnIndex - scrollLeft].left * hdpiRatio;

        draggerCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.dragger = {
            columnIndex: columnIndex,
            startIndex: columnIndex,
            ctx: draggerCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, -5px)');
        style.zIndex = '5';
        style.cursor = draggingCursorName;
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this function is the main dragging logic
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    dragColumn: function(grid, x) {

        //TODO: this function is overly complex, refactor this in to something more reasonable
        var self = this;

        var autoScrollingNow = this.columnDragAutoScrollingRight || this.columnDragAutoScrollingLeft;

        var hdpiRatio = grid.getHiDPI(draggerCTX);

        var dragColumnIndex = grid.renderOverridesCache.dragger.columnIndex;

        var minX = 0;
        var maxX = grid.renderer.getFinalVisibleColumnBoundary();
        x = Math.min(x, maxX + 15);
        x = Math.max(minX - 15, x);

        //am I at my lower bound
        var atMin = x < minX && dragColumnIndex !== 0;

        //am I at my upper bound
        var atMax = x > maxX;

        var d = dragger;

        this.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + 0 + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, ' + -10 + 'px)');
        requestAnimationFrame(function() {
            d.style.display = 'inline';
        });

        var overCol = grid.renderer.getColumnFromPixelX(x + (d.width / 2 / hdpiRatio));

        if (atMin) {
            overCol = 0;
        }

        if (atMax) {
            overCol = grid.getColumnCount() - 1;
        }

        var doAFloat = dragColumnIndex > overCol;
        doAFloat = doAFloat || (overCol - dragColumnIndex >= 1);

        if (doAFloat && !atMax && !autoScrollingNow) {
            var draggedToTheRight = dragColumnIndex < overCol;
            // if (draggedToTheRight) {
            //     overCol -= 1;
            // }
            if (this.isFloatingNow) {
                return;
            }

            this.isFloatingNow = true;
            this.createFloatColumn(grid, overCol);
            this.floatColumnTo(grid, draggedToTheRight);
        } else {

            if (x < minX - 10) {
                this.checkAutoScrollToLeft(grid, x);
            }
            if (x > minX - 10) {
                this.columnDragAutoScrollingLeft = false;
            }
            //lets check for autoscroll to right if were up against it
            if (atMax || x > maxX + 10) {
                this.checkAutoScrollToRight(grid, x);
                return;
            }
            if (x < maxX + 10) {
                this.columnDragAutoScrollingRight = false;
            }
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the right if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToRight: function(grid, x) {
        if (this.columnDragAutoScrollingRight) {
            return;
        }
        this.columnDragAutoScrollingRight = true;
        this._checkAutoScrollToRight(grid, x);
    },

    _checkAutoScrollToRight: function(grid, x) {
        if (!this.columnDragAutoScrollingRight) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft > (grid.sbHScroller.range.max - 2)) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.scrollBy(1, 0);
        var newIndex = draggedIndex + 1;

        grid.swapColumns(newIndex, draggedIndex);
        grid.renderOverridesCache.dragger.columnIndex = newIndex;

        setTimeout(this._checkAutoScrollToRight.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the left if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToLeft: function(grid, x) {
        if (this.columnDragAutoScrollingLeft) {
            return;
        }
        this.columnDragAutoScrollingLeft = true;
        this._checkAutoScrollToLeft(grid, x);
    },

    _checkAutoScrollToLeft: function(grid, x) {
        if (!this.columnDragAutoScrollingLeft) {
            return;
        }

        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft < 1) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.swapColumns(draggedIndex + scrollLeft, draggedIndex + scrollLeft - 1);
        grid.scrollBy(-1, 0);
        setTimeout(this._checkAutoScrollToLeft.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc a column drag has completed, update data and cleanup
     * @param {Hypergrid} grid
     */
    endDragColumn: function(grid) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        var columnIndex = grid.renderOverridesCache.dragger.columnIndex;

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var self = this;
        var startX = grid.renderer.visibleColumns[columnIndex - scrollLeft].left;
        var d = dragger;
        var changed = grid.renderOverridesCache.dragger.startIndex !== grid.renderOverridesCache.dragger.columnIndex;
        self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');
        self.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -1 + 'px)');
        d.style.boxShadow = '0px 0px 0px #888888';

        setTimeout(function() {
            grid.renderOverridesCache.dragger = null;
            grid.repaint();
            requestAnimationFrame(function() {
                d.style.display = 'none';
                grid.endDragColumnNotification(); //internal notification
                if (changed){
                    grid.fireSyntheticOnColumnsChangedEvent(); //public notification
                }
            });
        }, columnAnimationTime + 50);

    }

});

module.exports = ColumnMoving;

},{"./Feature":83}],80:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnResizing = Feature.extend('ColumnResizing', {

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default
     * @memberOf ColumnResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragStartWidth: -1,

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.x;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        var leftMostColumnIndex = grid.properties.showRowNumbers ? -1 : 0;
        return event.gridCell.x !== leftMostColumnIndex && event.mousePoint.x <= 3 ||
            event.mousePoint.x >= event.bounds.width - 3;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'col-resize';
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragColumn) {
            var delta = this.getMouseValue(event) - this.dragStart;
            grid.behavior.setColumnWidth(this.dragColumn, this.dragStartWidth + delta);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (event.isHeaderRow && this.overAreaDivider(grid, event)) {
            if (event.mousePoint.x <= 3) {
                var columnIndex = event.gridCell.x - 1;
                this.dragColumn = grid.behavior.getActiveColumn(columnIndex);
                this.dragStartWidth = grid.renderer.visibleColumns[columnIndex].width;
            } else {
                this.dragColumn = event.column;
                this.dragStartWidth = event.bounds.width;
            }

            this.dragStart = this.getMouseValue(event);
            this.detachChain();
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragColumn) {
            this.cursor = null;
            this.dragColumn = false;

            event.primitiveEvent.stopPropagation();
            //delay here to give other events a chance to be dropped
            var self = this;
            grid.synchronizeScrollingBoundaries();
            setTimeout(function() {
                self.attachChain();
            }, 200);
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (!this.dragColumn) {
            this.cursor = null;

            if (this.next) {
                this.next.handleMouseMove(grid, event);
            }

            this.cursor = event.isHeaderRow && this.overAreaDivider(grid, event) ? this.getCursorName() : null;
        }
    },

    /**
     * @param {Hypergrid} grid
     * @param {CellEvent} cellEvent
     * @memberOf ColumnResizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        if (event.isHeaderRow && this.overAreaDivider(grid, event)) {
            var column = event.mousePoint.x <= 3
                ? grid.behavior.getActiveColumn(event.gridCell.x - 1)
                : event.column;
            column.addProperties({
                columnAutosizing: true,
                columnAutosized: false // todo: columnAutosizing should be a setter that automatically resets columnAutosized on state change to true
            });
            setTimeout(function() { // do after next render, which measures text now that auto-sizing is on
                grid.autosizeColumn(column);
            });
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    }

});

module.exports = ColumnResizing;

},{"./Feature":83}],81:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * Extra msecs to avoid race condition with fincanvas's double click timer.
 * @type {number}
 * @defaultvalue 50
 * NOTE: 50 msecs seems to work well. 10 and even 25 proved insufficient in Chrome.
 * @private
 */
var RACE_TIME = 50;

/**
 * @constructor
 * @extends Feature
 */
var ColumnSelection = Feature.extend('ColumnSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    currentDrag: null,

    /**
     * The horizontal cell coordinate of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    lastDragColumn: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbAutoStart: 0,


    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    handleDoubleClick: function(grid, event) {
        if (this.doubleClickTimer) {
            clearTimeout(this.doubleClickTimer); // prevent mouseDown from continuing
            this.doubleClickTimer = undefined;
        }
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.doubleClickTimer) {
            return;
        }

        // todo: >= 5 depends on header being top-most row which is currently always true but we may allow header "section" to be arbitrary position within quadrant (see also handleMouseDown in ColumnMoving.js)
        if (
            grid.properties.columnSelection &&
            event.mousePoint.y >= 5 &&
            !event.primitiveEvent.detail.isRightClick &&
            event.isHeaderCell
        ) {
            // HOLD OFF WHILE WAITING FOR DOUBLE-CLICK
            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                this.dragging = true;
                this.extendSelection(grid, event.gridCell.x, event.primitiveEvent.detail.keys);
            }.bind(this), grid.properties.doubleClickDelay + RACE_TIME);
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (
            grid.properties.columnSelection &&
            !this.isColumnDragging(grid) &&
            !event.primitiveEvent.detail.isRightClick &&
            this.dragging
        ) {
            //if we are in the fixed area do not apply the scroll values
            this.lastDragColumn = event.gridCell.x;
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragColumn, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var detail = event.detail,
            handler = grid.getLastSelectionType() === 'column' &&
                this['handle' + detail.char];

        if (handler) {
            handler.call(this, grid, detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, x, keys) {
        var mouseX = grid.getMouseDown().x;

        grid.clearMostRecentColumnSelection();

        grid.selectColumn(mouseX, x);
        grid.setDragExtent(grid.newPoint(x - mouseX, 0));

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (
            grid.properties.scrollingEnabled &&
            grid.getDataBounds().contains(mouse)
        ) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else {
            if (!grid.isScrollingNow()) {
                grid.setScrollingNow(true);
                this.scrollDrag(grid);
            }
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var b = grid.getDataBounds(),
            xOffset;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        } else if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }

        if (xOffset) {
            if (this.lastDragColumn >= grid.getFixedColumnCount()) {
                this.lastDragColumn += xOffset;
            }
            grid.scrollBy(xOffset, 0);
        }

        this.handleMouseDragCellSelection(grid, this.lastDragColumn, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, x, keys) {
        if (!grid.abortEditing()) { return; }

        var mouseX = grid.getMouseDown().x,
            hasSHIFT = keys.indexOf('SHIFT') > 0;

        if (x < 0) { // outside of the grid?
            return; // do nothing
        }

        if (hasSHIFT) {
            grid.clearMostRecentColumnSelection();
            grid.selectColumn(x, mouseX);
            grid.setDragExtent(grid.newPoint(x - mouseX, 0));
        } else {
            grid.toggleSelectColumn(x, keys);
            grid.setMouseDown(grid.newPoint(x, 0));
            grid.setDragExtent(grid.newPoint(0, 0));
        }

        grid.repaint();
    },


    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {

        // var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        // var maxRows = grid.getRowCount() - 1;

        // var newX = mouseCorner.x;
        // var newY = grid.getHeaderRowCount() + grid.getVScrollValue();

        // newY = Math.min(maxRows, newY);

        // grid.clearSelections();
        // grid.select(newX, newY, 0, 0);
        // grid.setMouseDown(new grid.rectangular.Point(newX, newY));
        // grid.setDragExtent(new grid.rectangular.Point(0, 0));

        // grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var elapsed = this.getAutoScrollDuration() / 2000;
        return Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX) {
        var origin = grid.getMouseDown(),
            extent = grid.getDragExtent(),
            newX = extent.x + offsetX,
            maxViewableColumns = grid.renderer.visibleColumns.length - 1,
            maxColumns = grid.getColumnCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));

        grid.clearMostRecentColumnSelection();
        grid.selectColumn(origin.x, origin.x + newX);
        grid.setDragExtent(grid.newPoint(newX, 0));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX) {
        var extent = grid.getDragExtent(),
            mouseCorner = grid.getMouseDown().plus(extent),
            newX = mouseCorner.x + offsetX,
            maxColumns = grid.getColumnCount() - 1,
            maxViewableColumns = grid.getVisibleColumnsCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        newX = Math.min(maxColumns, Math.max(0, newX));

        grid.clearSelections();
        grid.selectColumn(newX);
        grid.setMouseDown(grid.newPoint(newX, 0));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();
    },

    isColumnDragging: function(grid) {
        var dragger = grid.lookupFeature('ColumnMoving');
        return dragger && dragger.dragging && !this.dragging;
    }

});

module.exports = ColumnSelection;

},{"./Feature":83}],82:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnSorting = Feature.extend('ColumnSorting', {

    /**
     * @memberOf ColumnSorting.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */

    handleDoubleClick: function(grid, event) {
        var columnProperties;
        if (
            event.isHeaderCell &&
            (columnProperties = grid.behavior.getColumnProperties(event.gridCell.x)) &&
            !columnProperties.unsortable
        ) {
            grid.fireSyntheticColumnSortEvent(event.gridCell.x, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        var columnProperties;
        if (
            event.isRowFixed &&
            event.isHeaderCell &&
            (columnProperties = grid.behavior.getColumnProperties(event.gridCell.x)) &&
            !columnProperties.unsortable
        ) {
            this.cursor = 'pointer';
        } else {
            this.cursor = null;
        }
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = ColumnSorting;

},{"./Feature":83}],83:[function(require,module,exports){
'use strict';

var Base = require('../Base');

/**
 * Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 * @constructor
 */
var Feature = Base.extend('Feature', {

    /**
     * the next feature to be given a chance to handle incoming events
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    next: null,

    /**
     * a temporary holding field for my next feature when I'm in a disconnected state
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    detached: null,

    /**
     * the cursor I want to be displayed
     * @type {string}
     * @default null
     * @memberOf Feature.prototype
     */
    cursor: null,

    /**
     * the cell location where the cursor is currently
     * @type {Point}
     * @default null
     * @memberOf Feature.prototype
     */
    currentHoverCell: null,

    /**
     * @memberOf Feature.prototype
     * @desc set my next field, or if it's populated delegate to the feature in my next field
     * @param {Feature} nextFeature - this is how we build the chain of responsibility
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    setNext: function(nextFeature) {
        if (this.next) {
            this.next.setNext(nextFeature);
        } else {
            this.next = nextFeature;
            this.detached = nextFeature;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc disconnect my child
     */
    detachChain: function() {
        this.next = null;
    },

    /**
     * @memberOf Feature.prototype
     * @desc reattach my child from the detached reference
     */
    attachChain: function() {
        this.next = this.detached;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle mouse move down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseMove: function(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseExit: function(grid, event) {
        if (this.next) {
            this.next.handleMouseExit(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseEnter: function(grid, event) {
        if (this.next) {
            this.next.handleMouseEnter(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseDown: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseUp: function(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleKeyDown: function(grid, event) {
        if (this.next) {
            this.next.handleKeyDown(grid, event);
        } else {
            return true;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleKeyUp: function(grid, event) {
        if (this.next) {
            this.next.handleKeyUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleWheelMoved: function(grid, event) {
        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleDoubleClick: function(grid, event) {
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleClick: function(grid, event) {
        if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseDrag: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleContextMenu: function(grid, event) {
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    moveSingleSelect: function(grid, x, y) {
        if (this.next) {
            this.next.moveSingleSelect(grid, x, y);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedRow: function(grid, event) {
        this.deprecated('isFixedRow', 'isFixedRow(grid, event) has been deprecated as of v1.2.0 in favor of event.isRowFixed. (Will be removed in a future version.)');
        return event.isRowFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedRow: function(grid, event) {
        return event.gridCell.y < 1;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedColumn: function(grid, event) {
        this.deprecated('isFixedColumn', 'isFixedColumn(grid, event) has been deprecated as of v1.2.0 in favor of event.isColumnFixed. (Will be removed in a future version.)');
        return event.isColumnFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedColumn: function(grid, event) {
        return event.gridCell.x === 0;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isTopLeft: function(grid, event) {
        this.deprecated('isTopLeft', 'isTopLeft(grid, event) has been deprecated as of v1.2.0 in favor of event.isCellFixed. (Will be removed in a future version.)');
        return event.isCellFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    setCursor: function(grid) {
        if (this.next) {
            this.next.setCursor(grid);
        }
        if (this.cursor) {
            grid.beCursor(this.cursor);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    initializeOn: function(grid) {
        if (this.next) {
            this.next.initializeOn(grid);
        }
    }

});

module.exports = Feature;

},{"../Base":41}],84:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var Filters = Feature.extend('Filters', {

    /**
     * Navigate away from the filter cell when:
     * 1. Coming from a cell editor (`event.detail.editor` defined).
     * 2. The cell editor was for a filter cell.
     * 3. The key (`event.detail.char) maps (through {@link module:defaults.navKeyMap|navKeyMap}) to one of:
     *    * `'UP'` or `'DOWN'` - Selects first visible data cell under filter cell.
     *    * `'LEFT'` - Opens filter cell editor in previous filterable column; if nonesuch, selects first visible data cell under filter cell.
     *    * `'RIGHT'` - Opens filter cell editor in next filterable column; if nonesuch, selects first visible data cell under filter cell.
     */
    handleKeyDown: function(grid, event) {
        var cellEvent, mappedNavKey, handler,
            detail = event.detail;

        if (detail.editor) {
            cellEvent = detail.editor.event;
            if (cellEvent.isFilterCell) {
                mappedNavKey = cellEvent.properties.mappedNavKey(detail.char);
                handler = this['handle' + mappedNavKey];
            }
        }

        if (handler) {
            handler.call(this, grid, detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    handleLEFT: function(grid, detail) { moveLaterally(grid, detail, -1); },
    handleRIGHT: function(grid, detail) { moveLaterally(grid, detail, +1); },
    handleUP: moveDown,
    handleDOWN: moveDown,

    handleDoubleClick: function(grid, event) {
        if (event.isFilterCell) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function(grid, event) {
        if (event.isFilterCell) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    }

});

function moveLaterally(grid, detail, deltaX) {
    var cellEvent = detail.editor.event,
        gridX = cellEvent.visibleColumn.index,
        gridY = cellEvent.visibleRow.index,
        originX = gridX,
        C = grid.renderer.visibleColumns.length;

    cellEvent = new grid.behavior.CellEvent; // redefine so we don't reset the original below

    while (
        (gridX = (gridX + deltaX + C) % C) !== originX &&
        cellEvent.resetGridXY(gridX, gridY)
    ) {
        if (cellEvent.properties.filterable) {
            // Select previous or next filterable column's filter cell
            grid.editAt(cellEvent);
            return;
        }
    }

    moveDown(grid, cellEvent);
}

function moveDown(grid, detail) {
    var cellEvent = detail.editor.event,
        gridX = cellEvent.visibleColumn.columnIndex;

    // Select first visible grid cell of this column
    grid.selectViewportCell(gridX, 0);
    grid.takeFocus();
}

module.exports = Filters;

},{"./Feature":83}],85:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

var commands = {
    PAGEDOWN: function(grid) { grid.pageDown(); },
    PAGEUP: function(grid) { grid.pageUp(); },
    PAGELEFT: function(grid) { grid.pageLeft(); },
    PAGERIGHT: function(grid) { grid.pageRight(); }
};

/**
 * @constructor
 */
var KeyPaging = Feature.extend('KeyPaging', {

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var func = commands[event.detail.char];
        if (func) {
            func(grid);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = KeyPaging;

},{"./Feature":83}],86:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var OnHover = Feature.extend('OnHover', {

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf OnHover.prototype
     */
    handleMouseMove: function(grid, event) {
        var hoverCell = grid.hoverCell;
        if (!event.gridCell.equals(hoverCell)) {
            if (hoverCell) {
                this.handleMouseExit(grid, hoverCell);
            }
            this.handleMouseEnter(grid, event);
            grid.setHoverCell(event);
        } else if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = OnHover;

},{"./Feature":83}],87:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var RowSelection = Feature.extend('RowSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf RowSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf RowSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbAutoStart: 0,

    dragArmed: false,

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragArmed) {
            this.dragArmed = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.dragging) {
            this.dragging = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var rowSelectable = grid.properties.rowSelection &&
            !event.primitiveEvent.detail.isRightClick &&
            grid.properties.showRowNumbers &&
            event.isHandleColumn;

        if (rowSelectable && event.isHeaderHandle) {
            //global row selection
            grid.toggleSelectAllRows();
        } else if (rowSelectable && event.isDataRow)  {
            // if we are in the fixed area, do not apply the scroll values
            this.dragArmed = true;
            this.extendSelection(grid, event.dataCell.y, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (
            this.dragArmed &&
            grid.properties.rowSelection &&
            !event.primitiveEvent.detail.isRightClick
        ) {
            //if we are in the fixed area do not apply the scroll values
            this.lastDragRow = event.dataCell.y;
            this.dragging = true;
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragRow, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if (
            grid.getLastSelectionType() === 'row' &&
            (handler = this['handle' + event.detail.char])
        ) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, y, keys) {
        var mouseY = grid.getMouseDown().y;

        grid.clearMostRecentRowSelection();

        grid.selectRow(mouseY, y);
        grid.setDragExtent(grid.newPoint(0, y - mouseY));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (
            grid.properties.scrollingEnabled &&
            grid.getDataBounds().contains(mouse)
        ) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else {
            if (!grid.isScrollingNow()) {
                grid.setScrollingNow(true);
                this.scrollDrag(grid);
            }
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var b = grid.getDataBounds(),
            yOffset;

        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        } else if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        if (yOffset) {
            if (this.lastDragRow >= grid.getFixedRowCount()) {
                this.lastDragRow += yOffset;
            }
            grid.scrollBy(0, yOffset);
        }

        this.handleMouseDragCellSelection(grid, this.lastDragRow, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, y, keys) {
        if (!grid.abortEditing()) { return; }

        var mouseY = grid.getMouseDown().y,
            hasSHIFT = keys.indexOf('SHIFT') > 0;

        if (y < 0) { // outside of the grid?
            return; // do nothing
        }

        if (hasSHIFT) {
            grid.clearMostRecentRowSelection();
            grid.selectRow(y, mouseY);
            grid.setDragExtent(grid.newPoint(0, y - mouseY));
        } else {
            grid.toggleSelectRow(y, keys);
            grid.setMouseDown(grid.newPoint(0, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }

        grid.repaint();
    },


    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent()),
            maxColumns = grid.getColumnCount() - 1,
            newX = grid.getHScrollValue(),
            newY = mouseCorner.y;

        newX = Math.min(maxColumns, newX);

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetY) {
        var origin = grid.getMouseDown(),
            extent = grid.getDragExtent(),
            maxViewableRows = grid.renderer.visibleRows.length - 1,
            maxRows = grid.getRowCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var newY = extent.y + offsetY;

        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentRowSelection();
        grid.selectRow(origin.y, origin.y + newY);
        grid.setDragExtent(grid.newPoint(0, newY));

        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetY) {
        var maxRows = grid.getRowCount() - 1,
            maxViewableRows = grid.getVisibleRowsCount() - 1,
            mouseCorner = grid.getMouseDown().plus(grid.getDragExtent()),
            newY = mouseCorner.y + offsetY;

        if (!grid.properties.scrollingEnabled) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.selectRow(newY);
        grid.setMouseDown(grid.newPoint(0, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();
    },

    isSingleRowSelection: function() {
        return true;
    }

});

module.exports = RowSelection;

},{"./Feature":83}],88:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var ThumbwheelScrolling = Feature.extend('ThumbwheelScrolling', {

    /**
     * @memberOf ThumbwheelScrolling.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, e) {
        if (!grid.properties.scrollingEnabled) {
            return;
        }

        var primEvent = e.primitiveEvent,
            deltaX = Math.sign(primEvent.wheelDeltaX || -primEvent.deltaX),
            deltaY = Math.sign(primEvent.wheelDeltaY || -primEvent.deltaY);

        if (deltaX || deltaY) {
            grid.scrollBy(
                -deltaX || 0, // 0 if NaN
                -deltaY || 0
            );
        }
    }

});


module.exports = ThumbwheelScrolling;

},{"./Feature":83}],89:[function(require,module,exports){
'use strict';

module.exports = {
    Feature: require('./Feature'), // abstract base class
    CellClick: require('./CellClick'),
    CellEditing: require('./CellEditing'),
    CellSelection: require('./CellSelection'),
    ColumnMoving: require('./ColumnMoving'),
    ColumnResizing: require('./ColumnResizing'),
    ColumnSelection: require('./ColumnSelection'),
    ColumnSorting: require('./ColumnSorting'),
    Filters: require('./Filters'),
    KeyPaging: require('./KeyPaging'),
    OnHover: require('./OnHover'),
    // RowResizing: require('./RowResizing'),
    RowSelection: require('./RowSelection'),
    ThumbwheelScrolling: require('./ThumbwheelScrolling')
};

},{"./CellClick":76,"./CellEditing":77,"./CellSelection":78,"./ColumnMoving":79,"./ColumnResizing":80,"./ColumnSelection":81,"./ColumnSorting":82,"./Feature":83,"./Filters":84,"./KeyPaging":85,"./OnHover":86,"./RowSelection":87,"./ThumbwheelScrolling":88}],90:[function(require,module,exports){
/* eslint-env browser */

'use strict';

if (typeof window.CustomEvent !== 'function') {
    window.CustomEvent = function(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    };

    window.CustomEvent.prototype = window.Event.prototype;
}

var rectangular = require('rectangular');

var RESIZE_POLLING_INTERVAL = 200,
    paintables = [],
    resizables = [],
    paintRequest,
    resizeInterval,
    charMap = makeCharMap();

function Canvas(div, component) {
    var self = this;

    // create the containing <div>...</div>
    this.div = div;
    this.component = component;

    this.dragEndtime = Date.now();

    // create and append the info <div>...</div> (to be displayed when there are no data rows)
    this.infoDiv = document.createElement('div');
    this.infoDiv.className = 'info';
    this.div.appendChild(this.infoDiv);

    // create and append the canvas
    this.gc = getCachedContext(this.canvas = document.createElement('canvas'));
    this.bc = getCachedContext(this.buffer = document.createElement('canvas'));

    this.div.appendChild(this.canvas);

    this.canvas.style.outline = 'none';

    this.mouseLocation = new rectangular.Point(-1, -1);
    this.dragstart = new rectangular.Point(-1, -1);
    //this.origin = new rectangular.Point(0, 0);
    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
    this.hasMouse = false;

    document.addEventListener('mousemove', function(e) {
        if (self.hasMouse || self.isDragging()) {
            self.finmousemove(e);
        }
    });
    document.addEventListener('mouseup', function(e) {
        self.finmouseup(e);
    });
    document.addEventListener('wheel', function(e) {
        self.finwheelmoved(e);
    });
    document.addEventListener('keydown', function(e) {
        self.finkeydown(e);
    });
    document.addEventListener('keyup', function(e) {
        self.finkeyup(e);
    });

    this.canvas.onmouseover = function() {
        self.hasMouse = true;
    };
    this.addEventListener('focus', function(e) {
        self.finfocusgained(e);
    });
    this.addEventListener('blur', function(e) {
        self.finfocuslost(e);
    });
    this.addEventListener('mousedown', function(e) {
        self.finmousedown(e);
    });
    this.addEventListener('mouseout', function(e) {
        self.hasMouse = false;
        self.finmouseout(e);
    });
    this.addEventListener('click', function(e) {
        self.finclick(e);
    });
    this.addEventListener('contextmenu', function(e) {
        self.fincontextmenu(e);
        e.preventDefault();
        return false;
    });

    this.canvas.setAttribute('tabindex', 0);
    this.canvas.contentEditable = true;

    this.resize();

    this.beginResizing();
    this.beginPainting();
}

Canvas.prototype = {
    constructor: Canvas.prototype.constructor,
    div: null,
    component: null,
    canvas: null,
    focuser: null,
    buffer: null,
    ctx: null,
    mouseLocation: null,
    dragstart: null,
    origin: null,
    bounds: null,
    dirty: false,
    size: null,
    mousedown: false,
    dragging: false,
    repeatKeyCount: 0,
    repeatKey: null,
    repeatKeyStartTime: 0,
    currentKeys: [],
    hasMouse: false,
    lastDoubleClickTime: 0,
    dragEndTime: 0,
    lastRepaintTime: 0,
    currentPaintCount: 0,
    currentFPS: 0,
    lastFPSComputeTime: 0,

    addEventListener: function(name, callback) {
        this.canvas.addEventListener(name, callback);
    },

    removeEventListener: function(name, callback) {
        this.canvas.removeEventListener(name, callback);
    },

    stopPaintLoop: stopPaintLoop,
    restartPaintLoop: restartPaintLoop,

    stopResizeLoop: stopResizeLoop,
    restartResizeLoop: restartResizeLoop,

    detached: function() {
        this.stopPainting();
        this.stopResizing();
    },

    getCurrentFPS:function() {
        return this.currentFPS;
    },


    tickPaint: function(now) {
        var isContinuousRepaint = this.component.properties.enableContinuousRepaint,
            fps = this.component.properties.repaintIntervalRate;
        if (fps === 0) {
            return;
        }
        var interval = 1000 / fps;

        var elapsed = now - this.lastRepaintTime;
        if (elapsed > interval && (isContinuousRepaint || this.dirty)) {
            this.paintNow();
            this.lastRepaintTime = now;
            /* - (elapsed % interval);*/
            if (isContinuousRepaint) {
                this.currentPaintCount++;
                if (now - this.lastFPSComputeTime >= 1000) {
                    this.currentFPS = (this.currentPaintCount * 1000) / (now - this.lastFPSComputeTime);
                    this.currentPaintCount = 0;
                    this.lastFPSComputeTime = now;
                }
            }
        }
    },

    beginPainting: function() {
        var self = this;
        this.dirty = true;
        this.tickPainter = function(now) {
            self.tickPaint(now);
        };
        paintables.push(this);
    },

    stopPainting: function() {
        paintables.splice(paintables.indexOf(this), 1);
    },

    beginResizing: function() {
        var self = this;
        this.tickResizer = function() {
            self.checksize();
        };
        resizables.push(this);
    },

    stopResizing: function() {
        resizables.splice(resizables.indexOf(this), 1);
    },

    start: function() {
        this.beginPainting();
        this.beginResizing();
    },

    stop: function() {
        this.stopPainting();
        this.stopResizing();
    },

    checksize: function() {
        //this is expensive lets do it at some modulo
        var sizeNow = this.div.getBoundingClientRect();
        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
            this.resize();
        }
    },

    resize: function() {
        var box = this.size = this.div.getBoundingClientRect();

        this.width = box.width;
        this.height = box.height;

        //fix ala sir spinka, see
        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
        //just add 'hdpi' as an attribute to the fin-canvas tag
        var ratio = 1;
        var isHIDPI = window.devicePixelRatio && this.component.properties.useHiDPI;
        if (isHIDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = this.gc.webkitBackingStorePixelRatio ||
                this.gc.mozBackingStorePixelRatio ||
                this.gc.msBackingStorePixelRatio ||
                this.gc.oBackingStorePixelRatio ||
                this.gc.backingStorePixelRatio || 1;

            ratio = devicePixelRatio / backingStoreRatio;
            //this.canvasCTX.scale(ratio, ratio);
        }

        this.buffer.width = this.canvas.width = this.width * ratio;
        this.buffer.height = this.canvas.height = this.height * ratio;

        this.canvas.style.width = this.buffer.style.width = this.width + 'px';
        this.canvas.style.height = this.buffer.style.height = this.height + 'px';

        this.bc.scale(ratio, ratio);
        if (isHIDPI && !this.component.properties.useBitBlit) {
            this.gc.scale(ratio, ratio);
        }

        this.bounds = new rectangular.Rectangle(0, 0, this.width, this.height);
        this.component.setBounds(this.bounds);
        this.resizeNotification();
        this.paintNow();
    },

    resizeNotification: function() {
        this.dispatchNewEvent(undefined, 'fin-canvas-resized', {
            width: this.width,
            height: this.height
        });
    },

    getBounds: function() {
        return this.bounds;
    },

    paintNow: function() {
        var useBitBlit = this.component.properties.useBitBlit,
            gc = useBitBlit ? this.bc : this.gc;

        try {
            gc.cache.save();
            this.component.paint(gc);
            this.dirty = false;
        } catch (e) {
            console.error(e);
        } finally {
            gc.cache.restore();
        }

        if (useBitBlit) {
            this.flushBuffer();
        }
    },

    flushBuffer: function() {
        if (this.buffer.width > 0 && this.buffer.height > 0) {
            this.gc.drawImage(this.buffer, 0, 0);
        }
    },

    newEvent: function(primitiveEvent, name, detail) {
        var event = {
            detail: detail || {}
        };
        if (primitiveEvent) {
            event.detail.primitiveEvent = primitiveEvent;
        }
        return new CustomEvent(name, event);
    },

    dispatchNewEvent: function(primitiveEvent, name, detail) {
        return this.canvas.dispatchEvent(this.newEvent(primitiveEvent, name, detail));
    },

    dispatchNewMouseKeysEvent: function(event, name, detail) {
        detail = detail || {};
        detail.mouse = this.mouseLocation;
        detail.keys = this.currentKeys;
        return this.dispatchNewEvent(event, name, detail);
    },

    finmousemove: function(e) {
        if (!this.isDragging() && this.mousedown) {
            this.beDragging();
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
                isRightClick: this.isRightClick(e)
            });
            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
        }
        this.mouseLocation = this.getLocal(e);
        //console.log(this.mouseLocation);
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
        }
        if (this.bounds.contains(this.mouseLocation)) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
        }
    },

    finmousedown: function(e) {
        this.mouseLocation = this.mouseDownLocation = this.getLocal(e);
        this.mousedown = true;

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
            isRightClick: this.isRightClick(e)
        });
        this.takeFocus();
    },

    finmouseup: function(e) {
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
            this.beNotDragging();
            this.dragEndtime = Date.now();
        }
        this.mousedown = false;
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
            isRightClick: this.isRightClick(e)
        });
        //this.mouseLocation = new rectangular.Point(-1, -1);
    },

    finmouseout: function(e) {
        if (!this.mousedown) {
            this.mouseLocation = new rectangular.Point(-1, -1);
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout');
    },

    finwheelmoved: function(e) {
        if (this.isDragging() || !this.hasFocus()) {
            return;
        }
        e.preventDefault();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
            isRightClick: this.isRightClick(e)
        });
    },

    finclick: function(e) {
        var delay = this.component.properties.doubleClickDelay;
        if (delay < 100) {
            dispatchClickEvent.call(this, e);
        } else if (this.doubleClickTimer && Date.now() - this.lastClickTime < delay) {
            //this is a double click...
            clearTimeout(this.doubleClickTimer); // prevent click event
            this.doubleClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();
            this.doubleClickTimer = setTimeout(dispatchClickEvent.bind(this, e), delay);
        }
    },

    findblclick: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.lastDoubleClickTime = Date.now();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
            isRightClick: this.isRightClick(e)
        });
        //console.log('dblclick', this.currentKeys);
    },

    getCharMap: function() {
        return charMap;
    },

    getKeyChar: function(e) {
        var key = e.keyCode || e.detail.key,
            shift = e.shiftKey || e.detail.shift;
        return charMap[key][shift ? 1 : 0];
    },

    finkeydown: function(e) {
        if (!this.hasFocus()) {
            return;
        }

        // prevent TAB from moving focus off the canvas element
        if (e.keyCode === 9) {
            e.preventDefault();
        }

        var keyChar = this.getKeyChar(e);
        if (e.repeat) {
            if (this.repeatKey === keyChar) {
                this.repeatKeyCount++;
            } else {
                this.repeatKey = keyChar;
                this.repeatKeyStartTime = Date.now();
            }
        } else {
            this.repeatKey = null;
            this.repeatKeyCount = 0;
            this.repeatKeyStartTime = 0;
        }
        if (this.currentKeys.indexOf(keyChar) === -1) {
            this.currentKeys.push(keyChar);
        }

        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeatCount: this.repeatKeyCount,
            repeatStartTime: this.repeatKeyStartTime,
            shift: e.shiftKey,
            identifier: e.key,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finkeyup: function(e) {
        if (!this.hasFocus()) {
            return;
        }

        // prevent TAB from moving focus off the canvas element
        if (e.keyCode === 9) {
            e.preventDefault();
        }

        var keyChar = this.getKeyChar(e);
        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
        this.repeatKeyCount = 0;
        this.repeatKey = null;
        this.repeatKeyStartTime = 0;
        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeat: e.repeat,
            shift: e.shiftKey,
            identifier: e.key,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finfocusgained: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
    },

    finfocuslost: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
    },

    fincontextmenu: function(e) {
        var delay = this.component.properties.doubleClickDelay;

        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
            this.currentKeys.push('CTRL');
        }

        if (delay < 100) {
            dispatchContextMenuEvent.call(this, e);
        } else if (this.doubleRightClickTimer && Date.now() - this.lastClickTime < delay) {
            //this is a double click...
            clearTimeout(this.doubleRightClickTimer); // prevent context menu event
            this.doubleRightClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleRightClickTimer = setTimeout(dispatchContextMenuEvent.bind(this, e), delay);
        }
    },

    repaint: function() {
        this.dirty = true;
        if (!paintRequest || this.component.properties.repaintIntervalRate === 0) {
            this.paintNow();
        }
    },

    getMouseLocation: function() {
        return this.mouseLocation;
    },

    getOrigin: function() {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(rect.left, rect.top);
        return p;
    },

    getLocal: function(e) {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
        return p;
    },

    hasFocus: function() {
        return document.activeElement === this.canvas;
    },

    takeFocus: function() {
        var self = this;
        if (!this.hasFocus()) {
            setTimeout(function() {
                self.canvas.focus();
            }, 10);
        }
    },

    beDragging: function() {
        this.dragging = true;
        this.disableDocumentElementSelection();
    },

    beNotDragging: function() {
        this.dragging = false;
        this.enableDocumentElementSelection();
    },

    isDragging: function() {
        return this.dragging;
    },

    disableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText + '-webkit-user-select: none';
    },

    enableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
    },

    setFocusable: function(truthy) {
        this.focuser.style.display = truthy ? '' : 'none';
    },

    isRightClick: function(e) {
        var isRightMB;
        e = e || window.event;

        if ('which' in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            isRightMB = e.which === 3;
        } else if ('button' in e) { // IE, Opera
            isRightMB = e.button === 2;
        }
        return isRightMB;
    },

    dispatchEvent: function(e) {
        return this.canvas.dispatchEvent(e);
    },

    setInfo: function(message, width) {
        if (message) {
            if (width !== undefined) {
                if (width && !isNaN(Number(width))) {
                    width += 'px';
                }
                this.infoDiv.style.width = width;
            }

            if (message.indexOf('<')) {
                this.infoDiv.innerHTML = message;
            } else {
                this.infoDiv.innerText = message;
            }
        }

        this.infoDiv.style.display = message ? 'block' : 'none';
    }
};

function dispatchClickEvent(e) {
    this.doubleClickTimer = undefined;
    this.mouseLocation = this.getLocal(e);
    this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
        isRightClick: this.isRightClick(e)
    });
}

function dispatchContextMenuEvent(e) {
    this.doubleRightClickTimer = undefined;
    this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
        isRightClick: this.isRightClick(e)
    });
}

function paintLoopFunction(now) {
    if (paintRequest) {
        paintables.forEach(function(paintable) {
            try {
                paintable.tickPainter(now);
            } catch (e) {
                console.error(e);
            }

            if (paintable.component.tickNotification) {
                paintable.component.tickNotification();
            }
        });
        paintRequest = requestAnimationFrame(paintLoopFunction);
    }
}
function restartPaintLoop() {
    paintRequest = paintRequest || requestAnimationFrame(paintLoopFunction);
}
function stopPaintLoop() {
    if (paintRequest) {
        cancelAnimationFrame(paintRequest);
        paintRequest = undefined;
    }
}
restartPaintLoop();

function resizablesLoopFunction(now) {
    if (resizeInterval) {
        for (var i = 0; i < resizables.length; i++) {
            try {
                resizables[i].tickResizer(now);
            } catch (e) {
                console.error(e);
            }
        }
    }
}
function restartResizeLoop() {
    resizeInterval = resizeInterval || setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);
}
function stopResizeLoop() {
    if (resizeInterval) {
        clearInterval(resizeInterval);
        resizeInterval = undefined;
    }
}
restartResizeLoop();

function makeCharMap() {
    var map = [];

    var empty = ['', ''];

    for (var i = 0; i < 256; i++) {
        map[i] = empty;
    }

    map[27] = ['ESC', 'ESCSHIFT'];
    map[192] = ['`', '~'];
    map[49] = ['1', '!'];
    map[50] = ['2', '@'];
    map[51] = ['3', '#'];
    map[52] = ['4', '$'];
    map[53] = ['5', '%'];
    map[54] = ['6', '^'];
    map[55] = ['7', '&'];
    map[56] = ['8', '*'];
    map[57] = ['9', '('];
    map[48] = ['0', ')'];
    map[189] = ['-', '_'];
    map[187] = ['=', '+'];
    map[8] = ['BACKSPACE', 'BACKSPACESHIFT'];
    map[46] = ['DELETE', 'DELETESHIFT'];
    map[9] = ['TAB', 'TABSHIFT'];
    map[81] = ['q', 'Q'];
    map[87] = ['w', 'W'];
    map[69] = ['e', 'E'];
    map[82] = ['r', 'R'];
    map[84] = ['t', 'T'];
    map[89] = ['y', 'Y'];
    map[85] = ['u', 'U'];
    map[73] = ['i', 'I'];
    map[79] = ['o', 'O'];
    map[80] = ['p', 'P'];
    map[219] = ['[', '{'];
    map[221] = [']', '}'];
    map[220] = ['\\', '|'];
    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    map[65] = ['a', 'A'];
    map[83] = ['s', 'S'];
    map[68] = ['d', 'D'];
    map[70] = ['f', 'F'];
    map[71] = ['g', 'G'];
    map[72] = ['h', 'H'];
    map[74] = ['j', 'J'];
    map[75] = ['k', 'K'];
    map[76] = ['l', 'L'];
    map[186] = [';', ':'];
    map[222] = ['\'', '|'];
    map[13] = ['RETURN', 'RETURNSHIFT'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[90] = ['z', 'Z'];
    map[88] = ['x', 'X'];
    map[67] = ['c', 'C'];
    map[86] = ['v', 'V'];
    map[66] = ['b', 'B'];
    map[78] = ['n', 'N'];
    map[77] = ['m', 'M'];
    map[188] = [',', '<'];
    map[190] = ['.', '>'];
    map[191] = ['/', '?'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[17] = ['CTRL', 'CTRLSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    map[32] = ['SPACE', 'SPACESHIFT'];
    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[38] = ['UP', 'UPSHIFT'];
    map[37] = ['LEFT', 'LEFTSHIFT'];
    map[40] = ['DOWN', 'DOWNSHIFT'];
    map[39] = ['RIGHT', 'RIGHTSHIFT'];

    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT']; // END
    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT']; // HOME

    map[112] = ['F1', 'F1SHIFT'];
    map[113] = ['F2', 'F2SHIFT'];
    map[114] = ['F3', 'F3SHIFT'];
    map[115] = ['F4', 'F4SHIFT'];
    map[116] = ['F5', 'F5SHIFT'];
    map[117] = ['F6', 'F6SHIFT'];
    map[118] = ['F7', 'F7SHIFT'];
    map[119] = ['F8', 'F8SHIFT'];
    map[120] = ['F9', 'F9SHIFT'];
    map[121] = ['F10', 'F10SHIFT'];
    map[122] = ['F11', 'F1S1HIFT'];
    map[123] = ['F12', 'F121HIFT'];

    return map;
}

function getCachedContext(canvasElement, type) {
    var gc = canvasElement.getContext(type || '2d'),
        props = {},
        values = {};

    // Stub out all the prototype members of the canvas 2D graphics context:
    Object.keys(Object.getPrototypeOf(gc)).forEach(makeStub);

    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
    // 2D graphics context in the prototype so we make this additional call:
    Object.keys(gc).forEach(makeStub);

    function makeStub(key) {
        if (
            !(key in props) &&
            !/^(webkit|moz|ms|o)[A-Z]/.test(key) &&
            typeof gc[key] !== 'function'
        ) {
            Object.defineProperty(props, key, {
                get: function() {
                    return (values[key] = values[key] || gc[key]);
                },
                set: function(value) {
                    if (value !== values[key]) {
                        gc[key] = values[key] = value;
                    }
                }
            });
        }
    }

    gc.cache = props;

    gc.cache.save = function() {
        gc.save();
        values = Object.create(values);
    };

    gc.cache.restore = function() {
        gc.restore();
        values = Object.getPrototypeOf(values);
    };

    gc.conditionalsStack = [];

    return Object.assign(gc, require('./graphics'));
}


module.exports = Canvas;

},{"./graphics":104,"rectangular":39}],91:[function(require,module,exports){
/* eslint-env browser */

/** @module effects */

/** @typedef {function} effectFunction
 * @desc Element to perform transitions upon is `options.el` if defined or `this.el`.
 * @param {object} [options]
 * @param {HTMLElement} [options.el=this.el]
 * @param {function} [options.callback] Function to call at conclusion of transitions.
 * @param {string} [options.duration='0.065s'] - Duration of each transition.
 * @param {object} [options.styles=defaultGlowerStyles] - Hash of CSS styles and values to transition. (For {@link effects~glower|glower} only.
 */

'use strict';

/**
 * Shake element back and fourth a few times as if to say, "Nope!"
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.shaker = function(options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.065s',
        computedStyle = window.getComputedStyle(el),
        transitions = computedStyle.transition.split(','),
        position = computedStyle.position,
        x = parseInt(computedStyle.left),
        dx = -3,
        shakes = 6;

    transitions.push('left ' + duration);
    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', shaker);
    shaker();
    function shaker(event) {
        if (!event || event.propertyName === 'left') {
            el.style.left = x + dx + 'px';
            if (!shakes--) {
                el.removeEventListener('transitionend', shaker);
                transitions.pop();
                el.style.transition = transitions.join(',');
                el.style.position = position;
                if (options.callback) {
                    options.callback.call(context, options);
                }
            }
            dx = shakes ? -dx : 0;
        }
    }
};

var defaultGlowerStyles = {
    'background-color': 'yellow',
    'box-shadow': '0 0 10px red'
};

/**
 * Transition styles on element for a moment and revert as if to say, "Whoa!."
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.glower = function(options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.25s',
        styles = options.styles || defaultGlowerStyles,
        values = styles.length,
        computedStyle = window.getComputedStyle(el),
        styleWas = {},
        transition = computedStyle.transition,
        transitions = transition.split(',');

    Object.keys(styles).forEach(function(style) {
        styleWas[style] = {
            style: computedStyle[style],
            undo: true
        };
        transitions.push(style + ' ' + duration);
    });

    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', glower);
    Object.keys(styles).forEach(function(style) {
        el.style[style] = styles[style];
    });

    function glower(event) {
        var was = styleWas[event.propertyName];
        if (was.undo) {
            el.style[event.propertyName] = was.style;
            was.undo = false;
        } else if (!--values) {
            el.removeEventListener('transitionend', glower);
            el.style.transition = transition;
            if (options.callback) {
                options.callback.call(context, options);
            }
        }
    }
};

},{}],92:[function(require,module,exports){
/* eslint-env browser */

'use strict';

module.exports.each = function(selector, iteratee, context) {
    return Array.prototype.forEach.call((context || document).querySelectorAll(selector), iteratee);
};

module.exports.find = function(selector, iteratee, context) {
    return Array.prototype.find.call((context || document).querySelectorAll(selector), iteratee);
};

},{}],93:[function(require,module,exports){
'use strict';

function Queueless(element, context) {
    this.element = element;
    this.context = context;
    this.transitioning = false;
}

Queueless.prototype.begin = function(callback) {
    var self = this;

    this.transitioning = true;

    this.element.addEventListener('transitionend', function end(transEvent) {
        self.element.removeEventListener('transitionend', end);

        if (callback) {
            callback.call(this, transEvent, self);
        }

        self.transitioning = false;
    });
};

module.exports = Queueless;

},{}],94:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var DataSourceBase = require('fin-hypergrid-data-source-base');

var getFieldNames = require('./fields').getFieldNames;

/**
 * See {@link DataSourceOrigin#initialize} for constructor parameters.
 * @constructor
 */
var DataSourceOrigin = DataSourceBase.extend('DataSourceOrigin',  {

    /**
     * Currently a synonym for {@link DataSourceOrigin#setData} (see).
     */
    initialize: function(data, schema) {
        delete this.dataSource; // added by DataSourceBase#initialize but we don't want here
        this._schema = [];
        this.setData(data, schema);
    },

    /** @typedef {object} columnSchemaObject
     * @property {string} name - The required column name.
     * @property {string} [header] - An override for derived header
     * @property {function} [calculator] - A function for a computed column. Undefined for normal data columns.
     * @property {string} [type] - Used for sorting when and only when comparator not given.
     * @property {object} [comparator] - For sorting, both of following required:
     * @property {function} comparator.asc - ascending comparator
     * @property {function} comparator.desc - descending comparator
     */

    /**
     * @param {object[]} [data=[]] - Array of uniform objects containing the grid data.
     * @param {columnSchemaObject[]} [schema=[]]
     * @memberOf DataSourceOrigin#
     */
    setData: function(data, schema) {
        /**
         * @summary The array of uniform data objects.
         * @name schema
         * @type {columnSchemaObject[]}
         * @memberOf DataSourceOrigin#
         */
        this.data = data || [];

        if (schema) {
            this.setSchema(schema);
        } else if (this.data.length && !this.schema.length) {
            this.setSchema([]);
        }
    },

    get schema() { return this._schema; },
    set schema(schema) { this._schema = schema; },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {columnSchemaObject[]}
     */
    getSchema:  function(){
        return this._schema;
    },
    /**
     * @memberOf DataSourceOrigin#
     * Caveat: Do not call on a data update when you expect to reuse the existing schema.
     * @param schema
     */
    setSchema: function(schema){
        if (!schema.length) {
            var fields = getFieldNames(this.data[0]);

            schema = Array(fields.length);

            for (var i = 0; i < fields.length; i++) {
                schema[i] = { name: fields[i] };
            }
        }

        /**
         * @summary The array of column schema objects.
         * @name schema
         * @type {columnSchemaObject[]}
         * @memberOf DataSourceOrigin#
         */
        this._schema = schema;
    },

    isNullObject: false,

    getDataIndex: function(y) {
        return y;
    },

    /**
     * @memberOf DataSourceOrigin#
     * @param y
     * @returns {dataRowObject}
     */
    getRow: function(y) {
        return this.data[y];
    },

    /**
     * @summary Find, replace, or update a row by it's primary key column.
     * @param {string|object} columnName - One of:
     * * _string_ - Column name. See `value`.
     * * _object_ - Hash of 0 or more key-value pairs to search for.
     * @param {string[]|*} [value] - One of:
     * _omitted_ - When `columnName` is a hash and you want to search all its keys.
     * _string[]_ - When `columnName` is a hash but you only want to search certain keys.
     * _otherwise_ - When `columnName` is a string. Value to search for.
     * Note that `null` is a valid search value.
     * @param {object|null|undefined} [replacement] - One of:
     * * _omitted_ - Ignored.
     * * _object_ - Replacement for the data row if found.
     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
     * * `undefined` - Flag to return index of found row instead of row object itself.
     * @returns {object|number|undefined} One of:
     * * `undefined` - data row not found
     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
     * * _number_ - index of found data row object in `this.data` (if `replacement` was `undefined`)
     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
     * @memberOf DataSourceOrigin#
     */
    findRow: function findRow(columnName, value, replacement) {
        var result, index, keys, hash, args;

        if (typeof columnName === 'object') {
            hash = columnName;

            if (value instanceof Array) {
                args = 2;
                keys = value;
                if (keys.reduce(function(sum, key) {
                        if (key in hash) {
                            sum++;
                        }
                        return sum;
                    }, 0) !== keys.length) {
                    throw 'Expected all keys given in 2nd arg to be found in hash given in 1st arg.';
                }
            } else {
                args = 1;
                keys = Object.keys(hash);
                replacement = value; // promote
            }

            if (keys.length === 1) {
                columnName = keys[0];
                value = hash[columnName];
                hash = undefined;
            } else if (keys.length) {
                result = this.data.find(function(row, idx) {
                    if (!row) {
                        return;
                    }
                    index = idx;
                    for (var key in keys) {
                        columnName = keys[key];
                        if (row[columnName] !== hash[columnName]) {
                            return; // bail
                        }
                    }
                    return true; // found!
                });
            }
        } else {
            if (arguments.length < 2) {
                throw 'Expected at least 2 arguments when first argument not object but found ' + arguments.length + '.';
            }
            args = 2;
        }

        if (!hash) {
            result = this.data.find(function(row, idx) {
                if (!row) { return; }
                index = idx;
                return row[columnName] === value;
            });
        }

        if (result) {
            this.foundRowIndex = index;
            if (replacement === null) {
                this.data.splice(index, 1);
            } else if (typeof replacement === 'object') {
                this.data[index] = replacement;
            } else if (replacement === undefined) {
                if (arguments.length > args) {
                    delete this.data[index];
                }
            } else {
                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
            }
        } else {
            this.foundRowIndex = undefined;
        }

        return result;
    },

    /**
     * @summary Find, replace, or update a row by it's index.
     * @param {number} index - Row index that is being accessed
     * @param {object|null|undefined} [replacement] - One of:
     * * _omitted_ - Ignored.
     * * _object_ - Replacement for the data row if found.
     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
     * * `undefined` - Flag to delete the row at that index.
     * @returns {object|number|undefined} One of:
     * * `undefined` - data row not found
     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
     * @memberOf DataSourceOrigin#
     */
    findRowByIndex: function findRow(index, replacement) {
        var result;

        if (arguments.length < 1) {
            throw 'Expected at least 1 argument but found ' + arguments.length + '.';
        }

        if (typeof index !== 'number') {
            throw 'Expected at index to be a number but got ' + index + '.';
        }

        result = this.data[index];

        if (result) {
            if (replacement === null) {
                this.data.splice(index, 1);
            } else if (typeof replacement === 'object') {
                this.data[index] = replacement;
            } else if (replacement === undefined && arguments.length >= 2) {
                delete this.data[index];
            } else if (replacement !== undefined) {
                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
            }
        }

        return result;
    },


    /**
     * @memberOf DataSourceOrigin#
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.schema[x].name];
    },

    /**
     * @memberOf DataSourceOrigin#
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.getRow(y)[this.schema[x].name] = value;
    },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {number}
     */
    getRowCount: function() {
        return this.data.length;
    },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {number}
     */
    getColumnCount: function() {
        return this.schema.length;
    },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {number[]}
     */
    getFields: function() {
        return this.schema.map(function(columnSchema) { return columnSchema.name; });
    },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.schema.map(function(columnSchema) { return columnSchema.header; });
    },

    /**
     * @memberOf DataSourceOrigin#
     * @param {string[]} fields
     */
    setFields: function(fields) {
        if (!(Array.isArray(fields) && fields.length === this.schema.length)) {
            throw new this.DataSourceError('Expected argument to be an array with correct length.');
        }
        fields.forEach(function(field, i) {
            this.schema[i].field = field;
        }, this);
    },

    /**
     * @memberOf DataSourceOrigin#
     * @param {string[]} [headers] - If omitted, headers will be reset to their derived defaults on next call to `getHeaders`.
     */
    setHeaders: function(headers) {
        if (!(Array.isArray(headers) && headers.length === this.schema.length)) {
            throw new this.DataSourceError('Expected argument to be an array with correct length.');
        }
        headers.forEach(function(header, i) {
            this.schema[i].header = header;
        }, this);
    }
});


module.exports = DataSourceOrigin;


// Create the `datasaur` namespace and the `datasaur.base` object for use by data sources included via <script> tags:
(window.datasaur = window.datasaur || {}).base = require('fin-hypergrid-data-source-base');

},{"./fields":103,"fin-hypergrid-data-source-base":7}],95:[function(require,module,exports){
/* eslint-env browser */

/**
 * @module localization
 */

'use strict';

var Base = require('../Base');
var deprecated = require('./deprecated');


/**
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale]
 * @param {object} [options]
 * @constructor
 */
var Formatter = Base.extend({
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
            locale = defaultLocale;
        }

        this.locale = locale;

        if (options) {
            if (typeof options.invalid === 'function') {
                this.invalid = options.invalid;
            }

            if (options.expectation) {
                this.expectation = options.expectation;
            }
        }
    }
});


// Safari has no Intl implementation
if (!window.Intl) {
    window.Intl = {
        NumberFormat: function(locale, options) {
            var digits = '0123456789';
            this.format = function(n) {
                var s = n.toString();
                if (!options || options.useGrouping === undefined || options.useGrouping) {
                    var dp = s.indexOf('.');
                    if (dp < 0) {
                        dp = s.length;
                    }
                    while ((dp -= 3) > 0 && digits.indexOf(s[dp - 1]) >= 0) {
                        s = s.substr(0, dp) + ',' + s.substr(dp);
                    }
                }
                return s;
            };
        },
        DateTimeFormat: function(locale, options) {
            this.format = function(date) {
                if (date != null) {
                    if (typeof date !== 'object') {
                        date = new Date(date);
                    }
                    date = date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear();
                } else {
                    date = null;
                }
                return date;
            };
        }
    };
}


/**
 * @summary Create a number localizer.
 * @implements localizerInterface
 * @desc Create an object conforming to {@link localizerInterface} for numbers, using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat|Intl.NumberFormat}.
 * @param {string} defaultLocale
 * @param {string} [locale=defaultLocale] - Passed to the {@link Intl.NumberFormat|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.NumberFormat` constructor.
 * @param {boolean} [options.acceptStandardDigits=false] - Accept standard digits and decimal point interchangeably with localized digits and decimal point. (This option is interpreted here; it is not used by `Intl.NumberFormat`.)
 * @constructor
 * @extends Formatter
 * @tutorial localization
 */
var NumberFormatter = Formatter.extend('NumberFormatter', {
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
        }

        options = options || {};

        this.format = new Intl.NumberFormat(this.locale, options).format;

        var mapperOptions = { useGrouping: false },
            mapper = new Intl.NumberFormat(this.locale, mapperOptions).format;

        this.demapper = demap.bind(this);

        /**
         * @summary A string containing the valid characters.
         * @desc Contains all localized digits + localized decimal point.
         * If we're accepting standard digits, will also contain all the standard digits + standard decimal point (if different than localized versions).
         * @type {string}
         * @private
         * @desc Localized digits and decimal point. Will also include standardized digits and decimal point if `options.acceptStandardDigits` is truthy.
         *
         * For internal use by the {@link NumberFormatter#parse|parse} method.
         * @memberOf NumberFormatter.prototype
         */
        this.map = mapper(10123456789.5).substr(1, 11); // localized '0123456789.'

        if (options.acceptStandardDigits && this.map !== '0123456789.') {
            this.map += '0123456789.';  // standard '0123456789.'
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Localized decimal point
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Standard decimal point (when `options.acceptStandardDigits` is truthy)
         * * Cosmetic characters added by formatter as per `options` (for human-friendly readability).
         *
         * Any characters outside this set are considered invalid.
         *
         * Set by the constructor; consumed by the {@link module:localization~NumberFormatter#invalid|invalid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf NumberFormatter.prototype
         */
        this.invalids = new RegExp(
            '[^' +
            this.format(11111).replace(this.map[1], '') + // thousands separator if in use
            this.map + // digits + decimal point
            ']'
        );
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The number may be unformatted or it may be formatted with any of the permitted formatting characters, as implied by the constructor's `options` (passed to `Intl.NumberFormat`). Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~NumberFormatter#parse|parse}.
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean|string} Falsy means valid which in this case means contains only valid characters.
     * @memberOf NumberFormatter.prototype
     */
    invalid: function(number) {
        return this.invalids.test(number);
    },

    expectation:
        'Expected a number with optional commas (thousands grouping separator), optional decimal point, and an optional fractional part.\n' +
        'Comma separators are part of the format and will always be displayed for values >= 1000.\n' +
        'Edited values are always saved in their entirety even though the formatted value is rounded to the specified number of decimal places.',

    /**
     * This method will:
     * * Convert localized digits and decimal point characters to standard digits and decimal point characters.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} formattedLocalizedNumber - May or may not be formatted.
     * @returns {number} Number primitive.
     * @throws {string} Invalid number.
     * @memberOf NumberFormatter.prototype
     */
    parse: function(formattedLocalizedNumber) {
        var number = Number(
            formattedLocalizedNumber.split('').map(this.demapper).join('')
        );

        if (isNaN(number)) {
            throw 'Invalid Number';
        }

        return number;
    }
});

function demap(c) {
    var d = this.map.indexOf(c) % 11;
    return d < 0 ? '' : d < 10 ? d : '.';
}

/**
 * @implements localizerInterface
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale] - Passed to the {@link Intl.DateFormat|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.DateFormat` constructor.
 * @constructor
 * @extends Formatter
 */
var DateFormatter = Formatter.extend('DateFormatter', {
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
        }

        options = options || {};

        /** @summary Transform a date object into human-friendly string representation.
         * @method
         */
        this.format = new Intl.DateTimeFormat(this.locale, options).format;

        // Get digits because may be chinese or "real Arabic" numerals.
        var testOptions = { useGrouping: false, style: 'decimal' },
            localizeNumber = new Intl.NumberFormat(this.locale, testOptions).format,
            localizedDigits = this.localizedDigits = localizeNumber(10123456789).substr(1, 10); // all localized digits in numerical order

        this.digitFormatter = formatDigit.bind(this);
        this.digitParser = parseDigit.bind(this);

        // Localize a test date with the default numeric parts to find out the resulting order of these parts.
        var yy = 1987,
            mm = 12,
            dd = 30,
            YY = this.transformNumber(this.digitFormatter, yy),
            MM = this.transformNumber(this.digitFormatter, mm),
            DD = this.transformNumber(this.digitFormatter, dd),
            testDate = new Date(yy, mm - 1, dd),
            localizeDate = new Intl.DateTimeFormat(this.locale).format,
            localizedDate = localizeDate(testDate), // all localized digits + localized punctuation
            missingDigits = new Intl.NumberFormat(this.locale).format(456),
            localizedNumberPattern = this.localizedNumberPattern = new RegExp('[' + localizedDigits + ']+', 'g'),
            parts = localizedDate.match(localizedNumberPattern);

        this.partsMap = {
            yy: parts.indexOf(YY),
            mm: parts.indexOf(MM),
            dd: parts.indexOf(DD)
        };

        if (options.acceptStandardDigits) {
            missingDigits += '1234567890';
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Localized punctuation to delimit date parts
         *
         * Any characters outside this set are considered invalid. Note that this only currently implemented when all three date parts are numeric
         *
         * Set by the constructor; consumed by the {@link NumberFormatter#valid|valid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf DateFormatter.prototype
         */
        this.invalids = new RegExp(
            '[^' +
            localizedDate.replace(/-/g, '\\-') +
            missingDigits +
            ']'
        );
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The date is assumed to contain localized digits and punctuation as would be returned by `Intl.DateFormat` with the given `locale` and `options`. Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are also considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~DateFormatter#parse|parse}.
     *
     * NOTE: The current implementation only supports date formats using all numerics (which is the default for `Intl.DateFormat`).
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean} Contains only valid characters.
     * @memberOf DateFormatter.prototype
     */
    invalid: function(number) {
        return this.invalids.test(number);
    },

    /**
     * This method will:
     * * Convert localized date to Date object.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} localizedDate
     * @returns {Date}
     * @throws {string} Invalid date.
     * @memberOf DateFormatter.prototype
     */
    parse: function(localizedDate) {
        var date,
            parts = localizedDate.match(this.localizedNumberPattern);

        if (parts && parts.length === 3) {
            var y = this.transformNumber(this.digitParser, parts[this.partsMap.yy]),
                m = this.transformNumber(this.digitParser, parts[this.partsMap.mm]) - 1,
                d = this.transformNumber(this.digitParser, parts[this.partsMap.dd]);

            date = new Date(y, m, d);
        } else {
            throw 'Invalid Date';
        }

        return date;
    },

    /**
     * Transform a number to or from a string representation with localized digits.
     * @param {function} digitTransformer - A function bound to `this`.
     * @param {number} number
     * @returns {string}
     * @private
     * @memberOf DateFormatter.prototype
     */
    transformNumber: function(digitTransformer, number) {
        return number.toString().split('').map(digitTransformer).join('');
    }
});

function formatDigit(d) {
    return this.localizedDigits[d];
}

function parseDigit(c) {
    var d = this.localizedDigits.indexOf(c);
    if (d < 0) { d = ''; }
    return d;
}

/**
 * All members are localizers (conform to {@link localizerInterface}) with exception of `get`, `set`, and localizer constructors which are named (by convention) ending in "Formmatter".
 *
 * The application developer is free to add localizers and localizer factory methods. See the {@link Localization#construct|construct} convenience method which may be helpful in this regard.
 * @param locale
 * @param {object} [numberOptions]
 * @param {object} [dateOptions]
 * @constructor
 */
function Localization(locale, numberOptions, dateOptions) {
    this.locale = locale;

    /**
     * @name number
     * @see The {@link NumberFormatter|NumberFormatter} class
     * @memberOf Localization.prototype
     */
    this.int = this.float = this.construct('number', NumberFormatter, numberOptions);

    /**
     * @see The {@link DateFormatter|DateFormatter} class
     * @memberOf Localization.prototype
     */
    this.construct('date', DateFormatter, dateOptions);
}

Localization.prototype = {
    constructor: Localization.prototype.constructor,
    $$CLASS_NAME: 'Localization',
    deprecated: deprecated,

    /** @summary Creates a localizer from a localizer factory object using the default locale.
     * @desc Performs the following actions:
     * 1. Binds `Constructor` to `locale`.
     * 2. Adds the newly bound constructor to this object (for future reference) with the key "NameFormatter" (where "Name" is the localizer name, all lower case but with an initial capital).
     * 3. Uses the newly bound constructor to create a new localized localizer with the provided options.
     * 4. Adds new localizer to this object via {@link Localization#add|add}.
     *
     * @param {string} localizerName
     * @param {Constructor
     * @param {object} {factoryOptions}
     * @returns {localizerInterface} The new localizer.
     */
    construct: function(localizerName, Constructor, factoryOptions) {
        var constructorName = localizerName[0].toUpperCase() + localizerName.substr(1).toLowerCase() + 'Formatter',
            BoundConstructor = Constructor.bind(null, this.locale),
            localizer = new BoundConstructor(factoryOptions);

        this[constructorName] = BoundConstructor;

        return this.add(localizerName, localizer);
    },

    /** @summary Register a localizer.
     * @desc Checks the provided localizer that it conforms to {@link localizerInterface}
     * and adds it to the object using localizerName all lower case as the key.
     * @param {string} name
     * @param {localizerInterface} localizer
     * @memberOf Localization.prototype
     * @returns {localizerInterface} The provided localizer.
     */
    add: function(name, localizer) {
        if (typeof name === 'object') {
            localizer = name;
            name = undefined;
        }

        if (
            typeof localizer !== 'object' ||
            typeof localizer.format !== 'function' ||
            typeof localizer.parse !== 'function' ||
            localizer.invalid && typeof localizer.invalid !== 'function' ||
            localizer.expectation && typeof localizer.expectation !== 'string'
        ) {
            throw 'Expected localizer object to conform to interface.';
        }

        name = name || localizer.name;
        name = name && name.toLowerCase();
        this[name] = localizer;

        return localizer;
    },

    set: function(name) {
        return this.deprecated('set(name, localizer)', 'add(name, localizer)', '1.0.6', arguments);
    },

    /**
     *
     * @param localizerName
     * @returns {localizerInterface}
     * @memberOf Localization.prototype
     */
    get: function(name) {
        return this[name && name.toLowerCase()] || this.string;
    },

    ///  ///  ///  ///  ///    LOCALIZERS    ///  ///  ///  ///  ///

    // Special localizer for use by Chrome's date input control.
    chromeDate: {
        format: function(date) {
            if (date != null) {
                if (typeof date !== 'object') {
                    date = new Date(date);
                }

                var yy = date.getFullYear(),
                    m = date.getMonth() + 1, mm = m < 10 ? '0' + m : m,
                    d = date.getDate(), dd = d < 10 ? '0' + d : d;

                date = yy + '-' + mm + '-' + dd;
            } else {
                date = null;
            }
            return date;
        },
        parse: function(str) {
            var date,
                parts = str.split('-');
            if (parts && parts.length === 3) {
                date = new Date(parts[0], parts[1] - 1, parts[2]);
            } else {
                date = null;
            }
            return date;
        }
    },

    null: {
        format: function(value) {
            return value;
        },
        parse: function(str) {
            return str;
        }
    },

    string: {
        format: function(value) {
            return value + '';
        },
        parse: function(str) {
            return str + '';
        }
    }
};

module.exports = Localization;

},{"../Base":41,"./deprecated":99}],96:[function(require,module,exports){
'use strict';

var RangeSelectionModel = require('sparse-boolean-array');

/**
 *
 * @constructor
 * @desc We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains. This is how we know to highlight the fixed regions on the edges of the grid.
 */

function SelectionModel(grid) {
    this.grid = grid;
    this.reset();
}

SelectionModel.prototype = {

    constructor: SelectionModel.prototype.constructor,

    /**
     * @type {boolean}
     * @memberOf SelectionModel.prototype
     */
    allRowsSelected: false,

    reset: function() {
        /**
         * @name selections
         * @type {Rectangle[]}
         * @summary The selection rectangles.
         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.selections = [];

        /**
         * @name flattenedX
         * @type {Rectangle[]}
         * @summary The selection rectangles flattened in the horizontal direction (no width).
         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.flattenedX = [];

        /**
         * @name flattenedY
         * @type {Rectangle[]}
         * @summary The selection rectangles flattened in the vertical direction (no height).
         * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.flattenedY = [];

        /**
         * @name rowSelectionModel
         * @type {RangeSelectionModel}
         * @summary The selection rectangles.
         * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.rowSelectionModel = new RangeSelectionModel();

        /**
         * @name columnSelectionModel
         * @type {RangeSelectionModel}
         * @summary The selection rectangles.
         * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
         * @memberOf SelectionModel.prototype
         */
        this.columnSelectionModel = new RangeSelectionModel();

        this.setLastSelectionType('');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelection: function() {
        var sels = this.selections;
        var sel = sels[sels.length - 1];
        return sel;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelectionType: function() {
        return this.lastSelectionType;
    },

    /**
     * @param type
     * @memberOf SelectionModel.prototype
     */
    setLastSelectionType: function(type) {
        this.lastSelectionType = type;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @description Select the region described by the given coordinates.
     *
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @param {boolean} silent - whether to fire selection changed event
     */
    select: function(ox, oy, ex, ey, silent) {
        var newSelection = this.grid.newRectangle(ox, oy, ex, ey);

        //Cache the first selected cell before it gets normalized to top-left origin
        newSelection.firstSelectedCell = this.grid.newPoint(ox, oy);

        newSelection.lastSelectedCell = (
            newSelection.firstSelectedCell.x === newSelection.origin.x &&
            newSelection.firstSelectedCell.y === newSelection.origin.y
        )
            ? newSelection.corner
            : newSelection.origin;

        if (this.grid.properties.multipleSelections) {
            this.selections.push(newSelection);
            this.flattenedX.push(newSelection.flattenXAt(0));
            this.flattenedY.push(newSelection.flattenYAt(0));
        } else {
            this.selections[0] = newSelection;
            this.flattenedX[0] = newSelection.flattenXAt(0);
            this.flattenedY[0] = newSelection.flattenYAt(0);
        }
        this.setLastSelectionType('cell');

        if (!silent) {
            this.grid.selectionChanged();
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    toggleSelect: function(ox, oy, ex, ey) {

        var selected, index;

        selected = this.selections.find(function(selection, idx) {
            index = idx;
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });

        if (selected) {
            this.selections.splice(index, 1);
            this.flattenedX.splice(index, 1);
            this.flattenedY.splice(index, 1);
            this.grid.selectionChanged();
        } else {
            this.select(ox, oy, ex, ey);
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Remove the last selection that was created.
     */
    clearMostRecentSelection: function(keepRowSelections) {
        if (!keepRowSelections) {
            this.setAllRowsSelected(false);
        }
        if (this.selections.length) { --this.selections.length; }
        if (this.flattenedX.length) { --this.flattenedX.length; }
        if (this.flattenedY.length) { --this.flattenedY.length; }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentColumnSelection: function() {
        this.columnSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentRowSelection: function() {
        this.rowSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearRowSelection: function() {
        this.rowSelectionModel.clear();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelections: function() {
        return this.selections;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean} There are active selection(s).
     */
    hasSelections: function() {
        return this.selections.length !== 0;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasRowSelections: function() {
        return !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasColumnSelections: function() {
        return !this.columnSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @return {boolean} Selection covers a specific column.
     * @param {number} y
     */
    isCellSelectedInRow: function(y) {
        return this._isCellSelected(this.flattenedX, 0, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns Selection covers a specific row.
     * @param {number} x
     */
    isCellSelectedInColumn: function(x) {
        return this._isCellSelected(this.flattenedY, x, 0);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @summary Selection query function.
     * @returns {boolean} The given cell is selected (part of an active selection).
     * @param {Rectangle[]} selections - Selection rectangles to search through.
     * @param {number} x
     * @param {number} y
     */
    isSelected: function(x, y) {
        return (
            this.isColumnSelected(x) ||
            this.isRowSelected(y) ||
            this._isCellSelected(this.selections, x, y)
        );
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isCellSelected: function(x, y) {
        return this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param selections
     * @param x
     * @param y
     * @returns {boolean}
     * @private
     */
    _isCellSelected: function(selections, x, y) {
        var self = this;
        return !!selections.find(function(selection) {
            return self.rectangleContains(selection, x, y);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc empty out all our state
     *
     */
    clear: function(keepRowSelections) {
        this.selections.length = 0;
        this.flattenedX.length = 0;
        this.flattenedY.length = 0;
        this.columnSelectionModel.clear();
        if (!keepRowSelections) {
            this.setAllRowsSelected(false);
            this.rowSelectionModel.clear();
        }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @returns {boolean}
     */
    isRectangleSelected: function(ox, oy, ex, ey) {
        return !!this.selections.find(function(selection) {
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @returns {*}
     */
    isColumnSelected: function(x) {
        return this.columnSelectionModel.isSelected(x);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y
     * @returns {boolean|*}
     */
    isRowSelected: function(y) {
        return this.allRowsSelected || this.rowSelectionModel.isSelected(y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    selectColumn: function(x1, x2) {
        this.columnSelectionModel.select(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    selectAllRows: function() {
        this.clear();
        this.setAllRowsSelected(true);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */

    setAllRowsSelected: function(isIt) {
        this.allRowsSelected = isIt;
    },

    areAllRowsSelected: function() {
        return this.allRowsSelected;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    selectRow: function(y1, y2) {
        this.rowSelectionModel.select(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    deselectColumn: function(x1, x2) {
        this.columnSelectionModel.deselect(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    deselectRow: function(y1, y2) {
        if (this.areAllRowsSelected()) {
            // To deselect a row, we must first remove the all rows flag...
            this.setAllRowsSelected(false);
            // ...and create a single range representing all rows
            this.rowSelectionModel.select(0, this.grid.getRowCount() - 1);
        }
        this.rowSelectionModel.deselect(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelectedRows: function() {
        if (this.areAllRowsSelected()) {
            var headerRows = this.grid.getHeaderRowCount();
            var rowCount = this.grid.getRowCount() - headerRows;
            var result = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                result[i] = i + headerRows;
            }
            return result;
        }
        return this.rowSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*|Array.Array.number}
     */
    getSelectedColumns: function() {
        return this.columnSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
     isColumnOrRowSelected: function() {
        return !this.columnSelectionModel.isEmpty() || !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {Array}
     */
    getFlattenedYs: function() {
        var result = [];
        var set = {};
        this.selections.forEach(function(selection) {
            var top = selection.origin.y;
            var size = selection.extent.y + 1;
            for (var r = 0; r < size; r++) {
                var ti = r + top;
                if (!set[ti]) {
                    result.push(ti);
                    set[ti] = true;
                }
            }
        });
        result.sort(function(x, y) {
            return x - y;
        });
        return result;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectRowsFromCells: function(offset, keepRowSelections) {
        offset = offset || 0;

        var sm = this.rowSelectionModel;

        if (!keepRowSelections) {
            this.setAllRowsSelected(false);
            sm.clear();
        }

        this.selections.forEach(function(selection) {
            var top = selection.origin.y,
                extent = selection.extent.y;
            top += offset;
            sm.select(top, top + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectColumnsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.columnSelectionModel;
        sm.clear();

        this.selections.forEach(function(selection) {
            var left = selection.origin.x,
                extent = selection.extent.x;
            left += offset;
            sm.select(left, left + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isInCurrentSelectionRectangle: function(x, y) {
        var last = this.selections[this.selections.length - 1];
        return last && this.rectangleContains(last, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param rect
     * @param x
     * @param y
     * @returns {boolean}
     */
    rectangleContains: function(rect, x, y) { //TODO: explore why this works and contains on rectanglular does not
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }
};

module.exports = SelectionModel;

},{"sparse-boolean-array":40}],97:[function(require,module,exports){
'use strict';

var Point = require('rectangular').Point;

/**
 * Variation of `rectangular.Point` but with writable `x` and `y`
 * @constructor
 */
function WritablePoint(x, y) {
    // skip x and y initialization here for performance
    // because typically reset after instantiation
}

WritablePoint.prototype = Point.prototype;

module.exports = WritablePoint;

},{"rectangular":39}],98:[function(require,module,exports){
'use strict';

var deprecated = require('./deprecated');
var WritablePoint = require('./WritablePoint');

var writableDescriptor = { writable: true };
var eumerableDescriptor = { writable: true, enumerable: true };

// The nullSubgrid is for CellEvents representing clicks below last row.
// var nullSubgrid = {};

var prototype = Object.defineProperties({}, {
    value: {
        get: function() { return this.visibleRow.subgrid.getValue(this.dataCell.x, this.dataCell.y); },
        set: function(value) { this.visibleRow.subgrid.setValue(this.dataCell.x, this.dataCell.y, value); }
    },

    dataRow: {
        get: function() { return this.visibleRow.subgrid.getRow(this.dataCell.y); }
    },

    formattedValue: {
        get: function() { return this.grid.formatValue(this.properties.format, this.value); }
    },

    bounds: { get: function() {
        return this._bounds || (this._bounds = {
            x: this.visibleColumn.left,
            y: this.visibleRow.top,
            width: this.visibleColumn.width,
            height: this.visibleRow.height
        });
    } },

    columnProperties: { get: function() {
        var cp = this._columnProperties;
        if (!cp) {
            cp = this.column.properties;
            if (this.isHandleColumn || this.isHierarchyColumn) {
                cp = cp.rowHeader;
            } else if (this.isDataRow) {
                // cp already set to basic props
            } else if (this.isFilterRow) {
                cp = cp.filterProperties;
            } else { // unselected header, summary, etc., all have save look as unselected header
                cp = cp.columnHeader;
            }
            this._columnProperties = cp;
        }
        return cp;
    } },
    cellOwnProperties: { get: function() { // do not use for get/set prop because may return null; instead use  .getCellProperty('prop') or .properties.prop (preferred) to get and setCellProperty('prop', value) to set
        if (this._cellOwnProperties === undefined) {
            this._cellOwnProperties = this.column.getCellOwnProperties(this.dataCell.y, this.visibleRow.subgrid);
        }
        return this._cellOwnProperties; // null return means there is no cell properties object
    } },
    properties: { get: function() {
        return this.cellOwnProperties || this.columnProperties;
    } },
    getCellProperty: { value: function(key) { // included for completeness but .properties[key] is preferred
        return this.properties[key];
    } },
    setCellProperty: { value: function(key, value) { // do not use .cellOwnProperties[key] = value because object may be null (this method creates object as needed)
        this._cellOwnProperties = this.column.setCellProperty(this.dataCell.y, key, value, this.visibleRow.subgrid);
    } },

    // special methods for use by renderer which reuses cellEvent object for performance reasons
    reset: { value: function(visibleColumn, visibleRow) {
        // getter caches
        this._columnProperties = undefined;
        this._cellOwnProperties = undefined;
        this._bounds = undefined;

        // partial render support
        this.snapshot = undefined;
        this.minWidth = undefined;
        this.disabled = undefined;

        this.visibleColumn = visibleColumn;
        this.visibleRow = visibleRow;

        this.subgrid = visibleRow.subgrid;

        this.column = visibleColumn.column; // enumerable so will be copied to cell renderer object

        this.gridCell.x = visibleColumn.columnIndex;
        this.gridCell.y = visibleRow.index;

        this.dataCell.x = this.column && this.column.index;
        this.dataCell.y = visibleRow.rowIndex;
    } },

    /**
     * Set up this `CellEvent` instance to point to the cell at the given grid coordinates.
     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
     * @param {number} gridC - Horizontal grid cell coordinate adjusted for horizontal scrolling after fixed columns.
     * @param {number} gridY - Raw vertical grid cell coordinate.
     * @returns {boolean} Visibility.
     * @memberOf CellEvent#
     */
    resetGridCY: { value: function(gridC, gridY) {
        var vr, vc, visible = (vc = this.renderer.getVisibleColumn(gridC)) && (vr = this.renderer.getVisibleRow(gridY));
        if (visible) { this.reset(vc, vr); }
        return visible;
    } },

    /**
     * Set up this `CellEvent` instance to point to the cell at the given grid coordinates.
     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
     * @param {number} gridX - Raw horizontal grid cell coordinate.
     * @param {number} gridY - Raw vertical grid cell coordinate.
     * @returns {boolean} Visibility.
     * @memberOf CellEvent#
     */
    resetGridXY: { value: function(gridX, gridY) {
        var vr, vc, visible = (vc = this.renderer.visibleColumns[gridX]) && (vr = this.renderer.getVisibleRow(gridY));
        if (visible) { this.reset(vc, vr); }
        return visible;
    } },

    /**
     * @summary Set up this `CellEvent` instance to point to the cell at the given data coordinates.
     * @desc If the requested cell is not be visible (due to being scrolled out of view), the instance is not reset.
     * @param {number} dataX - Horizontal data cell coordinate.
     * @param {number} dataY - Vertical data cell coordinate.
     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
     * @returns {boolean} Visibility.
     * @memberOf CellEvent#
     */
    resetDataXY: { value: function(dataX, dataY, subgrid) {
        var vr, vc, visible = (vc = this.renderer.getVisibleDataColumn(dataX)) && (vr = this.renderer.getVisibleDataRow(dataY, subgrid));
        if (visible) { this.reset(vc, vr); }
        return visible;
    } },

    /**
     * Set up this `CellEvent` instance to point to the cell at the given grid column and data row coordinates.
     * @desc If the requested cell is not be visible (due to being scrolled out of view or outside the bounds of the rendered grid), the instance is not reset.
     * @param {number} gridX - Horizontal grid cell coordinate (adjusted for horizontal scrolling after fixed columns).
     * @param {number} dataY - Vertical data cell coordinate.
     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
     * @returns {boolean} Visibility.
     * @memberOf CellEvent#
     */
    resetGridXDataY: { value: function(gridX, dataY, subgrid) {
        var vr, vc, visible = (vc = this.renderer.getVisibleColumn(gridX)) && (vr = this.renderer.getVisibleDataRow(dataY, subgrid));
        if (visible) { this.reset(vc, vr); }
        return visible && this;
    } },

    /**
     * Copy self with or without own properties
     * @param {boolan} [assign=false] - Copy the own properties to the clone.
     * @returns {CellEvent}
     * @memberOf CellEvent#
     */
    clone: { value: function(assign) {
        var cellEvent = new this.constructor;

        cellEvent.resetGridXY(this.visibleColumn.index, this.visibleRow.index);

        if (assign) {
            // copy own props
            Object.assign(cellEvent, this);
        }

        return cellEvent;
    } },

    editPoint: {
        get: function() {
            throw 'The `.editPoint` property is no longer available as of v1.2.10. Use the following coordinates instead:\n' +
            '`.gridCell.x` - The active column index. (Adjusted for column scrolling after fixed columns.)\n' +
            '`.gridCell.y` - The vertical grid coordinate. (Unaffected by row scrolling.)\n' +
            '`.dataCell.x` - The data model\'s column index. (Unaffected by column scrolling.)\n' +
            '`.dataCell.y` - The data model\'s row index. (Adjusted for data row scrolling after fixed rows.)\n';
        }
    },

    // "Visible" means scrolled into view.
    isRowVisible:    { get: function() { return !!this.visibleRow; } },
    isColumnVisible: { get: function() { return !!this.visibleColumn; } },
    isCellVisible:   { get: function() { return this.isRowVisible && this.isColumnVisible; } },

    isDataRow:    { get: function() { return this.visibleRow.subgrid.isData; } },
    isDataColumn: { get: function() { return this.gridCell.x >= 0; } },
    isDataCell:   { get: function() { return this.isDataRow && this.isDataColumn; } },

    isRowSelected:    { get: function() { return this.isDataRow && this.selectionModel.isRowSelected(this.dataCell.y); } },
    isColumnSelected: { get: function() { return this.isDataColumn && this.selectionModel.isColumnSelected(this.gridCell.x); } },
    isCellSelected:   { get: function() { return this.selectionModel.isCellSelected(this.gridCell.x, this.dataCell.y); } },

    isRowHovered:    { get: function() { return this.isDataRow && this.grid.hoverCell && this.grid.hoverCell.y === this.gridCell.y; } },
    isColumnHovered: { get: function() { return this.isDataColumn && this.grid.hoverCell && this.grid.hoverCell.x === this.gridCell.x; } },
    isCellHovered:   { get: function() { return this.isRowHovered && this.isColumnHovered; } },

    isRowFixed:    { get: function() { return this.isDataRow && this.dataCell.y < this.grid.properties.fixedRowCount; } },
    isColumnFixed: { get: function() { return this.isDataColumn && this.gridCell.x < this.grid.properties.fixedColumnCount; } },
    isCellFixed:   { get: function() { return this.isRowFixed && this.isColumnFixed; } },

    isHandleColumn: { get: function() { return !this.isDataColumn; } },
    isHandleCell:   { get: function() { return this.isHandleColumn && this.isDataRow; } },

    isHierarchyColumn: { get: function() { return this.gridCell.x === 0 && this.grid.properties.showTreeColumn && this.dataModel.isDrillDown(this.dataCell.x); } },

    isHeaderRow:    { get: function() { return this.visibleRow.subgrid.isHeader; } },
    isHeaderHandle: { get: function() { return this.isHeaderRow && this.isHandleColumn; } },
    isHeaderCell:   { get: function() { return this.isHeaderRow && this.isDataColumn; } },

    isFilterRow:    { get: function() { return this.visibleRow.subgrid.isFilter; } },
    isFilterHandle: { get: function() { return this.isFilterRow && this.isHandleColumn; } },
    isFilterCell:   { get: function() { return this.isFilterRow && this.isDataColumn; } },

    isSummaryRow:    { get: function() { return this.visibleRow.subgrid.isSummary; } },
    isSummaryHandle: { get: function() { return this.isSummaryRow && this.isHandleColumn; } },
    isSummaryCell:   { get: function() { return this.isSummaryRow && this.isDataColumn; } },

    isTopTotalsRow:    { get: function() { return this.visibleRow.subgrid === this.behavior.subgrids.lookup.topTotals; } },
    isTopTotalsHandle: { get: function() { return this.isTopTotalsRow && this.isHandleColumn; } },
    isTopTotalsCell:   { get: function() { return this.isTopTotalsRow && this.isDataColumn; } },

    isBottomTotalsRow:    { get: function() { return this.visibleRow.subgrid === this.behavior.subgrids.lookup.bottomTotals; } },
    isBottomTotalsHandle: { get: function() { return this.isBottomTotalsRow && this.isHandleColumn; } },
    isBottomTotalsCell:   { get: function() { return this.isBottomTotalsRow && this.isDataColumn; } },

    $$CLASS_NAME: { value: 'CellEvent' },
    deprecated: { value: deprecated },

    isGridRow: { get: function() {
        this.deprecated('isGridRow', '.isGridRow is deprecated as of v1.2.10 in favor of .isDataRow. (Will be removed in a future release.)');
        return this.isDataRow;
    } },
    isGridColumn: { get: function() {
        this.deprecated('isGridColumn', '.isGridColumn is deprecated as of v1.2.10 in favor of .isDataColumn. (Will be removed in a future release.)');
        return this.isDataColumn;
    } },
    isGridCell: { get: function() {
        this.deprecated('isGridCell', '.isGridCell is deprecated as of v1.2.10 in favor of .isDataCell. (Will be removed in a future release.)');
        return this.isDataCell;
    } },
});

/**
 * @classdesc `CellEvent` is a very low-level object that needs to be super-efficient. JavaScript objects are well known to be light weight in general, but at this level we need to be careful.
 *
 * These objects were originally only being created on mouse events. This was no big deal as mouse events are few and far between. However, as of v1.2.0, the renderer now also creates one for each visible cell on each and every grid paint.
 *
 * For this reason, to maintain performance, each grid gets a custom definition of `CellEvent`, created by this class factory, with the following optimizations:
 *
 * * Use of `extend-me` is avoided because its `initialize` chain is a bit too heavy here.
 * * Custom versions of `CellEvent` for each grid lightens the load on the constructor.
 *
 * @summary Create a custom `CellEvent` class.
 *
 * @desc Create a custom definition of `CellEvent` for each grid instance, setting the `grid`, `behavior`, and `dataModel` properties on the prototype. As this happens once per grid instantiation, it avoids having to perform this set up work on every `CellEvent` instantiation.
 *
 * @param {HyperGrid} grid
 *
 * @returns {CellEvent}
 */
function factory(grid) {

    /**
     * @summary Create a new CellEvent object.
     * @desc All own enumerable properties are mixed into cell editor:
     * * Includes `this.column` defined by constructor (as enumerable).
     * * Excludes `this.gridCell`, `this.dataCell`, `this.visibleRow.subgrid` defined by constructor (as non-enumerable).
     * * Any additional (enumerable) members mixed in by application's `getCellEditorAt` override.
     *
     * Omit params to defer the convenience call to {CellEvent#resetGridCY}.
     * (See also the alternative {@link CellEvent#resetGridXY}; and {@link CellEvent#resetDataXY} which accepts `dataX`, `dataY`.)
     *
     * @param {number} [gridX] - grid cell coordinate (adjusted for horizontal scrolling after fixed columns).
     * @param {number} [gridY] - grid cell coordinate, adjusted (adjusted for vertical scrolling if data subgrid)
     * @constructor
     */
    function CellEvent(gridX, gridY) {
        // remaining instance vars are non-enumerable so `CellEditor` constructor won't mix them in (for mustache use).
        Object.defineProperties(this, {
            /**
             * @name visibleColumn
             * @type {visibleColumnDescriptor}
             * @memberOf CellEvent#
             */
            visibleColumn: writableDescriptor,

            /**
             * @name visibleRow
             * @type {visibleRowDescriptor}
             * @memberOf CellEvent#
             */
            visibleRow: writableDescriptor,

            /**
             * @name subgrid
             * @type {dataModelAPI}
             * @memberOf CellEvent#
             */
            subgrid: writableDescriptor,

            /**
             * @name gridCell
             * @type {WritablePoint}
             * @memberOf CellEvent#
             */
            gridCell: {
                value: new WritablePoint
            },

            /**
             * @name dataCell
             * @type {WritablePoint}
             * @memberOf CellEvent#
             */
            dataCell: {
                value: new WritablePoint
            },

            // column is enumerable so it will be copied to cell event on CellEvent.prototype.initialize.
            column: eumerableDescriptor,

            // getter caches
            _columnProperties: writableDescriptor,
            _cellOwnProperties: writableDescriptor,
            _bounds: writableDescriptor,

            // Following supports cell renderers' "partial render" capability:
            snapshot: writableDescriptor,
            minWidth: writableDescriptor,
            disabled: writableDescriptor
        });

        if (arguments.length) {
            this.resetGridCY(gridX, gridY);
        }
    }

    CellEvent.prototype = Object.create(prototype);

    Object.defineProperties(CellEvent.prototype, {
        constructor: { value: CellEvent },
        grid: { value: grid },
        renderer: { value: grid.renderer },
        selectionModel: { value: grid.selectionModel },
        behavior: { value: grid.behavior },
        dataModel: { value: grid.behavior.dataModel }
    });

    return CellEvent;
}

module.exports = factory;

},{"./WritablePoint":97,"./deprecated":99}],99:[function(require,module,exports){
'use strict';

// console.warn polyfill as needed
// used for deprecation warnings
if (!console.warn) {
    console.warn = function() {
        console.log.apply(console, ['WARNING:'].concat(Array.prototype.slice.call(arguments)));
    };
}

var classWarned = {};

var regexIsMethod = /^\w+\(.*\)$/;

/**
 * User is warned and new property is returned or new method is called and the result is returned.
 * @param {string} methodName - Warning key paired with arbitrary warning in `dotProps` OR deprecated method name with parentheses containing optional argument list paired with replacement property or method in `dotProps`.
 * @param {string} dotProps - Arbitrary warning paired with warning key in `methodName` OR dot-separated new property name to invoke or method name to call. Method names are indicated by including parentheses with optional argument list. The arguments in each list are drawn from the arguments presented in the `methodName` parameter.
 * @param {string} since - Version in which the name was deprecated.
 * @param {Arguments|Array} [args] - The actual arguments in the order listed in `methodName`. Only needed when arguments need to be forwarded.
 * @param {string} [notes] - Notes to add to message.
 * @returns {*} Return value of new property or method call.
 */
var deprecated = function(methodName, dotProps, since, args, notes) {
    if (typeof args === 'string') {
        // `args` omitted
        notes = args;
        args = undefined;
    }

    var chain = dotProps.split('.'),
        warned = classWarned[this.$$CLASS_NAME] = classWarned[this.$$CLASS_NAME] || {},
        result = this,
        isSimpleWarning = dotProps.indexOf(' ') >= 0,
        isMethodCall = regexIsMethod.test(methodName),
        memberType,
        warning;

    if (!(methodName in warned)) {
        warned[methodName] = deprecated.warnings;
    }

    if (isMethodCall) {
        if (isSimpleWarning) {
            throw 'Expected replacement method or property in 2nd parameter of deprecated() call.';
        } else if (warned[methodName]) {
            --warned[methodName];
            memberType = regexIsMethod.test(dotProps) ? 'method' : 'property';
            warning = 'The .' + methodName + ' method is deprecated as of v' + since +
                ' in favor of the .' + chain.join('.') + ' ' + memberType + '.' +
                ' (Will be removed in a future release.)';

            if (notes) {
                warning += ' ' + notes;
            }

            console.warn(warning);
        }
    } else if (isSimpleWarning) {
        if (warned[methodName]) {
            --warned[methodName];
            console.warn(dotProps);
        }
        return;
    } else {
        throw 'Expected method name with parentheses in 1st parameter OR simple warning (containing one or more spaces) in 2nd parameter of deprecated() call.';
    }

    var formalArgList = argList(methodName);

    function mapToFormalArg(argName) {
        var index = formalArgList.indexOf(argName);
        if (index === -1) {
            throw 'Actual arg "' + argName + '" not found in formal arg list ' + formalArgList;
        }
        return args[index];
    }

    for (var i = 0, last = chain.length - 1; i <= last; ++i) {
        var link = chain[i],
            name = link.match(/\w+/)[0],
            linkIsMethodCall = regexIsMethod.test(link),
            actualArgList = linkIsMethodCall ? argList(link) : undefined,
            actualArgs = [];

        if (actualArgList) {
            actualArgs = actualArgList.map(mapToFormalArg);
            result = result[name].apply(result, actualArgs);
        } else if (linkIsMethodCall) {
            result = result[name]();
        } else {
            result = result[name];
        }
    }

    return result;
};

deprecated.warnings = 1; // 3 or 5 would get more attention

function argList(s) {
    return s.match(/^\w+\((.*)\)$/)[1].match(/(\w+)/g);
}

module.exports = deprecated;

},{}],100:[function(require,module,exports){
'use strict';

var defaults = require('../defaults');

/**
 * @summary Dynamic property getter/setters.
 * @desc Dynamic properties can make use of a backing store.
 * This backing store is created in the "own" layer by {@link Hypergrid#clearState|clearState}.
 * The members of the backing store have the same names as the dynamic properties that utilize them.
 * They are initialized by {@link Hypergrid#clearState|clearState} to the default values from {@link module:defaults|defaults} object members (also) of the same name.
 *
 * Note: Because this initialization picks up the values from {@link module:defaults|defaults} when {@link Hypergrid#clearState|clearState} is called, any changes the application developer may wish to make to {@link module:defaults|defaults} should be made _prior to_ any grid instantiations.
 * @name dynamicProperties
 * @module
 */
var dynamicProperties = Object.create(defaults, {
    /**
     * @memberOf module:dynamicProperties
     */
    gridRenderer: {
        get: function() {
            return this.var.gridRenderer;
        },
        set: function(rendererName) {
            this.var.gridRenderer = rendererName;
            this.grid.renderer.setGridRenderer(rendererName);
        }
    },

    /**
     * @memberOf module:dynamicProperties
     */
    columnIndexes: {
        get: function() {
            return this.grid.behavior.getActiveColumns().map(function(column) { return column.index; });
        },
        set: function(columnIndexes) {
            this.grid.behavior.setColumnOrder(columnIndexes);
            this.grid.behavior.changed();
        }
    },
});

module.exports = dynamicProperties;

},{"../defaults":74}],101:[function(require,module,exports){
'use strict';

function HypergridError(message) {
    this.message = message;
}

// extend from `Error`
HypergridError.prototype = Object.create(Error.prototype);

// override error name displayed in console
HypergridError.prototype.name = 'HypergridError';

module.exports = HypergridError;

},{}],102:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var Behavior = require('../behaviors/Behavior');

module.exports = {

    /**
     * @summary Add an event listener to me.
     * @desc Listeners added by this method should only be removed by {@link Hypergrid#removeEventListener|grid.removeEventListener} (or {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners}).
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} listener - The event handler.
     * @param {boolean} [internal=false] - Used by {@link Hypergrid#addInternalEventListener|grid.addInternalEventListener} (see).
     * @memberOf Hypergrid#
     */
    addEventListener: function(eventName, listener, internal) {
        var self = this,
            listeners = this.listeners[eventName] = this.listeners[eventName] || [],
            alreadyAttached = listeners.find(function(info) { return info.listener === listener; });

        if (!alreadyAttached) {
            var info = {
                internal: internal,
                listener: listener,
                decorator: function(e) {
                    if (self.allowEventHandlers){
                        listener(e);
                    }
                }
            };
            listeners.push(info);
            this.canvas.addEventListener(eventName, info.decorator);
        }
    },

    /**
     * @summary Add an internal event listener to me.
     * @desc The new listener is flagged as "internal." Internal listeners are removed as usual by {@link Hypergrid#removeEventListener|grid.removeEventListener}. However, they are ignored by {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners()} (as called by {@link Hypergrid#reset|reset}). (But see {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners(true)}.)
     *
     * Listeners added by this method should only be removed by {@link Hypergrid#removeEventListener|grid.removeEventListener} (or {@link Hypergrid#removeAllEventListeners|grid.removeAllEventListeners(true)}).
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} listener - The event handler.
     * @memberOf Hypergrid#
     */
    addInternalEventListener: function(eventName, listener) {
        this.addEventListener(eventName, listener, true);
    },

    /**
     * @summary Remove an event listeners.
     * @desc Removes the event listener with matching name and function that was added by {@link Hypergrid#addEventListener|grid.addEventListener}.
     *
     * NOTE: This method cannot remove event listeners added by other means.
     * @memberOf Hypergrid#
     */
    removeEventListener: function(eventName, listener) {
        var listenerList = this.listeners[eventName];

        if (listenerList) {
            listenerList.find(function(info, index) {
                if (info.listener === listener) {
                    listenerList.splice(index, 1); // remove it from the list
                    this.canvas.removeEventListener(eventName, info.decorator);
                    return true;
                }
            }, this);
        }
    },

    /**
     * @summary Remove all event listeners.
     * @desc Removes all event listeners added with {@link Hypergrid#addEventListener|grid.addEventListener} except those added as "internal."
     * @param {boolean} [internal=false] - Include internal listeners.
     * @memberOf Hypergrid#
     */
    removeAllEventListeners: function(internal) {
        _(this.listeners).each(function(listenerList, key) {
            listenerList.forEach(function(info) {
                if (internal || !info.internal) {
                    this.removeEventListener(key, info.listener);
                }
            }, this);
        }, this);
    },

    allowEvents: function(allow){
        if ((this.allowEventHandlers = !!allow)){
            this.behavior.featureChain.attachChain();
        } else {
            this.behavior.featureChain.detachChain();
        }

        this.behavior.changed();
    },

    /**
     * @memberOf Hypergrid#
     * @param {number} c - grid column index.
     * @param {string[]} keys
     */
    fireSyntheticColumnSortEvent: function(c, keys) {
        return dispatchEvent.call(this, 'fin-column-sort', {
            column: c,
            keys: keys
        });
    },

    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
        return dispatchEvent.call(this, 'fin-editor-keyup', {
            input: inputControl,
            keyEvent: keyEvent,
            char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
        });
    },

    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
        return dispatchEvent.call(this, 'fin-editor-keydown', {
            input: inputControl,
            keyEvent: keyEvent,
            char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
        });
    },

    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
        return dispatchEvent.call(this, 'fin-editor-keypress', {
            input: inputControl,
            keyEvent: keyEvent,
            char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
        });
    },

    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
        return dispatchEvent.call(this, 'fin-editor-data-change', true, {
            input: inputControl,
            oldValue: oldValue,
            newValue: newValue
        });
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-row-selection-changed` event.
     */
    fireSyntheticRowSelectionChangedEvent: function() {
        return dispatchEvent.call(this, 'fin-row-selection-changed', {
            rows: this.getSelectedRows(),
            columns: this.getSelectedColumns(),
            selections: this.selectionModel.getSelections(),
        });
   },

    fireSyntheticColumnSelectionChangedEvent: function() {
        return dispatchEvent.call(this, 'fin-column-selection-changed', {
            rows: this.getSelectedRows(),
            columns: this.getSelectedColumns(),
            selections: this.selectionModel.getSelections()
        });
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-context-menu` event
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticContextMenuEvent: function(event) {
        event.rows = this.getSelectedRows();
        event.columns = this.getSelectedColumns();
        event.selections = this.selectionModel.getSelections();
        return dispatchEvent.call(this, 'fin-context-menu', {}, event);
    },

    fireSyntheticMouseUpEvent: function(event) {
        event.rows = this.getSelectedRows();
        event.columns = this.getSelectedColumns();
        event.selections = this.selectionModel.getSelections();
        return dispatchEvent.call(this, 'fin-mouseup', {}, event);
    },

    fireSyntheticMouseDownEvent: function(event) {
        event.rows = this.getSelectedRows();
        event.columns = this.getSelectedColumns();
        event.selections = this.selectionModel.getSelections();
        return dispatchEvent.call(this, 'fin-mousedown', {}, event);
    },

    fireSyntheticMouseMoveEvent: function(event) {
        return dispatchEvent.call(this, 'fin-mousemove', {}, event);
    },

    fireSyntheticButtonPressedEvent: function(event) {
        if (this.isViewableButton(event.dataCell.x, event.gridCell.y)) {
            return dispatchEvent.call(this, 'fin-button-pressed', {}, event);
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-column-drag-start` event.
     */
    fireSyntheticOnColumnsChangedEvent: function() {
        return dispatchEvent.call(this, 'fin-column-changed-event', {});
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-keydown` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeydownEvent: function(keyEvent) {
        return dispatchEvent.call(this, 'fin-keydown', keyEvent.detail);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-keyup` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeyupEvent: function(keyEvent) {
        return dispatchEvent.call(this, 'fin-keyup', keyEvent.detail);
    },

    fireSyntheticFilterAppliedEvent: function() {
        return dispatchEvent.call(this, 'fin-filter-applied', {});
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-cell-enter` event
     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellEnterEvent: function(cellEvent) {
        return dispatchEvent.call(this, 'fin-cell-enter', cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-cell-exit` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellExitEvent: function(cellEvent) {
        return dispatchEvent.call(this, 'fin-cell-exit', cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-cell-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticClickEvent: function(cellEvent) {
        return dispatchEvent.call(this, 'fin-click', {}, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a `fin-double-click` event.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticDoubleClickEvent: function(cellEvent) {
        if (!this.abortEditing()) { return; }

        if (this.behavior.cellDoubleClicked !== Behavior.prototype.cellDoubleClicked) {
            this.deprecated('fin-double-click', 'behavior.cellDoubleClicked(gridCell, cellEvent) has been deprecated as of v1.2.6 in favor of handling in a \'fin-double-click\' event (event.detail.gridCell, event.primitiveEvent) and will be removed in a future release.');
        }
        // to deprecate, remove above warning + following line + abstract implementation in Behavior.js
        this.behavior.cellDoubleClicked(cellEvent.gridCell, cellEvent);

        return dispatchEvent.call(this, 'fin-double-click', {}, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a rendered event.
     */
    fireSyntheticGridRenderedEvent: function() {
       return dispatchEvent.call(this, 'fin-grid-rendered', { source: this });
    },

    fireSyntheticTickEvent: function() {
        return dispatchEvent.call(this, 'fin-tick', { source: this });
    },

    fireSyntheticGridResizedEvent: function(e) {
        return dispatchEvent.call(this, 'fin-grid-resized', e);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a scroll event.
     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
     * @param {number} oldValue - The old scroll value.
     * @param {number} newValue - The new scroll value.
     */
    fireScrollEvent: function(eventName, oldValue, newValue) {
        return dispatchEvent.call(this, eventName, {
            oldValue: oldValue,
            value: newValue
        });
    },

    fireRequestCellEdit: function(cellEvent, value) {
        return dispatchEvent.call(this, 'fin-request-cell-edit', true, { value: value }, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and fire a fin-before-cell-edit event.
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} value - The current value.
     * @returns {boolean} Proceed (don't cancel).
     */
    fireBeforeCellEdit: function(cellEvent, oldValue, newValue, control) {
        return dispatchEvent.call(this, 'fin-before-cell-edit', true, {
            oldValue: oldValue,
            newValue: newValue,
            input: control
        }, cellEvent);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterCellEdit: function(cellEvent, oldValue, newValue, control) {
        return dispatchEvent.call(this, 'fin-after-cell-edit', {
            newValue: newValue,
            oldValue: oldValue,
            input: control
        }, cellEvent);
    },

    delegateCanvasEvents: function() {
        var self = this;

        function handleMouseEvent(e, cb) {
            var primitiveEvent = self.getGridCellFromMousePoint(e.detail.mouse),
                decoratedEvent;

            if (primitiveEvent) {
                decoratedEvent = Object.defineProperty(
                    primitiveEvent,
                    'primitiveEvent',
                    {
                        value: e,
                        enumerable: false,
                        configurable: true,
                        writable: true
                    }
                );
                cb.call(self, decoratedEvent);
            }
        }

        this.addInternalEventListener('fin-canvas-resized', function(e) {
            self.resized();
            self.fireSyntheticGridResizedEvent(e);
        });

        this.addInternalEventListener('fin-canvas-mousemove', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            handleMouseEvent(e, function(mouseEvent) {
                this.delegateMouseMove(mouseEvent);
                this.fireSyntheticMouseMoveEvent(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-canvas-mousedown', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            if (!self.abortEditing()) {
                event.stopPropagation();
                return;
            }

            handleMouseEvent(e, function(mouseEvent) {
                mouseEvent.keys = e.detail.keys;
                this.mouseDownState = mouseEvent;
                this.delegateMouseDown(mouseEvent);
                this.fireSyntheticMouseDownEvent(mouseEvent);
                this.repaint();
            });
        });

        this.addInternalEventListener('fin-canvas-click', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            handleMouseEvent(e, function(mouseEvent) {
                mouseEvent.keys = e.detail.keys; // todo: this was in fin-tap but wasn't here
                this.fireSyntheticClickEvent(mouseEvent);
                this.delegateClick(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-canvas-mouseup', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.dragging = false;
            if (self.isScrollingNow()) {
                self.setScrollingNow(false);
            }
            if (self.columnDragAutoScrolling) {
                self.columnDragAutoScrolling = false;
            }
            handleMouseEvent(e, function(mouseEvent) {
                this.delegateMouseUp(mouseEvent);
                if (self.mouseDownState) {
                    self.fireSyntheticButtonPressedEvent(self.mouseDownState);
                }
                this.mouseDownState = null;
                this.fireSyntheticMouseUpEvent(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-canvas-dblclick', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            handleMouseEvent(e, function(mouseEvent) {
                this.fireSyntheticDoubleClickEvent(mouseEvent, e);
                this.delegateDoubleClick(mouseEvent);
            });
        });

        this.addInternalEventListener('fin-canvas-drag', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.dragging = true;
            handleMouseEvent(e, self.delegateMouseDrag);
        });

        this.addInternalEventListener('fin-canvas-keydown', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.fireSyntheticKeydownEvent(e);
            self.delegateKeyDown(e);
        });

        this.addInternalEventListener('fin-canvas-keyup', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.fireSyntheticKeyupEvent(e);
            self.delegateKeyUp(e);
        });

        this.addInternalEventListener('fin-canvas-wheelmoved', function(e) {
            handleMouseEvent(e, self.delegateWheelMoved);
        });

        this.addInternalEventListener('fin-canvas-mouseout', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            handleMouseEvent(e, self.delegateMouseExit);
        });

        this.addInternalEventListener('fin-canvas-context-menu', function(e) {
            handleMouseEvent(e, function(mouseEvent){
                self.delegateContextMenu(mouseEvent);
                self.fireSyntheticContextMenuEvent(mouseEvent);
            });
        });

        //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
        document.body.addEventListener('copy', function(evt) {
            self.checkClipboardCopy(evt);
        });
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate the wheel moved event to the behavior.
     * @param {Event} event - The pertinent event.
     */
    delegateWheelMoved: function(event) {
        this.behavior.onWheelMoved(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateMouseExit: function(event) {
        this.behavior.handleMouseExit(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateContextMenu: function(event) {
        this.behavior.onContextMenu(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate MouseMove to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseMove: function(mouseDetails) {
        this.behavior.onMouseMove(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDown: function(mouseDetails) {
        this.behavior.handleMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate mouseup to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseUp: function(mouseDetails) {
        this.behavior.onMouseUp(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate click to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateClick: function(mouseDetails) {
        this.behavior.onClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Delegate mouseDrag to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDrag: function(mouseDetails) {
        this.behavior.onMouseDrag(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @desc We've been doubleclicked on. Delegate through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateDoubleClick: function(mouseDetails) {
        this.behavior.onDoubleClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyDown: function(event) {
        this.behavior.onKeyDown(this, event);
    },

    /**
     * @memberOf Hypergrid#
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyUp: function(event) {
        this.behavior.onKeyUp(this, event);
    },
};

var details = [
    'gridCell',
    'dataCell',
    'mousePoint',
    'keys',
    'row'
];

/**
 *
 * @param {string} eventName
 * @param {boolean} [cancelable=false]
 * @param {object} event
 * @param {CellEvent|MouseEvent|KeyboardEvent|object} [primitiveEvent]
 * @returns {undefined|boolean}
 */
function dispatchEvent(eventName, cancelable, event, primitiveEvent) {
    var detail, result;

    if (typeof cancelable !== 'boolean') {
        primitiveEvent = event; // propmote primitiveEvent to 3rd position
        event = cancelable; // promote event to 2nd position
        cancelable = false; // default when omitted
    }

    if (!event.detail) {
        event = { detail: event };
    }

    detail = event.detail;

    if (!detail.grid) { // CellEvent objects already have a (read-only) `grid` prop
        detail.grid = this;
    }

    detail.time = Date.now();

    if (primitiveEvent) {
        if (!detail.primitiveEvent) {
            detail.primitiveEvent = primitiveEvent;
        }
        details.forEach(function(key) {
            if (key in primitiveEvent && !(key in detail)) {
                detail[key] = primitiveEvent[key];
            }
        });
    }

    if (cancelable) {
        event.cancelable = true;
    }

    result = this.canvas.dispatchEvent(new CustomEvent(eventName, event));

    if (cancelable) {
        return result;
    }
}

},{"../behaviors/Behavior":43,"object-iterators":36}],103:[function(require,module,exports){
'use strict';

/**
 * @name fields
 * @module
 */

var REGEXP_META_PREFIX = /^__/, // starts with double underscore
    REGEXP_WORD_SEPARATORS = /[\s\-_]*([^\s\-_])([^\s\-_]+)/g,
    REGEXP_CAPITAL_LETTERS = /[A-Z]/g,
    REGEXP_LOWER_CASE_LETTER = /[a-z]/;

/**
 * @param {object} hash
 * @returns {string[]} Member names from `hash` that do _not_ begin with double-underscore.
 * @memberOf module:fields
 */
function getFieldNames(hash) {
    return Object.keys(hash || []).filter(function(fieldName) {
        return !REGEXP_META_PREFIX.test(fieldName);
    });
}

function capitalize(a, b, c) {
    return b.toUpperCase() + c;
}

/**
 * Separates camel case or white-space-, hypen-, or underscore-separated-words into truly separate words and capitalizing the first letter of each.
 * @param string
 * @returns {string}
 * @memberOf module:fields
 */
function titleize(string) {
    return (REGEXP_LOWER_CASE_LETTER.test(string) ? string : string.toLowerCase())
        .replace(REGEXP_WORD_SEPARATORS, capitalize)
        .replace(REGEXP_CAPITAL_LETTERS, ' $&')
        .trim();
}

function getSchema(data){
    return getFieldNames(data && data[0] || {}).map(function(name) {
        return { name: name, header: titleize(name) };
    });
}

module.exports = {
    getFieldNames: getFieldNames,
    titleize: titleize,
    getSchema: getSchema
};

},{}],104:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var API;

function clearFill(x, y, width, height, color) {
    var a = alpha(color);
    if (a < 1) {
        // If background is translucent, we must clear the rect before the fillRect
        // below to prevent mixing with previous frame's render of this cell.
        this.clearRect(x, y, width, height);
    }
    if (a > 0) {
        this.cache.fillStyle = color;
        this.fillRect(x, y, width, height);
    }
}

var ALPHA_REGEX = /^(transparent|((RGB|HSL)A\(.*,\s*([\d\.]+)\)))$/i;
// Tried using an `alphaCache` here but it didn't make a measurable difference.
function alpha(cssColorSpec) {
    var matches, result;

    if (!cssColorSpec) {
        // undefined so not visible; treat as transparent
        result = 0;
    } else if ((matches = cssColorSpec.match(ALPHA_REGEX)) === null) {
        // an opaque color (a color spec with no alpha channel)
        result = 1;
    } else if (matches[4] === undefined) {
        // cssColorSpec must have been 'transparent'
        result = 0;
    } else {
        result = Number(matches[4]);
    }

    return result;
}

var fontMetrics = {};

/**
 * Accumulates width of string in pixels, character by character, by chaching character widths and reusing those values when previously cached.
 *
 * NOTE: There is a minor measuring error when taking the sum of the pixel widths of individual characters that make up a string vs. the pixel width of the string taken as a whole. This is possibly due to kerning or rounding. The error is typically about 0.1%.
 * @memberOf module:defaults
 * @param {CanvasRenderingContext2D} gc
 * @param {string} string - Text to measure.
 * @returns {nubmer} Width of string in pixels.
 */
function getTextWidth(string) {
    var metrics = fontMetrics[this.cache.font] = fontMetrics[this.cache.font] || {};
    string += '';
    for (var i = 0, sum = 0, len = string.length; i < len; ++i) {
        var c = string[i];
        sum += metrics[c] = metrics[c] || this.measureText(c).width;
    }
    return sum;
}

var ELLIPSIS = '\u2026'; // The "…" (dot-dot-dot) character

/**
 * Similar to `getTextWidth` except:
 * 1. Aborts accumulating when sum exceeds given `width`.
 * 2. Returns an object containing both the truncated string and the sum (rather than a number primitive containing the sum alone).
 * @param {CanvasRenderingContext2D} gc
 * @param {string} string - Text to measure.
 * @param {number} width - Width of target cell; overflow point.
 * @param {boolean|null|undefined} truncateTextWithEllipsis - See {@link module:defaults.truncateTextWithEllipsis}.
 * @param {boolean} [abort=false] - Abort measuring upon overflow. Returned `width` sum will reflect truncated string rather than untruncated string. Note that returned `string` is truncated in either case.
 * @returns {{string:string,width:number}}
 * * `object.string` - `undefined` if it fits; truncated version of provided `string` if it does not.
 * * `object.width` - Width of provided `string` if it fits; width of truncated string if it does not.
 */
function getTextWidthTruncated(string, width, truncateTextWithEllipsis, abort) {
    var metrics = fontMetrics[this.cache.font],
        truncating = truncateTextWithEllipsis !== undefined,
        truncString, truncWidth, truncAt;

    if (!metrics) {
        metrics = fontMetrics[this.cache.font] = {};
        metrics[ELLIPSIS] = this.measureText(ELLIPSIS).width;
    }

    string += ''; // convert to string
    width += truncateTextWithEllipsis === false ? 2 : -1; // fudge for inequality
    for (var i = 0, sum = 0, len = string.length; i < len; ++i) {
        var char = string[i];
        var charWidth = metrics[char] = metrics[char] || this.measureText(char).width;
        sum += charWidth;
        if (!truncString && truncating && sum > width) {
            truncAt = i;
            switch (truncateTextWithEllipsis) {
                case true: // truncate sufficient characters to fit ellipsis if possible
                    truncWidth = sum - charWidth + metrics[ELLIPSIS];
                    while (truncAt && truncWidth > width) {
                        truncWidth -= metrics[string[--truncAt]];
                    }
                    truncString = truncWidth > width
                        ? '' // not enough room even for ellipsis
                        : truncString = string.substr(0, truncAt) + ELLIPSIS;
                    break;
                case false: // truncate *before* last partially visible character
                    truncString = string.substr(0, truncAt);
                    break;
                default: // truncate *after* partially visible character
                    if (++truncAt < string.length) {
                        truncString = string.substr(0, truncAt);
                    }
            }
            if (abort) { break; }
        }
    }
    return {
        string: truncString,
        width: sum
    };
}

var fontData = {};

/**
 * @memberOf module:defaults
 * @param font
 * @returns {*}
 */
function getTextHeight(font) {
    var result = fontData[font];

    if (!result) {
        result = {};

        var text = document.createElement('span');
        text.textContent = 'Hg';
        text.style.font = font;

        var block = document.createElement('div');
        block.style.display = 'inline-block';
        block.style.width = '1px';
        block.style.height = '0px';

        var div = document.createElement('div');
        div.appendChild(text);
        div.appendChild(block);

        div.style.position = 'absolute';
        document.body.appendChild(div);

        try {

            block.style.verticalAlign = 'baseline';

            var blockRect = block.getBoundingClientRect();
            var textRect = text.getBoundingClientRect();

            result.ascent = blockRect.top - textRect.top;

            block.style.verticalAlign = 'bottom';
            result.height = blockRect.top - textRect.top;

            result.descent = result.height - result.ascent;

        } finally {
            document.body.removeChild(div);
        }
        if (result.height !== 0) {
            fontData[font] = result;
        }
    }

    return result;
}

function clipSave(conditional, x, y, width, height) {
    this.conditionalsStack.push(conditional);
    if (conditional) {
        this.cache.save();
        this.beginPath();
        this.rect(x, y, width, height);
        this.clip();
    }
}

function clipRestore(conditional) {
    if (this.conditionalsStack.pop()) {
        this.cache.restore(); // Remove clip region
    }
}

API = {
    clearFill: clearFill,
    alpha: alpha,
    getTextWidth: getTextWidth,
    getTextWidthTruncated: getTextWidthTruncated,
    getTextHeight: getTextHeight,
    clipSave: clipSave,
    clipRestore: clipRestore,
    truncateTextWithEllipsis: true
};

module.exports = API;

},{}],105:[function(require,module,exports){
'use strict';

module.exports = {
    fields: require('./fields')
};

},{"./fields":103}],106:[function(require,module,exports){
'use strict';


/* IMPORTANT NOTE:
 * If any of the modules listed below is removed from Hypergrid, the polyfill(s) they define must be added here!!!
 *
 * 1. object-iterators defines Array.prototype.find
 */


/* eslint-disable no-extend-native */

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill
// (Safari now supports Math.sign but IE still does not as of v11.)
Math.sign = Math.sign = function(x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) {
        return x;
    }
    return x > 0 ? 1 : -1;
};

// Lite version of: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex#Polyfill
if (typeof Array.prototype.findIndex !== 'function') {
    Array.prototype.findIndex = function(predicate) {
        var context = arguments[1];
        for (var i = 0, len = this.length; i < len; i++) {
            if (predicate.call(context, this[i], i, this)) {
                return i;
            }
        }
        return -1;
    };
}

// Simpler version of: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill
if (typeof Array.prototype.fill !== 'function') {
    Array.prototype.fill = function(value, start, end) {
        start = start === undefined ? 0 : start < 0 ? this.length + start : start;
        end = end === undefined ? this.length : end < 0 ? this.length + end : end;
        for (var i = start || 0; i < end; ++i) {
            this[i] = value;
        }
        return this;
    };
}

// Lite version of: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
if (typeof Object.assign !== 'function') {
    Object.assign = function(target) {
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source != null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        target[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return target;
    };
}

},{}],107:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var Rectangle = require('rectangular').Rectangle;

module.exports = {
    /**
     * @memberOf Hypergrid#
     * @returns {boolean} We have any selections.
     */
    hasSelections: function() {
        if (!this.getSelectionModel) {
            return; // were not fully initialized yet
        }
        return this.selectionModel.hasSelections();
    },

    /**
     * @memberOf Hypergrid#
     * @returns {string} Tab separated value string from the selection and our data.
     */
    getSelectionAsTSV: function() {
        var sm = this.selectionModel;
        if (sm.hasSelections()) {
            var selections = this.getSelectionMatrix();
            selections = selections[selections.length - 1];
            return this.getMatrixSelectionAsTSV(selections);
        } else if (sm.hasRowSelections()) {
            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
        } else if (sm.hasColumnSelections()) {
            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
        }
    },

    getMatrixSelectionAsTSV: function(selections) {
        var result = '';

        //only use the data from the last selection
        if (selections.length) {
            var width = selections.length,
                height = selections[0].length,
                area = width * height,
                lastCol = width - 1,
                //Whitespace will only be added on non-singular rows, selections
                whiteSpaceDelimiterForRow = (height > 1 ? '\n' : '');

            //disallow if selection is too big
            if (area > 20000) {
                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
                return '';
            }

            for (var h = 0; h < height; h++) {
                for (var w = 0; w < width; w++) {
                    result += selections[w][h] + (w < lastCol ? '\t' : whiteSpaceDelimiterForRow);
                }
            }
        }

        return result;
    },

    /**
     * @memberOf Hypergrid#
     * @desc Clear all the selections.
     */
    clearSelections: function() {
        var keepRowSelections = this.properties.checkboxOnlyRowSelections;
        this.selectionModel.clear(keepRowSelections);
        this.clearMouseDown();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Clear the most recent selection.
     */
    clearMostRecentSelection: function() {
        var keepRowSelections = this.properties.checkboxOnlyRowSelections;
        this.selectionModel.clearMostRecentSelection(keepRowSelections);
    },

    /**
     * @memberOf Hypergrid#
     * @desc Clear the most recent column selection.
     */
    clearMostRecentColumnSelection: function() {
        this.selectionModel.clearMostRecentColumnSelection();
    },

    /**
     * @memberOf Hypergrid#
     * @desc Clear the most recent row selection.
     */
    clearMostRecentRowSelection: function() {
        //this.selectionModel.clearMostRecentRowSelection(); // commented off as per GRID-112
    },

    clearRowSelection: function() {
        this.selectionModel.clearRowSelection();
        this.behavior.dataModel.clearSelectedData();
    },

    /**
     * @memberOf Hypergrid#
     * @summary Select given region.
     * @param {number} ox - origin x
     * @param {number} oy - origin y
     * @param {number} ex - extent x
     * @param {number} ex - extent y
     */
    select: function(ox, oy, ex, ey) {
        if (ox < 0 || oy < 0) {
            //we don't select negative area
            //also this means there is no origin mouse down for a selection rect
            return;
        }
        this.selectionModel.select(ox, oy, ex, ey);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} Given point is selected.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    isSelected: function(x, y) {
        return this.selectionModel.isSelected(x, y);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} The given column is selected anywhere in the entire table.
     * @param {number} y - The row index.
     */
    isCellSelectedInRow: function(y) {
        return this.selectionModel.isCellSelectedInRow(y);
    },

    /**
     * @memberOf Hypergrid#
     * @returns {boolean} The given row is selected anywhere in the entire table.
     * @param {number} x - The column index.
     */
    isCellSelectedInColumn: function(x) {
        return this.selectionModel.isCellSelectedInColumn(x);
    },

    /**
     * @param {boolean|number[]|string[]} [hiddenColumns=false] - See {@link Hypergrid~getColumns}.
     * @returns {{}}
     * @memberOf Hypergrid#
     */
    getRowSelection: function(hiddenColumns) {
        var column, rows,
            self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            columns = getColumns.call(this, hiddenColumns),
            result = {};

        for (var c = 0, C = columns.length; c < C; c++) {
            column = columns[c];
            rows = result[column.name] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        function getValue(selectedRowIndex, j) {
            var dataRow = self.getRow(selectedRowIndex);
            rows[j] = valOrFunc.call(dataRow, column);
        }

        return result;
    },

    /**
     * @param {boolean|number[]|string[]} [hiddenColumns=false] - See {@link Hypergrid~getColumns}.
     * @returns {Array}
     * @memberOf Hypergrid#
     */
    getRowSelectionMatrix: function(hiddenColumns) {
        var self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            columns = getColumns.call(this, hiddenColumns),
            result = new Array(columns.length);

        for (var c = 0, C = columns.length; c < C; c++) {
            var column = columns[c];
            result[c] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        function getValue(selectedRowIndex, r) {
            var dataRow = self.getRow(selectedRowIndex);
            result[c][r] = valOrFunc.call(dataRow, column);
        }

        return result;
    },

    getColumnSelectionMatrix: function() {
        var dataRow,
            self = this,
            headerRowCount = this.getHeaderRowCount(),
            selectedColumnIndexes = this.getSelectedColumns(),
            numRows = this.getRowCount(),
            result = new Array(selectedColumnIndexes.length);

        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
            var column = self.behavior.getActiveColumn(selectedColumnIndex),
                values = result[c] = new Array(numRows);

            for (var r = headerRowCount; r < numRows; r++) {
                dataRow = self.getRow(r);
                values[r] = valOrFunc.call(dataRow, column);
            }
        });

        return result;
    },

    getColumnSelection: function() {
        var dataRow,
            self = this,
            headerRowCount = this.getHeaderRowCount(),
            selectedColumnIndexes = this.getSelectedColumns(),
            result = {},
            rowCount = this.getRowCount();

        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
            var column = self.behavior.getActiveColumn(selectedColumnIndex),
                values = result[column.name] = new Array(rowCount);

            for (var r = headerRowCount; r < rowCount; r++) {
                dataRow = self.getRow(r);
                values[r] = valOrFunc.call(dataRow, column);
            }
        });

        return result;
    },

    getSelection: function() {
        var dataRow,
            self = this,
            selections = this.getSelections(),
            rects = new Array(selections.length);

        selections.forEach(getRect);

        function getRect(selectionRect, i) {
            var rect = normalizeRect(selectionRect),
                colCount = rect.extent.x + 1,
                rowCount = rect.extent.y + 1,
                columns = {};

            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
                var column = self.behavior.getActiveColumn(x),
                    values = columns[column.name] = new Array(rowCount);

                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
                    dataRow = self.getRow(y);
                    values[r] = valOrFunc.call(dataRow, column);
                }
            }

            rects[i] = columns;
        }

        return rects;
    },

    getSelectionMatrix: function() {
        var dataRow,
            self = this,
            selections = this.getSelections(),
            rects = new Array(selections.length);

        selections.forEach(getRect);

        function getRect(selectionRect, i) {
            var rect = normalizeRect(selectionRect),
                colCount = rect.extent.x + 1,
                rowCount = rect.extent.y + 1,
                rows = [];

            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
                var values = rows[c] = new Array(rowCount),
                    column = self.behavior.getActiveColumn(x);

                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
                    dataRow = self.getRow(y);
                    values[r] = valOrFunc.call(dataRow, column);
                }
            }

            rects[i] = rows;
        }

        return rects;
    },

    selectCell: function(x, y, silent) {
        var keepRowSelections = this.properties.checkboxOnlyRowSelections;
        this.selectionModel.clear(keepRowSelections);
        this.selectionModel.select(x, y, 0, 0, silent);
    },

    toggleSelectColumn: function(x, keys) {
        keys = keys || [];
        var model = this.selectionModel;
        var alreadySelected = model.isColumnSelected(x);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;
        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectColumn(x);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectColumn(x);
                } else {
                    model.selectColumn(x);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectColumn(this.lastEdgeSelection[0], x);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[0] = x;
        }
        this.repaint();
        this.fireSyntheticColumnSelectionChangedEvent();
    },

    toggleSelectRow: function(y, keys) {
        //we can select the totals rows if they exist, but not rows above that
        keys = keys || [];

        var sm = this.selectionModel;
        var alreadySelected = sm.isRowSelected(y);
        var hasSHIFT = keys.indexOf('SHIFT') >= 0;

        if (alreadySelected) {
            sm.deselectRow(y);
        } else {
            this.singleSelect();
            sm.selectRow(y);
        }

        if (hasSHIFT) {
            sm.clear();
            sm.selectRow(this.lastEdgeSelection[1], y);
        }

        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[1] = y;
        }

        this.repaint();
    },

    singleSelect: function() {
        var result = this.properties.singleRowSelectionMode;

        if (result) {
            this.selectionModel.clearRowSelection();
        }

        return result;
    },

    selectViewportCell: function(x, y) {
        var headerRowCount = this.getHeaderRowCount();
        x = this.renderer.visibleColumns[x].columnIndex;
        y = this.renderer.visibleRows[y + headerRowCount].rowIndex;
        this.clearSelections();
        this.select(x, y, 0, 0);
        this.setMouseDown(this.newPoint(x, y));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToViewportCell: function(x, y) {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var headerRowCount = this.getHeaderRowCount(),
                selection = selections[0],
                origin = selection.origin;
            x = this.renderer.visibleColumns[x].columnIndex;
            y = this.renderer.visibleRows[y + headerRowCount].rowIndex;
            this.setDragExtent(this.newPoint(x - origin.x, y - origin.y));
            this.select(origin.x, origin.y, x - origin.x, y - origin.y);
            this.repaint();
        }
    },

    selectFinalCellOfCurrentRow: function() {
        var x = this.getColumnCount() - 1,
            y = this.getSelectedRows()[0],
            headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.scrollBy(this.getColumnCount(), 0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFinalCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                extent = selection.extent,
                columnCount = this.getColumnCount();
            this.scrollBy(columnCount, 0);

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);

            this.repaint();
        }
    },

    selectFirstCellOfCurrentRow: function() {
        var x = 0,
            y = this.getSelectedRows()[0],
            headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.setHScrollValue(0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFirstCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                extent = selection.extent;
            this.clearSelections();
            this.select(origin.x, origin.y, -origin.x, extent.y);
            this.setHScrollValue(0);
            this.repaint();
        }
    },

    selectFinalCell: function() {
        this.selectCellAndScrollToMakeVisible(this.getColumnCount() - 1, this.getRowCount() - 1);
        this.repaint();
    },

    selectToFinalCell: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                columnCount = this.getColumnCount(),
                rowCount = this.getRowCount();

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
            this.scrollBy(columnCount, rowCount);
            this.repaint();
        }
    },

    /**
     * @memberOf Hypergrid#
     * @returns {object} An object that represents the currently selection row.
     */
    getSelectedRow: function() {
        var sels = this.selectionModel.getSelections();
        if (sels.length) {
            var behavior = this.behavior,
                colCount = this.getColumnCount(),
                topRow = sels[0].origin.y,
                row = {
                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
                };

            for (var c = 0; c < colCount; c++) {
                row[behavior.getActiveColumn(c).header] = behavior.getValue(c, topRow);
            }

            return row;
        }
    },

    /**
     * @memberOf Hypergrid#
     * @desc Synthesize and dispatch a `fin-selection-changed` event.
     */
    selectionChanged: function() {
        // Project the cell selection into the rows
        this.selectRowsFromCells();

        // Project the cell selection into the columns
        this.selectColumnsFromCells();

        var selectionEvent = new CustomEvent('fin-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    isColumnOrRowSelected: function() {
        return this.selectionModel.isColumnOrRowSelected();
    },
    selectColumn: function(x1, x2) {
        this.selectionModel.selectColumn(x1, x2);
    },
    selectRow: function(y1, y2) {
        var sm = this.selectionModel;

        if (this.singleSelect()) {
            y1 = y2;
        } else {
            // multiple row selection
            y2 = y2 || y1;
        }

        sm.selectRow(Math.min(y1, y2), Math.max(y1, y2));
    },

    selectRowsFromCells: function() {
        if (!this.properties.checkboxOnlyRowSelections && this.properties.autoSelectRows) {
            var last;

            if (!this.properties.singleRowSelectionMode) {
                this.selectionModel.selectRowsFromCells(0, true);
            } else if ((last = this.selectionModel.getLastSelection())) {
                this.selectRow(null, last.corner.y);
            } else {
                this.clearRowSelection();
            }
        }
    },
    selectColumnsFromCells: function() {
        if (this.properties.autoSelectColumns) {
            this.selectionModel.selectColumnsFromCells();
        }
    },
    getSelectedRows: function() {
        return this.behavior.getSelectedRows();
    },
    getSelectedColumns: function() {
        return this.behavior.getSelectedColumns();
    },
    getSelections: function() {
        return this.behavior.getSelections();
    },
    getLastSelectionType: function() {
        return this.selectionModel.getLastSelectionType();
    },
    isInCurrentSelectionRectangle: function(x, y) {
        return this.selectionModel.isInCurrentSelectionRectangle(x, y);
    },
    selectAllRows: function() {
        this.selectionModel.selectAllRows();
    },
    areAllRowsSelected: function() {
        return this.selectionModel.areAllRowsSelected();
    },
    toggleSelectAllRows: function() {
        if (this.areAllRowsSelected()) {
            this.selectionModel.clear();
        } else {
            this.selectAllRows();
        }
        this.repaint();
    },
    isCellSelection: function() {
        return this.deprecated('isCellSelection()', 'properties.cellSelection', '1.2.2');
    },
    isRowSelection: function() {
        return this.deprecated('isRowSelection()', 'properties.rowSelection', '1.2.2');
    },
    isColumnSelection: function() {
        return this.deprecated('isColumnSelection()', 'properties.columnSelection', '1.2.2');
    },
    isSingleRowSelectionMode: function() {
        return this.deprecated('isSingleRowSelectionMode()', 'properties.singleRowSelectionMode', '1.2.14');
    },

    /**
     * @summary Move cell selection by offset.
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {number} offsetX - x offset
     * @param {number} offsetY - y offset
     * @memberOf Hypergrid#
     */
    moveSingleSelect: function(offsetX, offsetY) {
        var mouseCorner = this.getMouseDown().plus(this.getDragExtent());
        this.moveToSingleSelect(
            mouseCorner.x + offsetX,
            mouseCorner.y + offsetY
        );
    },

    /**
     * @summary Move cell selection by offset.
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {number} newX - x coordinate to start at
     * @param {number} newY - y coordinate to start at
     * @memberOf Hypergrid#
     */
    moveToSingleSelect: function(newX, newY) {
        var maxColumns = this.getColumnCount() - 1,
            maxRows = this.getRowCount() - 1,

            maxViewableColumns = this.getVisibleColumnsCount() - 1,
            maxViewableRows = this.getVisibleRowsCount() - 1;

        if (!this.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newX = Math.min(maxColumns, Math.max(0, newX));
        newY = Math.min(maxRows, Math.max(0, newY));

        this.clearSelections();
        this.select(newX, newY, 0, 0);
        this.setMouseDown(this.newPoint(newX, newY));
        this.setDragExtent(this.newPoint(0, 0));

        this.selectCellAndScrollToMakeVisible(newX, newY);

        this.repaint();
    },

    /** @summary Extend cell selection by offset.
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     * @memberOf Hypergrid#
     */
    extendSelect: function(offsetX, offsetY) {
        var maxColumns = this.getColumnCount() - 1,
            maxRows = this.getRowCount() - 1,

            maxViewableColumns = this.renderer.visibleColumns.length - 1,
            maxViewableRows = this.renderer.visibleRows.length - 1,

            origin = this.getMouseDown(),
            extent = this.getDragExtent(),

            newX = extent.x + offsetX,
            newY = extent.y + offsetY;

        if (!this.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        this.clearMostRecentSelection();
        this.select(origin.x, origin.y, newX, newY);

        this.setDragExtent(this.newPoint(newX, newY));

        var colScrolled = this.insureModelColIsVisible(newX + origin.x, offsetX),
            rowScrolled = this.insureModelRowIsVisible(newY + origin.y, offsetY);

        this.repaint();

        return colScrolled || rowScrolled;
    },

    /**
     * @returns {undefined|CellEvent}
     * @memberOf Hypergrid#
     */
    getGridCellFromLastSelection: function() {
        var cellEvent,
            sel = this.selectionModel.getLastSelection();

        if (sel) {
            cellEvent = new this.behavior.CellEvent;
            cellEvent.resetGridXDataY(sel.origin.x, sel.origin.y);
        }

        return cellEvent;
    }
};

/**
 * @param {boolean|number[]|string[]} [hiddenColumns=false] - One of:
 * `false` - Active column list
 * `true` - All column list
 * `Array` - Active column list with listed columns prefixed as needed (when not already in the list). Each item in the array may be either:
 * * `number` - index into all column list
 * * `string` - name of a column from the all column list
 * @returns {Column[]}
 * @memberOf Hypergrid~
 */
function getColumns(hiddenColumns) {
    var columns,
        allColumns = this.behavior.getColumns(),
        activeColumns = this.behavior.getActiveColumns();

    if (Array.isArray(hiddenColumns)) {
        columns = [];
        hiddenColumns.forEach(function(index) {
            var key = typeof index === 'number' ? 'index' : 'name',
                column = allColumns.find(function(column) { return column[key] === index; });
            if (activeColumns.indexOf(column) < 0) {
                columns.push(column);
            }
        });
        columns = columns.concat(activeColumns);
    } else {
        columns = hiddenColumns ? allColumns : activeColumns;
    }

    return columns;
}

function normalizeRect(rect) {
    var o = rect.origin,
        c = rect.corner,

        ox = Math.min(o.x, c.x),
        oy = Math.min(o.y, c.y),

        cx = Math.max(o.x, c.x),
        cy = Math.max(o.y, c.y);

    return new Rectangle(ox, oy, cx - ox, cy - oy);
}

/**
 * @this {dataRowObject}
 * @param column
 * @returns {string}
 */
function valOrFunc(column) {
    var result, calculator;
    if (this) {
        result = this[column.name];
        calculator = (typeof result)[0] === 'f' && result || column.calculator;
        if (calculator) {
            result = calculator.call(this, column.name);
        }
    }
    return result || result === 0 || result === false ? result : '';
}

},{"rectangular":39}],108:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var automat = require('automat');

var css = require('../../css');

// note the position of the  first "natural" stylesheet. We will insert our stylesheets before this node.
var head = document.querySelector('head');
var refNode = Array.prototype.slice.call(head.children).find(function(child) {
    return child.tagName === 'STYLE' ||
        child.tagName === 'LINK' &&
        child.getAttribute('rel') === 'stylesheet' &&
        child.getAttribute('type') === 'text/css';
});

exports.prefix = 'injected-stylesheet-';

exports.inject = function(id, overrideDir) {
    var stylesheet = document.querySelector('#' + this.prefix + id);
    var repo = overrideDir || css;

    if (!stylesheet) {
        stylesheet = repo[id];
        stylesheet = '<style>\n' + stylesheet + '\n</style>\n';
        var args = [stylesheet, head, refNode].concat(Array.prototype.slice.call(arguments, 1));
        stylesheet = automat.append.apply(null, args)[0];
        stylesheet.id = this.prefix + id;
    }

    return stylesheet;
};

},{"../../css":1,"automat":4}],109:[function(require,module,exports){
'use strict';

/**
 * @param {function|string} string
 * @returns {function}
 * @private
 */
module.exports = function(string) {
    switch (typeof string) {
        case 'undefined':
        case 'function':
            return string;
        case 'string':
            break;
        default:
            throw 'Expected string, function, or undefined.';
    }

    var args = string.match(/function\s*\(([^]*?)\)/);
    if (!args) {
        throw 'Expected function keyword with formal parameter list.';
    }
    args = args[1].split(',').map(function(s, i) {
        s = s.match(/\s*(\w*)\s*/); // trim each argument
        if (!s && i) {
            throw 'Expected formal parameter.';
        }
        return s[1];
    });

    var body = string.match(/{\s*([^]*?)\s*}/);
    if (!body) {
        throw 'Expected function body.';
    }
    body = body[1];

    if (args.length === 1 && !args[0]) {
        args[0] = body;
    } else {
        args = args.concat(body);
    }

    return Function.apply(null, args);
};

},{}],110:[function(require,module,exports){
'use strict';

function bundleColumns(resetCellEvents) {
    var gridProps = this.grid.properties,
        vc, visibleColumns = this.visibleColumns,
        vr, visibleRows = this.visibleRows,
        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0,
        r, R = visibleRows.length,
        p, pool;

    if (resetCellEvents) {
        pool = this.cellEventPool;
        for (p = 0, c = c0; c < C; c++) {
            vc = visibleColumns[c];
            for (r = 0; r < R; r++, p++) {
                vr = visibleRows[r];
                // reset pool member to reflect coordinates of cell in newly shaped grid
                pool[p].reset(vc, vr);
            }
        }
    }

    var bundle,
        columnBundles = [],
        gridPrefillColor = gridProps.backgroundColor,
        backgroundColor;

    for (c = c0; c < C; c++) {
        vc = visibleColumns[c];
        backgroundColor = vc.column.properties.backgroundColor;
        if (bundle && bundle.backgroundColor === backgroundColor) {
            bundle.right = vc.right;
        } else if (backgroundColor === gridPrefillColor) {
            bundle = undefined;
        } else {
            bundle = {
                backgroundColor: backgroundColor,
                left: vc.left,
                right: vc.right
            };
            columnBundles.push(bundle);
        }
    }

    this.columnBundles = columnBundles;
}

module.exports = bundleColumns;

},{}],111:[function(require,module,exports){
'use strict';

function bundleRows(resetCellEvents) {
    var gridProps = this.grid.properties,
        vc, visibleColumns = this.visibleColumns,
        vr, visibleRows = this.visibleRows,
        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0,
        r, R = visibleRows.length,
        p, pool;

    if (resetCellEvents) {
        pool = this.cellEventPool;
        for (p = 0, r = 0; r < R; r++) {
            vr = visibleRows[r];
            for (c = c0; c < C; c++, p++) {
                vc = visibleColumns[c];
                // reset pool member to reflect coordinates of cell in newly shaped grid
                pool[p].reset(vc, vr);
            }
        }
    }

    var bundle, rowBundles = [],
        gridPrefillColor = gridProps.backgroundColor,
        rowPropsList = gridProps.rowProperties,
        rowPrefillColors = Array(R),
        rowProperties, backgroundColor;

    for (r = 0; r < R; r++) {
        vr = visibleRows[r]; // first cell in row r
        rowProperties = vr.subgrid.isData && rowPropsList && rowPropsList[vr.rowIndex % rowPropsList.length];
        backgroundColor = rowPrefillColors[r] = rowProperties && rowProperties.backgroundColor || gridPrefillColor;
        if (bundle && bundle.backgroundColor === backgroundColor) {
            bundle.bottom = vr.bottom;
        } else if (backgroundColor === gridPrefillColor) {
            bundle = undefined;
        } else {
            bundle = {
                backgroundColor: backgroundColor,
                top: vr.top,
                bottom: vr.bottom
            };
            rowBundles.push(bundle);
        }
    }

    this.rowBundles = rowBundles;
    this.rowPrefillColors = rowPrefillColors;
}

module.exports = bundleRows;

},{}],112:[function(require,module,exports){
'use strict';

var paintCellsByColumnsAndRows = require('./by-columns-and-rows');

/** @summary Render the grid only as needed ("partial render").
 * @desc Paints all the cells of a grid, one column at a time, but only as needed.
 *
 * Paints all the cells of a grid, one row at a time.
 *
 * #### On reset
 *
 * Defers to {@link Renderer#paintCellsByColumnsAndRows|paintCellsByColumnsAndRows}, which clears the canvas, draws the grid, and draws the grid lines.
 *
 * #### On the next call (afer reset)
 *
 * First, a background rect is drawn using the grid background color.
 *
 * Then, each cell is drawn. If its background differs from the grid background, the background is repainted.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * #### On subsequent calls
 *
 * Iterates through each cell, calling `_paintCell` with `undefined` prefill color. This signifies partial render to the {@link SimpleCell} cell renderer, which only renders the cell when it's text, font, or colors have changed.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsAsNeeded(gc) {
    var grid = this.grid,
        gridProps = grid.properties,
        cellEvent,
        vc, visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
        r, R = visibleRows.length,
        p, pool = this.cellEventPool,
        preferredWidth,
        columnClip,
        // clipToGrid,
        // viewWidth = C ? visibleColumns[cLast].right : 0,
        viewHeight = R ? visibleRows[R - 1].bottom : 0;

    if (!C || !R) { return; }

    if (paintCellsAsNeeded.reset) {
        this.resetAllGridRenderers();
        paintCellsByColumnsAndRows.call(this, gc);
        paintCellsAsNeeded.reset = false;
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each column...
    for (p = 0, c = c0; c < C; c++) {
        cellEvent = pool[p]; // first cell in column c
        vc = cellEvent.visibleColumn;

        // Optionally clip to visible portion of column to prevent text from overflowing to right.
        columnClip = vc.column.properties.columnClip;
        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

        // For each row of each subgrid (of each column)...
        for (preferredWidth = r = 0; r < R; r++, p++) {
            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)

            try {
                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, pool[p]));
            } catch (e) {
                this.renderErrorCell(e, gc, vc, pool[p].visibleRow);
            }
        }

        gc.clipRestore(columnClip);

        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
    }

    // gc.clipRestore(clipToGrid);
}

paintCellsAsNeeded.key = 'by-cells';

paintCellsAsNeeded.partial = true; // skip painting selectionRegionOverlayColor

module.exports = paintCellsAsNeeded;

},{"./by-columns-and-rows":113}],113:[function(require,module,exports){
'use strict';

var bundleColumns = require('./bundle-columns');
var bundleRows = require('./bundle-rows');

/** @summary Render the grid with consolidated row OR column rects.
 * @desc Paints all the cells of a grid, one column at a time.
 *
 * First, a background rect is drawn using the grid background color.
 *
 * Then, if there are any rows with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of row backgrounds are all drawn before iterating through cells. These row backgrounds get priority over column backgrounds.
 *
 * If there are no such row background rects to draw, the column rects are consolidated and drawn instead (again, before the cells). Note that these column rects are _not_ suitable for clipping overflow text from previous columns. If you have overflow text, either turn on clipping (big performance hit) or turn on one of the `truncateTextWithEllipsis` options.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsByColumnsAndRows(gc) {
    var grid = this.grid,
        gridProps = grid.properties,
        prefillColor, rowPrefillColors, gridPrefillColor = gridProps.backgroundColor,
        cellEvent,
        rowBundle, rowBundles,
        columnBundle, columnBundles,
        vc, visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
        r, R = visibleRows.length,
        p, pool = this.cellEventPool,
        preferredWidth,
        columnClip,
        // clipToGrid,
        viewWidth = C ? visibleColumns[C - 1].right : 0,
        viewHeight = R ? visibleRows[R - 1].bottom : 0;

    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);

    if (!C || !R) { return; }

    if (gc.alpha(gridPrefillColor) > 0) {
        gc.cache.fillStyle = gridPrefillColor;
        gc.fillRect(0, 0, viewWidth, viewHeight);
    }

    if (paintCellsByColumnsAndRows.reset) {
        this.resetAllGridRenderers();
        paintCellsByColumnsAndRows.reset = false;
        bundleRows.call(this, false);
        bundleColumns.call(this, true);
    } else if (paintCellsByColumnsAndRows.rebundle) {
        paintCellsByColumnsAndRows.rebundle = false;
        bundleColumns.call(this);
    }

    rowBundles = this.rowBundles;
    if (rowBundles.length) {
        rowPrefillColors = this.rowPrefillColors;
        for (r = rowBundles.length; r--;) {
            rowBundle = rowBundles[r];
            gc.clearFill(0, rowBundle.top, viewWidth, rowBundle.bottom - rowBundle.top, rowBundle.backgroundColor);
        }
    } else {
        for (columnBundles = this.columnBundles, c = columnBundles.length; c--;) {
            columnBundle = columnBundles[c];
            gc.clearFill(columnBundle.left, 0, columnBundle.right - columnBundle.left, viewHeight, columnBundle.backgroundColor);
        }
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each column...
    for (p = 0, c = c0; c < C; c++) {
        cellEvent = pool[p];
        vc = cellEvent.visibleColumn;

        if (!rowPrefillColors) {
            prefillColor = cellEvent.column.properties.backgroundColor;
        }

        // Optionally clip to visible portion of column to prevent text from overflowing to right.
        columnClip = vc.column.properties.columnClip;
        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

        // For each row of each subgrid (of each column)...
        for (preferredWidth = r = 0; r < R; r++, p++) {
            if (!pool[p].disabled) {
                if (rowPrefillColors) {
                    prefillColor = rowPrefillColors[r];
                }

                try {
                    preferredWidth = Math.max(preferredWidth, this._paintCell(gc, pool[p], prefillColor));
                } catch (e) {
                    this.renderErrorCell(e, gc, vc, pool[p].visibleRow);
                }
            }
        }

        gc.clipRestore(columnClip);

        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
    }

    // gc.clipRestore(clipToGrid);

    this.paintGridlines(gc);
}

paintCellsByColumnsAndRows.key = 'by-columns-and-rows';
paintCellsByColumnsAndRows.rebundle = false; // see rebundleGridRenderers

module.exports = paintCellsByColumnsAndRows;

},{"./bundle-columns":110,"./bundle-rows":111}],114:[function(require,module,exports){
'use strict';

var bundleColumns = require('./bundle-columns');

/** @summary Render the grid with discrete column rects.
 * @desc Paints all the cells of a grid, one column at a time.
 *
 * In this grid renderer, a background rect is _not_ drawn using the grid background color.
 *
 * Rather, all columns paint their own background rects, with color defaulting to grid background color.
 *
 * The idea of painting each column rect is to "clip" text that might have overflowed from the previous column by painting over it with the background from this column. Only the last column will show overflowing text, and only if the canvas width exceeds the grid width. If this is the case, you can turn on clipping for the last column only by setting `columnClip` to `true` for the last column.
 *
 * NOTE: As a convenience feature, setting `columnClip` to `null` will clip only the last column, so simply setting it on the grid (rather than the last column) will have the same effect. This is much more convenient because you don't have to worry about the last column being redefined (moved, hidden, etc).
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumnsDiscrete|paintCellsByColumnsDiscrete}.

 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsByColumnsDiscrete(gc) {
    var grid = this.grid,
        gridProps = grid.properties,
        prefillColor,
        cellEvent,
        vc, visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
        r, R = visibleRows.length,
        p, pool = this.cellEventPool,
        preferredWidth,
        columnClip,
        // clipToGrid,
        // viewWidth = C ? visibleColumns[C - 1].right : 0,
        viewHeight = R ? visibleRows[R - 1].bottom : 0;

    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);

    if (!C || !R) { return; }

    if (paintCellsByColumnsDiscrete.reset) {
        this.resetAllGridRenderers(['by-columns']);
        paintCellsByColumnsDiscrete.reset = false;
        bundleColumns.call(this, true);
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each column...
    for (p = 0, c = c0; c < C; c++) {
        cellEvent = pool[p]; // first cell in column c
        vc = cellEvent.visibleColumn;

        prefillColor = cellEvent.column.properties.backgroundColor;
        gc.clearFill(vc.left, 0, vc.width, viewHeight, prefillColor);

        // Optionally clip to visible portion of column to prevent text from overflowing to right.
        columnClip = vc.column.properties.columnClip;
        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

        // For each row of each subgrid (of each column)...
        for (preferredWidth = r = 0; r < R; r++, p++) {
            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)

            try {
                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, cellEvent, prefillColor));
            } catch (e) {
                this.renderErrorCell(e, gc, vc, cellEvent.visibleRow);
            }
        }

        gc.clipRestore(columnClip);

        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
    }

    // gc.clipRestore(clipToGrid);

    this.paintGridlines(gc);
}

paintCellsByColumnsDiscrete.key = 'by-columns-discrete';

module.exports = paintCellsByColumnsDiscrete;

},{"./bundle-columns":110}],115:[function(require,module,exports){
'use strict';

var bundleColumns = require('./bundle-columns');

/** @summary Render the grid with consolidated column rects.
 * @desc Paints all the cells of a grid, one column at a time.
 *
 * First, a background rect is drawn using the grid background color.
 *
 * Then, if there are any columns with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of column backgrounds are all drawn before iterating through cells. Note that these column rects are _not_ suitable for clipping overflow text from previous columns. If you have overflow text, either turn on clipping (big performance hit) or turn on one of the `truncateTextWithEllipsis` options.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * **Regading clipping.** The reason for clipping is to prevent text from overflowing into the next column. However there is a serious performance cost.
 *
 * For performance reasons {@link Renderer#_paintCell|_paintCell} does not set up a clipping region for each cell. However, iff grid property `columnClip` is truthy, this grid renderer will set up a clipping region to prevent text overflow to right. If `columnClip` is `null`, a clipping region will only be set up on the last column. Otherwise, there will be no clipping region.
 *
 * The idea of clipping just the last column is because in addition to the optional graphics clipping, we also clip ("truncate") text. Text can be truncated conservatively so it will never overflow. The problem with this is that characters vanish as they hit the right cell boundary, which may or may be obvious depending on font size. Alternatively, text can be truncated so that the overflow will be a maximum of 1 character. This allows partial characters to be rendered. But this is where graphics clipping is required.
 *
 * When renderering column by column as this particular renderer does, _and_ when the background color _of the next cell to the right_ is opaque (alpha = 1), clipping can be turned off because each column will _overpaint_ any text that overflowed from the one before. However, any text that overflows the last column will paint into unused canvas region to the right of the grid. This is the _raison d'être_ for "clip last column only" option mentioned above (when `columnClip` is set to `null`). To avoid even this performance cost (of clipping just the last column), column widths can be set to fill the available canvas.
 *
 * Note that text never overflows to left because text starting point is never < 0. The reason we don't clip to the left is for cell renderers that need to re-render to the left to produce a merged cell effect, such as grouped column header.

 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsByColumns(gc) {
    var grid = this.grid,
        gridProps = grid.properties,
        prefillColor, gridPrefillColor = gridProps.backgroundColor,
        cellEvent,
        columnBundle, columnBundles,
        vc, visibleColumns = this.visibleColumns,
        visibleRows = this.visibleRows,
        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
        r, R = visibleRows.length,
        p, pool = this.cellEventPool,
        preferredWidth,
        columnClip,
        // clipToGrid,
        viewWidth = C ? visibleColumns[cLast].right : 0,
        viewHeight = R ? visibleRows[R - 1].bottom : 0;

    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);

    if (!C || !R) { return; }

    if (gc.alpha(gridPrefillColor) > 0) {
        gc.cache.fillStyle = gridPrefillColor;
        gc.fillRect(0, 0, viewWidth, viewHeight);
    }

    if (paintCellsByColumns.reset) {
        this.resetAllGridRenderers(['by-columns-discrete']);
        paintCellsByColumns.reset = false;
        bundleColumns.call(this, true);
    } else if (paintCellsByColumns.rebundle) {
        paintCellsByColumns.rebundle = false;
        bundleColumns.call(this);
    }

    for (columnBundles = this.columnBundles, c = columnBundles.length; c--;) {
        columnBundle = columnBundles[c];
        gc.clearFill(columnBundle.left, 0, columnBundle.right - columnBundle.left, viewHeight, columnBundle.backgroundColor);
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each column...
    for (p = 0, c = c0; c < C; c++) {
        cellEvent = pool[p]; // first cell in column c
        vc = cellEvent.visibleColumn;

        prefillColor = cellEvent.column.properties.backgroundColor;

        // Optionally clip to visible portion of column to prevent text from overflowing to right.
        columnClip = vc.column.properties.columnClip;
        gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

        // For each row of each subgrid (of each column)...
        for (preferredWidth = r = 0; r < R; r++, p++) {
            cellEvent = pool[p]; // next cell down the column (redundant for first cell in column)

            try {
                preferredWidth = Math.max(preferredWidth, this._paintCell(gc, cellEvent, prefillColor));
            } catch (e) {
                this.renderErrorCell(e, gc, vc, cellEvent.visibleRow);
            }
        }

        gc.clipRestore(columnClip);

        cellEvent.column.properties.preferredWidth = Math.round(preferredWidth);
    }

    // gc.clipRestore(clipToGrid);

    this.paintGridlines(gc);
}

paintCellsByColumns.key = 'by-columns';
paintCellsByColumns.rebundle = false; // see rebundleGridRenderers

module.exports = paintCellsByColumns;

},{"./bundle-columns":110}],116:[function(require,module,exports){
'use strict';

var bundleRows = require('./bundle-rows');

/** @summary Render the grid.
 * @desc _**NOTE:** This grid renderer is not as performant as the others and it's use is not recommended if you care about performance. The reasons for the wanting performance are unclear, possibly having to do with the way Chrome optimizes access to the column objects?_
 *
 * Paints all the cells of a grid, one row at a time.
 *
 * First, a background rect is drawn using the grid background color.
 *
 * Then, if there are any rows with their own background color _that differs from the grid background color,_ these are consolidated and the consolidated groups of row backgrounds are all drawn before iterating through cells.
 *
 * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
 * The error message is error-logged to console AND displayed in cell.
 *
 * Each cell to be rendered is described by a {@link CellEvent} object. For performance reasons, to avoid constantly instantiating these objects, we maintain a pool of these. When the grid shape changes, we reset their coordinates by setting {@link CellEvent#reset|reset} on each.
 *
 * See also the discussion of clipping in {@link Renderer#paintCellsByColumns|paintCellsByColumns}.
 * @this {Renderer}
 * @param {CanvasRenderingContext2D} gc
 * @memberOf Renderer.prototype
 */
function paintCellsByRows(gc) {
    var grid = this.grid,
        gridProps = grid.properties,
        prefillColor, rowPrefillColors, gridPrefillColor = gridProps.backgroundColor,
        cellEvent,
        rowBundle, rowBundles = this.rowBundles,
        vc, visibleColumns = this.visibleColumns,
        vr, visibleRows = this.visibleRows,
        c, C = visibleColumns.length, c0 = gridProps.showRowNumbers ? -1 : 0, cLast = C - 1,
        r, R = visibleRows.length,
        p, pool = this.cellEventPool,
        preferredWidth = Array(C - c0).fill(0),
        columnClip,
        // clipToGrid,
        viewWidth = C ? visibleColumns[C - 1].right : 0,
        viewHeight = R ? visibleRows[R - 1].bottom : 0,
        lineWidth = gridProps.lineWidth,
        lineColor = gridProps.lineColor;

    gc.clearRect(0, 0, this.bounds.width, this.bounds.height);

    if (!C || !R) { return; }

    if (gc.alpha(gridPrefillColor) > 0) {
        gc.cache.fillStyle = gridPrefillColor;
        gc.fillRect(0, 0, viewWidth, viewHeight);
    }

    if (paintCellsByRows.reset) {
        this.resetAllGridRenderers();
        paintCellsByRows.reset = false;
        bundleRows.call(this, true);
    }

    rowPrefillColors = this.rowPrefillColors;

    for (r = rowBundles.length; r--;) {
        rowBundle = rowBundles[r];
        gc.clearFill(0, rowBundle.top, viewWidth, rowBundle.bottom - rowBundle.top, rowBundle.backgroundColor);
    }

    // gc.clipSave(clipToGrid, 0, 0, viewWidth, viewHeight);

    // For each row of each subgrid...
    for (p = 0, r = 0; r < R; r++) {
        prefillColor = rowPrefillColors[r];

        if (gridProps.gridLinesH) {
            gc.cache.fillStyle = lineColor;
            gc.fillRect(0, pool[p].visibleRow.bottom, viewWidth, lineWidth);
        }

        // For each column (of each row)...
        for (c = c0; c < C; c++, p++) {
            cellEvent = pool[p]; // next cell across the row (redundant for first cell in row)
            vc = cellEvent.visibleColumn;

            // Optionally clip to visible portion of column to prevent text from overflowing to right.
            columnClip = vc.column.properties.columnClip;
            gc.clipSave(columnClip || columnClip === null && c === cLast, 0, 0, vc.right, viewHeight);

            try {
                preferredWidth[c] = Math.max(preferredWidth[c], this._paintCell(gc, cellEvent, prefillColor));
            } catch (e) {
                this.renderErrorCell(e, gc, vc, vr);
            }

            gc.clipRestore(columnClip);
        }
    }

    // gc.clipRestore(clipToGrid);

    this.paintGridlines(gc);

    for (c = c0; c < C; c++) {
        visibleColumns[c].column.properties.preferredWidth = Math.round(preferredWidth[c]);
    }
}

paintCellsByRows.key = 'by-rows';

module.exports = paintCellsByRows;

},{"./bundle-rows":111}],117:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Base = require('../Base');
var images = require('../../images/index');


var visibleColumnPropertiesDescriptor = {
    find: {
        // Like Array.prototype.find except searches negative indexes as well.
        value: function(iteratee, context) {
            for (var i = -1; i in this; --i); // eslint-disable-line curly
            while (++i) {
                if (iteratee.call(context, this[i], i, this)) {
                    return this[i];
                }
            }
            return Array.prototype.find.call(this, iteratee, context);
        }
    }
};


/** @typedef {object} CanvasRenderingContext2D
 * @see [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 */

/** @typedef {object} visibleColumnDescriptor
 * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleColumns}.
 * @property {number} columnIndex - Dereferences {@link Behavior#columns}, the subset of _active_ columns, specifying which column to show in that position.
 * @property {number} left - Pixel coordinate of the left edge of this column, rounded to nearest integer.
 * @property {number} right - Pixel coordinate of the right edge of this column, rounded to nearest integer.
 * @property {number} width - Width of this column in pixels, rounded to nearest integer.
 */

/** @typedef {object} visibleRowDescriptor
 * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleRows}.
 * @property {number} rowIndex - Local vertical row coordinate within the subgrid to which the row belongs, adjusted for scrolling.
 * @property {dataModelAPI} subgrid - A reference to the subgrid to which the row belongs.
 * @property {number} top - Pixel coordinate of the top edge of this row, rounded to nearest integer.
 * @property {number} bottom - Pixel coordinate of the bottom edge of this row, rounded to nearest integer.
 * @property {number} height - Height of this row in pixels, rounded to nearest integer.
 */

/**
 * @constructor
 * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
 *
 * It relies on two other external subprojects
 *
 * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
 * 2. rectangular: a small npm module providing Point and Rectangle objects
 *
 * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
 * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
 *
 * Instances of this object have basically four main functions.
 *
 * 1. render fixed row headers
 * 2. render fixed col headers
 * 3. render main data cells
 * 4. render grid lines
 *
 * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
 *
 */
var Renderer = Base.extend('Renderer', {

    //the shared single item "pooled" cell object for drawing each cell
    cell: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    scrollHeight: 0,

    viewHeight: 0,

    reset: function() {
        this.bounds = {
            width: 0,
            height: 0
        };

        /**
         * Represents the ordered set of visible columns. Array size is always the exact number of visible columns, the last of which may only be partially visible.
         *
         * This sequence of elements' `columnIndex` values assumes one of three patterns. Which pattern is base on the following two questions:
         * * Are there "fixed" columns on the left?
         * * Is the grid horizontally scrolled?
         *
         * The set of `columnIndex` values consists of:
         * 1. The first element will be -1 if the row handle column is being rendered.
         * 2. A zero-based list of consecutive of integers representing the fixed columns (if any).
         * 3. An n-based list of consecutive of integers representing the scrollable columns (where n = number of fixed columns + the number of columns scrolled off to the left).
         * @type {visibleColumnDescriptor}
         */
        this.visibleColumns = Object.defineProperties([], visibleColumnPropertiesDescriptor);

        /**
         * Represents the ordered set of visible rows. Array size is always the exact number of visible rows.
         *
         * The sequence of elements' `rowIndex` values is local to each subgrid.
         * * **For each non-scrollable subgrid:** The sequence is a zero-based list of consecutive integers.
         * * **For the scrollable subgrid:**
         *   1. A zero-based list of consecutive of integers representing the fixed rows (if any).
         *   2. An n-based list of consecutive of integers representing the scrollable rows (where n = number of fixed rows + the number of rows scrolled off the top).
         *
         * Note that non-scrollable subgrids can come both before _and_ after the scrollable subgrid.
         * @type {visibleRowDescriptor}
         */
        this.visibleRows = [];

        this.insertionBounds = [];

        this.cellEventPool = [];
    },

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf Renderer.prototype
     */
    initialize: function(grid) {
        this.grid = grid;

        // typically grid properties won't exist yet
        this.setGridRenderer(this.properties.gridRenderer || 'by-columns-and-rows');

        this.reset();
    },

    gridRenderers: {},

    registerGridRenderer: function(gridRenderer, name) {
        this.gridRenderers[name || gridRenderer.key] = gridRenderer;
    },

    setGridRenderer: function(key) {
        var paintCells = this.gridRenderers[key];

        if (!paintCells) {
            throw new this.HypergridError('Unregistered grid renderer "' + key + '"');
        }

        if (paintCells !== this.paintCells) {
            this.paintCells = paintCells;
            this.paintCells.reset = true;
        }
    },

    resetAllGridRenderers: function(blackList) {
        // Notify renderers that grid shape has changed
        Object.keys(this.gridRenderers).forEach(function(key) {
            this.gridRenderers[key].reset = !blackList || blackList.indexOf(key) < 0;
        }, this);
    },

    /**
     * Certain renderers that pre-bundle column rects based on columns' background colors need to re-bundle when columns' background colors change. This method sets the `rebundle` property to `true` for those renderers that have that property.
     */
    rebundleGridRenderers: function() {
        Object.keys(this.gridRenderers).forEach(function(key) {
            if ('rebundle' in this.gridRenderers[key]) {
                this.gridRenderers[key].rebundle = true;
            }
        }, this);
    },

    /**
     * This function creates several data structures:
     * * {@link Renderer#visibleColumns}
     * Original comment:
     * "this function computes the grid coordinates used for extremely fast iteration over
     * painting the grid cells. this function is very fast, for thousand rows X 100 columns
     * on a modest machine taking usually 0ms and no more that 3 ms."
     */
    computeCellsBounds: function() {

        //var startTime = Date.now();

        var scrollTop = this.getScrollTop(),
            scrollLeft = this.getScrollLeft(),

            fixedColumnCount = this.grid.getFixedColumnCount(),
            fixedRowCount = this.grid.getFixedRowCount(),

            bounds = this.getBounds(),
            grid = this.grid,
            behavior = grid.behavior,
            editorCellEvent = grid.cellEditor && grid.cellEditor.event,

            vcEd, xEd,
            vrEd, yEd,
            sgEd, isSubgridEd,

            insertionBoundsCursor = 0,
            previousInsertionBoundsCursorValue = 0,

            lineWidth = grid.properties.lineWidth,

            start = grid.properties.showRowNumbers ? -1 : 0,
            x, X, // horizontal pixel loop index and limit
            y, Y, // vertical pixel loop index and limit
            c, C, // column loop index and limit
            g, G, // subgrid loop index and limit
            r, R, // row loop index and limitrows in current subgrid
            subrows, // rows in subgrid g
            base, // sum of rows for all subgrids so far
            subgrids = behavior.subgrids,
            subgrid,
            rowIndex,
            scrollableSubgrid,
            footerHeight,
            vx, vy,
            vr, vc,
            width, height,
            firstVX, lastVX,
            firstVY, lastVY,
            topR,
            xSpaced, widthSpaced, heightSpaced; // adjusted for cell spacing

        if (editorCellEvent) {
            xEd = editorCellEvent.gridCell.x;
            yEd = editorCellEvent.dataCell.y;
            sgEd = editorCellEvent.subgrid;
        }

        this.scrollHeight = 0;

        this.visibleColumns.length = 0;
        this.visibleRows.length = 0;

        this.visibleColumnsByIndex = []; // array because number of columns will always be reasonable
        this.visibleRowsByDataRowIndex = {}; // hash because keyed by (fixed and) scrolled row indexes

        this.insertionBounds = [];

        for (
            x = 0, c = start, C = this.grid.getColumnCount(), X = bounds.width || grid.canvas.width;
            c < C && x <= X;
            c++
        ) {
            vx = c;
            if (c >= fixedColumnCount) {
                lastVX = vx += scrollLeft;
                if (firstVX === undefined) {
                    firstVX = lastVX;
                }
            }
            if (vx >= C) {
                break; // scrolled beyond last column
            }

            width = Math.ceil(behavior.getColumnWidth(vx));

            xSpaced = x ? x + lineWidth : x;
            widthSpaced = x ? width - lineWidth : width;
            this.visibleColumns[c] = this.visibleColumnsByIndex[vx] = vc = {
                index: c,
                columnIndex: vx,
                column: behavior.getActiveColumn(vx),
                left: xSpaced,
                width: widthSpaced,
                right: xSpaced + widthSpaced
            };
            if (xEd === vx) {
                vcEd = vc;
            }

            x += width;

            insertionBoundsCursor += Math.round(width / 2) + previousInsertionBoundsCursorValue;
            this.insertionBounds.push(insertionBoundsCursor);
            previousInsertionBoundsCursorValue = Math.round(width / 2);
        }

        // get height of total number of rows in all subgrids following the data subgrid
        footerHeight = grid.properties.defaultRowHeight *
            subgrids.reduce(function(rows, subgrid) {
                if (scrollableSubgrid) {
                    rows += subgrid.getRowCount();
                } else {
                    scrollableSubgrid = subgrid.isData;
                }
                return rows;
            }, 0);

        for (
            base = r = g = y = 0, G = subgrids.length, Y = bounds.height - footerHeight;
            g < G;
            g++, base += subrows
        ) {
            subgrid = subgrids[g];
            subrows = subgrid.getRowCount();
            scrollableSubgrid = subgrid.isData;
            isSubgridEd = (sgEd === subgrid);
            topR = r;

            // For each row of each subgrid...
            for (R = r + subrows; r < R && y < Y; r++) {
                vy = r;
                if (scrollableSubgrid && r >= fixedRowCount) {
                    vy += scrollTop;
                    lastVY = vy - base;
                    if (firstVY === undefined) {
                        firstVY = lastVY;
                    }
                    if (vy >= R) {
                        break; // scrolled beyond last row
                    }
                }

                rowIndex = vy - base;
                height = behavior.getRowHeight(rowIndex, subgrid);

                heightSpaced = height - lineWidth;
                this.visibleRows[r] = vr = {
                    index: r,
                    subgrid: subgrid,
                    rowIndex: rowIndex,
                    top: y,
                    height: heightSpaced,
                    bottom: y + heightSpaced
                };

                if (scrollableSubgrid) {
                    this.visibleRowsByDataRowIndex[vy - base] = vr;
                }

                if (isSubgridEd && yEd === rowIndex) {
                    vrEd = vr;
                }

                y += height;
            }

            if (scrollableSubgrid) {
                subrows = r - topR;
                Y += footerHeight;
            }
        }

        if (editorCellEvent) {
            editorCellEvent.visibleColumn = vcEd;
            editorCellEvent.visibleRow = vrEd;
            editorCellEvent.gridCell.y = vrEd && vrEd.index;
            editorCellEvent._bounds = null;
        }

        this.viewHeight = Y;

        this.dataWindow = this.grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);

        // Resize CellEvent pool
        var pool = this.cellEventPool,
            previousLength = pool.length,
            P = (this.visibleColumns.length - start) * this.visibleRows.length;

        if (P > previousLength) {
            pool.length = P; // grow pool to accommodate more cells
        }
        for (var p = previousLength; p < P; p++) {
            pool[p] = new behavior.CellEvent; // instantiate new members
        }

        this.resetAllGridRenderers();
    },

    /**
     * CAUTION: Keep in place! Used by {@link Canvas}.
     * @memberOf Renderer.prototype
     * @returns {Object} The current grid properties object.
     */
    get properties() {
        return this.grid.properties;
    },

    /**
     * Previously used by fin-canvas.
     * @memberOf Renderer.prototype
     * @returns {Object} a property value at a key, delegates to the grid
     * @deprecated
     */
    resolveProperty: function(key) {
        this.deprecated('resolveProperty', 'The .resolveProperty(key) method is deprecated as of v1.2.10 in favor of the .grid.properties object dereferenced with [key]. (Will be removed in a future release.)');
        return this.properties[key];
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Notify the fin-hypergrid every time we've repainted.
     * @desc This is the entry point from fin-canvas.
     * @param {CanvasRenderingContext2D} gc
     */
    paint: function(gc) {
        if (this.grid.canvas) {
            this.renderGrid(gc);
            this.grid.gridRenderedNotification();
        }
    },

    tickNotification: function() {
        this.grid.tickNotification();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Answer how many rows we rendered
     */
    getVisibleRowsCount: function() {
        return this.visibleRows.length - 1;
    },

    getVisibleScrollHeight: function() {
        return this.viewHeight - this.grid.getFixedRowsHeight();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number[]} Rows we just rendered.
     */
    getVisibleRows: function() {
        this.deprecated('getVisibleRows', 'The getVisibleRows() method has been deprecated as of v1.2.0. (Will be removed in a future version.) Previously returned the this.visibleRows array but because this.visibleRows is no longer a simple array of integers but is now an array of objects, it now returns an array mapped to this.visibleRows[*].rowIndex. Note however that this mapping is not equivalent to what this method previously returned because while each object\'s .rowIndex property is still adjusted for scrolling within the data subgrid, the index is now local to (zero-based within) each subgrid');
        return this.visibleRows.map(function(vr) { return vr.rowIndex; });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Number of columns we just rendered.
     */
    getVisibleColumnsCount: function() {
        return this.visibleColumns.length - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Columns we just rendered.
     */
    getVisibleColumns: function() {
        this.deprecated('visibleColumns', 'The getVisibleColumns() method has been deprecated as of v1.2.0. (Will be removed in a future version.) Previously returned the this.visibleColumns but because this.visibleColumns is no longer a simple array of integers but is now an array of objects, it now returns an array mapped to the equivalent visibleColumns[*].columnIndex.');
        return this.visibleColumns.map(function(vc) { return vc.columnIndex; });
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CellEvent|number} x - CellEvent object or grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
     */
    getBoundsOfCell: function(x, y) {
        var vc = this.visibleColumns[x],
            vr = this.visibleRows[y];

        return {
            x: vc.left,
            y: vr.top,
            width: vc.width,
            height: vr.height
        };
    },

    /**
     * @memberOf Renderer.prototype
     * @desc answer the column index under the coordinate at pixelX
     * @param {number} pixelX - The horizontal coordinate.
     * @returns {number} The column index under the coordinate at pixelX.
     */
    getColumnFromPixelX: function(pixelX) {
        var width = 0,
            fixedColumnCount = this.grid.getFixedColumnCount(),
            scrollLeft = this.grid.getHScrollValue(),
            visibleColumns = this.visibleColumns;

        for (var c = 1; c < visibleColumns.length - 1; c++) {
            width = visibleColumns[c].left - (visibleColumns[c].left - visibleColumns[c - 1].left) / 2;
            if (pixelX < width) {
                if (c > fixedColumnCount) {
                    c += scrollLeft;
                }
                return c - 1;
            }
        }
        if (c > fixedColumnCount) {
            c += scrollLeft;
        }
        return c - 1;
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
     * @param {Point} point
     * @returns {Point} Cell coordinates
     */
    getGridCellFromMousePoint: function(point) {
        var x = point.x,
            y = point.y,
            vrs = this.visibleRows,
            vcs = this.visibleColumns,
            firstColumn = vcs[this.properties.showRowNumbers ? -1 : 0],
            inFirstColumn = x < firstColumn.right,
            vc = inFirstColumn ? firstColumn : vcs.find(function(vc) { return x < vc.right; }),
            vr = vrs.find(function(vr) { return y < vr.bottom; }),
            result = null;

        if (vr && vc) {
            var mousePoint = this.grid.newPoint(x - vc.left, y - vr.top),
                cellEvent = new this.grid.behavior.CellEvent(vc.columnIndex, vr.index);

            // cellEvent.visibleColumn = vc;
            // cellEvent.visibleRow = vr;

            result = Object.defineProperty(cellEvent, 'mousePoint', {value: mousePoint});
        }
        return result;
    },

    /**
     * @summary Get the visibility of the column matching the provided grid column index.
     * @desc Requested column may not be visible due to being scrolled out of view.
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} columnIndex - the column index
     * @returns {boolean} The given column is visible.
     */
    isColumnVisible: function(columnIndex) {
        return !!this.getVisibleColumn(columnIndex);
    },

    /**
     * @summary Get the "visible column" object matching the provided grid column index.
     * @desc Requested column may not be visible due to being scrolled out of view.
     * @memberOf Renderer.prototype
     * @summary Find a visible column object.
     * @param {number} columnIndex - The grid column index.
     * @returns {object|undefined} The given column if visible or `undefined` if not.
     */
    getVisibleColumn: function(columnIndex) {
        return this.visibleColumns.find(function(vc) {
            return vc.columnIndex === columnIndex;
        });
    },

    /**
     * @summary Get the visibility of the column matching the provided data column index.
     * @desc Requested column may not be visible due to being scrolled out of view or if the column is inactive.
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} columnIndex - the column index
     * @returns {boolean} The given column is visible.
     */
    isDataColumnVisible: function(columnIndex) {
        return !!this.getVisibleDataColumn(columnIndex);
    },

    /**
     * @summary Get the "visible column" object matching the provided data column index.
     * @desc Requested column may not be visible due to being scrolled out of view or if the column is inactive.
     * @memberOf Renderer.prototype
     * @summary Find a visible column object.
     * @param {number} columnIndex - The grid column index.
     * @returns {object|undefined} The given column if visible or `undefined` if not.
     */
    getVisibleDataColumn: function(columnIndex) {
        return this.visibleColumns.find(function(vc) {
            return vc.column.index === columnIndex;
        });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The width x coordinate of the last rendered column
     */
    getFinalVisibleColumnBoundary: function() {
        var chop = this.isLastColumnVisible() ? 2 : 1;
        var colWall = this.visibleColumns[this.visibleColumns.length - chop].right;
        return Math.min(colWall, this.getBounds().width);
    },

    /**
     * @summary Get the visibility of the row matching the provided grid row index.
     * @desc Requested row may not be visible due to being outside the bounds of the rendered grid.
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - The grid row index.
     * @returns {boolean} The given row is visible.
     */
    isRowVisible: function(rowIndex) {
        return !!this.visibleRows[rowIndex];
    },

    /**
     * @summary Get the "visible row" object matching the provided grid row index.
     * @desc Requested row may not be visible due to being outside the bounds of the rendered grid.
     * @memberOf Renderer.prototype
     * @summary Find a visible row object.
     * @param {number} rowIndex - The grid row index.
     * @returns {object|undefined} The given row if visible or `undefined` if not.
     */
    getVisibleRow: function(rowIndex) {
        return this.visibleRows[rowIndex];
    },

    /**
     * @summary Get the visibility of the row matching the provided data row index.
     * @desc Requested row may not be visible due to being scrolled out of view.
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - The data row index.
     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
     * @returns {boolean} The given row is visible.
     */
    isDataRowVisible: function(rowIndex, subgrid) {
        return !!this.getVisibleDataRow(rowIndex, subgrid);
    },

    /**
     * @summary Get the "visible row" object matching the provided data row index.
     * @desc Requested row may not be visible due to being scrolled out of view.
     * @memberOf Renderer.prototype
     * @summary Find a visible row object.
     * @param {number} rowIndex - The data row index within the given subgrid.
     * @param {dataModelAPI} [subgrid=this.behavior.subgrids.data]
     * @returns {object|undefined} The given row if visible or `undefined` if not.
     */
    getVisibleDataRow: function(rowIndex, subgrid) {
        subgrid = subgrid || this.grid.behavior.subgrids.lookup.data;
        return this.visibleRows.find(function(vr) {
            return vr.subgrid === subgrid && vr.rowIndex === rowIndex;
        });
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a cell is selected.
     * @param {number} x - the x cell coordinate
     * @param {number} y - the y cell coordinate*
     * @returns {boolean} The given cell is fully visible.
     */
    isSelected: function(x, y) {
        return this.grid.isSelected(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc This is the main forking of the renderering task.
     * @param {CanvasRenderingContext2D} gc
     */
    renderGrid: function(gc) {
        gc.beginPath();

        this.buttonCells = {};
        this.paintCells(gc);
        resetNumberColumnWidth(gc, this.grid.behavior);

        this.renderOverrides(gc);

        this.renderLastSelection(gc);

        gc.closePath();
    },

    renderLastSelection: function(gc) {
        var selections = this.grid.selectionModel.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }

        var selection = this.grid.selectionModel.getLastSelection();
        if (selection.origin.x === -1) {
            // no selected area, lets exit
            return;
        }

        var vci = this.visibleColumnsByIndex,
            vri = this.visibleRowsByDataRowIndex,
            lastColumn = this.visibleColumns[this.visibleColumns.length - 1], // last column in scrollable section
            lastRow = vri[this.dataWindow.corner.y]; // last row in scrollable data section
        if (
            !lastColumn || !lastRow ||
            selection.origin.x > lastColumn.columnIndex ||
            selection.origin.y > lastRow.rowIndex
        ) {
            // selection area begins to right or below grid
            return;
        }

        var vcOrigin = vci[selection.origin.x],
            vcCorner = vci[selection.corner.x],
            vrOrigin = vri[selection.origin.y],
            vrCorner = vri[selection.corner.y];
        if (
            !(vcOrigin || vcCorner) || // entire selection scrolled out of view to left of scrollable region
            !(vrOrigin || vrCorner)    // entire selection scrolled out of view above scrollable region
        ) {
            return;
        }

        var gridProps = this.properties;
        vcOrigin = vcOrigin || this.visibleColumns[gridProps.fixedColumnCount];
        vrOrigin = vrOrigin || this.visibleRows[gridProps.fixedRowCount];
        vcCorner = vcCorner || (selection.corner.x > lastColumn.columnIndex ? lastColumn : vci[gridProps.fixedColumnCount - 1]);
        vrCorner = vrCorner || (selection.corner.y > lastRow.rowIndex ? lastRow : vri[gridProps.fixedRowCount - 1]);

        // Render the selection model around the bounds
        var config = {
            bounds: {
                x: vcOrigin.left,
                y: vrOrigin.top,
                width: vcCorner.right - vcOrigin.left,
                height: vrCorner.bottom - vrOrigin.top
            },
            selectionRegionOverlayColor: this.paintCells.partial ? 'transparent' : gridProps.selectionRegionOverlayColor,
            selectionRegionOutlineColor: gridProps.selectionRegionOutlineColor
        };
        this.grid.cellRenderers.get('lastselection').paint(gc, config);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc iterate the renderering overrides and manifest each
     * @param {CanvasRenderingContext2D} gc
     */
    renderOverrides: function(gc) {
        var cache = this.grid.renderOverridesCache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                var override = cache[key];
                if (override) {
                    this.renderOverride(gc, override);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc copy each overrides specified area to it's target and blank out the source area
     * @param {CanvasRenderingContext2D} gc
     * @param {OverrideObject} override - an object with details contain an area and a target context
     */
    renderOverride: function(gc, override) {
        //lets blank out the drag row
        var hdpiRatio = override.hdpiratio;
        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
        var width = override.width + 1;
        var height = override.height;
        var targetCTX = override.ctx;
        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
        targetCTX.putImageData(imgData, 0, 0);
        gc.cache.fillStyle = this.properties.backgroundColor2;
        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current vertical scroll value.
     */
    getScrollTop: function() {
        return this.grid.getVScrollValue();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current horizontal scroll value.
     */
    getScrollLeft: function() {
        return this.grid.getHScrollValue();
    },

    getColumnEdges: function() {
        this.deprecated('columnEdges', 'The getColumnEdges() mehtod has been deprecated as of version 1.2.0 in favor of visibleColumns[*].top. (Will be removed in a future version.) Note however that columnEdges had one additional element (representing the right edge of the last visible column) which visibleColumns lacks. Instead you can reference visibleColumns[*].bottom.');
        return this.visibleColumns.map(function(vc) { return vc.left; }).concat([this.visibleColumns[this.visibleColumns.length - 1].right]);
    },

    getRowEdges: function() {
        this.deprecated('rowEdges', 'The getRowEdges() method has been deprecated as of version 1.2.0 in favor of visibleRows[*].top. (Will be removed in a future version.) Note however that rowEdges had one additional element (representing the bottom edge of the last visible row) which visibleRows lacks. Instead you can reference visibleRows[*].bottom.');
        return this.visibleRows.map(function(vr) { return vr.top; }).concat([this.visibleRows[this.visibleRows.length - 1].bottom]);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} The last col was rendered (is visible)
     */
    isLastColumnVisible: function() {
        var lastColumnIndex = this.grid.getColumnCount() - 1;
        return !!this.visibleColumns.find(function(vc) { return vc.columnIndex === lastColumnIndex; });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered column width at index
     */
    getRenderedWidth: function(index) {
        var result,
            columns = this.visibleColumns;

        if (index >= columns.length) {
            result = columns[columns.length - 1].right;
        } else {
            result = columns[index].left;
        }

        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered row height at index
     */
    getRenderedHeight: function(index) {
        var result,
            rows = this.visibleRows;

        if (index >= rows.length) {
            var last = rows[rows.length - 1];
            result = last.bottom;
        } else {
            result = rows[index].top;
        }

        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
     */
    getCanvas: function() {
        return this.deprecated('getCanvas()', 'grid.canvas', '1.2.2');
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} User is currently dragging a column for reordering.
     */
    isDraggingColumn: function() {
        return this.grid.isDraggingColumn();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to go to for a page up.
     */
    getPageUpRow: function() {
        var grid = this.grid,
            scrollHeight = this.getVisibleScrollHeight(),
            top = this.dataWindow.origin.y - this.properties.fixedRowCount - 1,
            scanHeight = 0;
        while (scanHeight < scrollHeight && top >= 0) {
            scanHeight += grid.getRowHeight(top);
            top--;
        }
        return top + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page down.
     */
    getPageDownRow: function() {
        return this.dataWindow.corner.y - this.properties.fixedRowCount + 1;
    },

    renderErrorCell: function(err, gc, vc, vr) {
        var message = err && (err.message || err) || 'Unknown error.',
            bounds = { x: vc.left, y: vr.top, width: vc.width, height: vr.height },
            config = { bounds: bounds };

        console.error(message);

        gc.cache.save(); // define clipping region
        gc.beginPath();
        gc.rect(bounds.x, bounds.y, bounds.width, bounds.height);
        gc.clip();

        this.grid.cellRenderers.get('errorcell').paint(gc, config, message);

        gc.cache.restore(); // discard clipping region
    },

    /**
     * @memberOf Renderer.prototype
     * @desc We opted to not paint borders for each cell as that was extremely expensive. Instead we draw grid lines here.
     * @param {CanvasRenderingContext2D} gc
     */
    paintGridlines: function(gc) {
        var visibleColumns = this.visibleColumns, C = visibleColumns.length,
            visibleRows = this.visibleRows, R = visibleRows.length;

        if (C && R) {
            var gridProps = this.properties,
                lineWidth = gridProps.lineWidth,
                lineColor = gridProps.lineColor;

            if (gridProps.gridLinesV) {
                gc.cache.fillStyle = lineColor;
                var viewHeight = visibleRows[R - 1].bottom,
                    c = gridProps.showRowNumbers ? -1 : 0;
                if (gridProps.gridBorderLeft) {
                    gc.fillRect(visibleColumns[c].left, 0, lineWidth, viewHeight);
                }
                for (c += 1; c < C; c++) {
                    gc.fillRect(visibleColumns[c].left - lineWidth, 0, lineWidth, viewHeight);
                }
                if (gridProps.gridBorderRight) {
                    gc.fillRect(visibleColumns[c - 1].right + 1 - lineWidth, 0, lineWidth, viewHeight);
                }
            }

            if (gridProps.gridLinesH) {
                gc.cache.fillStyle = lineColor;
                var viewWidth = visibleColumns[C - 1].right;
                if (gridProps.gridBorderTop) {
                    gc.fillRect(0, visibleRows[0].top, viewWidth, lineWidth);
                }
                if (!gridProps.gridBorderBottom) {
                    R -= 1;
                }
                if (gridProps.gridBorderRight) {
                    viewWidth += lineWidth;
                }
                for (var r = 0; r < R; r++) {
                    gc.fillRect(0, visibleRows[r].bottom, viewWidth, lineWidth);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     * @param x
     * @param y
     */
    paintCell: function(gc, x, y) {
        gc.moveTo(0, 0);

        var c = this.visibleColumns[x].index, // todo refac
            r = this.visibleRows[y].index;

        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
            this._paintCell(gc, c, r);
        }
    },

    /**
     * @summary Render a single cell.
     * @desc IMPORTANT NOTE: Do not change the line below with the comment "SEE IMPORTANT NOTE ABOVE" without careful performance testing. Building the config object from cell properties object produced much slower rendering times. The original line was:
     * ```javascript
     *     config = Object.create(cellEvent.columnProperties),
     * ```
     * Cell properties object came into play when `cellEvent.properties` getter which returns cell properties object when there is one (else it returns column properties object). The reason seemed to be that doing so caused optimization to fail on the cell renderer function. The work-around was to always build the `config` object from the column properties object, and then _copy_ the "own" cell properties onto it. The current line is:
     * ```javascript
     *     config = Object.assign(Object.create(cellEvent.columnProperties), cellEvent.cellOwnProperties),
     * ```
     * We kept the cell properties object prototype in place (extended from column properties) for other logic.
     * @param {CanvasRenderingContext2D} gc
     * @param {CellEvent} cellEvent
     * @param {string} [prefillColor] If omitted, this is a partial renderer; all other renderers must provide this.
     * @returns {number} Preferred width of renndered cell.
     * @private
     * @memberOf Renderer
     */
    _paintCell: function(gc, cellEvent, prefillColor) {
        var grid = this.grid,
            selectionModel = grid.selectionModel,
            behavior = grid.behavior,
            subgrid = cellEvent.subgrid,

            isHandleColumn = cellEvent.isHandleColumn,
            isHierarchyColumn = cellEvent.isHierarchyColumn,
            isColumnSelected = cellEvent.isColumnSelected,

            isDataRow = cellEvent.isDataRow,
            isRowSelected = cellEvent.isRowSelected,
            isCellSelected = cellEvent.isCellSelected,

            isHeaderRow = cellEvent.isHeaderRow,
            isFilterRow = cellEvent.isFilterRow,

            isRowHandleOrHierarchyColumn = isHandleColumn || isHierarchyColumn,
            isUserDataArea = !isRowHandleOrHierarchyColumn && isDataRow,

            config = Object.assign(Object.create(cellEvent.columnProperties), cellEvent.cellOwnProperties), // SEE IMPORTANT NOTE ABOVE
            x = (config.gridCell = cellEvent.gridCell).x,
            r = (config.dataCell = cellEvent.dataCell).y,

            format,
            isSelected;

        if (isHandleColumn) {
            isSelected = isRowSelected || selectionModel.isCellSelectedInRow(r);
            config.halign = 'right';
        } else if (isHierarchyColumn) {
            isSelected = isRowSelected || selectionModel.isCellSelectedInRow(r);
            config.halign = 'left';
        } else if (isDataRow) {
            isSelected = isCellSelected || isRowSelected || isColumnSelected;
            format = config.format;

            // Iff we have a defined rowProperties array, apply it to config, treating it as a repeating pattern, keyed to row index.
            // Note that Object.assign will ignore undefined.
            var row = cellEvent.columnProperties.rowProperties;
            Object.assign(config, row && row[cellEvent.dataCell.y % row.length]);
        } else {
            format = subgrid.format || config.format; // subgrid format can override column format
            if (isFilterRow) {
                isSelected = false;
            } else if (isColumnSelected) {
                isSelected = true;
            } else {
                isSelected = selectionModel.isCellSelectedInColumn(x); // header or summary or other non-meta
            }
        }

        // Set cell contents:
        // * For all cells: set `config.value` (writable property)
        // * For cells outside of row handle column: also set `config.dataRow` for use by valOrFunc
        if (!isHandleColumn) {
            config.dataRow = cellEvent.dataRow;
            config.value = cellEvent.value;
        } else {
            config.isHandleColumn = true;
            if (isDataRow) {
                // row handle for a data row
                config.value = r + 1; // row number is 1-based
            } else if (isHeaderRow) {
                // row handle for header row: gets "master" checkbox
                config.allRowsSelected = selectionModel.areAllRowsSelected();
            }
        }

        config.isSelected = isSelected;
        config.isDataColumn = !isRowHandleOrHierarchyColumn;
        config.isDataRow = isDataRow;
        config.isHeaderRow = isHeaderRow;
        config.isFilterRow = isFilterRow;
        config.isUserDataArea = isUserDataArea;
        config.isColumnHovered = cellEvent.isColumnHovered;
        config.isRowHovered = cellEvent.isRowHovered;
        config.isCellHovered = cellEvent.isCellHovered;
        config.bounds = cellEvent.bounds;
        config.isCellSelected = isCellSelected;
        config.isRowSelected = isRowSelected;
        config.isColumnSelected = isColumnSelected;
        config.isInCurrentSelectionRectangle = selectionModel.isInCurrentSelectionRectangle(x, r);
        config.prefillColor = prefillColor;

        if (grid.mouseDownState) {
            config.mouseDown = grid.mouseDownState.gridCell.equals(cellEvent.gridCell);
        }

        // This call's dataModel.getCell which developer can override to:
        // * mutate the (writable) properties of `config`
        // * mutate cell renderer choice (instance of which is returned)
        var cellRenderer = behavior.dataModel.getCell(config, config.renderer);

        if (!(config.value && config.value.constructor === Array)) { // fastest array determination
            config.value = config.exec(config.value);
        }

        // Overwrite possibly mutated cell properties, if requested to do so by `getCell` override
        if (cellEvent.cellOwnProperties && config.reapplyCellProperties) {
            Object.assign(config, cellEvent.cellOwnProperties);
        }

        behavior.cellPropertiesPrePaintNotification(config);

        //allow the renderer to identify itself if it's a button
        config.buttonCells = this.buttonCells;

        config.formatValue = grid.getFormatter(format);

        // Following supports partial render>
        config.snapshot = cellEvent.snapshot;
        config.minWidth = cellEvent.minWidth; // in case `paint` aborts before setting `minWidth`

        // Render the cell
        cellRenderer.paint(gc, config);

        // Following supports partial render:
        cellEvent.snapshot = config.snapshot;
        cellEvent.minWidth = config.minWidth;

        return config.minWidth;
    },

    /**
     * @param {number|CellEvent} colIndexOrCellEvent - This is the "data" x coordinate.
     * @param {number} [rowIndex] - This is the "data" y coordinate. Omit if `colIndexOrCellEvent` is a `CellEvent`.
     * @param {dataModelAPI} [dataModel=this.grid.behavior.dataModel] Omit if `colIndexOrCellEvent` is a `CellEvent`.
     * @returns {CellEvent} The matching `CellEvent` object from the renderer's pool. Returns `undefined` if the requested cell is not currently visible (due to being scrolled out of view).
     */
    findCell: function(colIndexOrCellEvent, rowIndex, dataModel) {
        var colIndex, cellEvent,
            pool = this.cellEventPool;

        if (typeof colIndexOrCellEvent === 'object') {
            // colIndexOrCellEvent is a cell event object
            dataModel = rowIndex;
            rowIndex = colIndexOrCellEvent.visibleRow.rowIndex;
            colIndex = colIndexOrCellEvent.column.index;
        } else {
            colIndex = colIndexOrCellEvent;
        }

        dataModel = dataModel || this.grid.behavior.dataModel;

        for (var p = 0, len = this.visibleColumns.length * this.visibleRows.length; p < len; ++p) {
            cellEvent = pool[p];
            if (
                cellEvent.subgrid === dataModel &&
                cellEvent.column.index === colIndex &&
                cellEvent.visibleRow.rowIndex === rowIndex
            ) {
                return cellEvent;
            }
        }
    },

    /**
     * Resets the cell properties cache in the matching `CellEvent` object from the renderer's pool. This will insure that a new cell properties object will be known to the renderer. (Normally, the cache is not reset until the pool is updated by the next call to {@link Renderer#computeCellBounds}).
     * @param {number|CellEvent} xOrCellEvent
     * @param {number} [y]
     * @param {dataModelAPI} [dataModel=this.grid.behavior.dataModel]
     * @returns {CellEvent} The matching `CellEvent` object.
     */
    resetCellPropertiesCache: function(xOrCellEvent, y, dataModel) {
        var cellEvent = this.findCell.apply(this, arguments);
        if (cellEvent) { cellEvent._cellOwnProperties = undefined; }
        return cellEvent;
    },

    resetAllCellPropertiesCaches: function() {
        this.cellEventPool.forEach(function(cellEvent) {
            cellEvent._cellOwnProperties = undefined;
        });
    },

    isViewableButton: function(c, r) {
        var key = c + ',' + r;
        return this.buttonCells[key] === true;
    },

    getBounds: function() {
        return this.bounds;
    },

    setBounds: function(bounds) {
        return (this.bounds = bounds);
    },

    setInfo: function(message) {
        var width;
        if (this.visibleColumns.length) {
            width = this.visibleColumns[this.visibleColumns.length - 1].right;
        }
        this.grid.canvas.setInfo(message, width);
    }
});

function resetNumberColumnWidth(gc, behavior) {
    var rowCount = behavior.dataModel.getRowCount(),
        columnProperties = behavior.getColumnProperties(-1),
        cellProperties = columnProperties.rowHeader,
        padding = 2 * columnProperties.cellPadding,
        iconWidth = columnProperties.preferredWidth = Math.max(
            images.checked ? images.checked.width : 0,
            images.unchecked ? images.unchecked.width : 0
        );

    gc.cache.font = cellProperties.foregroundSelectionFont.indexOf('bold ') >= 0
        ? cellProperties.foregroundSelectionFont : cellProperties.font;

    columnProperties.preferredWidth = iconWidth + padding + gc.getTextWidth(rowCount);

    if (columnProperties.width === undefined) {
        columnProperties.width = columnProperties.preferredWidth;
    }
}

Renderer.prototype.registerGridRenderer(require('./by-cells'));
Renderer.prototype.registerGridRenderer(require('./by-columns'));
Renderer.prototype.registerGridRenderer(require('./by-columns-discrete'));
Renderer.prototype.registerGridRenderer(require('./by-columns-and-rows'));
Renderer.prototype.registerGridRenderer(require('./by-rows'));

module.exports = Renderer;

},{"../../images/index":3,"../Base":41,"./by-cells":112,"./by-columns":115,"./by-columns-and-rows":113,"./by-columns-discrete":114,"./by-rows":116}]},{},[75])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL2Nzcy9pbmRleC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL2ltYWdlcy9pbWFnZXMuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW5kZXguanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvYXV0b21hdC9pbmRleC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9jc3MtaW5qZWN0b3IvaW5kZXguanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZXh0ZW5kLW1lL2luZGV4LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2Zpbi1oeXBlcmdyaWQtZGF0YS1zb3VyY2UtYmFzZS9pbmRleC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5iYXJzL2luZGV4LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9pbmRleC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvQWdncmVnYXRvck5vZGVCYXNlTWl4aW4uanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0FnZ3JlZ2F0b3JOb2RlR3JvdXAuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0FnZ3JlZ2F0b3JOb2RlTGVhZi5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvQWdncmVnYXRvck5vZGVUcmVlLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9CYXNlLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhTm9kZUJhc2UuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFOb2RlR3JvdXAuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFOb2RlR3JvdXBTb3J0ZXIuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFOb2RlTGVhZi5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVUcmVlLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlQWdncmVnYXRvci5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZURlcHRoU29ydGVyLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlR2xvYmFsRmlsdGVyLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlR3JvdXBWaWV3LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlSW5kZXhlZC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZVNvcnRlci5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZVRyZWV2aWV3LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlVHJlZXZpZXdGaWx0ZXIuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2VUcmVldmlld1NvcnRlci5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9NYXBweS5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9hZ2dyZWdhdGlvbnMuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL3V0aWwvaGVhZGVyaWZ5LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy91dGlsL3N0YWJsZVNvcnQuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvbXVzdGFjaGUvbXVzdGFjaGUuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvb2JqZWN0LWl0ZXJhdG9ycy9pbmRleC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9vdmVycmlkZXIvaW5kZXguanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvcG9wLW1lbnUvaW5kZXguanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvcmVjdGFuZ3VsYXIvaW5kZXguanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvc3BhcnNlLWJvb2xlYW4tYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvQmFzZS5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9IeXBlcmdyaWQuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0JlaGF2aW9yLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9Db2x1bW4uanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0pTT04uanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL2NlbGxQcm9wZXJ0aWVzLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9jb2x1bW5Qcm9wZXJ0aWVzLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9pbmRleC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvc3ViZ3JpZHMuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ2VsbEVkaXRvci5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9Db2xvci5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9Db21ib0JveC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9EYXRlLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL0ZpbHRlckJveC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9OdW1iZXIuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvU2xpZGVyLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL1NwaW5uZXIuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvVGV4dGZpZWxkLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL2luZGV4LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvQnV0dG9uLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvQ2VsbFJlbmRlcmVyLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvRXJyb3JDZWxsLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvTGFzdFNlbGVjdGlvbi5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL1NpbXBsZUNlbGwuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TbGlkZXJDZWxsLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvU3BhcmtCYXIuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TcGFya0xpbmUuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9UcmVlQ2VsbC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL2luZGV4LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvRGF0YU1vZGVsLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvSGVhZGVyU3ViZ3JpZC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9kYXRhTW9kZWxzL0pTT04uanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvZGF0YU1vZGVscy9pbmRleC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9kZWZhdWx0cy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9mYWtlX2FiYTM4Zjg2LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NlbGxDbGljay5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsRWRpdGluZy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsU2VsZWN0aW9uLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtbk1vdmluZy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5SZXNpemluZy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5TZWxlY3Rpb24uanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uU29ydGluZy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9GZWF0dXJlLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0ZpbHRlcnMuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvS2V5UGFnaW5nLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL09uSG92ZXIuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvUm93U2VsZWN0aW9uLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1RodW1id2hlZWxTY3JvbGxpbmcuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvaW5kZXguanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvbGliL0NhbnZhcy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvRE9NL2VmZmVjdHMuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvbGliL0RPTS9lbGZvci5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvRE9NL3F1ZXVlbGVzcy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvRGF0YVNvdXJjZU9yaWdpbi5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvTG9jYWxpemF0aW9uLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9TZWxlY3Rpb25Nb2RlbC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvV3JpdGFibGVQb2ludC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvY2VsbEV2ZW50RmFjdG9yeS5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvZGVwcmVjYXRlZC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvZHluYW1pY1Byb3BlcnRpZXMuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvbGliL2Vycm9yLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9ldmVudHMuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvbGliL2ZpZWxkcy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvZ3JhcGhpY3MuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvbGliL2luZGV4LmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9wb2x5ZmlsbHMuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvbGliL3NlbGVjdGlvbi5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvc3R5bGVzaGVldC5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9saWIvdG9GdW5jdGlvbi5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9yZW5kZXJlci9idW5kbGUtY29sdW1ucy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9yZW5kZXJlci9idW5kbGUtcm93cy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9yZW5kZXJlci9ieS1jZWxscy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9yZW5kZXJlci9ieS1jb2x1bW5zLWFuZC1yb3dzLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL3JlbmRlcmVyL2J5LWNvbHVtbnMtZGlzY3JldGUuanMiLCIvVXNlcnMvRHdheW5la2ovUHJvamVjdHMvZmluLWh5cGVyZ3JpZC9zcmMvcmVuZGVyZXIvYnktY29sdW1ucy5qcyIsIi9Vc2Vycy9Ed2F5bmVrai9Qcm9qZWN0cy9maW4taHlwZXJncmlkL3NyYy9yZW5kZXJlci9ieS1yb3dzLmpzIiwiL1VzZXJzL0R3YXluZWtqL1Byb2plY3RzL2Zpbi1oeXBlcmdyaWQvc3JjL3JlbmRlcmVyL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3B4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25uQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenJFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5ncmlkID0gW1xuJy5oeXBlcmdyaWQtY29udGFpbmVyIHsnLFxuJ1x0cG9zaXRpb246IHJlbGF0aXZlOycsXG4nXHRoZWlnaHQ6IDUwMHB4OycsXG4nfScsXG4nLmh5cGVyZ3JpZC1jb250YWluZXIgPiBkaXY6Zmlyc3QtY2hpbGQgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGxlZnQ6IDA7JyxcbidcdHRvcDogMDsnLFxuJ1x0cmlnaHQ6IDA7JyxcbidcdGJvdHRvbTogMDsnLFxuJ30nLFxuJy5oeXBlcmdyaWQtY29udGFpbmVyID4gZGl2OmZpcnN0LWNoaWxkID4gZGl2LmluZm8geycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGRpc3BsYXk6IG5vbmU7IC8qIGluaXRpYWxseSBoaWRkZW4gKi8nLFxuJ1x0bWFyZ2luLXRvcDogMTUwcHg7IC8qIHRvIHBsYWNlIGJlbG93IGhlYWRlcnMgKi8nLFxuJ1x0Y29sb3I6ICNlZWU7JyxcbidcdHRleHQtc2hhZG93OiAxcHggMXB4ICNjY2M7JyxcbidcdGZvbnQtc2l6ZTogMzZwdDsnLFxuJ1x0Zm9udC13ZWlnaHQ6IGJvbGQ7JyxcbidcdHRleHQtYWxpZ246IGNlbnRlcjsnLFxuJ1x0dG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBsZWZ0OiAwOycsXG4nfScsXG4nLmh5cGVyZ3JpZC10ZXh0ZmllbGQgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGZvbnQtc2l6ZTogMTJweDsnLFxuJ1x0Y29sb3I6IGJsYWNrOycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiBpdm9yeTsnLFxuJ1x0Ym94LXNpemluZzogYm9yZGVyLWJveDsnLFxuJ1x0bWFyZ2luOiAwOycsXG4nXHRwYWRkaW5nOiAwIDVweDsnLFxuJ1x0Ym9yZGVyOiAwOyAvKmJvcmRlcjogMXB4IHNvbGlkICM3Nzc7Ki8nLFxuJ1x0b3V0bGluZTogMDsnLFxuJ30nLFxuJycsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCB7JyxcbidcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0ZGlzcGxheTogbm9uZTsnLFxuJ1x0b3V0bGluZTogMDsnLFxuJ1x0cGFkZGluZzogMDsnLFxuJ1x0Ym9yZGVyOiAwOyAvKmJvcmRlcjogMXB4IHNvbGlkICM3Nzc7Ki8nLFxuJ1x0Ym94LXNpemluZzogYm9yZGVyLWJveDsnLFxuJ1x0YmFja2dyb3VuZC1jb2xvcjogaXZvcnk7JyxcbidcdGNvbG9yOiBibGFjazsnLFxuJ1x0Zm9udC1zaXplOiAxMnB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IGlucHV0IHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRtYXJnaW4tdG9wOiAtMXB4OycsXG4nXHRoZWlnaHQ6IDEwMCU7JyxcbidcdHJpZ2h0OiAyMHB4OycsXG4nXHRsZWZ0OiAwOycsXG4nXHR3aWR0aDogMTAwJTsnLFxuJ1x0b3V0bGluZTogMDsnLFxuJ1x0cGFkZGluZzogMDsnLFxuJycsXG4nXHRib3JkZXI6IDVweCBzb2xpZCB0cmFuc3BhcmVudDsnLFxuJ1x0Ym9yZGVyLXJpZ2h0LXdpZHRoOiAyMHB4OycsXG4nXHRib3JkZXItYm90dG9tLXdpZHRoOiAwOycsXG4nXHRib3JkZXItdG9wLXdpZHRoOiAwOycsXG4nXHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nJyxcbidcdGZvbnQtc2l6ZTogMTJweDsnLFxuJ1x0Y29sb3I6IGJsYWNrOycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggPiBzcGFuIHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nXHR3aWR0aDogMjBweDsnLFxuJ1x0aGVpZ2h0OiAxMDAlOycsXG4nXHRyaWdodDogMDsnLFxuJ1x0dGV4dC1hbGlnbjogY2VudGVyOycsXG4nXHRmb250LXNpemU6IDEuNWVtOycsXG4nXHRsaW5lLWhlaWdodDogMWVtOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCBzcGFuW3RpdGxlXSB7JyxcbidcdGNvbG9yOiBsaWdodGdyZXk7JyxcbidcdGN1cnNvcjogcG9pbnRlcjsnLFxuJ1x0bWFyZ2luLXRvcDogLTJweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggc3Bhblt0aXRsZV06aG92ZXIgeycsXG4nXHRjb2xvcjogZ3JleTsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggc3Bhblt0aXRsZV06YWN0aXZlLCBkaXYuaHlwZXJncmlkLWNvbWJvYm94IHNwYW5bdGl0bGVdLmFjdGl2ZSB7JyxcbidcdGNvbG9yOiBibHVlOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IHNwYW4geycsXG4nXHRtYXJnaW4tdG9wOiAtMXB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IHNwYW46OmFmdGVyIHsnLFxuJ1x0Y29udGVudDogXFwnXFxcXDI1QkVcXCc7JyxcbidcdGZvbnQtc2l6ZTogMjBweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggPiBkaXYgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGxlZnQ6IC0xcHg7JyxcbidcdHJpZ2h0OiAtMXB4OycsXG4nXHR0b3A6IDE0cHg7JyxcbidcdGhlaWdodDogMDsnLFxuJ1x0dHJhbnNpdGlvbjogaGVpZ2h0IC4yNXM7JyxcbidcdHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuJ1x0Lypib3gtc2hhZG93OiB3aGl0ZSAwIDAgMXB4IDFweDsqLycsXG4nXHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nXHRib3JkZXI6IDFweCBzb2xpZCAjNzc3OycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiBpdm9yeTsnLFxuJ1x0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsnLFxuJ1x0LW1vei11c2VyLXNlbGVjdDogbm9uZTsnLFxuJ1x0LW1zLXVzZXItc2VsZWN0OiBub25lOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IGRpdiA+IGRpdiB7JyxcbidcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0aGVpZ2h0OiAxM3B4OycsXG4nXHR3aWR0aDogMTAwJTsnLFxuJ1x0dGV4dC1hbGlnbjogY2VudGVyOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IGRpdiBzcGFuW3RpdGxlXSB7JyxcbidcdGZvbnQtd2VpZ2h0OiBib2xkOycsXG4nXHRmb250LXNpemU6IDEycHg7JyxcbidcdGZvbnQtZmFtaWx5OiB2ZXJkYW5hLCBnZW5ldmEsIHNhbnMtc2VyaWY7JyxcbidcdG1hcmdpbi1sZWZ0OiA2cHg7JyxcbidcdG1hcmdpbi1yaWdodDogNnB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IGRpdiBzcGFuOm5vdChbdGl0bGVdKSB7JyxcbidcdGZvbnQtc3R5bGU6IGl0YWxpYzsnLFxuJ1x0cGFkZGluZy10b3A6IDFweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggPiBkaXYgc2VsZWN0IHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRwYWRkaW5nLXRvcDogMnB4OycsXG4nXHRib3JkZXI6IDA7JyxcbidcdG91dGxpbmU6IDA7JyxcbidcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjNzc3OycsXG4nXHR3aWR0aDogMTAwJTsnLFxuJ1x0dG9wOiAxNXB4OycsXG4nXHRib3R0b206IDA7JyxcbidcdGxlZnQ6IDA7JyxcbidcdHJpZ2h0OiAwOycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsnLFxuJ1x0Zm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7JyxcbidcdGZvbnQtd2VpZ2h0OiBib2xkOycsXG4nXHRmb250LXNpemU6IDlweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggPiBkaXYgc2VsZWN0IG9wdGlvbjpob3ZlciB7JyxcbidcdGJhY2tncm91bmQtY29sb3I6ICM3Nzc7JyxcbidcdGNvbG9yOiBpdm9yeTsnLFxuJ30nXG5dLmpvaW4oJ1xcbicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiY2FsZW5kYXJcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQW9BQUFBS0NBWUFBQUNOTXMrOUFBQUFjMGxFUVZSNG5JWFF3UWtDTVJTRTRVOVpMTUNUOVhqYXEyQWZOaGZZVTVvUUxNQU90b040OEVXZWk1aUJJUlBlL3lZUTNxcmhmMWxGRzdpS2NFYUp4U2Z1a1V2TVdnZEhhdnQwdVdIdGcyUXd4WG5BbkpaMnVPTHlWWnR5Ynp6aGdXTm1mb0ZsMC9ZQjg3TmJ6UjFjalA5eGVRSFNEQzZtY0wxeEZRQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJjaGVja2VkXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUEwQUFBQVBDQVlBQUFBL0kwVjNBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQVlKSlJFRlVPRStOa3N0TGdsRVF4ZjBmYWhHMGlGclV4bTJFbEZEWUxvaENxQ0RhQ0FrV1BheElSYkZGRUpFYUdFS0xEQ29NRVRSRlVBTUx5YUlIQlVHNnNTS0lNdEtGcUVoTFQ4MThaVWdtRGh6dTNEUG45ejB1VjFScm1Vd215R1F5cU5WcWZGdlZpd0J4dTVSRlBadUxTeUdNS2h6L3FsRXNSVjE5Szh4bTZ5K3c3YnBCUEZuQWZlcmpqM2JkUVg2RHBIY0FVd2F2QUhVTjJSR0laeEJKWkhIMm1DL1RVZXlkd3dUWnZCZWdMRU5OZ3c3c1g2V2gxRnN3Tm1QRW1qUENEeUdSUndDdFc5RTN0TWdkQXRRdzdHWmpZY05YK2d6YTJ3SjNaWHNTWlV1UTB2V0NPVjhTSGZKSi91bHVoYkhVajF2OFBLTk1zeklvUU5STUhDU2hENldoOHp5aHJiT1B3ejh3K1NUS2xDQ0o3b1JOVXpRSDYza0JzNXRoQmdoZVBYeGxqMmFVb1N4RFBjdVhQTmlMQWM1RUVaNkhJa2JtVjJEWWlYQlBIczBvMDc5K0swRFRWai9zMTFtRTAwQTBMK2c0VmNEcDEwcUtaTUF6eXRCaE1hVFJhUG1ZZzg4NURsY1N6U2lqMGVvRWlJb3VvVXFscXFxYUwycmxFb2srQWQ0dmxmelBvVkRzQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiZG93bi1yZWN0YW5nbGVcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWtBQUFBRUNBWUFBQUJjRHhYT0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBYWRFVllkRk52Wm5SM1lYSmxBRkJoYVc1MExrNUZWQ0IyTXk0MUxqRXhSL05DTndBQUFCcEpSRUZVR0ZkamdJTC9lREFLSUtnQUJnZ3FnQUUwQlF3TUFQVGxEL0ZwaTBKZkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcImZpbHRlci1vZmZcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBTUNBWUFBQUJTZ0l6YUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFDaFNVUkJWQ2hUelpIQkNvVWdGRVQ5VHFFaXNrZ3lXb3V0UXZSTFJJcitjUjdYUUFqaUpXLzFCZ1ptTVVldlhzWTV4eTlPb0RFR01jWWlVemVCNjdxaWJWdXdRalZOQTYzMTFWK1dCZU00dnNMRE1FQXBkZS8xZlk5cG10STQ1M25lSEVLQWxCSmQxejBmWHRjMTZQYmpPREswN3p2bWVVWlZWZDhub29jNzV6SklPWDNHbTZpMGJWc0dLZjh4S0lSSXV5SlRMZ0pKM252UXpzalcyZ2VJc1EvcHI5aE1WclNuY0FBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcImZpbHRlci1vblwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFNQ0FZQUFBQlNnSXphQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUNvU1VSQlZDaFRZM0JxZlAyZkhBeldtRGJqN2Y4cDI5NFJoVk9CYXNFYTAyZSsvZS9WQm1RUUNUeGFYLzlQbnZZR29qNXl3cHYvUWQyRU5mdDN2djRmMWdmVkJBUCtuVy8raC9hK0FUdG4xcTczS0hqeXR2ZGdnMzA3MERUQmdIdkw2LzhnMjJmc1FHaWFEbVNIQTIxeGF5YmdJcERIaXhhOGhXc3NuQThOREVJQXBDaDNMa0lqaUQySU5ZSkNMMlg2VzNCOGdkaEVhUVFCVU9DQTRneUU4K2U5eGFLSmdRRUEvNzRCTkUzY0Vsa0FBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcblx0XCJ1bmNoZWNrZWRcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTBBQUFBUENBWUFBQUEvSTBWM0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBUkJKUkVGVU9FKzlrcnR1ZzFBUVJQbGRTaW83RlExdFpJbU9rb0tPQm9tR1QwRVVSQzVpbm81NHlUdzkwV3l3UWhUa0lrVldHb0YyenV4ZHJsRCt0MHpUaEtacFQwVm14YjhDUVJDZzZ6cjBmYjhyZXI3dmZ3Y1B4eGRjcngrWXBnbnpQR05abGg5aWJ4eEhsR1VKc2hMU2RWMGF0OXROcGc3RElCclg1K09rUE05QlZrS0dZU0JKRXRSMWpiWnJCZGlxYlZ0VVZZVTBUVUZXUXErbkUrSTR4dnZsSW1HYVc3Rkhqd3haQ1ZtV2hiZnpHVm1Xb1NnS1dYVXI5dWlSSVNzaHgzRmtFbGRvbXViWGF1elJJME5XUXA3bnlVUitORy9yZnIvalVYeG5qeDV2bUt5RWJOdVdveDlYdmlkNlpNaEs2SEE0d25WZGhHR0lLSXAyUlk4TVdRbXgrSnVvcXZwVVpGYjhMNlVvbnlZTDN1T3RyRkgrQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwidXAtZG93bi1zcGluXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQVBDQVlBQUFEVUZQNTBBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93UUFBRHNFQnVKRnI3UUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUdKSlJFRlVPRStsa3dFS0FDRUlCSDJaYi9Qbkhzb0dlYVZKRFVqR09nUlJwS3BraUlqK3k0TU1FM2VEUjdrYUtPVk5zSnlNTmpJSHpHeTlZblc2SjdxSWNycmlRaW1lQ3FPUk5BQmQwZnBSVGt0OHVWVWo3RXN4QzZ2cy9xM2UvUTZpRDJid25CeWpQWEhOQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwidXAtZG93blwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFQQ0FZQUFBRFVGUDUwQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd1FBQURzRUJ1SkZyN1FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFHRkpSRUZVT0UrbGtrRUtRQ0VJUkQyWkozUGgzaU40V0Q5R2ZscFloajBZWW93cEdnSm1iaWtkM2dqTURGb2t3YnVUMWlBaXVyRzVub21ncW81UWFQbzlFUlFSSTZKZjdzZkdqdWR5MmplMjMraTBXbDJvUTg1VE9kbGZySlFPYXpGOGJyK3JxVFhRS24wQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSByZWdpc3RyeSBvZiBgSFRNTEltYWdlSWNvbmAgb2JqZWN0cy5cbiAqXG4gKiBIeXBlcmdyaWQgY29tZXMgd2l0aCBhIGZldyBpbWFnZXMgKHNlZSBiZWxvdykuXG4gKlxuICogQXBwbGljYXRpb24gZGV2ZWxvcGVyIGlzIGZyZWUgdG8gcmVnaXN0ZXIgYWRkaXRpb25hbCBpbWFnZSBvYmplY3RzIGhlcmUgKHNlZSB7QGxpbmsgbW9kdWxlOmltYWdlcy5hZGR8YWRkfSkuXG4gKiBAbW9kdWxlIGltYWdlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG5cbnZhciBpbWFnZXMgPSByZXF1aXJlKCcuL2ltYWdlcycpOyAvLyB0aGlzIGlzIHRoZSBmaWxlIGdlbmVyYXRlZCBieSBndWxwZmlsZS5qcyAoYW5kIGlnbm9yZWQgYnkgZ2l0KVxuXG4vKipcbiAqIDxpbWcgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL29wZW5maW4vZmluLWh5cGVyZ3JpZC9tYXN0ZXIvaW1hZ2VzL2NhbGVuZGFyLnBuZ1wiPlxuICogQG5hbWUgY2FsZW5kYXJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cblxuLyoqXG4gKiA8aW1nIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9vcGVuZmluL2Zpbi1oeXBlcmdyaWQvbWFzdGVyL2ltYWdlcy9jaGVja2VkLnBuZ1wiPlxuICogQG5hbWUgY2hlY2tlZFxuICogQG1lbWJlck9mIG1vZHVsZTppbWFnZXNcbiAqL1xuXG4vKipcbiAqIDxpbWcgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL29wZW5maW4vZmluLWh5cGVyZ3JpZC9tYXN0ZXIvaW1hZ2VzL3VuY2hlY2tlZC5wbmdcIj5cbiAqIEBuYW1lIHVuY2hlY2tlZFxuICogQG1lbWJlck9mIG1vZHVsZTppbWFnZXNcbiAqL1xuXG4vKipcbiAqIDxpbWcgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL29wZW5maW4vZmluLWh5cGVyZ3JpZC9tYXN0ZXIvaW1hZ2VzL2ZpbHRlci1vZmYucG5nXCI+XG4gKiBAbmFtZSBmaWx0ZXItb2ZmXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmltYWdlc1xuICovXG5cbi8qKlxuICogPGltZyBzcmM9XCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vb3BlbmZpbi9maW4taHlwZXJncmlkL21hc3Rlci9pbWFnZXMvZmlsdGVyLW9uLnBuZ1wiPlxuICogQG5hbWUgZmlsdGVyLW9uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmltYWdlc1xuICovXG5cbi8qKlxuICogPGltZyBzcmM9XCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vb3BlbmZpbi9maW4taHlwZXJncmlkL21hc3Rlci9pbWFnZXMvdXAtZG93bi5wbmdcIj5cbiAqIEBuYW1lIHVwLWRvd25cbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cblxuXyhpbWFnZXMpLmVhY2goZnVuY3Rpb24oaW1hZ2UsIGtleSkge1xuICAgIHZhciBlbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgZWxlbWVudC5zcmMgPSAnZGF0YTonICsgaW1hZ2UudHlwZSArICc7YmFzZTY0LCcgKyBpbWFnZS5kYXRhO1xuICAgIGltYWdlc1trZXldID0gZWxlbWVudDtcbn0pO1xuXG4vKipcbiAqIFN5bm9ueW0gb2Yge0BsaW5rIG1vZHVsZTppbWFnZXMuY2hlY2tlZHxjaGVja2VkfSAodW5hZmZlY3RlZCBpZiBgY2hlY2tlZGAgb3ZlcnJpZGRlbikuXG4gKiBAbmFtZSBjaGVja2JveC1vblxuICogQG1lbWJlck9mIG1vZHVsZTppbWFnZXNcbiAqL1xuaW1hZ2VzWydjaGVja2JveC1vbiddID0gaW1hZ2VzLmNoZWNrZWQ7XG5cbi8qKlxuICogU3lub255bSBvZiB7QGxpbmsgbW9kdWxlOmltYWdlcy51bmNoZWNrZWR8dW5jaGVja2VkfSAodW5hZmZlY3RlZCBpZiBgdW5jaGVja2VkYCBvdmVycmlkZGVuKS5cbiAqIEBuYW1lIGNoZWNrYm94LW9mZlxuICogQG1lbWJlck9mIG1vZHVsZTppbWFnZXNcbiAqL1xuaW1hZ2VzWydjaGVja2JveC1vZmYnXSA9IGltYWdlcy51bmNoZWNrZWQ7XG5cbi8qKlxuICogQG5hbWUgYWRkXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltZ1xuICogQG1lbWJlck9mIG1vZHVsZTppbWFnZXNcbiAqL1xuaW1hZ2VzLmFkZCA9IGZ1bmN0aW9uKGtleSwgaW1nKSB7XG4gICAgcmV0dXJuIGltYWdlc1trZXldID0gaW1nO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBmdW5jdGlvbi5cbiAqIEBuYW1lIGNoZWNrYm94XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlXG4gKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH0ge0BsaW5rIG1vZHVsZTppbWFnZXMuY2hlY2tlZHxjaGVja2VkfSB3aGVuIGBzdGF0ZWAgaXMgdHJ1dGh5IG9yIHtAbGluayBtb2R1bGU6aW1hZ2VzLnVuY2hlY2tlZHx1bmNoZWNrZWR9IG90aGVyd2lzZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6aW1hZ2VzXG4gKi9cbmltYWdlcy5jaGVja2JveCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIGltYWdlc1tzdGF0ZSA/ICdjaGVja2VkJyA6ICd1bmNoZWNrZWQnXTtcbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24uXG4gKiBAbmFtZSBmaWx0ZXJcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGVcbiAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fSB7QGxpbmsgbW9kdWxlOmltYWdlcy5maWx0ZXItb2ZmfGZpbHRlci1vZmZ9IHdoZW4gYHN0YXRlYCBpcyB0cnV0aHkgb3Ige0BsaW5rIG1vZHVsZTppbWFnZXMuZmlsdGVyLW9ufGZpbHRlci1vbn0gb3RoZXJ3aXNlLlxuICogQG1lbWJlck9mIG1vZHVsZTppbWFnZXNcbiAqL1xuaW1hZ2VzLmZpbHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIGltYWdlc1tzdGF0ZSA/ICdmaWx0ZXItb24nIDogJ2ZpbHRlci1vZmYnXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW1hZ2VzO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEBtb2R1bGUgYXV0b21hdCAqL1xuXG52YXIgRU5DT0RFUlMgPSAvJVxceyhcXGQrKVxcfS9nOyAvLyBkb3VibGUgJCQgdG8gZW5jb2RlXG5cbnZhciBSRVBMQUNFUlMgPSAvXFwkXFx7KC4qPylcXH0vZzsgLy8gc2luZ2xlICQgdG8gcmVwbGFjZVxuXG5cbi8qKlxuICogQHN1bW1hcnkgU3RyaW5nIGZvcm1hdHRlci5cbiAqXG4gKiBAZGVzYyBTdHJpbmcgc3Vic3RpdHV0aW9uIGlzIHBlcmZvcm1lZCBvbiBudW1iZXJlZCBfcmVwbGFjZXJfIHBhdHRlcm5zIGxpa2UgYCR7bn1gIG9yIF9lbmNvZGVyXyBwYXR0ZXJucyBsaWtlIGAle259YCB3aGVyZSBuIGlzIHRoZSB6ZXJvLWJhc2VkIGBhcmd1bWVudHNgIGluZGV4LiBTbyBgJHswfWAgd291bGQgYmUgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQgZm9sbG93aW5nIGB0ZXh0YC5cbiAqXG4gKiBFbmNvZGVycyBhcmUganVzdCBsaWtlIHJlcGxhY2VycyBleGNlcHQgdGhlIGFyZ3VtZW50IGlzIEhUTUwtZW5jb2RlZCBiZWZvcmUgYmVpbmcgdXNlZC5cbiAqXG4gKiBUbyBjaGFuZ2UgdGhlIGZvcm1hdCBwYXR0ZXJucywgYXNzaWduIG5ldyBgUmVnRXhwYCBwYXR0ZXJucyB0byBgYXV0b21hdC5lbmNvZGVyc2AgYW5kIGBhdXRvbWF0LnJlcGxhY2Vyc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gQSB0ZW1wbGF0ZSB0byBiZSBmb3JtYXR0ZWQgYXMgZGVzY3JpYmVkIGFib3ZlLiBPdmVybG9hZHM6XG4gKiAqIEEgc3RyaW5nIHByaW1pdGl2ZSBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZS5cbiAqICogQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCBgdGhpc2AgYXMgdGhlIGNhbGxpbmcgY29udGV4dC4gVGhlIHRlbXBsYXRlIGlzIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC5cbiAqXG4gKiBAcGFyYW0gey4uLip9IFtyZXBsYWNlbWVudHNdIC0gUmVwbGFjZW1lbnQgdmFsdWVzIGZvciBudW1iZXJlZCBmb3JtYXQgcGF0dGVybnMuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHRleHQuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIGF1dG9tYXQodGVtcGxhdGUsIHJlcGxhY2VtZW50cy8qLi4uKi8pIHtcbiAgICB2YXIgaGFzUmVwbGFjZW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG5cbiAgICAvLyBpZiBgdGVtcGxhdGVgIGlzIGEgZnVuY3Rpb24sIGNvbnZlcnQgaXQgdG8gdGV4dFxuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jYWxsKHRoaXMpOyAvLyBub24tdGVtcGxhdGUgZnVuY3Rpb246IGNhbGwgaXQgd2l0aCBjb250ZXh0IGFuZCB1c2UgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgaWYgKGhhc1JlcGxhY2VtZW50cykge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKGF1dG9tYXQucmVwbGFjZXJzUmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgICAgIGtleSAtPSAtMTsgLy8gY29udmVydCB0byBudW1iZXIgYW5kIGluY3JlbWVudFxuICAgICAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoID4ga2V5ID8gYXJnc1trZXldIDogJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShhdXRvbWF0LmVuY29kZXJzUmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgICAgIGtleSAtPSAtMTsgLy8gY29udmVydCB0byBudW1iZXIgYW5kIGluY3JlbWVudFxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4ga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxFbmNvZGVyTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICAgICAgICAgIGh0bWxFbmNvZGVyTm9kZS50ZXh0Q29udGVudCA9IGFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbEVuY29kZXJOb2RlLmlubmVySFRNTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgUmVwbGFjZSBjb250ZW50cyBvZiBgZWxgIHdpdGggYE5vZGVzYCBnZW5lcmF0ZWQgZnJvbSBmb3JtYXR0ZWQgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gU2VlIGB0ZW1wbGF0ZWAgcGFyYW1ldGVyIG9mIHtAbGluayBhdXRvbWF0fS5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZWxdIC0gTm9kZSBpbiB3aGljaCB0byByZXR1cm4gbWFya3VwIGdlbmVyYXRlZCBmcm9tIHRlbXBsYXRlLiBJZiBvbWl0dGVkLCBhIG5ldyBgPGRpdj4uLi48L2Rpdj5gIGVsZW1lbnQgd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gey4uLip9IFtyZXBsYWNlbWVudHNdIC0gUmVwbGFjZW1lbnQgdmFsdWVzIGZvciBudW1iZXJlZCBmb3JtYXQgcGF0dGVybnMuXG4gKlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBgZWxgIHByb3ZpZGVkIG9yIGEgbmV3IGA8ZGl2Pi4uLjwvZGl2PmAgZWxlbWVudCwgaXRzIGBpbm5lckhUTUxgIHNldCB0byB0aGUgZm9ybWF0dGVkIHRleHQuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UodGVtcGxhdGUsIGVsLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgdmFyIGVsT21pdHRlZCA9IHR5cGVvZiBlbCAhPT0gJ29iamVjdCcsXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgaWYgKGVsT21pdHRlZCkge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGVtcGxhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3NbMF0gPSB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBlbC5pbm5lckhUTUwgPSBhdXRvbWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IEFwcGVuZCBvciBpbnNlcnQgYE5vZGVgcyBnZW5lcmF0ZWQgZnJvbSBmb3JtYXR0ZWQgdGVtcGxhdGUgaW50byBnaXZlbiBgZWxgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIFNlZSBgdGVtcGxhdGVgIHBhcmFtZXRlciBvZiB7QGxpbmsgYXV0b21hdH0uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqXG4gKiBAcGFyYW0ge05vZGV9IFtyZWZlcmVuY2VOb2RlPW51bGxdIEluc2VydHMgYmVmb3JlIHRoaXMgZWxlbWVudCB3aXRoaW4gYGVsYCBvciBhdCBlbmQgb2YgYGVsYCBpZiBgbnVsbGAuXG4gKlxuICogQHBhcmFtIHsuLi4qfSBbcmVwbGFjZW1lbnRzXSAtIFJlcGxhY2VtZW50IHZhbHVlcyBmb3IgbnVtYmVyZWQgZm9ybWF0IHBhdHRlcm5zLlxuICpcbiAqIEByZXR1cm5zIHtOb2RlW119IEFycmF5IG9mIHRoZSBnZW5lcmF0ZWQgbm9kZXMgKHRoaXMgaXMgYW4gYWN0dWFsIEFycmF5IGluc3RhbmNlOyBub3QgYW4gQXJyYXktbGlrZSBvYmplY3QpLlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiBhcHBlbmQodGVtcGxhdGUsIGVsLCByZWZlcmVuY2VOb2RlLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgdmFyIHJlcGxhY2VtZW50c1N0YXJ0QXQgPSAzLFxuICAgICAgICByZWZlcmVuY2VOb2RlT21pdHRlZCA9IHR5cGVvZiByZWZlcmVuY2VOb2RlICE9PSAnb2JqZWN0JzsgIC8vIHJlcGxhY2VtZW50cyBhcmUgbmV2ZXIgb2JqZWN0c1xuXG4gICAgaWYgKHJlZmVyZW5jZU5vZGVPbWl0dGVkKSB7XG4gICAgICAgIHJlZmVyZW5jZU5vZGUgPSBudWxsO1xuICAgICAgICByZXBsYWNlbWVudHNTdGFydEF0ID0gMjtcbiAgICB9XG5cbiAgICByZXBsYWNlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIHJlcGxhY2VtZW50c1N0YXJ0QXQpO1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgZGl2ID0gcmVwbGFjZS5hcHBseShudWxsLCBbdGVtcGxhdGVdLmNvbmNhdChyZXBsYWNlbWVudHMpKTtcblxuICAgIHdoaWxlIChkaXYuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICBlbC5pbnNlcnRCZWZvcmUoZGl2LmZpcnN0Q2hpbGQsIHJlZmVyZW5jZU5vZGUpOyAvLyByZW1vdmVzIGNoaWxkIGZyb20gZGl2XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBVc2UgdGhpcyBjb252ZW5pZW5jZSB3cmFwcGVyIHRvIHJldHVybiB0aGUgZmlyc3QgY2hpbGQgbm9kZSBkZXNjcmliZWQgaW4gYHRlbXBsYXRlYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gdGVtcGxhdGUgLSBJZiBhIGZ1bmN0aW9uLCBleHRyYWN0IHRlbXBsYXRlIGZyb20gY29tbWVudCB3aXRoaW4uXG4gKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgZmlyc3QgYE5vZGVgIGluIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIGZpcnN0Q2hpbGQodGVtcGxhdGUsIHJlcGxhY2VtZW50cy8qLi4uKi8pIHtcbiAgICByZXR1cm4gcmVwbGFjZS5hcHBseShudWxsLCBhcmd1bWVudHMpLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogVXNlIHRoaXMgY29udmVuaWVuY2Ugd3JhcHBlciB0byByZXR1cm4gdGhlIGZpcnN0IGNoaWxkIGVsZW1lbnQgZGVzY3JpYmVkIGluIGB0ZW1wbGF0ZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gSWYgYSBmdW5jdGlvbiwgZXh0cmFjdCB0ZW1wbGF0ZSBmcm9tIGNvbW1lbnQgd2l0aGluLlxuICpcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGZpcnN0IGBIVE1MRWxlbWVudGAgaW4geW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuZnVuY3Rpb24gZmlyc3RFbGVtZW50KHRlbXBsYXRlLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgcmV0dXJuIHJlcGxhY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5maXJzdEVsZW1lbnRDaGlsZDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBGaW5kcyBzdHJpbmcgc3Vic3RpdHV0aW9uIGxleGVtZXMgdGhhdCByZXF1aXJlIEhUTUwgZW5jb2RpbmcuXG4gKiBAZGVzYyBNb2RpZnkgdG8gc3VpdC5cbiAqIEBkZWZhdWx0ICV7bn1cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuYXV0b21hdC5lbmNvZGVyc1JlZ2V4ID0gRU5DT0RFUlM7XG5cbi8qKlxuICogQHN1bW1hcnkgRmluZHMgc3RyaW5nIHN1YnN0aXR1dGlvbiBsZXhlbWVzLlxuICogQGRlc2MgTW9kaWZ5IHRvIHN1aXQuXG4gKiBAZGVmYXVsdCAke259XG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmF1dG9tYXQucmVwbGFjZXJzUmVnZXggPSBSRVBMQUNFUlM7XG5cbmF1dG9tYXQuZm9ybWF0ID0gYXV0b21hdDsgLy8gaWYgeW91IGZpbmQgdXNpbmcganVzdCBgYXV0b21hdCgpYCBjb25mdXNpbmdcbmF1dG9tYXQucmVwbGFjZSA9IHJlcGxhY2U7XG5hdXRvbWF0LmFwcGVuZCA9IGFwcGVuZDtcbmF1dG9tYXQuZmlyc3RDaGlsZCA9IGZpcnN0Q2hpbGQ7XG5hdXRvbWF0LmZpcnN0RWxlbWVudCA9IGZpcnN0RWxlbWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBhdXRvbWF0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqIEBuYW1lc3BhY2UgY3NzSW5qZWN0b3IgKi9cblxuLyoqXG4gKiBAc3VtbWFyeSBJbnNlcnQgYmFzZSBzdHlsZXNoZWV0IGludG8gRE9NXG4gKlxuICogQGRlc2MgQ3JlYXRlcyBhIG5ldyBgPHN0eWxlPi4uLjwvc3R5bGU+YCBlbGVtZW50IGZyb20gdGhlIG5hbWVkIHRleHQgc3RyaW5nKHMpIGFuZCBpbnNlcnRzIGl0IGJ1dCBvbmx5IGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QgaW4gdGhlIHNwZWNpZmllZCBjb250YWluZXIgYXMgcGVyIGByZWZlcmVuY2VFbGVtZW50YC5cbiAqXG4gKiA+IENhdmVhdDogSWYgc3R5bGVzaGVldCBpcyBmb3IgdXNlIGluIGEgc2hhZG93IERPTSwgeW91IG11c3Qgc3BlY2lmeSBhIGxvY2FsIGByZWZlcmVuY2VFbGVtZW50YC5cbiAqXG4gKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgbmV3bHkgY3JlYXRlZCBgPHN0eWxlPi4uLjwvc3R5bGU+YCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjc3NSdWxlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtJRF1cbiAqIEBwYXJhbSB7dW5kZWZpbmVkfG51bGx8RWxlbWVudHxzdHJpbmd9IFtyZWZlcmVuY2VFbGVtZW50XSAtIENvbnRhaW5lciBmb3IgaW5zZXJ0aW9uLiBPdmVybG9hZHM6XG4gKiAqIGB1bmRlZmluZWRgIHR5cGUgKG9yIG9taXR0ZWQpOiBpbmplY3RzIHN0eWxlc2hlZXQgYXQgdG9wIG9mIGA8aGVhZD4uLi48L2hlYWQ+YCBlbGVtZW50XG4gKiAqIGBudWxsYCB2YWx1ZTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IGJvdHRvbSBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgRWxlbWVudGAgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBlbGVtZW50LCB3aGVyZXZlciBpdCBpcyBmb3VuZC5cbiAqICogYHN0cmluZ2AgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBmaXJzdCBlbGVtZW50IGZvdW5kIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxuICpcbiAqIEBtZW1iZXJPZiBjc3NJbmplY3RvclxuICovXG5mdW5jdGlvbiBjc3NJbmplY3Rvcihjc3NSdWxlcywgSUQsIHJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZmVyZW5jZUVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJlZmVyZW5jZUVsZW1lbnQpO1xuICAgICAgICBpZiAoIXJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93ICdDYW5ub3QgZmluZCByZWZlcmVuY2UgZWxlbWVudCBmb3IgQ1NTIGluamVjdGlvbi4nO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZlcmVuY2VFbGVtZW50ICYmICEocmVmZXJlbmNlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHRocm93ICdHaXZlbiB2YWx1ZSBub3QgYSByZWZlcmVuY2UgZWxlbWVudC4nO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSByZWZlcmVuY2VFbGVtZW50ICYmIHJlZmVyZW5jZUVsZW1lbnQucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cbiAgICBpZiAoSUQpIHtcbiAgICAgICAgSUQgPSBjc3NJbmplY3Rvci5pZFByZWZpeCArIElEO1xuXG4gICAgICAgIGlmIChjb250YWluZXIucXVlcnlTZWxlY3RvcignIycgKyBJRCkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gc3R5bGVzaGVldCBhbHJlYWR5IGluIERPTVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgICBpZiAoSUQpIHtcbiAgICAgICAgc3R5bGUuaWQgPSBJRDtcbiAgICB9XG4gICAgaWYgKGNzc1J1bGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY3NzUnVsZXMgPSBjc3NSdWxlcy5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgY3NzUnVsZXMgPSAnXFxuJyArIGNzc1J1bGVzICsgJ1xcbic7XG4gICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzUnVsZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzUnVsZXMpKTtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0eWxlLCByZWZlcmVuY2VFbGVtZW50KTtcblxuICAgIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBPcHRpb25hbCBwcmVmaXggZm9yIGA8c3R5bGU+YCB0YWcgSURzLlxuICogQGRlc2MgRGVmYXVsdHMgdG8gYCdpbmplY3RlZC1zdHlsZXNoZWV0LSdgLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBjc3NJbmplY3RvclxuICovXG5jc3NJbmplY3Rvci5pZFByZWZpeCA9ICdpbmplY3RlZC1zdHlsZXNoZWV0LSc7XG5cbi8vIEludGVyZmFjZVxubW9kdWxlLmV4cG9ydHMgPSBjc3NJbmplY3RvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG92ZXJyaWRlciA9IHJlcXVpcmUoJ292ZXJyaWRlcicpO1xuXG4vKiogQG5hbWVzcGFjZSBleHRlbmQtbWUgKiovXG5cbi8qKiBAc3VtbWFyeSBFeHRlbmRzIGFuIGV4aXN0aW5nIGNvbnN0cnVjdG9yIGludG8gYSBuZXcgY29uc3RydWN0b3IuXG4gKlxuICogQHJldHVybnMge0NoaWxkQ29uc3RydWN0b3J9IEEgbmV3IGNvbnN0cnVjdG9yLCBleHRlbmRlZCBmcm9tIHRoZSBnaXZlbiBjb250ZXh0LCBwb3NzaWJseSB3aXRoIHNvbWUgcHJvdG90eXBlIGFkZGl0aW9ucy5cbiAqXG4gKiBAZGVzYyBFeHRlbmRzIFwib2JqZWN0c1wiIChjb25zdHJ1Y3RvcnMpLCB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgY29kZSwgb3B0aW9uYWwgcHJvdG90eXBlIGFkZGl0aW9ucywgYW5kIG9wdGlvbmFsIHByb3RvdHlwZSBtZW1iZXIgYWxpYXNlcy5cbiAqXG4gKiA+IENBVkVBVDogTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggVW5kZXJzY29yZS1zdHlsZSAuZXh0ZW5kKCkgd2hpY2ggaXMgc29tZXRoaW5nIGVsc2UgZW50aXJlbHkuIEkndmUgdXNlZCB0aGUgbmFtZSBcImV4dGVuZFwiIGhlcmUgYmVjYXVzZSBvdGhlciBwYWNrYWdlcyAobGlrZSBCYWNrYm9uZS5qcykgdXNlIGl0IHRoaXMgd2F5LiBZb3UgYXJlIGZyZWUgdG8gY2FsbCBpdCB3aGF0ZXZlciB5b3Ugd2FudCB3aGVuIHlvdSBcInJlcXVpcmVcIiBpdCwgc3VjaCBhcyBgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnZXh0ZW5kJylgLlxuICpcbiAqIFByb3ZpZGUgYSBjb25zdHJ1Y3RvciBhcyB0aGUgY29udGV4dCBhbmQgYW55IHByb3RvdHlwZSBhZGRpdGlvbnMgeW91IHJlcXVpcmUgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3Ugd2lzaCB0byBiZSBhYmxlIHRvIGV4dGVuZCBgQmFzZUNvbnN0cnVjdG9yYCB0byBhIG5ldyBjb25zdHJ1Y3RvciB3aXRoIHByb3RvdHlwZSBvdmVycmlkZXMgYW5kL29yIGFkZGl0aW9ucywgYmFzaWMgdXNhZ2UgaXM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuICogdmFyIEJhc2VDb25zdHJ1Y3RvciA9IEJhc2UuZXh0ZW5kKGJhc2VQcm90b3R5cGUpOyAvLyBtaXhlcyBpbiAuZXh0ZW5kXG4gKiB2YXIgQ2hpbGRDb25zdHJ1Y3RvciA9IEJhc2VDb25zdHJ1Y3Rvci5leHRlbmQoY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogdmFyIEdyYW5kY2hpbGRDb25zdHJ1Y3RvciA9IENoaWxkQ29uc3RydWN0b3IuZXh0ZW5kKGdyYW5kY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogYGBgXG4gKlxuICogVGhpcyBmdW5jdGlvbiAoYGV4dGVuZCgpYCkgaXMgYWRkZWQgdG8gdGhlIG5ldyBleHRlbmRlZCBvYmplY3QgY29uc3RydWN0b3IgYXMgYSBwcm9wZXJ0eSBgLmV4dGVuZGAsIGVzc2VudGlhbGx5IG1ha2luZyB0aGUgb2JqZWN0IGNvbnN0cnVjdG9yIGl0c2VsZiBlYXNpbHkgXCJleHRlbmRhYmxlLlwiIChOb3RlOiBUaGlzIGlzIGEgcHJvcGVydHkgb2YgZWFjaCBjb25zdHJ1Y3RvciBhbmQgbm90IGEgbWV0aG9kIG9mIGl0cyBwcm90b3R5cGUhKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXh0ZW5kZWRDbGFzc05hbWVdIC0gVGhpcyBpcyBzaW1wbHkgYWRkZWQgdG8gdGhlIHByb3RvdHlwZSBhcyAkJENMQVNTX05BTUUuIFVzZWZ1bCBmb3IgZGVidWdnaW5nIGJlY2F1c2UgYWxsIGRlcml2ZWQgY29uc3RydWN0b3JzIGFwcGVhciB0byBoYXZlIHRoZSBzYW1lIG5hbWUgKFwiQ29uc3RydWN0b3JcIikgaW4gdGhlIGRlYnVnZ2VyLlxuICpcbiAqIEBwYXJhbSB7ZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3R9IFtwcm90b3R5cGVBZGRpdGlvbnNdIC0gT2JqZWN0IHdpdGggbWVtYmVycyB0byBjb3B5IHRvIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWJ1Z10gLSBTZWUgcGFyYW1ldGVyIGBleHRlbmRlZENsYXNzTmFtZWAgXyhhYm92ZSlfLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBCYXNlIC0gQSBjb252ZW5pZW50IGJhc2UgY2xhc3MgZnJvbSB3aGljaCBhbGwgb3RoZXIgY2xhc3NlcyBjYW4gYmUgZXh0ZW5kZWQuXG4gKlxuICogQG1lbWJlck9mIGV4dGVuZC1tZVxuICovXG5mdW5jdGlvbiBleHRlbmQoZXh0ZW5kZWRDbGFzc05hbWUsIHByb3RvdHlwZUFkZGl0aW9ucykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBleHRlbmRlZENsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucyA9IGV4dGVuZGVkQ2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZENsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdTaW5nbGUtcGFyYW1ldGVyIG92ZXJsb2FkIG11c3QgYmUgZWl0aGVyIHN0cmluZyBvciBvYmplY3QuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVuZGVkQ2xhc3NOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvdG90eXBlQWRkaXRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUd28tcGFyYW1ldGVyIG92ZXJsb2FkIG11c3QgYmUgc3RyaW5nLCBvYmplY3QuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1RvbyBtYW55IHBhcmFtZXRlcnMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnN0cnVjdG9yKCkge1xuICAgICAgICBpZiAocHJvdG90eXBlQWRkaXRpb25zLnByZUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucy5wcmVJbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsaXplUHJvdG90eXBlQ2hhaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICBpZiAocHJvdG90eXBlQWRkaXRpb25zLnBvc3RJbml0aWFsaXplKSB7XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMucG9zdEluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbnN0cnVjdG9yLmV4dGVuZCA9IGV4dGVuZDtcblxuICAgIHZhciBwcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcbiAgICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcblxuICAgIGlmIChleHRlbmRlZENsYXNzTmFtZSkge1xuICAgICAgICBwcm90b3R5cGUuJCRDTEFTU19OQU1FID0gZXh0ZW5kZWRDbGFzc05hbWU7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGVyKHByb3RvdHlwZSwgcHJvdG90eXBlQWRkaXRpb25zKTtcblxuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gQmFzZSgpIHt9XG5CYXNlLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQmFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgZ2V0IHN1cGVyKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgfVxufTtcbkJhc2UuZXh0ZW5kID0gZXh0ZW5kO1xuZXh0ZW5kLkJhc2UgPSBCYXNlO1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBleHRlbmRlZENvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkgcHJvdG90eXBlLnN1cGVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIHByb3RvdHlwZSB0aGlzIGNvbnN0cnVjdG9yIHdhcyBleHRlbmRlZCBmcm9tLlxuICogQHByb3BlcnR5IFtleHRlbmRdIC0gSWYgYHByb3RvdHlwZUFkZGl0aW9ucy5leHRlbmRhYmxlYCB3YXMgdHJ1dGh5LCB0aGlzIHdpbGwgYmUgYSByZWZlcmVuY2UgdG8ge0BsaW5rIGV4dGVuZC5leHRlbmR8ZXh0ZW5kfS5cbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3RcbiAqIEBkZXNjIEFsbCBtZW1iZXJzIGFyZSBjb3BpZWQgdG8gdGhlIG5ldyBvYmplY3QuIFRoZSBmb2xsb3dpbmcgaGF2ZSBzcGVjaWFsIG1lYW5pbmcuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbaW5pdGlhbGl6ZV0gLSBBZGRpdGlvbmFsIGNvbnN0cnVjdG9yIGNvZGUgZm9yIG5ldyBvYmplY3QuIFRoaXMgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBuZXcgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuIENhbGxlZCBvbiBpbnN0YW50aWF0aW9uIGFmdGVyIHNpbWlsYXIgZnVuY3Rpb24gaW4gYWxsIGFuY2VzdG9ycyBjYWxsZWQgd2l0aCBzYW1lIHNpZ25hdHVyZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtwcmVJbml0aWFsaXplXSAtIENhbGxlZCBiZWZvcmUgdGhlIGBpbml0aWFsaXplYCBjYXNjYWRlLiBHZXRzIHBhc3NlZCBuZXcgb2JqZWN0IGFzIGNvbnRleHQgKyBzYW1lIGFyZ3MgYXMgY29uc3RydWN0b3IgaXRzZWxmLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3Bvc3RJbml0aWFsaXplXSAtIENhbGxlZCBhZnRlciB0aGUgYGluaXRpYWxpemVgIGNhc2NhZGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuXG4gKi9cblxuLyoqIEBzdW1tYXJ5IENhbGwgYWxsIGBpbml0aWFsaXplYCBtZXRob2RzIGZvdW5kIGluIHByb3RvdHlwZSBjaGFpbiwgYmVnaW5uaW5nIHdpdGggdGhlIG1vc3Qgc2VuaW9yIGFuY2VzdG9yJ3MgZmlyc3QuXG4gKiBAZGVzYyBUaGlzIHJlY3Vyc2l2ZSByb3V0aW5lIGlzIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gKiAxLiBXYWxrcyBiYWNrIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gYE9iamVjdGAncyBwcm90b3R5cGVcbiAqIDIuIFdhbGtzIGZvcndhcmQgdG8gbmV3IG9iamVjdCwgY2FsbGluZyBhbnkgYGluaXRpYWxpemVgIG1ldGhvZHMgaXQgZmluZHMgYWxvbmcgdGhlIHdheSB3aXRoIHRoZSBzYW1lIGNvbnRleHQgYW5kIGFyZ3VtZW50cyB3aXRoIHdoaWNoIHRoZSBjb25zdHJ1Y3RvciB3YXMgY2FsbGVkLlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJPZiBleHRlbmQtbWVcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb3RvdHlwZUNoYWluKCkge1xuICAgIHZhciB0ZXJtID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZWN1cih0ZXJtKTtcblxuICAgIGZ1bmN0aW9uIHJlY3VyKG9iaikge1xuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKHByb3RvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJlY3VyKHByb3RvKTtcbiAgICAgICAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnaW5pdGlhbGl6ZScpKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uaW5pdGlhbGl6ZS5hcHBseSh0ZXJtLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIERhdGFTb3VyY2VCYXNlKCkge31cblxuRGF0YVNvdXJjZUJhc2UuZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLW1lJyk7XG5cbkRhdGFTb3VyY2VCYXNlLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgcmVwbGFjZUluZGVudDogJ18nLFxuXG4gICAgaXNOdWxsT2JqZWN0OiB0cnVlLFxuXG4gICAgZHJpbGxEb3duQ2hhck1hcDoge1xuICAgICAgICBPUEVOOiAnXFx1MjViYycsIC8vIEJMQUNLIERPV04tUE9JTlRJTkcgVFJJQU5HTEUgYWthICfilrwnXG4gICAgICAgIENMT1NFOiAnXFx1MjViNicsIC8vIEJMQUNLIFJJR0hULVBPSU5USU5HIFRSSUFOR0xFIGFrYSAn4pa2J1xuICAgICAgICB1bmRlZmluZWQ6ICcnIC8vIGZvciBsZWFmIHJvd3NcbiAgICB9LFxuXG4gICAgRGF0YVNvdXJjZUVycm9yOiBEYXRhU291cmNlRXJyb3IsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgLy8gZmluZCB0aGlzIHR5cGUncyBEQ0kgaWYgYWxyZWFkeSBkZWZpbmVkLCBlbHNlIGNyZWF0ZSBpdFxuICAgICAgICAgICAgdmFyIHBpcGUgPSBkYXRhU291cmNlO1xuICAgICAgICAgICAgd2hpbGUgKHBpcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocGlwZS50eXBlID09PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqIEBzdW1tYXJ5IERhdGEgY29udHJvbCBpbnRlcmZhY2UuXG4gICAgICAgICAgICAgICAgICAgICAqIEBkZXNjIEEgRENJIGlzIGNyZWF0ZSBmb3IgYWxsIGRhdGEgc291cmNlcyB0aGF0IGhhdmUgYSBkZWZpbmVkIHR5cGUuIERhdGEgc291cmNlcyB0aGF0IHNoYXJlIHRoZSBzYW1lIHR5cGUgYWxzbyBzaGFyZSB0aGUgc2FtZSBEQ0kgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBwaXBlLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwaXBlID0gcGlwZS5kYXRhU291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyID0gdGhpcy5uZXdDb250cm9sbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR0VUVEVSUy9TRVRURVJTXG5cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNjaGVtYTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0IHNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8vIFwiU0VUXCIgTUVUSE9EUyAoQUxXQVlTIEhBVkUgQVJHUylcblxuICAgIHNldFNjaGVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0U2NoZW1hLmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXREYXRhLmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0VmFsdWUuYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5ld0NvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgYGNvbnRyb2xsZXJgIHByb3BlcnR5IG9mIHRoZSBtYXRjaGluZyBkYXRhIHNvdXJjZShzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFJlZmVycyB0byBfYWxsXyBkYXRhIHNvdXJjZXMgaW4gdGhlIHBpcGVsaW5lIHdpdGggbWF0Y2hpbmcgYHR5cGVgIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfCp9IGNvbnRyb2xsZXIgLSBJZiBgdW5kZWZpbmVkYCwgcmVzZXRzIHRoZSBEQ0kuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHwqfSAtIGBjb250cm9sbGVyYCBvciBhIG51bGwgRENJIGdlbmVyYXRlZCBieSBkYXRhIG1vZGVsIGlmIGBjb250cm9sbGVyYCBpcyBmYWxzeSBvciBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIHR5cGUuXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VCYXNlI1xuICAgICAqL1xuICAgIHNldENvbnRyb2xsZXI6IGZ1bmN0aW9uKHR5cGUsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgcGlwZTtcblxuICAgICAgICBpZiAoY29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyID0gdGhpcy5uZXdDb250cm9sbGVyLmNhbGwocGlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwaXBlID0gdGhpcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHBpcGUudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBpcGUuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaXBlID0gcGlwZS5kYXRhU291cmNlO1xuICAgICAgICB9IHdoaWxlIChwaXBlKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIERDSSAoYGNvbnRyb2xsZXJgIHByb3BlcnR5KSBvZiB0aGUgZmlyc3QgbWF0Y2hpbmcgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBSZWZlcnMgdG8gZmlyc3QgZGF0YSBzb3VyY2UgaW4gdGhlIHBpcGVsaW5lIHdpdGggbWF0Y2hpbmcgYHR5cGVgIHByb3BlcnR5LiAoQWxsIHN1Y2ggZGF0YSBzb3VyY2VzIHNoYXJlIHRoZSBzYW1lIHZhbHVlLilcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfCp9IFRoZSBEQ0k7IG9yIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggdHlwZS5cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUJhc2UjXG4gICAgICovXG4gICAgZ2V0Q29udHJvbGxlcjogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgcGlwZTtcblxuICAgICAgICBwaXBlID0gdGhpcztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHBpcGUudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwaXBlLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaXBlID0gcGlwZS5kYXRhU291cmNlO1xuICAgICAgICB9IHdoaWxlIChwaXBlKTtcbiAgICB9LFxuXG5cbiAgICAvLyBcIkdFVFwiIE1FVEhPRFMgV0lUSE9VVCBBUkdTXG5cbiAgICBnZXRTY2hlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFNjaGVtYSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEdyYW5kVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9yb3c6IElkZWFsbHkgdGhpcyBzaG91bGQgYmUgc2V0IGFuZCBnZXQgYm90dG9tL3RvcCB0b3RhbHNcbiAgICAgICAgLy9DdXJyZW50bHkgdGhpcyBmdW5jdGlvbiBpcyBqdXN0IHNlbmRpbmcgdGhlIHNhbWUgZm9yIGJvdGggaW4gYWdncmVnYXRpb25zXG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0R3JhbmRUb3RhbHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8vIFwiR0VUXCIgTUVUSE9EUyBXSVRIIEFSR1NcblxuICAgIGdldFByb3BlcnR5OiBmdW5jdGlvbiBnZXRQcm9wZXJ0eShwcm9wTmFtZSkge1xuICAgICAgICBpZiAocHJvcE5hbWUgaW4gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFByb3BlcnR5LmNhbGwodGhpcy5kYXRhU291cmNlLCBwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RGF0YUluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXREYXRhSW5kZXguYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93LmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5kUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5maW5kUm93LmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXZlYWxSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnJldmVhbFJvdy5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFZhbHVlLmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuY2xpY2suYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLy8gQk9PTEVBTiBNRVRIT0RTIChOTyBBUkdTKVxuXG4gICAgaXNEcmlsbERvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmlzRHJpbGxEb3duKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmlld01ha2VzU2Vuc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnZpZXdNYWtlc1NlbnNlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvLyBPVEhFUiBNRVRIT0RTXG5cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRhU291cmNlRXJyb3IoJ05vdGhpbmcgdG8gYXBwbHkuJyk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2V0IG5ldyBvYmplY3Qgd2l0aCBuYW1lIGFuZCBpbmRleCBnaXZlbiB0aGUgbmFtZSBvciB0aGUgaW5kZXguXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjb2x1bW5PckluZGV4IC0gQ29sdW1uIG5hbWUgb3IgaW5kZXguXG4gICAgICogQHJldHVybnMge3tuYW1lOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIGdldENvbHVtbkluZm86IGZ1bmN0aW9uKGNvbHVtbk9ySW5kZXgpIHtcbiAgICAgICAgdmFyIG5hbWUsIGluZGV4LCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW5PckluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSBjb2x1bW5PckluZGV4O1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuc2NoZW1hW2luZGV4XS5uYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IGNvbHVtbk9ySW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuc2NoZW1hLmZpbmRJbmRleChmdW5jdGlvbihjb2x1bW5TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uU2NoZW1hLm5hbWUgPT09IG5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGZpeEluZGVudEZvclRhYmxlRGlzcGxheTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHN0cmluZy5zZWFyY2goL1xcUy8pO1xuICAgICAgICB2YXIgZW5kID0gc3RyaW5nLnN1YnN0cmluZyhjb3VudCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBBcnJheShjb3VudCArIDEpLmpvaW4odGhpcy5yZXBsYWNlSW5kZW50KSArIGVuZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZHVtcDogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIG1heCA9IE1hdGgubWluKHRoaXMuZ2V0Um93Q291bnQoKSwgbWF4IHx8IE1hdGgubWF4KDEwMCwgdGhpcy5nZXRSb3dDb3VudCgpKSk7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLnNjaGVtYSA/IHRoaXMuc2NoZW1hLm1hcChmdW5jdGlvbihjcykgeyByZXR1cm4gY3MubmFtZTsgfSkgOiB0aGlzLmdldEhlYWRlcnMoKTtcbiAgICAgICAgdmFyIGNDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHZpZXdNYWtlc1NlbnNlID0gdGhpcy52aWV3TWFrZXNTZW5zZTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBtYXg7IHIrKykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmdldFZhbHVlKGMsIHIpO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAwICYmIHZpZXdNYWtlc1NlbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMuZml4SW5kZW50Rm9yVGFibGVEaXNwbGF5KHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd1tmaWVsZHNbY11dID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVtyXSA9IHJvdztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLnRhYmxlKGRhdGEpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIERhdGFTb3VyY2VFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuLy8gZXh0ZW5kIGZyb20gYEVycm9yYFxuRGF0YVNvdXJjZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuLy8gb3ZlcnJpZGUgZXJyb3IgbmFtZSBkaXNwbGF5ZWQgaW4gY29uc29sZVxuRGF0YVNvdXJjZUVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0RhdGFTb3VyY2VFcnJvcic7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUJhc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCdjc3MtaW5qZWN0b3InKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgRmluQmFyXG4gKiBAc3VtbWFyeSBDcmVhdGUgYSBzY3JvbGxiYXIgb2JqZWN0LlxuICogQGRlc2MgQ3JlYXRpbmcgYSBzY3JvbGxiYXIgaXMgYSB0aHJlZS1zdGVwIHByb2Nlc3M6XG4gKlxuICogMS4gSW5zdGFudGlhdGUgdGhlIHNjcm9sbGJhciBvYmplY3QgYnkgY2FsbGluZyB0aGlzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiBVcG9uIGluc3RhbnRpYXRpb24sIHRoZSBET00gZWxlbWVudCBmb3IgdGhlIHNjcm9sbGJhciAod2l0aCBhIHNpbmdsZSBjaGlsZCBlbGVtZW50IGZvciB0aGUgc2Nyb2xsYmFyIFwidGh1bWJcIikgaXMgY3JlYXRlZCBidXQgaXMgbm90IGluc2VydCBpdCBpbnRvIHRoZSBET00uXG4gKiAyLiBBZnRlciBpbnN0YW50aWF0aW9uLCBpdCBpcyB0aGUgY2FsbGVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gaW5zZXJ0IHRoZSBzY3JvbGxiYXIsIHtAbGluayBGaW5CYXIjYmFyfHRoaXMuYmFyfSwgaW50byB0aGUgRE9NLlxuICogMy4gQWZ0ZXIgaW5zZXJ0aW9uLCB0aGUgY2FsbGVyIG11c3QgY2FsbCB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0gYXQgbGVhc3Qgb25jZSB0byBzaXplIGFuZCBwb3NpdGlvbiB0aGUgc2Nyb2xsYmFyIGFuZCBpdHMgdGh1bWIuIEFmdGVyIHRoYXQsIGByZXNpemUoKWAgc2hvdWxkIGFsc28gYmUgY2FsbGVkIHJlcGVhdGVkbHkgb24gcmVzaXplIGV2ZW50cyAoYXMgdGhlIGNvbnRlbnQgZWxlbWVudCBpcyBiZWluZyByZXNpemVkKS5cbiAqXG4gKiBTdWdnZXN0ZWQgY29uZmlndXJhdGlvbnM6XG4gKiAqIF8qKlVuYm91bmQqKl88YnIvPlxuICogVGhlIHNjcm9sbGJhciBzZXJ2ZXMgbWVyZWx5IGFzIGEgc2ltcGxlIHJhbmdlIChzbGlkZXIpIGNvbnRyb2wuIE9taXQgYm90aCBgb3B0aW9ucy5vbmNoYW5nZWAgYW5kIGBvcHRpb25zLmNvbnRlbnRgLlxuICogKiBfKipCb3VuZCB0byB2aXJ0dWFsIGNvbnRlbnQgZWxlbWVudCoqXzxici8+XG4gKiBWaXJ0dWFsIGNvbnRlbnQgaXMgcHJvamVjdGVkIGludG8gdGhlIGVsZW1lbnQgdXNpbmcgYSBjdXN0b20gZXZlbnQgaGFuZGxlciBzdXBwbGllZCBieSB0aGUgcHJvZ3JhbW1lciBpbiBgb3B0aW9ucy5vbmNoYW5nZWAuIEEgdHlwaWNhbCB1c2UgY2FzZSB3b3VsZCBiZSB0byBoYW5kbGUgc2Nyb2xsaW5nIG9mIHRoZSB2aXJ0dWFsIGNvbnRlbnQuIE90aGVyIHVzZSBjYXNlcyBpbmNsdWRlIGRhdGEgdHJhbnNmb3JtYXRpb25zLCBncmFwaGljcyB0cmFuc2Zvcm1hdGlvbnMsIF9ldGMuX1xuICogKiBfKipCb3VuZCB0byByZWFsIGNvbnRlbnQqKl88YnIvPlxuICogU2V0IGBvcHRpb25zLmNvbnRlbnRgIHRvIHRoZSBcInJlYWxcIiBjb250ZW50IGVsZW1lbnQgYnV0IG9taXQgYG9wdGlvbnMub25jaGFuZ2VgLiBUaGlzIHdpbGwgY2F1c2UgdGhlIHNjcm9sbGJhciB0byB1c2UgdGhlIGJ1aWx0LWluIGV2ZW50IGhhbmRsZXIgKGB0aGlzLnNjcm9sbFJlYWxDb250ZW50YCkgd2hpY2ggaW1wbGVtZW50cyBzbW9vdGggc2Nyb2xsaW5nIG9mIHRoZSBjb250ZW50IGVsZW1lbnQgd2l0aGluIHRoZSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIHtmaW5iYXJPcHRpb25zfSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIG9iamVjdC4gU2VlIHRoZSB0eXBlIGRlZmluaXRpb24gZm9yIG1lbWJlciBkZXRhaWxzLlxuICovXG5mdW5jdGlvbiBGaW5CYXIob3B0aW9ucykge1xuXG4gICAgLy8gbWFrZSBib3VuZCB2ZXJzaW9ucyBvZiBhbGwgdGhlIG1vdXNlIGV2ZW50IGhhbmRsZXJcbiAgICB2YXIgYm91bmQgPSB0aGlzLl9ib3VuZCA9IHt9O1xuICAgIGZvciAoa2V5IGluIGhhbmRsZXJzVG9CZUJvdW5kKSB7XG4gICAgICAgIGJvdW5kW2tleV0gPSBoYW5kbGVyc1RvQmVCb3VuZFtrZXldLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgdGh1bWJcbiAgICAgKiBAc3VtbWFyeSBUaGUgZ2VuZXJhdGVkIHNjcm9sbGJhciB0aHVtYiBlbGVtZW50LlxuICAgICAqIEBkZXNjIFRoZSB0aHVtYiBlbGVtZW50J3MgcGFyZW50IGVsZW1lbnQgaXMgYWx3YXlzIHRoZSB7QGxpbmsgRmluQmFyI2JhcnxiYXJ9IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHR5cGljYWxseSByZWZlcmVuY2VkIGludGVybmFsbHkgb25seS4gVGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoZSB0aHVtYiBlbGVtZW50IGlzIG1haW50YWluZWQgYnkgYF9jYWxjVGh1bWIoKWAuXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2YXIgdGh1bWIgPSB0aGlzLnRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGh1bWIuY2xhc3NMaXN0LmFkZCgndGh1bWInKTtcbiAgICB0aHVtYi5vbmNsaWNrID0gYm91bmQuc2hvcnRTdG9wO1xuICAgIHRodW1iLm9ubW91c2VvdmVyID0gYm91bmQub25tb3VzZW92ZXI7XG4gICAgdGh1bWIub25tb3VzZW91dCA9IHRoaXMuX2JvdW5kLm9ubW91c2VvdXQ7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBiYXJcbiAgICAgKiBAc3VtbWFyeSBUaGUgZ2VuZXJhdGVkIHNjcm9sbGJhciBlbGVtZW50LlxuICAgICAqIEBkZXNjIFRoZSBjYWxsZXIgaW5zZXJ0cyB0aGlzIGVsZW1lbnQgaW50byB0aGUgRE9NICh0eXBpY2FsbHkgaW50byB0aGUgY29udGVudCBjb250YWluZXIpIGFuZCB0aGVuIGNhbGxzIGl0cyB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0gbWV0aG9kLlxuICAgICAqXG4gICAgICogVGh1cyB0aGUgbm9kZSB0cmVlIGlzIHR5cGljYWxseTpcbiAgICAgKiAqIEEgKipjb250ZW50IGNvbnRhaW5lcioqIGVsZW1lbnQsIHdoaWNoIGNvbnRhaW5zOlxuICAgICAqICAgKiBUaGUgY29udGVudCBlbGVtZW50KHMpXG4gICAgICogICAqIFRoaXMgKipzY3JvbGxiYXIgZWxlbWVudCoqLCB3aGljaCBpbiB0dXJuIGNvbnRhaW5zOlxuICAgICAqICAgICAqIFRoZSAqKnRodW1iIGVsZW1lbnQqKlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2YXIgYmFyID0gdGhpcy5iYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYXIuY2xhc3NMaXN0LmFkZCgnZmluYmFyLXZlcnRpY2FsJyk7XG4gICAgYmFyLm9ubW91c2Vkb3duID0gdGhpcy5fYm91bmQub25tb3VzZWRvd247XG4gICAgaWYgKHRoaXMucGFnaW5nKSB7IGJhci5vbmNsaWNrID0gYm91bmQub25jbGljazsgfVxuICAgIGJhci5hcHBlbmRDaGlsZCh0aHVtYik7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIHByZXNldHNcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICB0aGlzLl9taW4gPSB0aGlzLl9pbmRleCA9IDA7XG4gICAgdGhpcy5fbWF4ID0gMTAwO1xuXG4gICAgLy8gb3B0aW9uc1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IG9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkUmFuZ2Uob3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWluID0gb3B0aW9uLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF4ID0gb3B0aW9uLm1heDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IG9wdGlvbi5tYXggLSBvcHRpb24ubWluICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuY2hhckF0KDApICE9PSAnXycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBGaW5CYXIucHJvdG90eXBlW2tleV0gIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSBwcm90b3R5cGUgZGVmYXVsdHMgZm9yIHN0YW5kYXJkIDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyAoZm9yIHVzZSBpbiBvbmNoYW5nZSBldmVudCBoYW5kbGVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IG9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3NzSW5qZWN0b3IoY3NzRmluQmFycywgJ2ZpbmJhci1iYXNlJywgb3B0aW9ucy5jc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudCk7XG59XG5cbkZpbkJhci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgc2Nyb2xsYmFyIG9yaWVudGF0aW9uLlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IgdG8gZWl0aGVyIGAndmVydGljYWwnYCBvciBgJ2hvcml6b250YWwnYC4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgdmFsdWVzIGFyZSBgJ3ZlcnRpY2FsJ2AgKHRoZSBkZWZhdWx0KSBvciBgJ2hvcml6b250YWwnYC5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSByZXNldHMgYHRoaXMub2hgIGFuZCBgdGhpcy5kZWx0YVByb3BgIGFuZCBjaGFuZ2VzIHRoZSBjbGFzcyBuYW1lcyBzbyBhcyB0byByZXBvc2l0aW9uIHRoZSBzY3JvbGxiYXIgYXMgcGVyIHRoZSBDU1MgcnVsZXMgZm9yIHRoZSBuZXcgb3JpZW50YXRpb24uXG4gICAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgb3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSB0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBuYW1lIG9oXG4gICAgICAgICAqIEBzdW1tYXJ5IDx1Pk88L3U+cmllbnRhdGlvbiA8dT5oPC91PmFzaCBmb3IgdGhpcyBzY3JvbGxiYXIuXG4gICAgICAgICAqIEBkZXNjIFNldCBieSB0aGUgYG9yaWVudGF0aW9uYCBzZXR0ZXIgdG8gZWl0aGVyIHRoZSB2ZXJ0aWNhbCBvciB0aGUgaG9yaXpvbnRhbCBvcmllbnRhdGlvbiBoYXNoLiBUaGUgcHJvcGVydHkgc2hvdWxkIGFsd2F5cyBiZSBzeW5jaHJvbml6ZWQgd2l0aCBgb3JpZW50YXRpb25gOyBkbyBub3QgdXBkYXRlIGRpcmVjdGx5IVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VkIGludGVybmFsbHkgdG8gYWNjZXNzIHNjcm9sbGJhcnMnIERPTSBlbGVtZW50IHByb3BlcnRpZXMgaW4gYSBnZW5lcmFsaXplZCB3YXkgd2l0aG91dCBuZWVkaW5nIHRvIGNvbnN0YW50bHkgcXVlcnkgdGhlIHNjcm9sbGJhciBvcmllbnRhdGlvbi4gRm9yIGV4YW1wbGUsIGluc3RlYWQgb2YgZXhwbGljaXRseSBjb2RpbmcgYHRoaXMuYmFyLnRvcGAgZm9yIGEgdmVydGljYWwgc2Nyb2xsYmFyIGFuZCBgdGhpcy5iYXIubGVmdGAgZm9yIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIsIHNpbXBseSBjb2RlIGB0aGlzLmJhclt0aGlzLm9oLmxlYWRpbmddYCBpbnN0ZWFkLiBTZWUgdGhlIHtAbGluayBvcmllbnRhdGlvbkhhc2hUeXBlfSBkZWZpbml0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VmdWwgZXh0ZXJuYWxseSBmb3IgY29kaW5nIGdlbmVyYWxpemVkIHtAbGluayBmaW5iYXJPbkNoYW5nZX0gZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdGhhdCBzZXJ2ZSBib3RoIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjcm9sbGJhcnMuXG4gICAgICAgICAqIEB0eXBlIHtvcmllbnRhdGlvbkhhc2hUeXBlfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vaCA9IG9yaWVudGF0aW9uSGFzaGVzW3RoaXMuX29yaWVudGF0aW9uXTtcblxuICAgICAgICBpZiAoIXRoaXMub2gpIHtcbiAgICAgICAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBgb3B0aW9ucy5fb3JpZW50YXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgZGVsdGFQcm9wXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBuYW1lIG9mIHRoZSBgV2hlZWxFdmVudGAgcHJvcGVydHkgdGhpcyBzY3JvbGxiYXIgc2hvdWxkIGxpc3RlbiB0by5cbiAgICAgICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWZ1bCB2YWx1ZXMgYXJlIGAnZGVsdGFYJ2AsIGAnZGVsdGFZJ2AsIG9yIGAnZGVsdGFaJ2AuIEEgdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRvIGlnbm9yZSBtb3VzZSB3aGVlbCBldmVudHMgZW50aXJlbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBtb3VzZSB3aGVlbCBpcyBvbmUtZGltZW5zaW9uYWwgYW5kIG9ubHkgZW1pdHMgZXZlbnRzIHdpdGggYGRlbHRhWWAgZGF0YS4gVGhpcyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBzbyB0aGF0IHlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb2YgYCdkZWx0YVgnYCB3aXRoIGEgdmFsdWUgb2YgYCdkZWx0YVknYCBvbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIHByaW1hcmlseSB0byBhY2NvbW1vZGF0ZSBjZXJ0YWluIFwicGFub3JhbWljXCIgaW50ZXJmYWNlIGRlc2lnbnMgd2hlcmUgdGhlIG1vdXNlIHdoZWVsIHNob3VsZCBjb250cm9sIGhvcml6b250YWwgcmF0aGVyIHRoYW4gdmVydGljYWwgc2Nyb2xsaW5nLiBKdXN0IGdpdmUgYHsgZGVsdGFQcm9wOiAnZGVsdGFZJyB9YCBpbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIGluc3RhbnRpYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIENhdmVhdDogTm90ZSB0aGF0IGEgMi1maW5nZXIgZHJhZyBvbiBhbiBBcHBsZSB0cmFja3BhZCBlbWl0cyBldmVudHMgd2l0aCBfYm90aF8gYGRlbHRhWCBgIGFuZCBgZGVsdGFZYCBkYXRhIHNvIHlvdSBtaWdodCB3YW50IHRvIGRlbGF5IG1ha2luZyB0aGUgYWJvdmUgYWRqdXN0bWVudCB1bnRpbCB5b3UgY2FuIGRldGVybWluZSB0aGF0IHlvdSBhcmUgZ2V0dGluZyBZIGRhdGEgb25seSB3aXRoIG5vIFggZGF0YSBhdCBhbGwgKHdoaWNoIGlzIGEgc3VyZSBiZXQgeW91IG9uIGEgbW91c2Ugd2hlZWwgcmF0aGVyIHRoYW4gYSB0cmFja3BhZCkuXG5cbiAgICAgICAgICogQHR5cGUge29iamVjdHxudWxsfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWx0YVByb3AgPSB0aGlzLm9oLmRlbHRhO1xuXG4gICAgICAgIHRoaXMuYmFyLmNsYXNzTmFtZSA9IHRoaXMuYmFyLmNsYXNzTmFtZS5yZXBsYWNlKC8odmVydGljYWx8aG9yaXpvbnRhbCkvZywgb3JpZW50YXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLmJhci5zdHlsZS5jc3NUZXh0IHx8IHRoaXMudGh1bWIuc3R5bGUuY3NzVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5iYXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2FsbGJhY2sgZm9yIHNjcm9sbCBldmVudHMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciB2aWEgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgYHRoaXMub25jaGFuZ2VgIG1heSBiZSB1cGRhdGVkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogVGhpcyBldmVudCBoYW5kbGVyIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciBpcyBjaGFuZ2VkIHRocm91Z2ggdXNlciBpbnRlcmFjdGlvbi4gVGhlIHR5cGljYWwgdXNlIGNhc2UgaXMgd2hlbiB0aGUgY29udGVudCBpcyBzY3JvbGxlZC4gSXQgaXMgY2FsbGVkIHdpdGggdGhlIGBGaW5CYXJgIG9iamVjdCBhcyBpdHMgY29udGV4dCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciAoaXRzIGluZGV4LCByb3VuZGVkKSBhcyB0aGUgb25seSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAgdG8gc3RvcCBlbWl0dGluZyBzdWNoIGV2ZW50cy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKXxudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgb25jaGFuZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCB3aWxsIGFsd2F5cyBpbmNsdWRlIGBmaW5iYXItdmVydGljYWxgIChvciBgZmluYmFyLWhvcml6b250YWxgIGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uKS4gV2hlbmV2ZXIgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gc29tZSB2YWx1ZSwgZmlyc3QgdGhlIG9sZCBwcmVmaXgrb3JpZW50YXRpb24gaXMgcmVtb3ZlZCBmcm9tIHRoZSBiYXIgZWxlbWVudCdzIGNsYXNzIGxpc3Q7IHRoZW4gdGhlIG5ldyBwcmVmaXgrb3JpZW50YXRpb24gaXMgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhpcyBwcm9wZXJ0eSBjYXVzZXMgX2FuIGFkZGl0aW9uYWxfIGNsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhlcmVmb3JlLCB0aGlzIHByb3BlcnR5IHdpbGwgb25seSBhZGQgYXQgbW9zdCBvbmUgYWRkaXRpb25hbCBjbGFzcyBuYW1lIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVG8gcmVtb3ZlIF9jbGFzc25hbWUtb3JpZW50YXRpb25fIGZyb20gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCwgc2V0IHRoaXMgcHJvcGVydHkgdG8gYSBmYWxzeSB2YWx1ZSwgc3VjaCBhcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiA+IE5PVEU6IFlvdSBvbmx5IG5lZWQgdG8gc3BlY2lmeSBhbiBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgd2hlbiB5b3UgbmVlZCB0byBoYXZlIG11bGx0aXBsZSBkaWZmZXJlbnQgc3R5bGVzIG9mIHNjcm9sbGJhcnMgb24gdGhlIHNhbWUgcGFnZS4gSWYgdGhpcyBpcyBub3QgYSByZXF1aXJlbWVudCwgdGhlbiB5b3UgZG9uJ3QgbmVlZCB0byBtYWtlIGEgbmV3IGNsYXNzOyB5b3Ugd291bGQganVzdCBjcmVhdGUgc29tZSBhZGRpdGlvbmFsIHJ1bGVzIHVzaW5nIHRoZSBzYW1lIHNlbGVjdG9ycyBpbiB0aGUgYnVpbHQtaW4gc3R5bGVzaGVldCAoLi4vY3NzL2ZpbmJhcnMuY3NzKTpcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWxgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsYCkgZm9yIHRoZSBzY3JvbGxiYXJcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWwgPiBkaXZgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsID4gZGl2YCkgZm9yIHRoZSBcInRodW1iLlwiXG4gICAgICpcbiAgICAgKiBPZiBjb3Vyc2UsIHlvdXIgcnVsZXMgc2hvdWxkIGNvbWUgYWZ0ZXIgdGhlIGJ1aWx0LWlucy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGNsYXNzUHJlZml4KHByZWZpeCkge1xuICAgICAgICBpZiAodGhpcy5fY2xhc3NQcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3NQcmVmaXggKyB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsYXNzUHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5hZGQocHJlZml4ICsgJy0nICsgdGhpcy5vcmllbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzUHJlZml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBpbmNyZW1lbnRcbiAgICAgKiBAc3VtbWFyeSBOdW1iZXIgb2Ygc2Nyb2xsYmFyIGluZGV4IHVuaXRzIHJlcHJlc2VudGluZyBhIHBhZ2VmdWwuIFVzZWQgZXhjbHVzaXZlbHkgZm9yIHBhZ2luZyB1cCBhbmQgZG93biBhbmQgZm9yIHNldHRpbmcgdGh1bWIgc2l6ZSByZWxhdGl2ZSB0byBjb250ZW50IHNpemUuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBDYW4gYWxzbyBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplfSBtZXRob2QsIHdoaWNoIGlzIHBlcnRpbmVudCBiZWNhdXNlIGNvbnRlbnQgYXJlYSBzaXplIGNoYW5nZXMgYWZmZWN0IHRoZSBkZWZpbml0aW9uIG9mIGEgXCJwYWdlZnVsLlwiIEhvd2V2ZXIsIHlvdSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpZiB0aGlzIHZhbHVlIGlzIGJlaW5nIHVzZWQuIEl0IG5vdCB1c2VkIHdoZW46XG4gICAgICogKiB5b3UgZGVmaW5lIGBwYWdpbmcudXBgIGFuZCBgcGFnaW5nLmRvd25gXG4gICAgICogKiB5b3VyIHNjcm9sbGJhciBpcyB1c2luZyBgc2Nyb2xsUmVhbENvbnRlbnRgXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluY3JlbWVudDogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGJhclN0eWxlc1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbGJhciBzdHlsZXMgdG8gYmUgYXBwbGllZCBieSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgdmFsdWUgdG8gYmUgYXNzaWduZWQgdG8ge0BsaW5rIEZpbkJhciNzdHlsZXN8c3R5bGVzfSBvbiBlYWNoIGNhbGwgdG8ge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9LiBUaGF0IGlzLCBhIGhhc2ggb2YgdmFsdWVzIHRvIGJlIGNvcGllZCB0byB0aGUgc2Nyb2xsYmFyIGVsZW1lbnQncyBzdHlsZSBvYmplY3Qgb24gcmVzaXplOyBvciBgbnVsbGAgZm9yIG5vbmUuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc3R5bGV8c3R5bGV9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc3xudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgYmFyU3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc3R5bGVcbiAgICAgKiBAc3VtbWFyeSBBZGRpdGlvbmFsIHNjcm9sbGJhciBzdHlsZXMuXG4gICAgICogQGRlc2MgU2VlIHR5cGUgZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLiBUaGVzZSBzdHlsZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIHNjcm9sbGJhcidzIGBiYXJgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgYXJlIGFkanVzdGVkIGFzIGZvbGxvd3MgYmVmb3JlIGJlaW5nIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQ6XG4gICAgICogMS4gSW5jbHVkZWQgXCJwc2V1ZG8tcHJvcGVydHlcIiBuYW1lcyBmcm9tIHRoZSBzY3JvbGxiYXIncyBvcmllbnRhdGlvbiBoYXNoLCB7QGxpbmsgRmluQmFyI29ofG9ofSwgYXJlIHRyYW5zbGF0ZWQgdG8gYWN0dWFsIHByb3BlcnR5IG5hbWVzIGJlZm9yZSBiZWluZyBhcHBsaWVkLlxuICAgICAqIDIuIFdoZW4gdGhlcmUgYXJlIG1hcmdpbnMsIHBlcmNlbnRhZ2VzIGFyZSB0cmFuc2xhdGVkIHRvIGFic29sdXRlIHBpeGVsIHZhbHVlcyBiZWNhdXNlIENTUyBpZ25vcmVzIG1hcmdpbnMgaW4gaXRzIHBlcmNlbnRhZ2UgY2FsY3VsYXRpb25zLlxuICAgICAqIDMuIElmIHlvdSBnaXZlIGEgdmFsdWUgd2l0aG91dCBhIHVuaXQgKGEgcmF3IG51bWJlciksIFwicHhcIiB1bml0IGlzIGFwcGVuZGVkLlxuICAgICAqXG4gICAgICogR2VuZXJhbCBub3RlczpcbiAgICAgKiAxLiBJdCBpcyBhbHdheXMgcHJlZmVyYWJsZSB0byBzcGVjaWZ5IHN0eWxlcyB2aWEgYSBzdHlsZXNoZWV0LiBPbmx5IHNldCB0aGlzIHByb3BlcnR5IHdoZW4geW91IG5lZWQgdG8gc3BlY2lmaWNhbGx5IG92ZXJyaWRlIChhKSBzdHlsZXNoZWV0IHZhbHVlKHMpLlxuICAgICAqIDIuIENhbiBiZSBzZXQgZGlyZWN0bHkgb3IgdmlhIGNhbGxzIHRvIHRoZSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemV9IG1ldGhvZC5cbiAgICAgKiAzLiBTaG91bGQgb25seSBiZSBzZXQgYWZ0ZXIgdGhlIHNjcm9sbGJhciBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICogNC4gQmVmb3JlIGFwcGx5aW5nIHRoZXNlIG5ldyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQsIF9hbGxfIGluLWxpbmUgc3R5bGUgdmFsdWVzIGFyZSByZXNldCAoYnkgcmVtb3ZpbmcgdGhlIGVsZW1lbnQncyBgc3R5bGVgIGF0dHJpYnV0ZSksIGV4cG9zaW5nIGluaGVyaXRlZCB2YWx1ZXMgKGZyb20gc3R5bGVzaGVldHMpLlxuICAgICAqIDUuIEVtcHR5IG9iamVjdCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIDYuIEZhbHNleSB2YWx1ZSBpbiBwbGFjZSBvZiBvYmplY3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqID4gQ0FWRUFUOiBEbyBub3QgYXR0ZW1wdCB0byB0cmVhdCB0aGUgb2JqZWN0IHlvdSBhc3NpZ24gdG8gdGhpcyBwcm9wZXJ0eSBhcyBpZiBpdCB3ZXJlIGB0aGlzLmJhci5zdHlsZWAuIFNwZWNpZmljYWxseSwgY2hhbmdpbmcgdGhpcyBvYmplY3QgYWZ0ZXIgYXNzaWduaW5nIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIHNjcm9sbGJhci4gWW91IG11c3QgYXNzaWduIGl0IGFnYWluIGlmIHlvdSB3YW50IGl0IHRvIGhhdmUgYW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBzdHlsZShzdHlsZXMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZXMgPSBleHRlbmQoe30sIHN0eWxlcywgdGhpcy5fYXV4U3R5bGVzKSk7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYmFyID0gdGhpcy5iYXIsXG4gICAgICAgICAgICAgICAgYmFyUmVjdCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5vaDtcblxuICAgICAgICAgICAgLy8gQmVmb3JlIGFwcGx5aW5nIG5ldyBzdHlsZXMsIHJldmVydCBhbGwgc3R5bGVzIHRvIHZhbHVlcyBpbmhlcml0ZWQgZnJvbSBzdHlsZXNoZWV0c1xuICAgICAgICAgICAgYmFyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gc3R5bGVzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIG9oKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9oW2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKHZhbCB8fCAwKSArICdweCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvJSQvLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGJhciBzaXplIGdpdmVuIGFzIHBlcmNlbnRhZ2Ugb2YgY29udGFpbmVyLCBpZiBiYXIgaGFzIG1hcmdpbnMsIHJlc3RhdGUgc2l6ZSBpbiBwaXhlbHMgbGVzcyBtYXJnaW5zLlxuICAgICAgICAgICAgICAgICAgICAvLyAoSWYgbGVmdCBhcyBwZXJjZW50YWdlLCBDU1MncyBjYWxjdWxhdGlvbiB3aWxsIG5vdCBleGNsdWRlIG1hcmdpbnMuKVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZW50ZWQgPSBheGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5zID0gYmFyUmVjdFtvcmllbnRlZC5tYXJnaW5MZWFkaW5nXSArIGJhclJlY3Rbb3JpZW50ZWQubWFyZ2luVHJhaWxpbmddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2lucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQodmFsLCAxMCkgLyAxMDAgKiBjb250YWluZXJSZWN0W29yaWVudGVkLnNpemVdIC0gbWFyZ2lucyArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiYXIuc3R5bGVba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBuYW1lIHBhZ2luZ1xuICAgICAqIEBzdW1tYXJ5IEVuYWJsZSBwYWdlIHVwL2RuIGNsaWNrcy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRydXRoeSwgbGlzdGVuIGZvciBjbGlja3MgaW4gcGFnZS11cCBhbmQgcGFnZS1kb3duIHJlZ2lvbnMgb2Ygc2Nyb2xsYmFyLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0LCBjYWxsIGAucGFnaW5nLnVwKClgIG9uIHBhZ2UtdXAgY2xpY2tzIGFuZCBgLnBhZ2luZy5kb3duKClgIHdpbGwgYmUgY2FsbGVkIG9uIHBhZ2UtZG93biBjbGlja3MuXG4gICAgICpcbiAgICAgKiBDaGFuZ2luZyB0aGUgdHJ1dGhpbmVzcyBvZiB0aGlzIHZhbHVlIGFmdGVyIGluc3RhbnRpYXRpb24gY3VycmVudGx5IGhhcyBubyBlZmZlY3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFnaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgcmFuZ2VcbiAgICAgKiBAc3VtbWFyeSBTZXR0ZXIgZm9yIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHNjcm9sbCB2YWx1ZXMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gVGhlc2UgdmFsdWVzIGFyZSB0aGUgbGltaXRzIGZvciB7QGxpbmsgRm9vQmFyI2luZGV4fGluZGV4fS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXR0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2l0aCBleGFjdGx5IHR3byBudW1lcmljIHByb3BlcnRpZXM6IGAubWluYCB3aGljaCBtdXN0IGJlIGxlc3MgdGhhbiBgLm1heGAuIFRoZSB2YWx1ZXMgYXJlIGV4dHJhY3RlZCBhbmQgdGhlIG9iamVjdCBpcyBkaXNjYXJkZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZ2V0dGVyIHJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggYC5taW5gIGFuZCAnLm1heGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7cmFuZ2VUeXBlfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IHJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHZhbGlkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLl9taW4gPSByYW5nZS5taW47XG4gICAgICAgIHRoaXMuX21heCA9IHJhbmdlLm1heDtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbiArIDE7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4OyAvLyByZS1jbGFtcFxuICAgIH0sXG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiB0aGlzLl9taW4sXG4gICAgICAgICAgICBtYXg6IHRoaXMuX21heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRleCB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwgdGh1bWIuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgY2xhbXBzIGl0IHRvIHtAbGluayBGaW5CYXIjbWlufG1pbn0uLntAbGluayBGaW5CYXIjbWF4fG1heH0sIHNjcm9sbCB0aGUgY29udGVudCwgYW5kIG1vdmVzIHRodW1iLlxuICAgICAqXG4gICAgICogR2V0dGluZyB0aGlzIHZhbHVlIHJldHVybnMgdGhlIGN1cnJlbnQgaW5kZXguIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuIEl0IGlzIGludGVudGlvbmFsbHkgbm90IHJvdW5kZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB2YWx1ZSBhcyBhbiBhbHRlcm5hdGl2ZSB0byAob3IgaW4gYWRkaXRpb24gdG8pIHVzaW5nIHRoZSB7QGxpbmsgRmluQmFyI29uY2hhbmdlfG9uY2hhbmdlfSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNfc2V0U2Nyb2xsfF9zZXRTY3JvbGx9XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBpbmRleChpZHgpIHtcbiAgICAgICAgaWR4ID0gTWF0aC5taW4odGhpcy5fbWF4LCBNYXRoLm1heCh0aGlzLl9taW4sIGlkeCkpOyAvLyBjbGFtcCBpdFxuICAgICAgICB0aGlzLl9zZXRTY3JvbGwoaWR4KTtcbiAgICAgICAgLy8gdGhpcy5fc2V0VGh1bWJTaXplKCk7XG4gICAgfSxcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBNb3ZlIHRoZSB0aHVtYi5cbiAgICAgKiBAZGVzYyBBbHNvIGRpc3BsYXlzIHRoZSBpbmRleCB2YWx1ZSBpbiB0aGUgdGVzdCBwYW5lbCBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGlkeCAtIFRoZSBuZXcgc2Nyb2xsIGluZGV4LCBhIHZhbHVlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuXG4gICAgICogQHBhcmFtIFtzY2FsZWQ9ZihpZHgpXSAtIFRoZSBuZXcgdGh1bWIgcG9zaXRpb24gaW4gcGl4ZWxzIGFuZCBzY2FsZWQgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LCBpLmUuLCBhIHByb3BvcnRpb25hbCBudW1iZXIgaW4gdGhlIHJhbmdlIGAwYC4uYHRodW1iTWF4YC4gV2hlbiBvbWl0dGVkLCBhIGZ1bmN0aW9uIG9mIGBpZHhgIGlzIHVzZWQuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsOiBmdW5jdGlvbiAoaWR4LCBzY2FsZWQpIHtcbiAgICAgICAgdGhpcy5faW5kZXggPSBpZHg7XG5cbiAgICAgICAgLy8gRGlzcGxheSB0aGUgaW5kZXggdmFsdWUgaW4gdGhlIHRlc3QgcGFuZWxcbiAgICAgICAgaWYgKHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXggaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXguaW5uZXJIVE1MID0gTWF0aC5yb3VuZChpZHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25jaGFuZ2UuY2FsbCh0aGlzLCBNYXRoLnJvdW5kKGlkeCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgdGh1bWJcbiAgICAgICAgaWYgKHNjYWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2FsZWQgPSAoaWR4IC0gdGhpcy5fbWluKSAvICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICogdGhpcy5fdGh1bWJNYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHVtYi5zdHlsZVt0aGlzLm9oLmxlYWRpbmddID0gc2NhbGVkICsgJ3B4JztcbiAgICB9LFxuXG4gICAgc2Nyb2xsUmVhbENvbnRlbnQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSB0aGlzLmNvbnRlbnQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNpemVQcm9wID0gdGhpcy5vaC5zaXplLFxuICAgICAgICAgICAgbWF4U2Nyb2xsID0gTWF0aC5tYXgoMCwgdGhpcy5jb250ZW50W3NpemVQcm9wXSAtIGNvbnRhaW5lclJlY3Rbc2l6ZVByb3BdKSxcbiAgICAgICAgICAgIC8vc2Nyb2xsID0gTWF0aC5taW4oaWR4LCBtYXhTY3JvbGwpO1xuICAgICAgICAgICAgc2Nyb2xsID0gKGlkeCAtIHRoaXMuX21pbikgLyAodGhpcy5fbWF4IC0gdGhpcy5fbWluKSAqIG1heFNjcm9sbDtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2Nyb2xsOiAnICsgc2Nyb2xsKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3RoaXMub2gubGVhZGluZ10gPSAtc2Nyb2xsICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVjYWxjdWxhdGUgdGh1bWIgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG1ldGhvZCByZWNhbGN1bGF0ZXMgdGhlIHRodW1iIHNpemUgYW5kIHBvc2l0aW9uLiBDYWxsIGl0IG9uY2UgYWZ0ZXIgaW5zZXJ0aW5nIHlvdXIgc2Nyb2xsYmFyIGludG8gdGhlIERPTSwgYW5kIHJlcGVhdGVkbHkgd2hpbGUgcmVzaXppbmcgdGhlIHNjcm9sbGJhciAod2hpY2ggdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiB0aGUgc2Nyb2xsYmFyJ3MgcGFyZW50IGlzIHJlc2l6ZWQgYnkgdXNlci5cbiAgICAgKlxuICAgICAqID4gVGhpcyBmdW5jdGlvbiBzaGlmdHMgYXJncyBpZiBmaXJzdCBhcmcgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5jcmVtZW50PXRoaXMuaW5jcmVtZW50XSAtIFJlc2V0cyB7QGxpbmsgRm9vQmFyI2luY3JlbWVudHxpbmNyZW1lbnR9IChzZWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmaW5iYXJTdHlsZXN9IFtiYXJTdHlsZXM9dGhpcy5iYXJTdHlsZXNdIC0gKFNlZSB0eXBlIGRlZmluaXRpb24gZm9yIGRldGFpbHMuKSBTY3JvbGxiYXIgc3R5bGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGJhciBlbGVtZW50LlxuICAgICAqXG4gICAgICogT25seSBzcGVjaWZ5IGEgYGJhclN0eWxlc2Agb2JqZWN0IHdoZW4geW91IG5lZWQgdG8gb3ZlcnJpZGUgc3R5bGVzaGVldCB2YWx1ZXMuIElmIHByb3ZpZGVkLCBiZWNvbWVzIHRoZSBuZXcgZGVmYXVsdCAoYHRoaXMuYmFyU3R5bGVzYCksIGZvciB1c2UgYXMgYSBkZWZhdWx0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICpcbiAgICAgKiBJdCBpcyBnZW5lcmFsbHkgdGhlIGNhc2UgdGhhdCB0aGUgc2Nyb2xsYmFyJ3MgbmV3IHBvc2l0aW9uIGlzIHN1ZmZpY2llbnRseSBkZXNjcmliZWQgYnkgdGhlIGN1cnJlbnQgc3R5bGVzLiBUaGVyZWZvcmUsIGl0IGlzIHVudXN1YWwgdG8gbmVlZCB0byBwcm92aWRlIGEgYGJhclN0eWxlc2Agb2JqZWN0IG9uIGV2ZXJ5IGNhbGwgdG8gYHJlc2l6ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBTZWxmIGZvciBjaGFpbmluZy5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24gKGluY3JlbWVudCwgYmFyU3R5bGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmJhcjtcblxuICAgICAgICBpZiAoIWJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vdCBpbiBET00geWV0IHNvIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gc2hpZnQgYXJncyBpZiBpZiAxc3QgYXJnIG9taXR0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiBpbmNyZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBiYXJTdHlsZXMgPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICBpbmNyZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5iYXJTdHlsZXMgPSBiYXJTdHlsZXMgfHwgdGhpcy5iYXJTdHlsZXM7XG5cbiAgICAgICAgLy8gQm91bmQgdG8gcmVhbCBjb250ZW50OiBDb250ZW50IHdhcyBnaXZlbiBidXQgbm8gb25jaGFuZ2UgaGFuZGxlci5cbiAgICAgICAgLy8gU2V0IHVwIC5vbmNoYW5nZSwgLmNvbnRhaW5lclNpemUsIGFuZCAuaW5jcmVtZW50LlxuICAgICAgICAvLyBOb3RlIHRoaXMgb25seSBtYWtlcyBzZW5zZSBpZiB5b3VyIGluZGV4IHVuaXQgaXMgcGl4ZWxzLlxuICAgICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2hhbmdlID0gdGhpcy5zY3JvbGxSZWFsQ29udGVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gdGhpcy5jb250ZW50W3RoaXMub2guc2l6ZV07XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXggPSB0aGlzLmNvbnRlbnRTaXplIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbmNoYW5nZSA9PT0gdGhpcy5zY3JvbGxSZWFsQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplID0gY29udGFpbmVyUmVjdFt0aGlzLm9oLnNpemVdO1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQgPSB0aGlzLmNvbnRhaW5lclNpemUgLyAodGhpcy5jb250ZW50U2l6ZSAtIHRoaXMuY29udGFpbmVyU2l6ZSkgKiAodGhpcy5fbWF4IC0gdGhpcy5fbWluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCA9IGluY3JlbWVudCB8fCB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMudGVzdFBhbmVsSXRlbSA9IHRoaXMudGVzdFBhbmVsSXRlbSB8fCB0aGlzLl9hZGRUZXN0UGFuZWxJdGVtKCk7XG4gICAgICAgIHRoaXMuX3NldFRodW1iU2l6ZSgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVsdGFQcm9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9ib3VuZC5vbndoZWVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG9ydGVuIHRyYWlsaW5nIGVuZCBvZiBzY3JvbGxiYXIgYnkgdGhpY2tuZXNzIG9mIHNvbWUgb3RoZXIgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIEluIHRoZSBcImNsYXNzaWNhbFwiIHNjZW5hcmlvIHdoZXJlIHZlcnRpY2FsIHNjcm9sbCBiYXIgaXMgb24gdGhlIHJpZ2h0IGFuZCBob3Jpem9udGFsIHNjcm9sbGJhciBpcyBvbiB0aGUgYm90dG9tLCB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcInRyYWlsaW5nIGVuZFwiIChib3R0b20gYW5kIHJpZ2h0IGVuZHMsIHJlc3BlY3RpdmVseSkgb2YgYXQgbGVhc3Qgb25lIG9mIHRoZW0gc28gdGhleSBkb24ndCBvdmVybGF5LlxuICAgICAqXG4gICAgICogVGhpcyBjb252ZW5pZW5jZSBmdW5jdGlvbiBpcyBhbiBwcm9ncmFtbWF0aWMgYWx0ZXJuYXRpdmUgdG8gaGFyZGNvZGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHlvdXIgc3R5bGVzaGVldDsgb3Igc2V0dGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHRoZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgc2hvcnRlbkJ5OiBmdW5jdGlvbiAob3RoZXJGaW5CYXIpIHsgcmV0dXJuIHRoaXMuc2hvcnRlbkVuZEJ5KCd0cmFpbGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gbGVhZGluZyBlbmQgb2Ygc2Nyb2xsYmFyIGJ5IHRoaWNrbmVzcyBvZiBzb21lIG90aGVyIHNjcm9sbGJhci5cbiAgICAgKiBAZGVzYyBTdXBwb3J0cyBub24tY2xhc3NpY2FsIHNjcm9sbGJhciBzY2VuYXJpb3Mgd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBtYXkgYmUgb24gbGVmdCBhbmQgaG9yaXpvbnRhbCBzY3JvbGxiYXIgbWF5IGJlIG9uIHRvcCwgaW4gd2hpY2ggY2FzZSB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcImxlYWRpbmcgZW5kXCIgcmF0aGVyIHRoYW4gdGhlIHRyYWlsaW5nIGVuZC5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc2hvcnRlbkJ5fHNob3J0ZW5CeX0uXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZm9yZXNob3J0ZW5CeTogZnVuY3Rpb24gKG90aGVyRmluQmFyKSB7IHJldHVybiB0aGlzLnNob3J0ZW5FbmRCeSgnbGVhZGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdlbmVyYWxpemVkIHNob3J0ZW5pbmcgZnVuY3Rpb24uXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI3Nob3J0ZW5CeXxzaG9ydGVuQnl9LlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aGljaEVuZCAtIGEgQ1NTIHN0eWxlIHByb3BlcnR5IG5hbWUgb3IgYW4gb3JpZW50YXRpb24gaGFzaCBuYW1lIHRoYXQgdHJhbnNsYXRlcyB0byBhIENTUyBzdHlsZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEBwYXJhbSB7RmluQmFyfG51bGx9IG90aGVyRmluQmFyIC0gT3RoZXIgc2Nyb2xsYmFyIHRvIGF2b2lkIGJ5IHNob3J0ZW5pbmcgdGhpcyBvbmU7IGBudWxsYCByZW1vdmVzIHRoZSB0cmFpbGluZyBzcGFjZVxuICAgICAqIEByZXR1cm5zIHtGaW5CYXJ9IEZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHNob3J0ZW5FbmRCeTogZnVuY3Rpb24gKHdoaWNoRW5kLCBvdGhlckZpbkJhcikge1xuICAgICAgICBpZiAoIW90aGVyRmluQmFyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV4U3R5bGVzO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyRmluQmFyIGluc3RhbmNlb2YgRmluQmFyICYmIG90aGVyRmluQmFyLm9yaWVudGF0aW9uICE9PSB0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG90aGVyRmluQmFyLmJhciksXG4gICAgICAgICAgICAgICAgb29oID0gb3JpZW50YXRpb25IYXNoZXNbb3RoZXJGaW5CYXIub3JpZW50YXRpb25dO1xuICAgICAgICAgICAgdGhpcy5fYXV4U3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9hdXhTdHlsZXNbd2hpY2hFbmRdID0gb3RoZXJTdHlsZVtvb2gudGhpY2tuZXNzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN1bW1hcnkgU2V0cyB0aGUgcHJvcG9ydGlvbmFsIHRodW1iIHNpemUgYW5kIGhpZGVzIHRodW1iIHdoZW4gMTAwJS5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgc2l6ZSBoYXMgYW4gYWJzb2x1dGUgbWluaW11bSBvZiAyMCAocGl4ZWxzKS5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRUaHVtYlNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9oID0gdGhpcy5vaCxcbiAgICAgICAgICAgIHRodW1iQ29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMudGh1bWIpLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5MZWFkaW5nID0gcGFyc2VJbnQodGh1bWJDb21wW29oLm1hcmdpbkxlYWRpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2luVHJhaWxpbmcgPSBwYXJzZUludCh0aHVtYkNvbXBbb2gubWFyZ2luVHJhaWxpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2lucyA9IHRodW1iTWFyZ2luTGVhZGluZyArIHRodW1iTWFyZ2luVHJhaWxpbmcsXG4gICAgICAgICAgICBiYXJTaXplID0gdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbb2guc2l6ZV0sXG4gICAgICAgICAgICB0aHVtYlNpemUgPSBNYXRoLm1heCgyMCwgYmFyU2l6ZSAqIHRoaXMuY29udGFpbmVyU2l6ZSAvIHRoaXMuY29udGVudFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclNpemUgPCB0aGlzLmNvbnRlbnRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5zdHlsZVtvaC5zaXplXSA9IHRodW1iU2l6ZSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgX3RodW1iTWF4XG4gICAgICAgICAqIEBzdW1tYXJ5IE1heGltdW0gb2Zmc2V0IG9mIHRodW1iJ3MgbGVhZGluZyBlZGdlLlxuICAgICAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBwaXhlbCBvZmZzZXQgd2l0aGluIHRoZSBzY3JvbGxiYXIgb2YgdGhlIHRodW1iIHdoZW4gaXQgaXMgYXQgaXRzIG1heGltdW0gcG9zaXRpb24gYXQgdGhlIGV4dHJlbWUgZW5kIG9mIGl0cyByYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB2YWx1ZSB0YWtlcyBpbnRvIGFjY291bnQgdGhlIG5ld2x5IGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgdGh1bWIgZWxlbWVudCAoaW5jbHVkaW5nIGl0cyBtYXJnaW5zKSBhbmQgdGhlIGlubmVyIHNpemUgb2YgdGhlIHNjcm9sbGJhciAodGhlIHRodW1iJ3MgY29udGFpbmluZyBlbGVtZW50LCBpbmNsdWRpbmcgX2l0c18gbWFyZ2lucykuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNjcm9sbGJhciBwYWRkaW5nIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgYW5kIGFzc3VtZWQgdG8gYmUgMCBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbmQgaXMgYXNzdW1lZCB0byBiZSBgMGA7IHVzZSB0aHVtYiBtYXJnaW5zIGluIHBsYWNlIG9mIHNjcm9sbGJhciBwYWRkaW5nLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGh1bWJNYXggPSBiYXJTaXplIC0gdGh1bWJTaXplIC0gdGh1bWJNYXJnaW5zO1xuXG4gICAgICAgIHRoaXMuX3RodW1iTWFyZ2luTGVhZGluZyA9IHRodW1iTWFyZ2luTGVhZGluZzsgLy8gdXNlZCBpbiBtb3VzZWRvd25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVtb3ZlIHRoZSBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgVW5ob29rcyBhbGwgdGhlIGV2ZW50IGhhbmRsZXJzIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBBbHdheXMgY2FsbCB0aGlzIG1ldGhvZCBwcmlvciB0byBkaXNwb3Npbmcgb2YgdGhlIHNjcm9sbGJhciBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5iYXIub25tb3VzZWRvd24gPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNlbW92ZScpO1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNldXAnKTtcblxuICAgICAgICAodGhpcy5jb250YWluZXIgfHwgdGhpcy5iYXIucGFyZW50RWxlbWVudCkuX3JlbW92ZUV2dCgnd2hlZWwnLCB0aGlzLl9ib3VuZC5vbndoZWVsKTtcblxuICAgICAgICB0aGlzLmJhci5vbmNsaWNrID1cbiAgICAgICAgICAgIHRoaXMudGh1bWIub25jbGljayA9XG4gICAgICAgICAgICAgICAgdGhpcy50aHVtYi5vbm1vdXNlb3ZlciA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGh1bWIudHJhbnNpdGlvbmVuZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuYmFyLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBfYWRkVGVzdFBhbmVsSXRlbVxuICAgICAqIEBzdW1tYXJ5IEFwcGVuZCBhIHRlc3QgcGFuZWwgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBJZiB0aGVyZSBpcyBhIHRlc3QgcGFuZWwgaW4gdGhlIERPTSAodHlwaWNhbGx5IGFuIGA8b2w+Li4uPC9vbD5gIGVsZW1lbnQpIHdpdGggY2xhc3MgbmFtZXMgb2YgYm90aCBgdGhpcy5jbGFzc1ByZWZpeGAgYW5kIGAndGVzdC1wYW5lbCdgIChvciwgYmFycmluZyB0aGF0LCBhbnkgZWxlbWVudCB3aXRoIGNsYXNzIG5hbWUgYCd0ZXN0LXBhbmVsJ2ApLCBhbiBgPGxpPi4uLjwvbGk+YCBlbGVtZW50IHdpbGwgYmUgY3JlYXRlZCBhbmQgYXBwZW5kZWQgdG8gaXQuIFRoaXMgbmV3IGVsZW1lbnQgd2lsbCBjb250YWluIGEgc3BhbiBmb3IgZWFjaCBjbGFzcyBuYW1lIGdpdmVuLlxuICAgICAqXG4gICAgICogWW91IHNob3VsZCBkZWZpbmUgYSBDU1Mgc2VsZWN0b3IgYC5saXN0ZW5pbmdgIGZvciB0aGVzZSBzcGFucy4gVGhpcyBjbGFzcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzcGFucyB0byBhbHRlciB0aGVpciBhcHBlYXJhbmNlIHdoZW4gYSBsaXN0ZW5lciBpcyBhZGRlZCB3aXRoIHRoYXQgY2xhc3MgbmFtZSAocHJlZml4ZWQgd2l0aCAnb24nKS5cbiAgICAgKlxuICAgICAqIChUaGlzIGlzIGFuIGludGVybmFsIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uY2UgYnkgdGhlIGNvbnN0cnVjdG9yIG9uIGV2ZXJ5IGluc3RhbnRpYXRpb24uKVxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fHVuZGVmaW5lZH0gVGhlIGFwcGVuZGVkIGA8bGk+Li4uPC9saT5gIGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gdGVzdCBwYW5lbC5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9hZGRUZXN0UGFuZWxJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXN0UGFuZWxJdGVtLFxuICAgICAgICAgICAgdGVzdFBhbmVsRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5fY2xhc3NQcmVmaXggKyAnLnRlc3QtcGFuZWwnKSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGVzdC1wYW5lbCcpO1xuXG4gICAgICAgIGlmICh0ZXN0UGFuZWxFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdGVzdFBhbmVsSXRlbVBhcnROYW1lcyA9IFsgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdpbmRleCcgXSxcbiAgICAgICAgICAgICAgICBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgICAgICAgICAgdGVzdFBhbmVsSXRlbVBhcnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0TmFtZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uaW5uZXJIVE1MICs9ICc8c3BhbiBjbGFzcz1cIicgKyBwYXJ0TmFtZSArICdcIj4nICsgcGFydE5hbWUucmVwbGFjZSgnbW91c2UnLCAnJykgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGVzdFBhbmVsRWxlbWVudC5hcHBlbmRDaGlsZChpdGVtKTtcblxuICAgICAgICAgICAgdGVzdFBhbmVsSXRlbSA9IHt9O1xuICAgICAgICAgICAgdGVzdFBhbmVsSXRlbVBhcnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0TmFtZSkge1xuICAgICAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1bcGFydE5hbWVdID0gaXRlbS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHBhcnROYW1lKVswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRlc3RQYW5lbEl0ZW07XG4gICAgfSxcblxuICAgIF9hZGRFdnQ6IGZ1bmN0aW9uIChldnROYW1lKSB7XG4gICAgICAgIHZhciBzcHkgPSB0aGlzLnRlc3RQYW5lbEl0ZW0gJiYgdGhpcy50ZXN0UGFuZWxJdGVtW2V2dE5hbWVdO1xuICAgICAgICBpZiAoc3B5KSB7IHNweS5jbGFzc0xpc3QuYWRkKCdsaXN0ZW5pbmcnKTsgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldnROYW1lLCB0aGlzLl9ib3VuZFsnb24nICsgZXZ0TmFtZV0pO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlRXZ0OiBmdW5jdGlvbiAoZXZ0TmFtZSkge1xuICAgICAgICB2YXIgc3B5ID0gdGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbVtldnROYW1lXTtcbiAgICAgICAgaWYgKHNweSkgeyBzcHkuY2xhc3NMaXN0LnJlbW92ZSgnbGlzdGVuaW5nJyk7IH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgdGhpcy5fYm91bmRbJ29uJyArIGV2dE5hbWVdKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG9iam4gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmIChvYmpuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2Jqbikge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gb2JqbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHZhbGlkUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJhbmdlKSxcbiAgICAgICAgdmFsaWQgPSAga2V5cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHR5cGVvZiByYW5nZS5taW4gPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICB0eXBlb2YgcmFuZ2UubWF4ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgcmFuZ2UubWluIDw9IHJhbmdlLm1heDtcblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgLnJhbmdlIG9iamVjdC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhbmRsZXJzVG9CZUJvdW5kXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQGRlc2MgVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IGFyZSBhbGwgRE9NIGV2ZW50IGhhbmRsZXJzIHRoYXQgYXJlIGJvdW5kIGJ5IHRoZSBGaW5CYXIgY29uc3RydWN0b3IgdG8gZWFjaCBuZXcgaW5zdGFuY2UuIEluIG90aGVyIHdvcmRzLCB0aGUgYHRoaXNgIHZhbHVlIG9mIHRoZXNlIGhhbmRsZXJzLCBvbmNlIGJvdW5kLCByZWZlciB0byB0aGUgRmluQmFyIG9iamVjdCBhbmQgbm90IHRvIHRoZSBldmVudCBlbWl0dGVyLiBcIkRvIG5vdCBjb25zdW1lIHJhdy5cIlxuICovXG52YXIgaGFuZGxlcnNUb0JlQm91bmQgPSB7XG4gICAgc2hvcnRTdG9wOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgb253aGVlbDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLmluZGV4ICs9IGV2dFt0aGlzLmRlbHRhUHJvcF07XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIG9uY2xpY2s6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGdvaW5nVXAgPSBldnRbdGhpcy5vaC5jb29yZGluYXRlXSA8IHRodW1iQm94W3RoaXMub2gubGVhZGluZ107XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhZ2luZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnBhZ2luZ1tnb2luZ1VwID8gJ3VwJyA6ICdkb3duJ10oTWF0aC5yb3VuZCh0aGlzLmluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ICs9IGdvaW5nVXAgPyAtdGhpcy5pbmNyZW1lbnQgOiB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2UgdGhlIHRodW1iIGdsb3cgbW9tZW50YXJpbHlcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QuYWRkKCdob3ZlcicpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudGh1bWIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIHdhaXRGb3JJdCgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHdhaXRGb3JJdCk7XG4gICAgICAgICAgICBzZWxmLl9ib3VuZC5vbm1vdXNldXAoZXZ0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRodW1iLmNsYXNzTGlzdC5hZGQoJ2hvdmVyJyk7XG4gICAgfSxcblxuICAgIG9ubW91c2VvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlZG93bjogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgdGh1bWJCb3ggPSB0aGlzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnBpbk9mZnNldCA9IGV2dFt0aGlzLm9oLmF4aXNdIC0gdGh1bWJCb3hbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMuYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMub2gubGVhZGluZ10gKyB0aGlzLl90aHVtYk1hcmdpbkxlYWRpbmc7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW1vdmU6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IE1hdGgubWluKHRoaXMuX3RodW1iTWF4LCBNYXRoLm1heCgwLCBldnRbdGhpcy5vaC5heGlzXSAtIHRoaXMucGluT2Zmc2V0KSk7XG4gICAgICAgIHZhciBpZHggPSBzY2FsZWQgLyB0aGlzLl90aHVtYk1heCAqICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICsgdGhpcy5fbWluO1xuXG4gICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgsIHNjYWxlZCk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZXVwOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG5cbiAgICAgICAgdmFyIHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGh1bWJCb3gubGVmdCA8PSBldnQuY2xpZW50WCAmJiBldnQuY2xpZW50WCA8PSB0aHVtYkJveC5yaWdodCAmJlxuICAgICAgICAgICAgdGh1bWJCb3gudG9wIDw9IGV2dC5jbGllbnRZICYmIGV2dC5jbGllbnRZIDw9IHRodW1iQm94LmJvdHRvbVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kLm9ubW91c2VvdmVyKGV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0KGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbnZhciBvcmllbnRhdGlvbkhhc2hlcyA9IHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgICBjb29yZGluYXRlOiAgICAgJ2NsaWVudFknLFxuICAgICAgICBheGlzOiAgICAgICAgICAgJ3BhZ2VZJyxcbiAgICAgICAgc2l6ZTogICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICBvdXRzaWRlOiAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgaW5zaWRlOiAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgbGVhZGluZzogICAgICAgICd0b3AnLFxuICAgICAgICB0cmFpbGluZzogICAgICAgJ2JvdHRvbScsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICAnbWFyZ2luVG9wJyxcbiAgICAgICAgbWFyZ2luVHJhaWxpbmc6ICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICB0aGlja25lc3M6ICAgICAgJ3dpZHRoJyxcbiAgICAgICAgZGVsdGE6ICAgICAgICAgICdkZWx0YVknXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGNvb3JkaW5hdGU6ICAgICAnY2xpZW50WCcsXG4gICAgICAgIGF4aXM6ICAgICAgICAgICAncGFnZVgnLFxuICAgICAgICBzaXplOiAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgb3V0c2lkZTogICAgICAgICdib3R0b20nLFxuICAgICAgICBpbnNpZGU6ICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGxlYWRpbmc6ICAgICAgICAnbGVmdCcsXG4gICAgICAgIHRyYWlsaW5nOiAgICAgICAncmlnaHQnLFxuICAgICAgICBtYXJnaW5MZWFkaW5nOiAgJ21hcmdpbkxlZnQnLFxuICAgICAgICBtYXJnaW5UcmFpbGluZzogJ21hcmdpblJpZ2h0JyxcbiAgICAgICAgdGhpY2tuZXNzOiAgICAgICdoZWlnaHQnLFxuICAgICAgICBkZWx0YTogICAgICAgICAgJ2RlbHRhWCdcbiAgICB9XG59O1xuXG52YXIgYXhpcyA9IHtcbiAgICB0b3A6ICAgICd2ZXJ0aWNhbCcsXG4gICAgYm90dG9tOiAndmVydGljYWwnLFxuICAgIGhlaWdodDogJ3ZlcnRpY2FsJyxcbiAgICBsZWZ0OiAgICdob3Jpem9udGFsJyxcbiAgICByaWdodDogICdob3Jpem9udGFsJyxcbiAgICB3aWR0aDogICdob3Jpem9udGFsJ1xufTtcblxudmFyIGNzc0ZpbkJhcnM7IC8vIGRlZmluaXRpb24gaW5zZXJ0ZWQgYnkgZ3VscGZpbGUgYmV0d2VlbiBmb2xsb3dpbmcgY29tbWVudHNcbi8qIGluamVjdDpjc3MgKi9cbmNzc0ZpbkJhcnMgPSAnZGl2LmZpbmJhci1ob3Jpem9udGFsLGRpdi5maW5iYXItdmVydGljYWx7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjNweH1kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1iLGRpdi5maW5iYXItdmVydGljYWw+LnRodW1ie3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2QzZDNkMzstd2Via2l0LWJveC1zaGFkb3c6MCAwIDFweCAjMDAwOy1tb3otYm94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym9yZGVyLXJhZGl1czo0cHg7bWFyZ2luOjJweDtvcGFjaXR5Oi40O3RyYW5zaXRpb246b3BhY2l0eSAuNXN9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYi5ob3ZlcixkaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYi5ob3ZlcntvcGFjaXR5OjE7dHJhbnNpdGlvbjpvcGFjaXR5IC41c31kaXYuZmluYmFyLXZlcnRpY2Fse3RvcDowO2JvdHRvbTowO3JpZ2h0OjA7d2lkdGg6MTFweH1kaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYnt0b3A6MDtyaWdodDowO3dpZHRoOjdweH1kaXYuZmluYmFyLWhvcml6b250YWx7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7aGVpZ2h0OjExcHh9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYntsZWZ0OjA7Ym90dG9tOjA7aGVpZ2h0OjdweH0nO1xuLyogZW5kaW5qZWN0ICovXG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93ICdmaW5iYXJzOiAnICsgbXNnO1xufVxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gRmluQmFyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBKU0RhdGFTb3VyY2U6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZScpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVNvcnRlcicpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScpLFxuICAgIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicpLFxuICAgIERhdGFTb3VyY2VHcm91cFZpZXc6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZUdyb3VwVmlldycpLFxuICAgIERhdGFTb3VyY2VBZ2dyZWdhdG9yOiByZXF1aXJlKCcuL2pzL0RhdGFTb3VyY2VBZ2dyZWdhdG9yJyksXG4gICAgRGF0YVNvdXJjZVRyZWV2aWV3OiByZXF1aXJlKCcuL2pzL0RhdGFTb3VyY2VUcmVldmlldycpLFxuICAgIERhdGFTb3VyY2VUcmVldmlld0ZpbHRlcjogcmVxdWlyZSgnLi9qcy9EYXRhU291cmNlVHJlZXZpZXdGaWx0ZXInKSxcbiAgICBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVRyZWV2aWV3U29ydGVyJyksXG4gICAgRGF0YU5vZGVHcm91cFNvcnRlcjogcmVxdWlyZSgnLi9qcy9EYXRhTm9kZUdyb3VwU29ydGVyJyksXG4gICAgdXRpbDoge1xuICAgICAgICBhZ2dyZWdhdGlvbnM6IHJlcXVpcmUoJy4vanMvdXRpbC9hZ2dyZWdhdGlvbnMnKSxcbiAgICAgICAgTWFwcHk6IHJlcXVpcmUoJy4vanMvdXRpbC9NYXBweScpLFxuICAgICAgICBzdGFibGVTb3J0OiByZXF1aXJlKCcuL2pzL3V0aWwvc3RhYmxlU29ydCcpLFxuICAgICAgICBoZWFkZXJpZnk6IHJlcXVpcmUoJy4vanMvdXRpbC9oZWFkZXJpZnknKVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIEFnZ3JlZ2F0b3JOb2RlQmFzZU1peGluID0ge1xuICAgIGdldFJvd0RhdGE6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXG4gICAgICAgIGlmIChpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBncm91cHNPZmZzZXQgPSBOdW1iZXIoYWdncmVnYXRvci5oYXNHcm91cHMoKSk7XG5cbiAgICAgICAgICAgIC8vIHJlZGltZW5zaW9uIHRoZSBkYXRhXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGRhdGEubGVuZ3RoID0gZ3JvdXBzT2Zmc2V0ICsgYWdncmVnYXRvci5hZ2dyZWdhdGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIHNvcnRlciA9IGFnZ3JlZ2F0b3Iuc29ydGVySW5zdGFuY2U7XG4gICAgICAgICAgICBzb3J0ZXIuaW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgYWdncmVnYXRvci5hZ2dyZWdhdGVzLmZvckVhY2goZnVuY3Rpb24oYWdncmVnYXRlLCBpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtncm91cHNPZmZzZXQgKyBpXSA9IGFnZ3JlZ2F0ZShzb3J0ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3JOb2RlQmFzZU1peGluO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWdncmVnYXRvck5vZGVCYXNlTWl4aW4gPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3JOb2RlQmFzZU1peGluJyk7XG52YXIgRGF0YU5vZGVHcm91cCA9IHJlcXVpcmUoJy4vRGF0YU5vZGVHcm91cCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YU5vZGVCYXNlXG4gKi9cbnZhciBBZ2dyZWdhdG9yTm9kZUdyb3VwID0gRGF0YU5vZGVHcm91cC5leHRlbmQoJ0FnZ3JlZ2F0b3JOb2RlR3JvdXAnLCB7XG4gICAgZ2V0Um93RGF0YTogZnVuY3Rpb24gKGRyaWxsRG93bikge1xuICAgICAgICBBZ2dyZWdhdG9yTm9kZUJhc2VNaXhpbi5nZXRSb3dEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZ2V0Um93RGF0YShkcmlsbERvd24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdG9yTm9kZUdyb3VwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWdncmVnYXRvck5vZGVCYXNlTWl4aW4gPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3JOb2RlQmFzZU1peGluJyk7XG52YXIgRGF0YU5vZGVMZWFmID0gcmVxdWlyZSgnLi9EYXRhTm9kZUxlYWYnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlQmFzZVxuICovXG52YXIgQWdncmVnYXRvck5vZGVMZWFmID0gRGF0YU5vZGVMZWFmLmV4dGVuZCgnQWdncmVnYXRvck5vZGVMZWFmJywgQWdncmVnYXRvck5vZGVCYXNlTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3JOb2RlTGVhZjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFnZ3JlZ2F0b3JOb2RlQmFzZU1peGluID0gcmVxdWlyZSgnLi9BZ2dyZWdhdG9yTm9kZUJhc2VNaXhpbicpO1xudmFyIERhdGFOb2RlVHJlZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVUcmVlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTm9kZUJhc2VcbiAqL1xudmFyIEFnZ3JlZ2F0b3JOb2RlVHJlZSA9IERhdGFOb2RlVHJlZS5leHRlbmQoJ0FnZ3JlZ2F0b3JOb2RlVHJlZScsIHtcbiAgICBnZXRSb3dEYXRhOiBmdW5jdGlvbiAoZHJpbGxEb3duKSB7XG4gICAgICAgIEFnZ3JlZ2F0b3JOb2RlQmFzZU1peGluLmdldFJvd0RhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5nZXRSb3dEYXRhKGRyaWxsRG93bik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3JOb2RlVHJlZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCdmaW4taHlwZXJncmlkLWRhdGEtc291cmNlLWJhc2UnKTtcblxuLy8gRm9sbG93aW5nIGFyZSBmb3IgbGVnYWN5IG1ldGhvZHNcblxuQmFzZS5wcm90b3R5cGUuZ2V0RmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgIH1cbn07XG5cbkJhc2UucHJvdG90eXBlLmdldEhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0SGVhZGVycygpO1xuICAgIH1cbn07XG5cbkJhc2UucHJvdG90eXBlLmdldENhbGN1bGF0b3JzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnJldmVhbFJvdygpO1xuICAgIH1cbn07XG5cbkJhc2UucHJvdG90eXBlLnNldEZpZWxkcyA9IGZ1bmN0aW9uKGFycikge1xuICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRGaWVsZHMuY2FsbCh0aGlzLmRhdGFTb3VyY2UsIGFycik7XG4gICAgfVxufTtcblxuQmFzZS5wcm90b3R5cGUuc2V0SGVhZGVycyA9IGZ1bmN0aW9uKGFycikge1xuICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzLmNhbGwodGhpcy5kYXRhU291cmNlLCBhcnIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFCYXNlTm9kZSNpbml0aWFsaXplfGluaXRpYWxpemUoKX0gbWV0aG9kIGZvciBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhTm9kZUJhc2UgPSBCYXNlLmV4dGVuZCgnRGF0YU5vZGVCYXNlJywge1xuXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIElOREVOVDogJyAgICcsIC8vIDMgc3BhY2VzXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlI1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UjXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMubGFiZWwgPSBrZXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UjXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFsnJ107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UjXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQGRlZmF1bHQgWycnXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IFtdOyAvLyBmb3JtZXJseSByb3dJbmRleFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlI1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQ2hpbGRyZW4gPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlI1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZSNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlI1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZiNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHBhcmFtIGRlcHRoXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgY29tcHV0ZURlcHRoU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KHRoaXMuZGVwdGggKyAxKS5qb2luKHRoaXMuSU5ERU5UKSArICcgICcgKyB0aGlzLmxhYmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7IC8vIFRPRE86IGZvcm1lcmx5IGdldEFsbFJvd0luZGV4ZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHBhcmFtIGRyaWxsRG93blxuICAgICAqL1xuICAgIGdldFJvd0RhdGE6IGZ1bmN0aW9uKGRyaWxsRG93bikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cbiAgICAgICAgaWYgKGluZGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gR3JvdXAgYW5kIFRyZWUgbm9kZXMgd2lsbCBoYXZlIG5vIGRhdGEgYmVzaWRlcyB0aGUgdHJlZSBjb2x1bW5cbiAgICAgICAgICAgIHRoaXMuZGF0YS5sZW5ndGggPSBkcmlsbERvd24uZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEBwYXJhbSBkcmlsbERvd25cbiAgICAgKi9cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGRyaWxsRG93bikge1xuICAgICAgICBkcmlsbERvd24uYWRkVmlldyh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZiNcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vZG8gbm90aGluZyBieSBkZWZhdWx0XG4gICAgfSxcblxuICAgIHNvcnRHcm91cHM6IGZ1bmN0aW9uKGdyb3VwU29ydGVyKSB7XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUJhc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXAgPSByZXF1aXJlKCcuL3V0aWwvTWFwcHknKTtcbnZhciBEYXRhTm9kZUJhc2UgPSByZXF1aXJlKCcuL0RhdGFOb2RlQmFzZScpO1xuXG4vKipcbiAqID4gU2VlIHtAbGluayBEYXRhTm9kZUdyb3VwI2luaXRpYWxpemV8aW5pdGlhbGl6ZSgpfSBtZXRob2QgZm9yIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlQmFzZVxuICovXG52YXIgRGF0YU5vZGVHcm91cCA9IERhdGFOb2RlQmFzZS5leHRlbmQoJ0RhdGFOb2RlR3JvdXAnLCB7XG5cbiAgICBleHRlbmRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAjXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcGFyYW0gZGVwdGhcbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnZhbHVlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC50b0FycmF5KGRlcHRoICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvbXB1dGVEZXB0aFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBBcnJheSh0aGlzLmRlcHRoICsgMSkuam9pbih0aGlzLklOREVOVCkgK1xuICAgICAgICAgICAgdGhpcy5kcmlsbERvd25DaGFyTWFwW3RoaXMuZXhwYW5kZWQgPyAnT1BFTicgOiAnQ0xPU0UnXSArICcgJyArXG4gICAgICAgICAgICB0aGlzLmxhYmVsO1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuY29tcHV0ZUluZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwI1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb21wdXRlSW5kZXg6IGZ1bmN0aW9uKCkgeyAvLyBUT0RPOiBmb3JtZXJseSBjb21wdXRlQWxsUm93SW5kZXhlc1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHJlc3VsdC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjaGlsZC5nZXRJbmRleCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwI1xuICAgICAqIEBwYXJhbSBkcmlsbERvd25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBhbmRdIC0gT25lIG9mOlxuICAgICAqICogYHRydWVgIC0gRXhwYW5kIGFsbCByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBjb2xsYXBzZWQuXG4gICAgICogKiBgZmFsc2VgIC0gQ29sbGFwc2UgYWxsIHJvd3MgdGhhdCBhcmUgY3VycmVudGx5IGV4cGFuZGVkLlxuICAgICAqICogYHVuZGVmaW5lZGAgKG9yIG9taXR0ZWQpIC0gRXhwYW5kIGFsbCBjdXJyZW50bHkgY29sbGFwc2VkIHJvd3M7IGNvbGxhcHNlIGFsbCBjdXJyZW50bHkgZXhwYW5kZWQgcm93cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhpcyBjYWxsIHJlc3VsdGVkIGluIGEgc3RhdGUgY2hhbmdlLlxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvblN0YXRlOiBmdW5jdGlvbihkcmlsbERvd24sIGV4cGFuZCkgeyAvKiBhZ2dyZWdhdG9yICovXG4gICAgICAgIGlmIChleHBhbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwYW5kID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmV4cGFuZGVkIF4gZXhwYW5kO1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZXhwYW5kO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5nZXRSb3dEYXRhKGRyaWxsRG93bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAjXG4gICAgICogQHBhcmFtIGRyaWxsRG93blxuICAgICAqL1xuICAgIGdldFJvd0RhdGE6IGZ1bmN0aW9uKGRyaWxsRG93bikge1xuICAgICAgICBEYXRhTm9kZUJhc2UucHJvdG90eXBlLmdldFJvd0RhdGEuY2FsbCh0aGlzLCBkcmlsbERvd24pOyAvLyBjYWxsIGJhc2UgY2xhc3MncyB2ZXJzaW9uXG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5nZXRSb3dEYXRhKGRyaWxsRG93bik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRvclxuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oZHJpbGxEb3duKSB7XG4gICAgICAgIGRyaWxsRG93bi52aWV3LnB1c2godGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5idWlsZFZpZXcoZHJpbGxEb3duKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSAxO1xuXG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKyBjaGlsZC5jb21wdXRlSGVpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpcy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBzb3J0V2l0aDogZnVuY3Rpb24oc29ydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICBzb3J0ZXIuc29ydEdyb3VwKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuc29ydFdpdGgoc29ydGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjbGVhckdyb3VwU29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5hbE9yZGVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3JpZ2luYWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0gPSB0aGlzLm9yaWdpbmFsT3JkZXJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5jbGVhckdyb3VwU29ydHMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN1bW1hcnkgQXJyYXkgbWl4aW4gdG8gYXBwZW5kIGFub3RoZXIgYXJyYXkgdG8gZW5kIG9mIGB0aGlzYCBvbmUuXG4gKiBAZGVzYyBBcHBlbmRzIGluIHBsYWNlLCB1bmxpa2UgYHRoaXMuY29uY2F0KClgIHdoaWNoIGNyZWF0ZXMgYSBuZXcgYXJyYXkuXG4gKiBVc2VzIGxlc3MgbWVtb3J5IHRoYW4gY29uY2F0LCBpbXBvcnRhbnQgd2hlbiBgYXBwZW5kaXhgIGlzIGh1Z2UuXG4gKiA+IENBVVRJT046IE11dGF0ZXMgYHRoaXNgIGFycmF5IVxuICogQHBhcmFtIHtBcnJheX0gYXBwZW5kaXhcbiAqIEByZXR1cm5zIHtBcnJheX0gUmVmZXJlbmNlIHRvIGB0aGlzYCAoZm9yIGNvbnZlbmllbmNlKVxuICovXG5mdW5jdGlvbiBhcHBlbmQoYXBwZW5kaXgpIHtcbiAgICB0aGlzLnNwbGljZS5iaW5kKHRoaXMsIHRoaXMubGVuZ3RoLCAwKS5hcHBseSh0aGlzLCBhcHBlbmRpeCk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVHcm91cDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbnZhciBzdGFibGVTb3J0ID0gcmVxdWlyZSgnLi91dGlsL3N0YWJsZVNvcnQnKS5zb3J0O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFOb2RlR3JvdXBTb3J0ZXIgPSBCYXNlLmV4dGVuZCgnRGF0YU5vZGVHcm91cFNvcnRlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwU29ydGVyI1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgdGhpcy5zb3J0cyA9IFtdO1xuXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICogIEBwYXJhbSBjb2x1bW5JbmRleFxuICAgICAqICBAcGFyYW0gZGlyZWN0aW9uXG4gICAgICovXG5cbiAgICBzb3J0T246IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zb3J0cy5wdXNoKHsgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LCBkaXJlY3Rpb246IGRpcmVjdGlvbiB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXBTb3J0ZXIjXG4gICAgICogQHBhcmFtIHtzb3J0ZXJGdW5jdGlvbn0gW3NvcnRlcl0gLSBJZiB1bmRlZmluZWQsIGRlbGV0ZXMgc29ydGVyLlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oc29ydGVyKSB7XG4gICAgICAgIGlmIChzb3J0ZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgc29ydGVySW50ZXJmYWNlaVxuICAgICAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc29ydGVyID0gc29ydGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc29ydGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXBTb3J0ZXIjXG4gICAgICovXG4gICAgYXBwbHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc29ydEdyb3Vwcyh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICovXG4gICAgY2xlYXJTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc29ydHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLmJ1aWxkVmlldygpO1xuICAgIH0sXG5cbiAgICBzb3J0R3JvdXA6IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmICghZ3JvdXAub3JpZ2luYWxPcmRlcikge1xuICAgICAgICAgICAgZ3JvdXAub3JpZ2luYWxPcmRlciA9IGdyb3VwLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGxpc3Qgb2Ygc29ydHMgZnJvbSBlaXRoZXIgQVBJIG9yIHVzZSBleGlzdGluZ1xuICAgICAgICB0aGlzLnNvcnRzID0gKHRoaXMuc29ydGVyICYmIHRoaXMuc29ydGVyLnByb3AoJ3NvcnRzJykpIHx8IHRoaXMuc29ydHM7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNvcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRHcm91cE9uRWFjaChncm91cCwgdGhpcy5zb3J0c1t0aGlzLnNvcnRzLmxlbmd0aCAtIGkgLSAxXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc29ydEdyb3VwT25FYWNoOiBmdW5jdGlvbihncm91cCwgc29ydFNwZWMpIHtcbiAgICAgICAgLy8gd2UgYWN0dWFsbHkgc29ydCB0aGUgY2hpbGRyZW4gaGVyZS4uLi5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZ3JvdXAuY2hpbGRyZW4uc2xpY2UoMCk7XG4gICAgICAgIHZhciBpbmRleFZlY3RvciA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4VmVjdG9yW2ldID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YWJsZVNvcnQoaW5kZXhWZWN0b3IsIGZ1bmN0aW9uKHJvd051bWJlcikge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bcm93TnVtYmVyXTtcbiAgICAgICAgICAgIGlmIChzb3J0U3BlYy5jb2x1bW5JbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5sYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5kYXRhW3NvcnRTcGVjLmNvbHVtbkluZGV4XTtcbiAgICAgICAgfSwgc29ydFNwZWMuZGlyZWN0aW9uKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdyb3VwLmNoaWxkcmVuW2ldID0gY2hpbGRyZW5baW5kZXhWZWN0b3JbaV1dO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuRGF0YU5vZGVHcm91cFNvcnRlci5wcm90b3R5cGUuYXBwbHlTb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIChjb25zb2xlLndhcm4gfHwgY29uc29sZS5sb2cpLmNhbGwoY29uc29sZSwgJ2FwcGx5U29ydHMgZGVwcmVjYXRlZDsgdXNlIGFwcGx5Jyk7XG4gICAgdGhpcy5hcHBseSgpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlR3JvdXBTb3J0ZXIucHJvdG90eXBlLCAndHlwZScsIHsgdmFsdWU6ICdzb3J0ZXInIH0pOyAvLyByZWFkLW9ubHkgcHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUdyb3VwU29ydGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YU5vZGVCYXNlID0gcmVxdWlyZSgnLi9EYXRhTm9kZUJhc2UnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlQmFzZVxuICovXG52YXIgRGF0YU5vZGVMZWFmID0gRGF0YU5vZGVCYXNlLmV4dGVuZCgnRGF0YU5vZGVMZWFmJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZiNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMuaGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZiNcbiAgICAgKiBAcGFyYW0gZGVwdGhcbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuZGF0YVswXSA9IHRoaXMuY29tcHV0ZURlcHRoU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHJldHVybnMge251bWVyW119XG4gICAgICovXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZiNcbiAgICAgKiBAcGFyYW0gZHJpbGxEb3duXG4gICAgICovXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihkcmlsbERvd24pIHtcbiAgICAgICAgZHJpbGxEb3duLmFkZFZpZXcodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBnZXRSb3dEYXRhOiBmdW5jdGlvbihkcmlsbERvd24pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXG4gICAgICAgIGlmIChpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBncm91cHNPZmZzZXQgPSBkcmlsbERvd24uaGFzR3JvdXBzKCkgPyAxIDogMCxcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgIGRhdGFMZW4gPSBkcmlsbERvd24uZ2V0Q29sdW1uQ291bnQoKSAtIGdyb3Vwc09mZnNldCxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBzb3J0ZXIgPSBkcmlsbERvd24uc29ydGVySW5zdGFuY2U7XG5cbiAgICAgICAgICAgIHNvcnRlci5pbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgICBmb3IgKGk7IGkgPCBkYXRhTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW2dyb3Vwc09mZnNldCArIGldID0gc29ydGVyLmdldFZhbHVlKGksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIHNvcnRXaXRoOiBmdW5jdGlvbihzb3J0ZXIpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgd2UgaGF2ZSBubyBjaGlsZHJlbiB0byBzb3J0XG4gICAgfSxcblxuICAgIGNsZWFyR3JvdXBTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBkbyBub3RoaW5nIHdlIGhhdmUgbm8gY2hpbGRyZW4gdG8gc29ydFxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVMZWFmO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YU5vZGVHcm91cCA9IHJlcXVpcmUoJy4vRGF0YU5vZGVHcm91cCcpO1xuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YU5vZGVHcm91cCNpbml0aWFsaXplfGluaXRpYWxpemUoKX0gbWV0aG9kIGZvciBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTm9kZUdyb3VwXG4gKi9cbnZhciBEYXRhTm9kZVRyZWUgPSBEYXRhTm9kZUdyb3VwLmV4dGVuZCgnRGF0YU5vZGVUcmVlJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4udmFsdWVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnRvQXJyYXkoMCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcGFyYW0gZHJpbGxEb3duXG4gICAgICovXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihkcmlsbERvd24pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5idWlsZFZpZXcoZHJpbGxEb3duKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSAxO1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICsgY2hpbGQuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKHRoaXMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFOb2RlVHJlZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbnZhciBoZWFkZXJpZnkgPSByZXF1aXJlKCcuL3V0aWwvaGVhZGVyaWZ5Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdFtdfSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZHNcbiAqL1xudmFyIERhdGFTb3VyY2UgPSBCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZScsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhLCBmaWVsZHMsIGNhbGN1bGF0b3JzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgYXJyYXkgb2YgZGF0YSByb3cgb2JqZWN0cy5cbiAgICAgICAgICogQGRlc2MgQWNjZXNzIHRocm91Z2gge0BsaW5rIERhdGFTb3VyY2UjZ2V0Um93fGdldFJvdygpfS5cbiAgICAgICAgICogQG5hbWUgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0W119XG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIGxpc3Qgb2YgZmllbGQgbmFtZXMuXG4gICAgICAgICAqIEBkZXNjIFRoZXNlIGFyZSBhbGwgdGhlIG1lbWJlcnMgb2YgdGhlIGRhdGEgcm93IG9iamVjdHMgdmlzaWJsZSB0byBIeXBlcmdyaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFjY2VzcyB0aHJvdWdoIHtAbGluayBEYXRhU291cmNlI2dldEZpZWxkc3xnZXRGaWVsZHMoKX0uXG4gICAgICAgICAqIEBuYW1lIGZpZWxkc1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHMgfHwgY29tcHV0ZUZpZWxkTmFtZXMoZGF0YVswXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBsaXN0IG9mIGNhbGN1bGF0b3JzIHRoYXQgaW1wbGVtZW50IGNvbXB1dGVkIGNvbHVtbnMuXG4gICAgICAgICAqIEBkZXNjIENvbmdydWVudCB0byB7QGxpbmsgRGF0YVNvdXJjZSNmaWVsZHN8ZmllbGRzfS5cbiAgICAgICAgICpcbiAgICAgICAgICogRWxlbWVudHMgcmVwcmVzZW50aW5nIHJlZ3VsYXIgKG5vbi1jb21wdXRlZCkgZmllbGRzIHNob3VsZCBjb250YWluIGB1bmRlZmluZWRgLlxuICAgICAgICAgKiBAbmFtZSBjYWxjdWxhdG9yc1xuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb25bXX1cbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGN1bGF0b3JzID0gY2FsY3VsYXRvcnMgfHwgQXJyYXkodGhpcy5maWVsZHMubGVuZ3RoKTtcblxuICAgICAgICAvLyBGb2xsb3dpbmcgY29kZSBhZGRlZCBwdXJlbHkgdG8gc2F0aXNmeSB0ZXN0cyBvZiBvdGhlciBtb2R1bGVzIHRoYXQgaGF2ZSB0aGlzIERhdGFTb3VyY2VPcmlnaW4gKGZvcm0gSHlwZXJncmlkKSBpbiB0aGVpciBwaXBlbGluZSBpbnN0ZWFkIG9mIHRoaXMgRGF0YVNvdXJjZS4gVGhlIGZvcm1lciBkZWZpbmVzIGBzY2hlbWFgIGJ1dCB0aGUgdGhpcyBvYmplY3QgZG9lcyBub3QsIHNvIHdlIGRlZmluZSBpdCBoZXJlLlxuICAgICAgICBkZWxldGUgdGhpcy5kYXRhU291cmNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjaGVtYScsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmZpZWxkcy5tYXAoZnVuY3Rpb24oZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0b3I6IHRoaXMuY2FsY3VsYXRvcnNbaW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpc051bGxPYmplY3Q6IGZhbHNlLFxuXG4gICAgZ2V0RGF0YUluZGV4OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5XTtcbiAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZpbmQsIHJlcGxhY2UsIG9yIHVwZGF0ZSBhIHJvdyBieSBpdCdzIHByaW1hcnkga2V5IGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGNvbHVtbk5hbWUgLSBPbmUgb2Y6XG4gICAgICogKiBfc3RyaW5nXyAtIENvbHVtbiBuYW1lLiBTZWUgYHZhbHVlYC5cbiAgICAgKiAqIF9vYmplY3RfIC0gSGFzaCBvZiAwIG9yIG1vcmUga2V5LXZhbHVlIHBhaXJzIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXXwqfSBbdmFsdWVdIC0gT25lIG9mOlxuICAgICAqIF9vbWl0dGVkXyAtIFdoZW4gYGNvbHVtbk5hbWVgIGlzIGEgaGFzaCBhbmQgeW91IHdhbnQgdG8gc2VhcmNoIGFsbCBpdHMga2V5cy5cbiAgICAgKiBfc3RyaW5nW11fIC0gV2hlbiBgY29sdW1uTmFtZWAgaXMgYSBoYXNoIGJ1dCB5b3Ugb25seSB3YW50IHRvIHNlYXJjaCBjZXJ0YWluIGtleXMuXG4gICAgICogX290aGVyd2lzZV8gLSBXaGVuIGBjb2x1bW5OYW1lYCBpcyBhIHN0cmluZy4gVmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBOb3RlIHRoYXQgYG51bGxgIGlzIGEgdmFsaWQgc2VhcmNoIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx8dW5kZWZpbmVkfSBbcmVwbGFjZW1lbnRdIC0gT25lIG9mOlxuICAgICAqICogX29taXR0ZWRfIC0gSWdub3JlZC5cbiAgICAgKiAqIF9vYmplY3RfIC0gUmVwbGFjZW1lbnQgZm9yIHRoZSBkYXRhIHJvdyBpZiBmb3VuZC5cbiAgICAgKiAqIGBudWxsYCAtIEZsYWcgdG8gZGVsZXRlIHRoZSBkYXRhIHJvdyBpZiBmb3VuZC4gVGhlIGZvdW5kIGRhdGEgcm93IGlzIG5vbmV0aGVsZXNzIHJldHVybmVkLlxuICAgICAqICogYHVuZGVmaW5lZGAgLSBGbGFnIHRvIHJldHVybiBpbmRleCBvZiBmb3VuZCByb3cgaW5zdGVhZCBvZiByb3cgb2JqZWN0IGl0c2VsZi5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bWJlcnx1bmRlZmluZWR9IE9uZSBvZjpcbiAgICAgKiAqIGB1bmRlZmluZWRgIC0gZGF0YSByb3cgbm90IGZvdW5kXG4gICAgICogKiBfb2JqZWN0XyAtIGZvdW5kIGRhdGEgcm93IG9iamVjdCAod2lsbCBoYXZlIGJlZW4gZGVsZXRlZCBpZiBgcmVwbGFjZW1lbnRgIHdhcyBgbnVsbGApXG4gICAgICogKiBfbnVtYmVyXyAtIGluZGV4IG9mIGZvdW5kIGRhdGEgcm93IG9iamVjdCBpbiBgdGhpcy5kYXRhYCAoaWYgYHJlcGxhY2VtZW50YCB3YXMgYHVuZGVmaW5lZGApXG4gICAgICogQHRvZG8gVXNlIGEgYmluYXJ5IHNlYXJjaCAocmF0aGVyIHRoYW4gYEFycmF5Li5maW5kYCkgd2hlbiBjb2x1bW4gaXMga25vd24gdG8gYmUgaW5kZXhlZCAoc29ydGVkKS5cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgKi9cbiAgICBmaW5kUm93OiBmdW5jdGlvbiBmaW5kUm93KGNvbHVtbk5hbWUsIHZhbHVlLCByZXBsYWNlbWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0LCBpbmRleCwga2V5cywgaGFzaCwgYXJncztcblxuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbk5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBoYXNoID0gY29sdW1uTmFtZTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gMjtcbiAgICAgICAgICAgICAgICBrZXlzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMucmVkdWNlKGZ1bmN0aW9uKHN1bSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgICAgICB9LCAwKSAhPT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGFsbCBrZXlzIGdpdmVuIGluIDJuZCBhcmcgdG8gYmUgZm91bmQgaW4gaGFzaCBnaXZlbiBpbiAxc3QgYXJnLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gMTtcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoaGFzaCk7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB2YWx1ZTsgLy8gcHJvbW90ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5OYW1lID0ga2V5c1swXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhhc2hbY29sdW1uTmFtZV07XG4gICAgICAgICAgICAgICAgaGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmRhdGEuZmluZChmdW5jdGlvbihyb3csIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ga2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZSA9IGtleXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dbY29sdW1uTmFtZV0gIT09IGhhc2hbY29sdW1uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGJhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZm91bmQhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgYXQgbGVhc3QgMiBhcmd1bWVudHMgd2hlbiBmaXJzdCBhcmd1bWVudCBub3Qgb2JqZWN0IGJ1dCBmb3VuZCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmRhdGEuZmluZChmdW5jdGlvbihyb3csIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmICghcm93KSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICAgICAgICAgIHJldHVybiByb3dbY29sdW1uTmFtZV0gPT09IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kUm93SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIG51bGwsIHVuZGVmaW5lZCwgb3Igb2JqZWN0IGJ1dCBmb3VuZCAnICsgdHlwZW9mIHJlcGxhY2VtZW50ICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3VuZFJvd0luZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvdyh5KTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dbdGhpcy5maWVsZHNbeF1dO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2V0Um93KHkpW3RoaXMuZmllbGRzW3hdXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHN1bW1hcnkgVGhlIGxpc3Qgb2YgaGVhZGVyIHN0cmluZ3MuXG4gICAgICAgICAgICAgKiBAZGVzYyBDb25ncnVlbnQgdG8ge0BsaW5rIERhdGFTb3VyY2UjZmllbGRzfGZpZWxkc30uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQWNjZXNzIHRocm91Z2gge0BsaW5rIERhdGFTb3VyY2UjZ2V0SGVhZGVyc3xnZXRIZWFkZXJzKCl9LlxuICAgICAgICAgICAgICogQG5hbWUgaGVhZGVyc1xuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHRoaXMuaGVhZGVycyB8fCB0aGlzLmdldERlZmF1bHRIZWFkZXJzKCkubWFwKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyaWZ5LnRyYW5zZm9ybShlYWNoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZHNcbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyc1xuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCEoaGVhZGVycyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgZXJyb3IoJ3NldEhlYWRlcnMnLCAncGFyYW0gIzEgYGhlYWRlcnNgIG5vdCBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqL1xuICAgIGdldEdyYW5kVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9ub3RoaW5nIGhlcmVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICogQHBhcmFtIGFycmF5T2ZVbmlmb3JtT2JqZWN0c1xuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGFycmF5T2ZVbmlmb3JtT2JqZWN0cykge1xuICAgICAgICB0aGlzLmRhdGEgPSBhcnJheU9mVW5pZm9ybU9iamVjdHM7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGVycm9yKG1ldGhvZE5hbWUsIG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTb3VyY2UuJyArIG1ldGhvZE5hbWUgKyAnOiAnICsgbWVzc2FnZSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpZWxkTmFtZXMob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0IHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS5zdWJzdHIoMCwgMikgIT09ICdfXyc7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbnZhciBEYXRhU291cmNlU29ydGVyID0gcmVxdWlyZSgnLi9EYXRhU291cmNlU29ydGVyJyk7XG52YXIgRGF0YU5vZGVUcmVlID0gcmVxdWlyZSgnLi9BZ2dyZWdhdG9yTm9kZVRyZWUnKTtcbnZhciBEYXRhTm9kZUdyb3VwID0gcmVxdWlyZSgnLi9BZ2dyZWdhdG9yTm9kZUdyb3VwJyk7XG52YXIgRGF0YU5vZGVMZWFmID0gcmVxdWlyZSgnLi9BZ2dyZWdhdG9yTm9kZUxlYWYnKTtcbnZhciBoZWFkZXJpZnkgPSByZXF1aXJlKCcuL3V0aWwvaGVhZGVyaWZ5Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0RhdGFTb3VyY2V9IGRhdGFTb3VyY2VcbiAqL1xudmFyIERhdGFTb3VyY2VBZ2dyZWdhdG9yID0gQmFzZS5leHRlbmQoJ0RhdGFTb3VyY2VBZ2dyZWdhdG9yJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGFTb3VyY2UpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7RGF0YVNvdXJjZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgICAgICogQHR5cGUge0RhdGFTb3VyY2V9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyZWVDb2x1bW5JbmRleCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgICAgICogQHR5cGUge0RhdGFOb2RlVHJlZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBEYXRhTm9kZVRyZWUoJ1RvdGFscycpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwQnlzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydGVySW5zdGFuY2UgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVzb3J0R3JvdXBzID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0QWdncmVnYXRlID0ge307XG5cbiAgICAgICAgdGhpcy5fc2NoZW1hID0gW107XG5cbiAgICAgICAgdGhpcy5zZXRBZ2dyZWdhdGVzKHt9KTtcblxuICAgIH0sXG5cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3TWFrZXNTZW5zZSgpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2hlbWE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNjaGVtYTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0IHNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld01ha2VzU2Vuc2UoKSl7XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0aW9ucywgZ3JvdXBzXG4gICAgICovXG4gICAgc2V0QWdncmVnYXRlR3JvdXBzOiBmdW5jdGlvbihhZ2dyZWdhdGlvbnMsIGdyb3Vwcykge1xuICAgICAgICB0aGlzLnNldEdyb3VwQnlzKGdyb3Vwcyk7XG4gICAgICAgIHRoaXMuc2V0QWdncmVnYXRlcyhhZ2dyZWdhdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0aW9uc1xuICAgICAqL1xuICAgIHNldEFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGFnZ3JlZ2F0aW9ucykge1xuICAgICAgICB0aGlzLmxhc3RBZ2dyZWdhdGUgPSBhZ2dyZWdhdGlvbnM7XG4gICAgICAgIHRoaXMuY2xlYXJBZ2dyZWdhdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fc2NoZW1hID0gW3tuYW1lOiAnVHJlZSd9XTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYWdncmVnYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEFnZ3JlZ2F0ZShrZXksIGFnZ3JlZ2F0aW9uc1trZXldKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEhlYWRlcnMoKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpLmpvaW4oJ18nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfSxcblxuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLnNjaGVtYS5tYXAoZnVuY3Rpb24oY29sdW1uU2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uU2NoZW1hLm5hbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEBwYXJhbSBsYWJlbFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICovXG4gICAgYWRkQWdncmVnYXRlOiBmdW5jdGlvbihsYWJlbCwgZnVuYykge1xuICAgICAgICBmdW5jLmhlYWRlciA9IGhlYWRlcmlmeS50cmFuc2Zvcm0obGFiZWwpO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMucHVzaChmdW5jKTtcbiAgICAgICAgdGhpcy5zY2hlbWEucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICAgIGhlYWRlcjogZnVuYy5oZWFkZXJcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXhBcnJheVxuICAgICAqL1xuICAgIHNldEdyb3VwQnlzOiBmdW5jdGlvbihjb2x1bW5JbmRleEFycmF5KSB7XG4gICAgICAgIHZhciBncm91cEJ5cyA9IHRoaXMuZ3JvdXBCeXM7XG4gICAgICAgIGdyb3VwQnlzLmxlbmd0aCA9IDA7XG4gICAgICAgIGNvbHVtbkluZGV4QXJyYXkuZm9yRWFjaChmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgZ3JvdXBCeXMucHVzaChjb2x1bW5JbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEFnZ3JlZ2F0ZXModGhpcy5sYXN0QWdncmVnYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIGFkZEdyb3VwQnk6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCeXMucHVzaChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdyb3VwQnlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0FnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtcyBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy5yb3dDbGljayAmJiAhb3B0aW9ucy5jb2x1bW5Tb3J0KXtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRHcm91cFRyZWUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICovXG4gICAgY2xlYXJHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyb3VwQnlzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKi9cbiAgICBjbGVhckFnZ3JlZ2F0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlcy5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICovXG4gICAgYnVpbGRHcm91cFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV2ZXJzZWRHcm91cEJ5cyA9IHRoaXMuZ3JvdXBCeXMuc2xpY2UoMCkucmV2ZXJzZSgpLFxuICAgICAgICAgICAgbGVhZkRlcHRoID0gdGhpcy5ncm91cEJ5cy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5kYXRhU291cmNlLFxuICAgICAgICAgICAgcm93Q291bnQgPSBzb3VyY2UuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLnRyZWUgPSBuZXcgRGF0YU5vZGVUcmVlKCdUb3RhbHMnKTtcblxuICAgICAgICAvLyBmaXJzdCBzb3J0IGRhdGFcbiAgICAgICAgaWYgKHRoaXMucHJlc29ydEdyb3Vwcykge1xuICAgICAgICAgICAgcmV2ZXJzZWRHcm91cEJ5cy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwQnkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5zb3J0T24oZ3JvdXBCeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0cmVlO1xuXG4gICAgICAgICAgICB0aGlzLmdyb3VwQnlzLmZvckVhY2goZnVuY3Rpb24oZywgYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBzb3VyY2UuZ2V0VmFsdWUoZywgciksXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnlEYXRhTm9kZSA9IChjID09PSBsZWFmRGVwdGgpID8gZmFjdG9yeURhdGFOb2RlTGVhZiA6IGZhY3RvcnlEYXRhTm9kZUdyb3VwO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmNoaWxkcmVuLmdldElmVW5kZWZpbmVkKGtleSwgZmFjdG9yeURhdGFOb2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwYXRoLmluZGV4LnB1c2gocik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvcnRlckluc3RhbmNlID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoc291cmNlKTtcbiAgICAgICAgdHJlZS50b0FycmF5KCk7XG4gICAgICAgIHRyZWUuZ2V0Um93RGF0YSh0aGlzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEBwYXJhbSBkYXRhTm9kZVxuICAgICAqL1xuICAgIGFkZFZpZXc6IGZ1bmN0aW9uKGRhdGFOb2RlKSB7XG4gICAgICAgIHRoaXMudmlldy5wdXNoKGRhdGFOb2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRyZWUuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnRyZWUuYnVpbGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSAmJiB0aGlzLmhhc0dyb3VwcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0RyaWxsRG93bjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudmlld01ha2VzU2Vuc2UoKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sdW1uSW5kZXggPT09IHRoaXMudHJlZUNvbHVtbkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3TWFrZXNTZW5zZSgpID8geSA6IHRoaXMuZGF0YVNvdXJjZS5nZXREYXRhSW5kZXgoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IHRoaXMudmlld1t5XTtcbiAgICAgICAgcmV0dXJuIHJvdyA/IHJvdy5nZXRWYWx1ZSh4KSA6IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5sZW5ndGg7IC8vaGVhZGVyIGNvbHVtblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBhbmRdIC0gT25lIG9mOlxuICAgICAqICogYHRydWVgIC0gRXhwYW5kIGFsbCByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBjb2xsYXBzZWQuXG4gICAgICogKiBgZmFsc2VgIC0gQ29sbGFwc2UgYWxsIHJvd3MgdGhhdCBhcmUgY3VycmVudGx5IGV4cGFuZGVkLlxuICAgICAqICogYHVuZGVmaW5lZGAgKG9yIG9taXR0ZWQpIC0gRXhwYW5kIGFsbCBjdXJyZW50bHkgY29sbGFwc2VkIHJvd3M7IGNvbGxhcHNlIGFsbCBjdXJyZW50bHkgZXhwYW5kZWQgcm93cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPUluZmluaXR5XSAtIE9uZSBvZjpcbiAgICAgKiAqIG51bWJlciA+IDAgLSBBcHBseSBvbmx5IGlmIHJvdyBkZXB0aCBpcyBhYm92ZSB0aGUgZ2l2ZW4gZGVwdGguXG4gICAgICogKiBudW1iZXIgPD0gMCAtIEFwcGx5IG9ubHkgaWYgcm93IGRlcHRoIGlzIGJlbG93IHRoZSBnaXZlbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IE9uZSBvZjpcbiAgICAgKiAqIGB1bmRlZmluZWRgIC0gcm93IHdhcyBub3QgZXhwYW5kYWJsZVxuICAgICAqICogYHRydWVgIC0gcm93IHdhcyBleHBhbmRhYmxlIF9hbmRfIHN0YXRlIGNoYW5nZWRcbiAgICAgKiAqIGBmYWxzZWAgLSByb3cgd2FzIGV4cGFuZGFibGUgX2J1dF8gc3RhdGUgZGlkIF9ub3RfIGNoYW5nZVxuICAgICAqL1xuICAgIGNsaWNrOiBmdW5jdGlvbih5LCBleHBhbmQsIGRlcHRoKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmNsaWNrLmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLnZpZXdbeV0sIGV4cGFuZGFibGUsIGNoYW5nZWQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyb3VwICYmIChcbiAgICAgICAgICAgICAgICBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgZGVwdGggPiAwICYmIGdyb3VwLmRlcHRoIDwgZGVwdGggfHxcbiAgICAgICAgICAgICAgICBkZXB0aCA8PSAwICYmIGdyb3VwLmRlcHRoID49IC1kZXB0aFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSBncm91cC50b2dnbGVFeHBhbnNpb25TdGF0ZSh0aGlzLCBleHBhbmQpO1xuICAgICAgICAgICAgaWYgKChleHBhbmRhYmxlID0gZ3JvdXAuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHBhbmRhYmxlID8gY2hhbmdlZCA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy50cmVlO1xuICAgICAgICByZXR1cm4gW3ZpZXcuZGF0YV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3coeSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9sbHVwcyA9IHRoaXMudmlld1t5XTtcblxuICAgICAgICByZXR1cm4gcm9sbHVwcyA/IHJvbGx1cHMgOiB0aGlzLnRyZWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0gYXJyYXlPZlVuaWZvcm1PYmplY3RzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oYXJyYXlPZlVuaWZvcm1PYmplY3RzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXREYXRhKGFycmF5T2ZVbmlmb3JtT2JqZWN0cyk7XG4gICAgICAgIHRoaXMuYXBwbHkoKTtcbiAgICB9LFxuXG4gICAgc29ydEdyb3VwczogZnVuY3Rpb24oZ3JvdXBTb3J0ZXIpIHtcbiAgICAgICAgdGhpcy50cmVlLmNsZWFyR3JvdXBTb3J0cygpO1xuICAgICAgICB0aGlzLnRyZWUuc29ydFdpdGgoZ3JvdXBTb3J0ZXIpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBmYWN0b3J5RGF0YU5vZGVMZWFmKGtleSkge1xuICAgIHJldHVybiBuZXcgRGF0YU5vZGVMZWFmKGtleSk7XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnlEYXRhTm9kZUdyb3VwKGtleSkge1xuICAgIHJldHVybiBuZXcgRGF0YU5vZGVHcm91cChrZXkpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlLCAndHlwZScsIHsgdmFsdWU6ICdhZ2dyZWdhdG9yJyB9KTsgLy8gcmVhZC1vbmx5IHByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUFnZ3JlZ2F0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBzdGFibGVTb3J0ID0gcmVxdWlyZSgnLi91dGlsL3N0YWJsZVNvcnQnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFNvcnRzIG9uIG5vbi10ZXJtaW5hbCB0cmVlIG5vZGUgcm93cyBvbmx5IChfaS5lLixfIGV4cGFuZGFibGUgcm93cyB3aXRoIGNoaWxkcmVuKS5cbiAqXG4gKiBPbmUgb2YgdGhlc2Ugc29ydGVycyBpcyBjcmVhdGVkIGJ5IHtAbGluayBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXJ9IGZvciBlYWNoIGdyb3VwaW5nIGxldmVsLCBzdGFydGluZyB3aXRoIHRoZSBtYXhpbXVtIGdyb3VwIGxldmVsIGRlcHRoLCBhbmQgdGhlbiBvbmUgZm9yIGVhY2ggZ3JvdXAgbGV2ZWwgdGhyb3VnaCB0aGUgdG9wIGxldmVsICgwKSBzb3J0IGRlcHRoLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZGF0YVNvdXJjZVxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFTb3VyY2VEZXB0aFNvcnRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZURlcHRoU29ydGVyJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGFTb3VyY2UsIHRyZWVWaWV3KSB7XG4gICAgICAgIHRoaXMuaWRDb2x1bW5OYW1lID0gdHJlZVZpZXcuaWRDb2x1bW4ubmFtZTtcbiAgICAgICAgdGhpcy5wYXJlbnRJZENvbHVtbk5hbWUgPSB0cmVlVmlldy5wYXJlbnRJZENvbHVtbi5uYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBTdGFibGUtc29ydHMgbm9uLXRlcm1pbmFsIHRyZWUgbm9kZSByb3dzLiBUZXJtaW5hbCAobGVhZikgcm93cyByZW1haW4gc3RhYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cExldmVsIC0gSWYgZ3JlYXRlciB0aGFuIHJvdyBkZXB0aCwgc29ydHMgb24gYW4gX2VkZ2UgdmFsdWVfIHZhbHVlLCB3aGljaCBpcyBhIHZhbHVlIGxleGljYWxseSBpbmZlcmlvciB0byAoYXNjZW5kaW5nIHNvcnQpIG9yIHN1cGVyaW9yIHRvIChkZXNjZW5kaW5nIHNvcnQpIHRoZSByb3cgdmFsdWUuXG4gICAgICogT3RoZXJ3aXNlIHNvcnRzIG9uIHZhbHVlIG9mIGFuY2VzdG9yIG9mIHRoaXMgZGVwdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpcmVjdGlvbj0xXSAtIE9uZSBvZjpcbiAgICAgKiBgMWAgLSBTb3J0IGFzY2VuZGluZy5cbiAgICAgKiBgLTFgIC0gU29ydCBkZXNjZW5kaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sdW1uSW5kZXhdIC0gU29ydHMgb24gdGhlIHZhbHVlcyBpbiB0aGlzIGNvbHVtbi4gT3RoZXJ3aXNlIHNvcnRzIG9uIHRoZSByb3cgaW5kZXguXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VEZXB0aFNvcnRlciNcbiAgICAgKi9cbiAgICBzb3J0T246IGZ1bmN0aW9uKGdyb3VwTGV2ZWwsIGRpcmVjdGlvbiwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW5kZXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0VmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZEluZGV4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBpbiBnZXRWYWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZSA9IGRpcmVjdGlvbiA9PT0gLTEgPyArSW5maW5pdHkgOiAtSW5maW5pdHk7IC8vIGZvciBudW1iZXJzLCBkYXRlIG9iamVjdHNcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSBnZXRSb3dJbmRleC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSBnZXRDb2x1bW5WYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5OYW1lID0gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpW2NvbHVtbkluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRvciA9IHRoaXMuZGF0YVNvdXJjZS5nZXRQcm9wZXJ0eSgnY2FsY3VsYXRvcnMnKVtjb2x1bW5JbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdldFZhbHVlKDApID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZSA9IGRpcmVjdGlvbiA9PT0gLTEgPyAnXFx1ZmZmZicgOiAnJzsgLy8gZm9yIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwdGggPSBncm91cExldmVsO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVTb3J0LnNvcnQodGhpcy5pbmRleCwgZ2V0VmFsdWUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFJvd0luZGV4KHJvd0lkeCkge1xuICAgIHZhciBwYXJlbnRJRCxcbiAgICAgICAgZGF0YVJvdyA9IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3cocm93SWR4KTtcblxuICAgIGlmIChkYXRhUm93Ll9fREVQVEggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2U7XG4gICAgfVxuXG4gICAgcm93SWR4ID0gdGhpcy5nZXREYXRhSW5kZXgocm93SWR4KTtcblxuICAgIC8vIGJ1YmJsZSB1cCB0byBncm91cCBsYWJlbCBvZiByZXF1ZXN0ZWQgZGVwdGggd2hpbGUgZWl0aGVyLi4uXG4gICAgd2hpbGUgKFxuICAgICAgICAvLyAuLi50aGlzIGlzIGEgbGVhZiByb3dcbiAgICAgICAgZGF0YVJvdy5fX0VYUEFOREVEID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgLy8gLi4ub3I6IHN0aWxsIGRlZXBlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZGVwdGhcbiAgICAgICAgZGF0YVJvdy5fX0RFUFRIID4gdGhpcy5kZXB0aFxuICAgICkge1xuICAgICAgICBwYXJlbnRJRCA9IGRhdGFSb3dbdGhpcy5wYXJlbnRJZENvbHVtbk5hbWVdO1xuICAgICAgICBpZiAocGFyZW50SUQgPT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICBkYXRhUm93ID0gdGhpcy5maW5kUm93KHRoaXMuaWRDb2x1bW5OYW1lLCBwYXJlbnRJRCk7XG4gICAgICAgIHJvd0lkeCA9IHRoaXMuZ2V0UHJvcGVydHkoJ2ZvdW5kUm93SW5kZXgnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93SWR4O1xufVxuXG5mdW5jdGlvbiBnZXRDb2x1bW5WYWx1ZShyb3dJZHgpIHtcbiAgICB2YXIgcGFyZW50SUQsXG4gICAgICAgIGRhdGFSb3cgPSB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHJvd0lkeCk7XG5cbiAgICBpZiAoZGF0YVJvdy5fX0RFUFRIIDwgdGhpcy5kZXB0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGdlO1xuICAgIH1cblxuICAgIC8vIGJ1YmJsZSB1cCB0byBncm91cCBsYWJlbCBvZiByZXF1ZXN0ZWQgZGVwdGggd2hpbGUgZWl0aGVyLi4uXG4gICAgd2hpbGUgKFxuICAgICAgICAvLyAuLi50aGlzIGlzIGEgbGVhZiByb3dcbiAgICAgICAgZGF0YVJvdy5fX0VYUEFOREVEID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgLy8gLi4ub3I6IHN0aWxsIGRlZXBlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZGVwdGhcbiAgICAgICAgZGF0YVJvdy5fX0RFUFRIID4gdGhpcy5kZXB0aFxuICAgICkge1xuICAgICAgICBwYXJlbnRJRCA9IGRhdGFSb3dbdGhpcy5wYXJlbnRJZENvbHVtbk5hbWVdO1xuICAgICAgICBpZiAocGFyZW50SUQgPT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICBkYXRhUm93ID0gdGhpcy5maW5kUm93KHRoaXMuaWRDb2x1bW5OYW1lLCBwYXJlbnRJRCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIERhdGFTb3VyY2VJbmRleGVkLnZhbE9yRnVuYy5jYWxsKGRhdGFSb3csIHRoaXMuY29sdW1uTmFtZSwgdGhpcy5jYWxjdWxhdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlRGVwdGhTb3J0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIGZpbHRlckludGVyZmFjZVxuICovXG5cbi8qKlxuICogQG5hbWUgZmlsdGVySW50ZXJmYWNlI3Rlc3RcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhUm93IC0gT2JqZWN0IHJlcHJlc2VudGluZyBhIHJvdyBpbiB0aGUgZ3JpZCBjb250YWluaW5nIGFsbCB0aGUgZmllbGRzIGxpc3RlZCBpbiB7QGxpbmsgRGF0YVNvdXJjZSNmaWVsZHN8ZmllbGRzfS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogKiBgdHJ1ZWAgLSBpbmNsdWRlIGluIGdyaWQgKHJvdyBwYXNzZXMgdGhyb3VnaCBmaWx0ZXIpXG4gKiAqIGBmYWxzZWAgLSBleGNsdWRlIGZyb20gZ3JpZCAocm93IGlzIGJsb2NrZWQgYnkgZmlsdGVyKVxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicsIHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIjXG4gICAgICogQHBhcmFtIHtmaWx0ZXJGdW5jdGlvbn0gW2ZpbHRlcl0gLSBJZiB1bmRlZmluZWQsIGRlbGV0ZXMgZmlsdGVyLlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgZmlsdGVySW50ZXJmYWNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuICAgIH0sXG5cbiAgICBzb3J0R3JvdXBzOiBmdW5jdGlvbihzb3J0ZXIpe1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc29ydEdyb3Vwcyhzb3J0ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR2xvYmFsRmlsdGVyI1xuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyICYmIHRoaXMuZmlsdGVyLnRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRJbmRleCh0aGlzLmZpbHRlclRlc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGltcGxlbWVudHMgZmlsdGVyUHJlZGljYXRlXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIjXG4gICAgICovXG4gICAgZmlsdGVyVGVzdDogZnVuY3Rpb24ociwgcm93T2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlci50ZXN0KHJvd09iamVjdCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyICYmIHRoaXMuZmlsdGVyLnRlc3QgPyB0aGlzLmluZGV4Lmxlbmd0aCA6IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5wcm90b3R5cGUsICd0eXBlJywgeyB2YWx1ZTogJ2ZpbHRlcicgfSk7IC8vIHJlYWQtb25seSBwcm9wZXJ0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpO1xudmFyIERhdGFOb2RlVHJlZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVUcmVlJyk7XG52YXIgRGF0YU5vZGVHcm91cCA9IHJlcXVpcmUoJy4vRGF0YU5vZGVHcm91cCcpO1xudmFyIERhdGFOb2RlTGVhZiA9IHJlcXVpcmUoJy4vRGF0YU5vZGVMZWFmJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0RhdGFTb3VyY2V9IGRhdGFTb3VyY2VcbiAqL1xudmFyIERhdGFTb3VyY2VHcm91cFZpZXcgPSBCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZUdyb3VwVmlldycsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAgICAgKiBAdHlwZSB7RGF0YVNvdXJjZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAgICAgKiBAdHlwZSB7RGF0YU5vZGVUcmVlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmVlID0gbmV3IERhdGFOb2RlVHJlZSgnR3JvdXAnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBCeXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlldyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJlZUNvbHVtbkluZGV4ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRlckluc3RhbmNlID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVzb3J0R3JvdXBzID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9zY2hlbWEgPSBbXTtcblxuICAgIH0sXG5cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3TWFrZXNTZW5zZSgpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2hlbWE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNjaGVtYTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0IHNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld01ha2VzU2Vuc2UoKSl7XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRGaWVsZHMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRIZWFkZXJzKCkubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnKS5qb2luKCdfJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH0sXG5cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0SGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5zY2hlbWEubWFwKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtblNjaGVtYS5uYW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICogQHBhcmFtIGNvbHVtbkluZGV4QXJyYXlcbiAgICAgKi9cbiAgICBzZXRHcm91cEJ5czogZnVuY3Rpb24oY29sdW1uSW5kZXhBcnJheSkge1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLmdyb3VwQnlzO1xuICAgICAgICBncm91cEJ5cy5sZW5ndGggPSAwO1xuICAgICAgICBjb2x1bW5JbmRleEFycmF5LmZvckVhY2goZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIGdyb3VwQnlzLnB1c2goY29sdW1uSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhcmVudFNjaGVtYSA9IHRoaXMuZGF0YVNvdXJjZS5zY2hlbWEuc2xpY2UoMCk7XG4gICAgICAgIHBhcmVudFNjaGVtYS51bnNoaWZ0KHtuYW1lOiAnVHJlZSd9KTtcbiAgICAgICAgdGhpcy5fc2NoZW1hID0gcGFyZW50U2NoZW1hO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBhZGRHcm91cEJ5OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLmdyb3VwQnlzLnB1c2goaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdyb3VwQnlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICogQHBhcmFtcyBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy5yb3dDbGljayAmJiAhb3B0aW9ucy5jb2x1bW5Tb3J0KXtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRHcm91cFRyZWUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKi9cbiAgICBjbGVhckdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCeXMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICovXG4gICAgYnVpbGRHcm91cFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV2ZXJzZWRHcm91cEJ5cyA9IHRoaXMuZ3JvdXBCeXMuc2xpY2UoMCkucmV2ZXJzZSgpLFxuICAgICAgICAgICAgbGVhZkRlcHRoID0gdGhpcy5ncm91cEJ5cy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5kYXRhU291cmNlLFxuICAgICAgICAgICAgcm93Q291bnQgPSBzb3VyY2UuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLnRyZWUgPSBuZXcgRGF0YU5vZGVUcmVlKCdHcm91cCcpO1xuXG4gICAgICAgIC8vIGZpcnN0IHNvcnQgZGF0YVxuICAgICAgICBpZiAodGhpcy5wcmVzb3J0R3JvdXBzKSB7XG4gICAgICAgICAgICByZXZlcnNlZEdyb3VwQnlzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXBCeSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBEYXRhU291cmNlU29ydGVyKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgc291cmNlLnNvcnRPbihncm91cEJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRyZWU7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBCeXMuZm9yRWFjaChmdW5jdGlvbihnLCBjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHNvdXJjZS5nZXRWYWx1ZShnLCByKSxcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeURhdGFOb2RlID0gKGMgPT09IGxlYWZEZXB0aCkgPyBmYWN0b3J5RGF0YU5vZGVMZWFmIDogZmFjdG9yeURhdGFOb2RlR3JvdXA7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguY2hpbGRyZW4uZ2V0SWZVbmRlZmluZWQoa2V5LCBmYWN0b3J5RGF0YU5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhdGguaW5kZXgucHVzaChyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc29ydGVySW5zdGFuY2UgPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihzb3VyY2UpO1xuICAgICAgICB0cmVlLnRvQXJyYXkoKTtcbiAgICAgICAgdHJlZS5nZXRSb3dEYXRhKHRoaXMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgICAgICAvL3RoaXMuZHVtcCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0gZGF0YU5vZGVcbiAgICAgKi9cbiAgICBhZGRWaWV3OiBmdW5jdGlvbihkYXRhTm9kZSkge1xuICAgICAgICB0aGlzLnZpZXcucHVzaChkYXRhTm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRyZWUuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnRyZWUuYnVpbGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIHZpZXdNYWtlc1NlbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzR3JvdXBzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XG4gICAgICovXG4gICAgaXNEcmlsbERvd246IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnZpZXdNYWtlc1NlbnNlKCk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbHVtbkluZGV4ID09PSB0aGlzLnRyZWVDb2x1bW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld01ha2VzU2Vuc2UoKSA/IHkgOiB0aGlzLmRhdGFTb3VyY2UuZ2V0RGF0YUluZGV4KHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IHRoaXMudmlld1t5XTtcbiAgICAgICAgcmV0dXJuIHJvdyA/IHJvdy5nZXRWYWx1ZSh4KSA6IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkZXJzKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5sZW5ndGg7IC8vaGVhZGVyIGNvbHVtblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4cGFuZF0gLSBPbmUgb2Y6XG4gICAgICogKiBgdHJ1ZWAgLSBFeHBhbmQgYWxsIHJvd3MgdGhhdCBhcmUgY3VycmVudGx5IGNvbGxhcHNlZC5cbiAgICAgKiAqIGBmYWxzZWAgLSBDb2xsYXBzZSBhbGwgcm93cyB0aGF0IGFyZSBjdXJyZW50bHkgZXhwYW5kZWQuXG4gICAgICogKiBgdW5kZWZpbmVkYCAob3Igb21pdHRlZCkgLSBFeHBhbmQgYWxsIGN1cnJlbnRseSBjb2xsYXBzZWQgcm93czsgY29sbGFwc2UgYWxsIGN1cnJlbnRseSBleHBhbmRlZCByb3dzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9SW5maW5pdHldIC0gT25lIG9mOlxuICAgICAqICogbnVtYmVyID4gMCAtIEFwcGx5IG9ubHkgaWYgcm93IGRlcHRoIGlzIGFib3ZlIHRoZSBnaXZlbiBkZXB0aC5cbiAgICAgKiAqIG51bWJlciA8PSAwIC0gQXBwbHkgb25seSBpZiByb3cgZGVwdGggaXMgYmVsb3cgdGhlIGdpdmVuIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gT25lIG9mOlxuICAgICAqICogYHVuZGVmaW5lZGAgLSByb3cgd2FzIG5vdCBleHBhbmRhYmxlXG4gICAgICogKiBgdHJ1ZWAgLSByb3cgd2FzIGV4cGFuZGFibGUgX2FuZF8gc3RhdGUgY2hhbmdlZFxuICAgICAqICogYGZhbHNlYCAtIHJvdyB3YXMgZXhwYW5kYWJsZSBfYnV0XyBzdGF0ZSBkaWQgX25vdF8gY2hhbmdlXG4gICAgICovXG4gICAgY2xpY2s6IGZ1bmN0aW9uKHksIGV4cGFuZCwgZGVwdGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuY2xpY2suYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMudmlld1t5XSwgZXhwYW5kYWJsZSwgY2hhbmdlZDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JvdXAgJiYgKFxuICAgICAgICAgICAgICAgIGRlcHRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBkZXB0aCA+IDAgJiYgZ3JvdXAuZGVwdGggPCBkZXB0aCB8fFxuICAgICAgICAgICAgICAgIGRlcHRoIDw9IDAgJiYgZ3JvdXAuZGVwdGggPj0gLWRlcHRoXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IGdyb3VwLnRvZ2dsZUV4cGFuc2lvblN0YXRlKHRoaXMsIGV4cGFuZCk7XG4gICAgICAgICAgICBpZiAoKGV4cGFuZGFibGUgPSBncm91cC5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cGFuZGFibGUgPyBjaGFuZ2VkIDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0gaGVhZGVyc1xuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldEhlYWRlcnMoaGVhZGVycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEBwYXJhbSBmaWVsZHNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3coeSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy52aWV3W3ldO1xuXG4gICAgICAgIHJldHVybiBncm91cHMgPyBncm91cHMgOiB0aGlzLnRyZWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEBwYXJhbSBhcnJheU9mVW5pZm9ybU9iamVjdHNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldERhdGEoYXJyYXlPZlVuaWZvcm1PYmplY3RzKTtcbiAgICAgICAgdGhpcy5hcHBseSgpO1xuICAgIH0sXG5cbiAgICBzb3J0R3JvdXBzOiBmdW5jdGlvbihncm91cFNvcnRlcikge1xuICAgICAgICB0aGlzLnRyZWUuY2xlYXJHcm91cFNvcnRzKCk7XG4gICAgICAgIHRoaXMudHJlZS5zb3J0V2l0aChncm91cFNvcnRlcik7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGZhY3RvcnlEYXRhTm9kZUxlYWYoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhTm9kZUxlYWYoa2V5KTtcbn1cblxuZnVuY3Rpb24gZmFjdG9yeURhdGFOb2RlR3JvdXAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhTm9kZUdyb3VwKGtleSk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhU291cmNlR3JvdXBWaWV3LnByb3RvdHlwZSwgJ3R5cGUnLCB7IHZhbHVlOiAnZ3JvdXB2aWV3ZXInIH0pOyAvLyByZWFkLW9ubHkgcHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlR3JvdXBWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xuXG4vKipcbiAqIEBwYXJhbSBkYXRhU291cmNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERhdGFTb3VyY2VJbmRleGVkID0gQmFzZS5leHRlbmQoJ0RhdGFTb3VyY2VJbmRleGVkJywge1xuXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZCNcbiAgICAgKiBAcGFyYW0gZGF0YVNvdXJjZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQjXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0cmFuc3Bvc2VZOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4Lmxlbmd0aCA/IHRoaXMuaW5kZXhbeV0gOiB5O1xuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXREYXRhSW5kZXgodGhpcy50cmFuc3Bvc2VZKHkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkI1xuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3codGhpcy50cmFuc3Bvc2VZKHkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkI1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7KnxNaXhlZH1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFZhbHVlKHgsIHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZCNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0VmFsdWUoeCwgdGhpcy50cmFuc3Bvc2VZKHkpLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZCNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfCp9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5sZW5ndGggfHwgdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZCNcbiAgICAgKi9cbiAgICBjbGVhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbmRleC5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQjXG4gICAgICogQHBhcmFtIHtmaWx0ZXJQcmVkaWNhdGV9IHByZWRpY2F0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBidWlsZEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCksXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUuY2FsbCh0aGlzLCByLCB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHIpKSkge1xuICAgICAgICAgICAgICAgIGluZGV4LnB1c2gocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufSk7XG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGZpbHRlclByZWRpY2F0ZVxuICogQHN1bW1hcnkgQXBwbGllcyBmaWx0ZXIgdG8gZ2l2ZW4gcm93LlxuICogQHRoaXMge0RhdGFTb3VyY2VHbG9iYWxGaWx0ZXJ9XG4gKiBAcGFyYW0ge251Ym1lcn0gciAtIFJvdyBpbmRleCBvZiByb3cgZGF0YSB3aXRoaW4gcm93cyBhcnJheSBgdGhpcy5kYXRhU291cmNlLmRhdGFbXWAuXG4gKiBAcGFyYW0ge29iamVjdH0gcm93T2JqZWN0IC0gUm93IGRhdGE7IGVsZW1lbnQgb2YgYHRoaXMuZGF0YVNvdXJjZS5kYXRhW11gLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJvdyBxdWFsaWZpZXMgKHBhc3NlcyB0aHJvdWdoIGZpbHRlcikuXG4gKi9cblxuLyoqXG4gKiBVc2VkIGJ5IHRoZSBzb3J0ZXJzIChgRGF0YVNvdXJjZVNvcnRlcmAgYW5kIGBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXJgKS5cbiAqIEB0aGlzIHtkYXRhUm93T2JqZWN0fVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbHVtbk5hbWVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5EYXRhU291cmNlSW5kZXhlZC52YWxPckZ1bmMgPSBmdW5jdGlvbihjb2x1bW5OYW1lLCBjYWxjdWxhdG9yKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAodGhpcykge1xuICAgICAgICByZXN1bHQgPSB0aGlzW2NvbHVtbk5hbWVdO1xuICAgICAgICBjYWxjdWxhdG9yID0gKHR5cGVvZiByZXN1bHQpWzBdID09PSAnZicgJiYgcmVzdWx0IHx8IGNhbGN1bGF0b3I7XG4gICAgICAgIGlmIChjYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxjdWxhdG9yLmNhbGwodGhpcywgY29sdW1uTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUluZGV4ZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBzdGFibGVTb3J0ID0gcmVxdWlyZSgnLi91dGlsL3N0YWJsZVNvcnQnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VJbmRleGVkXG4gKi9cbnZhciBEYXRhU291cmNlU29ydGVyID0gRGF0YVNvdXJjZUluZGV4ZWQuZXh0ZW5kKCdEYXRhU291cmNlU29ydGVyJywge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGlyZWN0aW9uPTFdXG4gICAgICovXG4gICAgc29ydE9uOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgZGlyZWN0aW9uLCB0eXBlKSB7XG4gICAgICAgIHZhciBkYXRhU291cmNlID0gdGhpcy5kYXRhU291cmNlLFxuICAgICAgICAgICAgY29sdW1uU2NoZW1hID0gZGF0YVNvdXJjZS5zY2hlbWEuZmluZChmdW5jdGlvbihjb2x1bW5TY2hlbWEsIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gY29sdW1uSW5kZXg7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBjb2x1bW5TY2hlbWEgJiYgY29sdW1uU2NoZW1hLm5hbWUsXG4gICAgICAgICAgICBjYWxjdWxhdG9yID0gZGF0YVNvdXJjZS5zY2hlbWFbY29sdW1uSW5kZXhdLmNhbGN1bGF0b3I7XG5cbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW5kZXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgIHN0YWJsZVNvcnQuc29ydCh0aGlzLmJ1aWxkSW5kZXgoKSwgZ2V0VmFsdWUsIGRpcmVjdGlvbiwgdHlwZSB8fCBkYXRhU291cmNlLnNjaGVtYVtjb2x1bW5JbmRleF0udHlwZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZShyb3dJZHgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUm93ID0gZGF0YVNvdXJjZS5nZXRSb3cocm93SWR4KTtcbiAgICAgICAgICAgIHJldHVybiBEYXRhU291cmNlSW5kZXhlZC52YWxPckZ1bmMuY2FsbChkYXRhUm93LCBjb2x1bW5OYW1lLCBjYWxjdWxhdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VTb3J0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBEYXRhU291cmNlU29ydGVyID0gcmVxdWlyZSgnLi9EYXRhU291cmNlU29ydGVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2F2ZWF0czpcbiAgICAgICAgICpcbiAgICAgICAgICogMS4gQ29sdW1ucyBzaG91bGQgYmUgdW5pcXVlbHkgcmVwcmVzZW50ZWQgKGkuZS4sIG5vIHJlcGVhdHMgd2l0aCBzYW1lIGNvbHVtbkluZGV4KVxuICAgICAgICAgKiAyLiBDb2x1bW5zIHNob3VsZCBiZSBhZGRlZCBsb3ctIHRvIGhpZ2gtb3JkZXIgKGkuZS4sIG1vc3QgZ3JvdXBlZCBjb2x1bW5zIGNvbWUgbGFzdClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0RhdGFTb3VyY2V9XG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3QuZ2V0Um93KHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSNcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uXG4gICAgICovXG4gICAgc29ydE9uOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc29ydHMucHVzaCh7IGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24gfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICogQHBhcmFtIHtzb3J0ZXJGdW5jdGlvbn0gW3NvcnRlcl0gLSBJZiB1bmRlZmluZWQsIGRlbGV0ZXMgc29ydGVyLlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oc29ydGVyKSB7XG4gICAgICAgIGlmIChzb3J0ZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgc29ydGVySW50ZXJmYWNlaVxuICAgICAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc29ydGVyID0gc29ydGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc29ydGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICovXG4gICAgYXBwbHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWFjaCA9IHRoaXMuZGF0YVNvdXJjZTtcbiAgICAgICAgLy8gZ2V0IGxpc3Qgb2Ygc29ydHMgZnJvbSBlaXRoZXIgQVBJIG9yIHVzZSBleGlzdGluZ1xuICAgICAgICB0aGlzLnNvcnRzID0gKHRoaXMuc29ydGVyICYmIHRoaXMuc29ydGVyLnByb3AoJ3NvcnRzJykpIHx8IHRoaXMuc29ydHM7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydHMpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydHMuZm9yRWFjaChmdW5jdGlvbihzb3J0U3BlYykge1xuICAgICAgICAgICAgICAgIGVhY2ggPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihlYWNoKTtcbiAgICAgICAgICAgICAgICBlYWNoLnNvcnRPbihzb3J0U3BlYy5jb2x1bW5JbmRleCwgc29ydFNwZWMuZGlyZWN0aW9uLCBzb3J0U3BlYy50eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXN0ID0gZWFjaDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSNcbiAgICAgKi9cbiAgICBjbGVhclNvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zb3J0cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLmRhdGFTb3VyY2U7XG4gICAgfSxcblxuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0LmdldERhdGFJbmRleCh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3QuZ2V0VmFsdWUoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGFzdC5zZXRWYWx1ZSh4LCB5LCB2YWx1ZSk7XG4gICAgfVxufSk7XG5cbkRhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlLmFwcGx5U29ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAoY29uc29sZS53YXJuIHx8IGNvbnNvbGUubG9nKS5jYWxsKGNvbnNvbGUsICdhcHBseVNvcnRzIGRlcHJlY2F0ZWQ7IHVzZSBhcHBseScpO1xuICAgIHRoaXMuYXBwbHkoKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZSwgJ3R5cGUnLCB7IHZhbHVlOiAnc29ydGVyJyB9KTsgLy8gcmVhZC1vbmx5IHByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VJbmRleGVkID0gcmVxdWlyZSgnLi9EYXRhU291cmNlSW5kZXhlZCcpO1xuXG4vKiogQHR5cGVkZWYgY29sdW1uQWRkcmVzc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiBhIGNvbHVtbiBsaXN0ZWQgaW4gdGhlIGZpZWxkcyBhcnJheS4gU2VlIHRoZSB7QGxpbmsgRGF0YVNvdXJjZVRyZWV2aWV3I2dldEZpZWxkc3xnZXRGaWVsZHMoKX0gbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gaW4gdGhlIGZpZWxkcyBhcnJheS4gU2VlIHRoZSB7QGxpbmsgRGF0YVNvdXJjZVRyZWV2aWV3I2dldEZpZWxkc3xnZXRGaWVsZHMoKX0gbWV0aG9kLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjIEZvciBwcm9wZXIgc29ydGluZywgaW5jbHVkZSBgRGF0YVNvdXJjZVRyZWV2aWV3U29ydGVyYCBpbiB5b3VyIGRhdGEgc291cmNlIHBpcGVsaW5lLCBfYWhlYWQgb2ZfIChjbG9zZXIgdG8gdGhlIGRhdGEgdGhhbikgdGhpcyBkYXRhIHNvdXJjZS5cbiAqXG4gKiBGb3IgcHJvcGVyIGZpbHRlcmluZywgaW5jbHVkZSBgRGF0YVNvdXJjZVRyZWV2aWV3RmlsdGVyYCBpbiB5b3VyIGRhdGEgc291cmNlIHBpcGVsaW5lLCBfYWhlYWQgb2ZfIGBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXJgLCBpZiBpbmNsdWRlZDsgb3IgYXQgYW55IHJhdGUgYWhlYWQgb2YgdGhpcyBkYXRhIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGRhdGFTb3VyY2VcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VJbmRleGVkXG4gKi9cbnZhciBEYXRhU291cmNlVHJlZXZpZXcgPSBEYXRhU291cmNlSW5kZXhlZC5leHRlbmQoJ0RhdGFTb3VyY2VUcmVldmlldycsIHtcblxuICAgIC8qKiBAc3VtbWFyeSBJbml0aWFsaXplIGEgbmV3IGluc3RhbmNlLlxuICAgICAqIEBkZXNjIFNldCB1cCB7QGxpbmsgRGF0YVNvdXJjZVRyZWV2aWV3U29ydGVyfSBhY2Nlc3MgdG8gdGhpcyBvYmplY3QuIEFjY2VzcyBpcyBwcm92aWRlZCB0byB0aGUgd2hvbGUgb2JqZWN0IGFsdGhvdWdoIG9ubHkgaW5zdGFuY2UgdmFyaWFibGVzIGBqb2luZWRgLCBgaWRDb2x1bW5gLCBhbmQgYHBhcmVudElkQ29sdW1uYCBhcmUgbmVlZGVkIGJ5IHRoZSBzb3J0ZXIuIFRoZSB0d28gSUQgY29sdW1ucyBhcmUgcGFzc2VkIHRvIHRoZSB7QGxpbmsgRGF0YVNvdXJjZURlcHRoU29ydGVyfSBjb25zdHJ1Y3Rvci4gKElmIGRhdGFTb3VyY2UgaXMgbm90IHRoZSBzb3J0ZXIsIHRoaXMgaXMgbm90IHVzZWQgYnV0IGhhcm1sZXNzLilcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhbGwgYW5jZXN0b3IgY2xhc3NlcycgYGluaXRpYWxpemVgIG1ldGhvZHMgYXJlIGNhbGxlZCAodG9wLWRvd24pIGJlZm9yZSB0aGlzIG9uZS4gU2VlIHtAbGluayBodHRwOi8vbnBtanMub3JnL2V4dGVuZC1tZX0gZm9yIG1vcmUgaW5mby5cbiAgICAgKiBAcGFyYW0gZGF0YVNvdXJjZVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlVHJlZXZpZXcjXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YVNvdXJjZSkge1xuICAgICAgICB3aGlsZSAoZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKC90cmVldmlldy9pLnRlc3QoZGF0YVNvdXJjZS4kJENMQVNTX05BTUUpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZS50cmVldmlldyA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhU291cmNlID0gZGF0YVNvdXJjZS5kYXRhU291cmNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBSZWZlcmVuY2UgdG8gdGhlIHByaW1hcnkga2V5IGNvbHVtbiBhZGRyZXNzIG9iamVjdC5cbiAgICAgKiBAZGVzYyBUaGUgcHJpbWFyeSBrZXkgY29sdW1uIHVuaXF1ZWx5IGlkZW50aWZpZXMgYSBkYXRhIHJvdy5cbiAgICAgKiBVc2VkIHRvIHJlbGF0ZSBhIGNoaWxkIHJvdyB0byBhIHBhcmVudCByb3cuXG4gICAgICpcbiAgICAgKiBSZWRlZmluZWQgZWFjaCB0aW1lIHRyZWUtdmlldyBpcyB0dXJuZWQgKk9OKiBieSBhIGNhbGwgdG8ge0BsaW5rIERhdGFTb3VyY2VUcmVldmlldyNzZXRSZWxhdGlvbnxzZXRSZWxhdGlvbigpfS5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGluZGV4T3JOYW1lXG4gICAgICogQHJldHVybnMge2NvbHVtbkFkZHJlc3N9IEdldHRlciByZXR1cm5zIGNvbHVtbiBhZGRyZXNzIG9iamVjdDsgc2V0dGVyIGhvd2V2ZXIgYWx3YXlzIHJldHVybnMgaXRzIGlucHV0LlxuICAgICAqL1xuICAgIHNldCBpZENvbHVtbihpbmRleE9yTmFtZSkge1xuICAgICAgICB0aGlzLl9pZENvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uSW5mbyhpbmRleE9yTmFtZSB8fCAnSUQnKTtcbiAgICB9LFxuICAgIGdldCBpZENvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkQ29sdW1uO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgUmVmZXJlbmNlIHRvIHRoZSBmb3JlaWduIGtleSBjb2x1bW4gYWRkcmVzcyBvYmplY3QuXG4gICAgICogQGRlc2MgVGhlIGZvcmVpZ24ga2V5IGNvbHVtbiBkZWZpbmVzIGdyb3VwaW5nOyBpdCByZWxhdGVzIHRoaXMgdHJlZSBub2RlIHJvdyB0byBpdHMgcGFyZW50IHRyZWUgbm9kZSByb3cuIFRvcC1sZXZlbCB0cmVlIG5vZGVzIGhhdmUgbm8gcGFyZW50LiBJbiB0aGF0IGNhc2UgdGhlIHZhbHVlIGluIHRoZSBjb2x1bW4gaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogUmVkZWZpbmVkIGVhY2ggdGltZSB0cmVlLXZpZXcgaXMgdHVybmVkICpPTiogYnkgYSBjYWxsIHRvIHtAbGluayBEYXRhU291cmNlVHJlZXZpZXcjc2V0UmVsYXRpb258c2V0UmVsYXRpb24oKX0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBpbmRleE9yTmFtZVxuICAgICAqIEByZXR1cm5zIHtjb2x1bW5BZGRyZXNzfSBHZXR0ZXIgcmV0dXJucyBjb2x1bW4gYWRkcmVzcyBvYmplY3Q7IHNldHRlciBob3dldmVyIGFsd2F5cyByZXR1cm5zIGl0cyBpbnB1dC5cbiAgICAgKi9cbiAgICBzZXQgcGFyZW50SWRDb2x1bW4oaW5kZXhPck5hbWUpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50SWRDb2x1bW4gPSB0aGlzLmdldENvbHVtbkluZm8oaW5kZXhPck5hbWUgfHwgJ3BhcmVudElEJyk7XG4gICAgfSxcbiAgICBnZXQgcGFyZW50SWRDb2x1bW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRJZENvbHVtbjtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFJlZmVyZW5jZSB0byB0aGUgZHJpbGwtZG93biBjb2x1bW4gYWRkcmVzcyBvYmplY3QuXG4gICAgICogQGRlc2MgVGhlIGRyaWxsLWRvd24gY29sdW1uIGlzIHRoZSBjb2x1bW4gdGhhdCBpcyBpbmRlbnRlZCBhbmQgZGVjb3JhdGVkIHdpdGggZHJpbGwtZG93biBjb250cm9scyAodHJpYW5nbGVzKS4gQSBjb2x1bW4gd2l0aCB0aGUgZ2l2ZW4gaW5kZXggb3IgbmFtZSBtdXN0IGV4aXN0LlxuICAgICAqXG4gICAgICogUmVkZWZpbmVkIGVhY2ggdGltZSB0cmVlLXZpZXcgaXMgdHVybmVkICpPTiogYnkgYSBjYWxsIHRvIHtAbGluayBEYXRhU291cmNlVHJlZXZpZXcjc2V0UmVsYXRpb258c2V0UmVsYXRpb24oKX0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBpbmRleE9yTmFtZVxuICAgICAqIEByZXR1cm5zIHtjb2x1bW5BZGRyZXNzfSBHZXR0ZXIgcmV0dXJucyBjb2x1bW4gYWRkcmVzcyBvYmplY3Q7IHNldHRlciBob3dldmVyIGFsd2F5cyByZXR1cm5zIGl0cyBpbnB1dC5cbiAgICAgKi9cbiAgICBzZXQgdHJlZUNvbHVtbihpbmRleE9yTmFtZSkge1xuICAgICAgICB0aGlzLl90cmVlQ29sdW1uID0gdGhpcy5nZXRDb2x1bW5JbmZvKGluZGV4T3JOYW1lIHx8ICduYW1lJyk7XG4gICAgfSxcbiAgICBnZXQgdHJlZUNvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVDb2x1bW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAvKiogQHN1bW1hcnkgUmVmZXJlbmNlIHRvIHRoZSBncm91cCBuYW1lIGNvbHVtbiBhZGRyZXNzIG9iamVjdC5cbiAgICAgKiBAZGVzYyBUaGUgZ3JvdXAgbmFtZSBjb2x1bW4gaXMgdGhlIGNvbHVtbiB3aG9zZSBjb250ZW50IGRlc2NyaWJlcyB0aGUgZ3JvdXAuIEEgY29sdW1uIHdpdGggdGhlIGdpdmVuIGluZGV4IG9yIG5hbWUgbXVzdCBleGlzdC5cbiAgICAgKlxuICAgICAqIFRoZSB0cmVldmlldyBzb3J0ZXIgdHJlYXRzIHRoZSBncm91cCBuYW1lIGNvbHVtbiBkaWZmZXJlbnRseSB0aGFuIG90aGVyIGNvbHVtbnMsXG4gICAgICogYXBwbHkgYSBcImdyb3VwIHNvcnRcIiB0byBpdCwgd2hpY2ggbWVhbnMgb25seSB0aGUgZ3JvdXAgcm93cyAocm93cyB3aXRoIGNoaWxkcmVuKVxuICAgICAqIGFyZSBzb3J0ZWQgYW5kIHRoZSBsZWF2ZXMgYXJlIGxlZnQgYWxvbmUgKHN0YWJsZSBzb3J0ZWQpLlxuICAgICAqXG4gICAgICogTm9ybWFsbHkgcmVmZXJzIHRvIHRoZSBzYW1lIGNvbHVtbiBhcyB7QGxpbmsgRGF0YVNvdXJjZVRyZWV2aWV3I3RyZWVDb2x1bW58dHJlZUNvbHVtbn0uXG4gICAgICpcbiAgICAgKiBSZWRlZmluZWQgZWFjaCB0aW1lIHRyZWUtdmlldyBpcyB0dXJuZWQgKk9OKiBieSBhIGNhbGwgdG8ge0BsaW5rIERhdGFTb3VyY2VUcmVldmlldyNzZXRSZWxhdGlvbnxzZXRSZWxhdGlvbigpfS5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGluZGV4T3JOYW1lXG4gICAgICogQHJldHVybnMge2NvbHVtbkFkZHJlc3N9IEdldHRlciByZXR1cm5zIGNvbHVtbiBhZGRyZXNzIG9iamVjdDsgc2V0dGVyIGhvd2V2ZXIgYWx3YXlzIHJldHVybnMgaXRzIGlucHV0LlxuICAgICAqL1xuICAgIHNldCBncm91cENvbHVtbihpbmRleE9yTmFtZSkge1xuICAgICAgICB0aGlzLl9ncm91cENvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uSW5mbyhpbmRleE9yTmFtZSB8fCB0aGlzLl90cmVlQ29sdW1uLm5hbWUpO1xuICAgIH0sXG4gICAgZ2V0IGdyb3VwQ29sdW1uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBDb2x1bW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRFTVBPUkFSWS4gVGhpcyBmdW5jdGlvbiBpbmNsdWRlZCBoZXJlIHVudGlsIG5leHQgdmVyc2lvbiBvZiBiYXNlIGlzIHB1Ymxpc2hlZC5cbiAgICAgKiBUaGUgY2hhbmdlIHdhcyB0byB1c2Ugc2NoZW1hIHJhdGhlciB0aGFuIGdldEZpZWxkcygpLlxuICAgICAqIChUaGUgY3VycmVudCB2ZXJzaW9uIGluIGJhc2UgaXMgbm90IGluIHVzZSBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZyb20gaGVyZS4pXG4gICAgICpcbiAgICAgKiBHZXQgbmV3IG9iamVjdCB3aXRoIG5hbWUgYW5kIGluZGV4IGdpdmVuIHRoZSBuYW1lIG9yIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGNvbHVtbk9ySW5kZXggLSBDb2x1bW4gbmFtZSBvciBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7e25hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlcn19XG4gICAgICovXG4gICAgZ2V0Q29sdW1uSW5mbzogZnVuY3Rpb24oY29sdW1uT3JJbmRleCkge1xuICAgICAgICB2YXIgbmFtZSwgaW5kZXgsIHJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbk9ySW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpbmRleCA9IGNvbHVtbk9ySW5kZXg7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5zY2hlbWFbaW5kZXhdLm5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gY29sdW1uT3JJbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zY2hlbWEuZmluZEluZGV4KGZ1bmN0aW9uKGNvbHVtblNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5TY2hlbWEubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgJiYgaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVG9nZ2xlIHRoZSB0cmVlLXZpZXcuXG4gICAgICogQGRlc2MgQ2FsY3VsYXRlcyBvciByZWNhbGN1bGF0ZXMgbmVzdGluZyBkZXB0aCBvZiBlYWNoIHJvdyBhbmQgbWFya3MgaXQgYXMgXCJleHBhbmRhYmxlXCIgaWZmIGl0IGhhcyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIElmIHJlc2V0dGluZyBwcmV2aW91c2x5IHNldCBkYXRhLCB0aGUgc3RhdGUgb2YgZXhwYW5zaW9uIG9mIGFsbCByb3dzIHRoYXQgc3RpbGwgaGF2ZSBjaGlsZHJlbiBpcyByZXRhaW5lZC4gKEFsbCBleHBhbmRlZCByb3dzIHdpbGwgc3RpbGwgYmUgZXhwYW5kZWQgd2hlbiB0cmVlLXZpZXcgaXMgdHVybmVkIGJhY2sgKk9OKi4pXG4gICAgICpcbiAgICAgKiBBbGwgb2YgdGhlIGNvbHVtbnMgcmVmZXJlbmNlZCBieSB0aGUgYG9wdGlvbnNgIHByb3BlcnRpZXMgYGlkQ29sdW1uYCwgYHBhcmVudElkQ29sdW1uYCwgYHRyZWVDb2x1bW5gLCBhbmQgYGdyb3VwQ29sdW1uYCBtdXN0IGV4aXN0LiBUaGVzZSBmb3VyIGNvbHVtbnMgaGF2ZSBkZWZhdWx0IHJlZmVyZW5jZXMgKG5hbWVzKSBhcyBsaXN0ZWQgYmVsb3cuIFRoZSByZWZlcmVuY2VzIG1heSBiZSBvdmVycmlkZGVuIGluIGBvcHRpb25zYCBieSBzdXBwbHlpbmcgYWx0ZXJuYXRlIGNvbHVtbiBuYW1lcyBvciBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufG9iamVjdH0gW29wdGlvbnNdIC0gRmFsc3kgdmFsdWUgKG9yIG9taXR0ZWQpIHR1cm5zIHRyZWUtdmlldyAqKk9GRioqLiBUcnV0aHkgdmFsdWUgdHVybnMgdHJlZS12aWV3ICoqT04qKiB1c2luZyBmb2xsb3dpbmcgb3B0aW9uczpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLmlkQ29sdW1uPSdJRCddIC0gTmFtZSBvciBpbmRleCBvZiB0aGUgcHJpbWFyeSBrZXkgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMucGFyZW50SWRDb2x1bW49J3BhcmVudElEJ10gLSBOYW1lIG9yIGluZGV4IG9mIHRoZSBmb3JlaWduIGtleSBjb2x1bW4gZm9yIGdyb3VwaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMudHJlZUNvbHVtbj0nbmFtZSddIC0gTmFtZSBvciBpbmRleCBvZiB0aGUgZHJpbGwtZG93biBjb2x1bW4gdG8gZGVjb3JhdGUgd2l0aCB0cmlhbmdsZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy5ncm91cENvbHVtbj10aGlzLl90cmVlQ29sdW1uLm5hbWVdIC0gTmFtZSBvciBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgY29udGFpbnMgdGhlIGdyb3VwIG5hbWVzLiBUaGlzIGlzIG5vcm1hbGx5IHRoZSBzYW1lIGFzIHRoZSBkcmlsbC1kb3duIGNvbHVtbi4gWW91IG9ubHkgbmVlZCB0byBzcGVjaWZ5IGEgZGlmZmVyZW50IHZhbHVlIHdoZW4geW91IHdhbnQgdGhlIGRyaWxsIGRvd24gdG8gdGhpcyBjb2x1bW4sIHN1Y2ggYXMgd2hlbiB0aGUgZHJpbGwtZG93biBpcyBpbiBhIGNvbHVtbiBvZiBpdHMgb3duLiBTZWUge0BsaW5rIGh0dHA6Ly9vcGVuZmluLmdpdGh1Yi5pby9maW4taHlwZXJncmlkL3RyZWUtdmlldy1zZXBhcmF0ZS1kcmlsbC1kb3duLmh0bWx9IGZvciBhbiBleGFtcGxlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBKb2luZWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVRyZWV2aWV3I1xuICAgICAqL1xuICAgIHNldFJlbGF0aW9uOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciByLCBwYXJlbnRJRCwgZGVwdGgsIGxlYWZSb3csIHJvdywgSUQ7XG5cbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBqb2luIHJlcXVpcmVzIHRoYXQgb3B0aW9ucyBvYmplY3QgYmUgZ2l2ZW4gYW5kIHRoYXQgYWxsIGNvbHVtbnMgZXhpc3RcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmpvaW5lZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pZENvbHVtbiA9IG9wdGlvbnMuaWRDb2x1bW47XG4gICAgICAgICAgICB0aGlzLnBhcmVudElkQ29sdW1uID0gb3B0aW9ucy5wYXJlbnRJZENvbHVtbjtcbiAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbiA9IG9wdGlvbnMudHJlZUNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBDb2x1bW4gPSBvcHRpb25zLmdyb3VwQ29sdW1uO1xuICAgICAgICAgICAgdGhpcy5qb2luZWQgPSAhISh0aGlzLmlkQ29sdW1uICYmIHRoaXMucGFyZW50SWRDb2x1bW4gJiYgdGhpcy50cmVlQ29sdW1uICYmIHRoaXMuZ3JvdXBDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWlsZEluZGV4KCk7IC8vIG1ha2UgYWxsIHJvd3MgdmlzaWJsZSB0byBnZXRSb3coKVxuXG4gICAgICAgIHIgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIGlmICh0aGlzLmpvaW5lZCkge1xuICAgICAgICAgICAgLy8gbXV0YXRlIGRhdGEgcm93IHdpdGggX19ERVBUSCAoYWxsIHJvd3MpIGFuZCBfX0VYUEFOREVEIChhbGwgXCJwYXJlbnRcIiByb3dzKVxuICAgICAgICAgICAgdmFyIGlkQ29sdW1uTmFtZSA9IHRoaXMuaWRDb2x1bW4ubmFtZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZENvbHVtbk5hbWUgPSB0aGlzLnBhcmVudElkQ29sdW1uLm5hbWU7XG5cbiAgICAgICAgICAgIHRoaXMubWF4RGVwdGggPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICAgICAgICAgIGxlYWZSb3cgPSB0aGlzLmdldFJvdyhyKTtcbiAgICAgICAgICAgICAgICByb3cgPSBsZWFmUm93O1xuICAgICAgICAgICAgICAgIElEID0gcm93W2lkQ29sdW1uTmFtZV07XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoKHBhcmVudElEID0gcm93W3BhcmVudElkQ29sdW1uTmFtZV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gdGhpcy5maW5kUm93KGlkQ29sdW1uTmFtZSwgcGFyZW50SUQpO1xuICAgICAgICAgICAgICAgICAgICArK2RlcHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heERlcHRoIDwgZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCA9IGRlcHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlYWZSb3cuX19ERVBUSCA9IGRlcHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbmRSb3cocGFyZW50SWRDb2x1bW5OYW1lLCBJRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYWZSb3cuX19FWFBBTkRFRDsgLy8gbm8gbG9uZ2VyIGV4cGFuZGFibGVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlYWZSb3cuX19FWFBBTkRFRCA9PT0gdW5kZWZpbmVkKSB7IC8vIHJldGFpbiBwcmV2aW91cyBzZXR0aW5nIGZvciBvbGQgcm93c1xuICAgICAgICAgICAgICAgICAgICBsZWFmUm93Ll9fRVhQQU5ERUQgPSBmYWxzZTsgLy8gZGVmYXVsdCBmb3IgbmV3IHJvdyBpcyB1bmV4cGFuZGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxhdHRlbiB0aGUgdHJlZSBzbyBncm91cCBzb3J0ZXIgc2VlcyBpdCBhcyBhIHNpbmdsZSBncm91cFxuICAgICAgICAgICAgd2hpbGUgKHItLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Um93KHIpLl9fREVQVEggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9vayBmb3IgRGF0YVNvdXJjZVRyZWV2aWV3RmlsdGVyXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuam9pbmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWJ1aWxkIHRoZSBpbmRleC5cbiAgICAgKiBAZGVzYyBSZWJ1aWxkIHRoZSBpbmRleCB0byBzaG93IG9ubHkgXCJyZXZlYWxlZFwiIHJvd3MuIChSb3dzIHRoYXQgYXJlIG5vdCBpbnNpZGUgYSBjb2xsYXBzZWQgcGFyZW50IG5vZGUgcm93LilcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVRyZWV2aWV3I1xuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWlsZEluZGV4KHRoaXMuam9pbmVkICYmIHJvd0lzUmV2ZWFsZWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgY2VsbC5cbiAgICAgKiBAZGVzYyBJbnRlcmNlcHRzIHRyZWUgY29sdW1uIHZhbHVlcyBhbmQgaW5kZW50cyBhbmQgZGVjb3JhdGVzIHRoZW0uXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlVHJlZXZpZXcjXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlLmdldFZhbHVlLmNhbGwodGhpcywgeCwgeSk7XG5cbiAgICAgICAgaWYgKHRoaXMudmlld01ha2VzU2Vuc2UoKSAmJiB4ID09PSB0aGlzLl90cmVlQ29sdW1uLmluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5nZXRSb3coeSk7XG5cbiAgICAgICAgICAgIGlmICghKHZhbHVlID09PSAnJyAmJiByb3cuX19FWFBBTkRFRCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQXJyYXkocm93Ll9fREVQVEggKyAxKS5qb2luKCcgICAnKSArIHRoaXMuZHJpbGxEb3duQ2hhck1hcFtyb3cuX19FWFBBTkRFRCA/ICdPUEVOJyA6ICdDTE9TRSddICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIHZpZXdNYWtlc1NlbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pbmVkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VUcmVldmlldyNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIGlzRHJpbGxEb3duOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy52aWV3TWFrZXNTZW5zZSgpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIGNvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2x1bW5JbmRleCA9PT0gdGhpcy50cmVlQ29sdW1uSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGFuZGxlIGEgY2xpY2sgZXZlbnQgaW4gdGhlIGRyaWxsLWRvd24gY29sdW1uLlxuICAgICAqIEBkZXNjIE9wZXJhdGVzIG9ubHkgb24gdGhlIGZvbGxvd2luZyByb3dzOlxuICAgICAqICogRXhwYW5kYWJsZSByb3dzIC0gUm93cyB3aXRoIGEgZHJpbGwtZG93biBjb250cm9sLlxuICAgICAqICogUmV2ZWFsZWQgcm93cyAtIFJvd3Mgbm90IGhpZGRlbiBpbnNpZGUgb2YgY29sbGFwc2VkIGRyaWxsLWRvd25zLlxuICAgICAqIEBwYXJhbSB5IC0gUmV2ZWFsZWQgcm93IG51bWJlci4gKFRoaXMgaXMgbm90IHRoZSByb3cgSUQuKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4cGFuZF0gLSBPbmUgb2Y6XG4gICAgICogKiBgdHJ1ZWAgLSBFeHBhbmQgYWxsIHJvd3MgdGhhdCBhcmUgY3VycmVudGx5IGNvbGxhcHNlZC5cbiAgICAgKiAqIGBmYWxzZWAgLSBDb2xsYXBzZSBhbGwgcm93cyB0aGF0IGFyZSBjdXJyZW50bHkgZXhwYW5kZWQuXG4gICAgICogKiBgdW5kZWZpbmVkYCAob3Igb21pdHRlZCkgLSBFeHBhbmQgYWxsIGN1cnJlbnRseSBjb2xsYXBzZWQgcm93czsgY29sbGFwc2UgYWxsIGN1cnJlbnRseSBleHBhbmRlZCByb3dzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9SW5maW5pdHldIC0gT25lIG9mOlxuICAgICAqICogbnVtYmVyID4gMCAtIEFwcGx5IG9ubHkgaWYgcm93IGRlcHRoIGlzIGFib3ZlIHRoZSBnaXZlbiBkZXB0aC5cbiAgICAgKiAqIG51bWJlciA8PSAwIC0gQXBwbHkgb25seSBpZiByb3cgZGVwdGggaXMgYmVsb3cgdGhlIGdpdmVuIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gT25lIG9mOlxuICAgICAqICogYHVuZGVmaW5lZGAgLSBSb3cgd2FzIG5vdCBleHBhbmRhYmxlLlxuICAgICAqICogYHRydWVgIC0gUm93IGhhZCBkcmlsbC1kb3duIF9hbmRfIHN0YXRlIGNoYW5nZWQuXG4gICAgICogKiBgZmFsc2VgIC0gUm93IGhhZCBkcmlsbC1kb3duIF9idXRfIHN0YXRlIGRpZCBfbm90XyBjaGFuZ2UuXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VUcmVldmlldyNcbiAgICAgKi9cbiAgICBjbGljazogZnVuY3Rpb24oeSwgZXhwYW5kLCBkZXB0aCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5jbGljay5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhbmdlZCwgcm93ID0gdGhpcy5nZXRSb3coeSk7XG4gICAgICAgIGlmIChyb3cgJiYgcm93Ll9fRVhQQU5ERUQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRlcHRoICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgIGRlcHRoID4gMCAmJiByb3cuX19ERVBUSCA+PSBkZXB0aCB8fFxuICAgICAgICAgICAgICAgIGRlcHRoIDw9IDAgJiYgcm93Ll9fREVQVEggPCAtZGVwdGhcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmQgPSAhcm93Ll9fRVhQQU5ERUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSByb3cuX19FWFBBTkRFRCAmJiAhZXhwYW5kIHx8ICFyb3cuX19FWFBBTkRFRCAmJiBleHBhbmQ7XG4gICAgICAgICAgICAgICAgcm93Ll9fRVhQQU5ERUQgPSBleHBhbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEV4cGFuZCBuZXN0ZWQgZHJpbGwtZG93bnMgY29udGFpbmluZyB0aGlzIHJvdy5cbiAgICAgKiBAcGFyYW0gSUQgLSBUaGUgdW5pcXVlIHJvdyBJRC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgYW55IHJvd3MgZXhwYW5kZWQuXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VUcmVldmlldyNcbiAgICAgKi9cbiAgICByZXZlYWxSb3c6IGZ1bmN0aW9uKElEKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnJldmVhbFJvdy5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm93LCBwYXJlbnQsIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKChyb3cgPSB0aGlzLmZpbmRSb3codGhpcy5faWRDb2x1bW4ubmFtZSwgSUQpKSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiByb3cuX19FWFBBTkRFRCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByb3cuX19FWFBBTkRFRCA9IGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIElEID0gcm93W3RoaXMuX3BhcmVudElkQ29sdW1uLm5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiByb3dJc1JldmVhbGVkKHIsIHJvdykge1xuICAgIHZhciBwYXJlbnRJRDtcblxuICAgIC8vIGFyZSBhbnkgb2YgdGhlIHJvdydzIGFuY2VzdG9ycyBjb2xsYXBzZWQ/XG4gICAgd2hpbGUgKChwYXJlbnRJRCA9IHJvd1t0aGlzLl9wYXJlbnRJZENvbHVtbi5uYW1lXSkgIT0gbnVsbCkge1xuICAgICAgICAvLyB3YWxrIHVwIHRocm91Z2ggZWFjaCBwYXJlbnQuLi5cbiAgICAgICAgcm93ID0gdGhpcy5maW5kUm93KHRoaXMuX2lkQ29sdW1uLm5hbWUsIHBhcmVudElEKTtcbiAgICAgICAgaWYgKHJvdy5fX0VYUEFOREVEID09PSBmYWxzZSkgeyAvLyBhbiBhbmNlc3RvciBpcyBjb2xsYXBzZWRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZXhjbHVkZSByb3cgZnJvbSBidWlsZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm8gYW5jZXN0b3JzIHdlcmUgY29sbGFwc2VkXG4gICAgcmV0dXJuIHRydWU7IC8vIGluY2x1ZGUgcm93IGluIGJ1aWxkXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhU291cmNlVHJlZXZpZXcucHJvdG90eXBlLCAndHlwZScsIHsgdmFsdWU6ICd0cmVldmlld2VyJyB9KTsgLy8gcmVhZC1vbmx5IHByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZVRyZWV2aWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgU2hvdWxkIGJlIHBvc2l0aW9uZWQgaW4gdGhlIGRhdGEgc291cmNlIHBpcGVsaW5lIF9haGVhZCBvZl8gKGNsb3NlciB0byB0aGUgZGF0YSB0aGFuKSB0aGUgb3B0aW9uYWwgYERhdGFTb3VyY2VUcmVldmlld1NvcnRlcmAgYW5kIHRoZSByZXF1aXJlZCBgRGF0YVNvdXJjZVRyZWV2aWV3YCAod2hpY2ggc2V0cyBgdGhpcy50cmVldmlld2ApLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZGF0YVNvdXJjZVxuICogQGV4dGVuZHMgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZVxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUdsb2JhbEZpbHRlclxuICovXG52YXIgRGF0YVNvdXJjZVRyZWV2aWV3RmlsdGVyID0gRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5leHRlbmQoJ0RhdGFTb3VyY2VUcmVldmlld0ZpbHRlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzIGZpbHRlclByZWRpY2F0ZVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR2xvYmFsRmlsdGVyI1xuICAgICAqL1xuICAgIGZpbHRlclRlc3Q6IGZ1bmN0aW9uKHIsIHJvd09iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVldmlldy52aWV3TWFrZXNTZW5zZSgpICYmIHJvd09iamVjdC5fX0VYUEFOREVEICE9PSB1bmRlZmluZWQgfHwgdGhpcy5maWx0ZXIudGVzdChyb3dPYmplY3QpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZVRyZWV2aWV3RmlsdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScpO1xudmFyIERhdGFTb3VyY2VEZXB0aFNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZURlcHRoU29ydGVyJyk7XG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgU2hvdWxkIGJlIHBvc2l0aW9uZWQgaW4gdGhlIGRhdGEgc291cmNlIHBpcGVsaW5lIF9haGVhZCBvZl8gKGNsb3NlciB0byB0aGUgZGF0YSB0aGFuKSB0aGUgcmVxdWlyZWQgYERhdGFTb3VyY2VUcmVldmlld2AgKHdoaWNoIHNldHMgYHRoaXMudHJlZXZpZXdgKSBidXQgX2JlaGluZF8gdGhlIG9wdGlvbmFsIGBEYXRhU291cmNlVHJlZXZpZXdGaWx0ZXJgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZGF0YVNvdXJjZVxuICogQGV4dGVuZHMgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZVxuICovXG52YXIgRGF0YVNvdXJjZVRyZWV2aWV3U29ydGVyID0gRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5leHRlbmQoJ0RhdGFTb3VyY2VUcmVldmlld1NvcnRlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlYnVpbGQgdGhlIGluZGV4LlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGpvaW5lZCA9IHRoaXMudHJlZXZpZXcudmlld01ha2VzU2Vuc2UoKSxcbiAgICAgICAgICAgIGVhY2ggPSB0aGlzLmRhdGFTb3VyY2UsXG4gICAgICAgICAgICBsYXN0LCAvLyBsYXN0IHNvcnQgc3BlYyAoXCJmaXJzdFwiIHNvcnQpIHdoZW4gYW5kIG9ubHkgd2hlbiBqb2luZWQgQU5EIGl0IGlzIHRoZSBncm91cCBjb2x1bW5cbiAgICAgICAgICAgIGxhc3RJc0dyb3VwLCBjb2x1bW5JbmRleCwgZGlyZWN0aW9uO1xuICAgICAgICAvLyBnZXQgbGlzdCBvZiBzb3J0cyBmcm9tIGVpdGhlciBBUEkgb3IgdXNlIGV4aXN0aW5nXG4gICAgICAgIHRoaXMuc29ydHMgPSAodGhpcy5zb3J0ZXIgJiYgdGhpcy5zb3J0ZXIucHJvcCgnc29ydHMnKSkgfHwgdGhpcy5zb3J0cztcblxuICAgICAgICBpZiAodGhpcy5zb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChqb2luZWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdGhpcy5zb3J0c1t0aGlzLnNvcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGxhc3RJc0dyb3VwID0gbGFzdC5jb2x1bW5JbmRleCA9PT0gdGhpcy50cmVldmlldy5ncm91cENvbHVtbi5pbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHNvcnRTcGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobGFzdElzR3JvdXAgJiYgc29ydFNwZWMgPT09IGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2ggPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihlYWNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWFjaC5zb3J0T24oc29ydFNwZWMuY29sdW1uSW5kZXgsIHNvcnRTcGVjLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICBpZiAobGFzdElzR3JvdXAgfHwgdGhpcy5zb3J0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IGxhc3QuY29sdW1uSW5kZXg7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGFwcGx5IGEgXCJkZXB0aCBzb3J0XCIgdG8gZWl0aGVyIHRoZSBncm91cCBjb2x1bW4gKGlmIGxhc3QpIG9yIHRoZSBJRCBjb2x1bW4gdG8gZ3JvdXAgaXQgcHJvcGVybHlcbiAgICAgICAgICAgIGZvciAodmFyIGRlcHRoID0gdGhpcy50cmVldmlldy5tYXhEZXB0aDsgZGVwdGggPj0gMDsgLS1kZXB0aCkge1xuICAgICAgICAgICAgICAgIGVhY2ggPSBuZXcgRGF0YVNvdXJjZURlcHRoU29ydGVyKGVhY2gsIHRoaXMudHJlZXZpZXcpO1xuICAgICAgICAgICAgICAgIGVhY2guc29ydE9uKGRlcHRoLCBkaXJlY3Rpb24sIGNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdCA9IGVhY2g7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hcHB5KCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMudmFsdWVzID0gW107XG59XG5cbk1hcHB5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBNYXBweS5wcm90b3R5cGUuY29uc3RydWN0b3IsIC8vIHByZXNlcnZlIGNvbnN0cnVjdG9yXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkjXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICghKGhhc2hDb2RlIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFbaGFzaENvZGVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweSNcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2hhc2hDb2RlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkjXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGlmVW5kZWZpbmVkRnVuYyAtIFZhbHVlIGdldHRlciB3aGVuIHZhbHVlIGlzIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SWZVbmRlZmluZWQ6IGZ1bmN0aW9uKGtleSwgaWZVbmRlZmluZWRGdW5jKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGlmVW5kZWZpbmVkRnVuYyhrZXkpO1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweSNcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMua2V5cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5I1xuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBkZWxldGU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaGFzaENvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJldHRlckluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtoYXNoQ29kZV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5I1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZSh2YWx1ZSwga2V5LCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweSNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZVxuICAgICAqIEByZXR1cm5zIHtNYXBweX1cbiAgICAgKi9cbiAgICBtYXA6IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICAgICAgbmV3TWFwID0gbmV3IE1hcHB5KCksXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoISh0eXBlb2YgaXRlcmF0ZWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBpdGVyYXRlZSA9IHJlZmxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgc2VsZik7XG4gICAgICAgICAgICBuZXdNYXAuc2V0KGtleSwgdHJhbnNmb3JtZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5I1xuICAgICAqIEByZXR1cm5zIHtNYXBweX1cbiAgICAgKi9cbiAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICBuZXdNYXAgPSBuZXcgTWFwcHkoKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpO1xuICAgICAgICAgICAgbmV3TWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfVxuXG59O1xuXG52YXIgT0lEX1BSRUZJWCA9ICcufi4jJV8nOyAvL3RoaXMgc2hvdWxkIGJlIHNvbWV0aGluZyB3ZSBuZXZlciB3aWxsIHNlZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nXG52YXIgY291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGhhc2goa2V5KSB7XG4gICAgdmFyIHR5cGVPZiA9IHR5cGVvZiBrZXk7XG5cbiAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiBPSURfUFJFRklYICsgdHlwZU9mICsgJ18nICsga2V5O1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZXR1cm4gJ1VOREVGSU5FRCc7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05VTEwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHdoZW4gbm90IG51bGw6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiAoa2V5Ll9fX2Zpbmhhc2ggPSBrZXkuX19fZmluaGFzaCB8fCBPSURfUFJFRklYICsgY291bnRlcisrKTtcbiAgICB9XG59XG5cbi8vIE9iamVjdC5pcyBwb2x5ZmlsbCwgY291cnRlc3kgb2YgQFdlYlJlZmxlY3Rpb25cbnZhciBpcyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgPyBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiIDogYSAhPSBhICYmIGIgIT0gYjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbn07XG5cbmZ1bmN0aW9uIHJlZmxlY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLy8gTW9yZSByZWxpYWJsZSBpbmRleE9mLCBjb3VydGVzeSBvZiBAV2ViUmVmbGVjdGlvblxuZnVuY3Rpb24gYmV0dGVySW5kZXhPZihhcnIsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSAwKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSAmJiAhaXMoYXJyW2ldLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBbXS5pbmRleE9mLmNhbGwoYXJyLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcHB5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBtb2R1bGUgYWdncmVnYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGFnZ3JlZ2F0aW9uRnVuY3Rpb25cbiAqIEBzdW1tYXJ5IEEgYm91bmQgZnVuY3Rpb24uXG4gKiBAZGVzYyBBbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBib3VuZCB0byB0aGUgYGNvbHVtbkluZGV4YCB2YWx1ZSBzdXBwbGllZCB0byBvbmUgb2YgdGhlIGFib3ZlIGZhY3RvcnkgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtvYmplY3R9IGdyb3VwXG4gKiBAcmV0dXJucyB7Kn0gQWdncmVnYXRlZCB2YWx1ZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY291bnQ6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN1bTogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN1bS5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG1pbjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbm1heC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4LCBNYXRoLm1pbiwgSW5maW5pdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbWlubWF4LmJpbmQodGhpcywgY29sdW1uSW5kZXgsIE1hdGgubWF4LCAtSW5maW5pdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXZnOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gYXZnLmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBmaXJzdC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGxhc3Q6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBsYXN0LmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RkZGV2OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gc3RkZGV2LmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNvdW50KGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLmdldFJvd0NvdW50KCk7XG59XG5cbmZ1bmN0aW9uIHN1bShjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICB2YXIgciA9IGdyb3VwLmdldFJvd0NvdW50KCksXG4gICAgICAgIG4gPSAwO1xuXG4gICAgd2hpbGUgKHItLSkge1xuICAgICAgICBuICs9IGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCByKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gbWlubWF4KGNvbHVtbkluZGV4LCBtZXRob2QsIG4sIGdyb3VwKSB7XG4gICAgdmFyIHIgPSBncm91cC5nZXRSb3dDb3VudCgpO1xuXG4gICAgd2hpbGUgKHItLSkge1xuICAgICAgICBuID0gbWV0aG9kKG4sIGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCByKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGF2Zyhjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICByZXR1cm4gc3VtKGNvbHVtbkluZGV4LCBncm91cCkgLyBncm91cC5nZXRSb3dDb3VudCgpO1xufVxuXG5mdW5jdGlvbiBmaXJzdChjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIDApO1xufVxuXG5mdW5jdGlvbiBsYXN0KGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgZ3JvdXAuZ2V0Um93Q291bnQoKSAtIDEpO1xufVxuXG5mdW5jdGlvbiBzdGRkZXYoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgdmFyIHJvd3MgPSBncm91cC5nZXRSb3dDb3VudCgpLFxuICAgICAgICBtZWFuID0gYXZnKGNvbHVtbkluZGV4LCBncm91cCk7XG5cbiAgICBmb3IgKHZhciBkZXYsIHIgPSByb3dzLCB2YXJpYW5jZSA9IDA7IHItLTsgdmFyaWFuY2UgKz0gZGV2ICogZGV2KSB7XG4gICAgICAgIGRldiA9IGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCByKSAtIG1lYW47XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydCh2YXJpYW5jZSAvIHJvd3MpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOT1RFOiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGBjYXBpdGFsaXplYCBpcyBzdGlsbCBhIGZ1bmN0aW9uLCBkb3VibGluZyBub3cgYXMgdGhlIEFQSS5cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gKC9bYS16XS8udGVzdChzdHJpbmcpID8gc3RyaW5nIDogc3RyaW5nLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKC9bXFxzXFwtX10qKFteXFxzXFwtX10pKFteXFxzXFwtX10rKS9nLCByZXBsYWNlcilcbiAgICAgICAgLnJlcGxhY2UoL1tBLVpdL2csICcgJCYnKVxuICAgICAgICAudHJpbSgpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlcihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGIudG9VcHBlckNhc2UoKSArIGM7XG59XG5cbmZ1bmN0aW9uIHNldChtZXRob2ROYW1lKSB7XG4gICAgY2FwaXRhbGl6ZS50cmFuc2Zvcm0gPSBjYXBpdGFsaXplW21ldGhvZE5hbWVdO1xufVxuXG5mdW5jdGlvbiBwYXNzdGhyb3VnaChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xufVxuXG5jYXBpdGFsaXplLnRyYW5zZm9ybSA9IHBhc3N0aHJvdWdoO1xuY2FwaXRhbGl6ZS5zZXQgPSBzZXQ7XG5jYXBpdGFsaXplLnBhc3N0aHJvdWdoID0gcGFzc3Rocm91Z2g7XG5jYXBpdGFsaXplLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhcGl0YWxpemU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTm90ZSB0aGF0IHtAbGluayBtb2R1bGU6c3RhYmxlU29ydCNzb3J0fHNvcnQoKX0gaXMgdGhlIG9ubHkgZXhwb3NlZCBtZXRob2QuXG4gKiBAbW9kdWxlIHN0YWJsZVNvcnRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVzY2VuZGluZ1xuICogQHBhcmFtIHtBcnJheX0gYXJyMVxuICogQHBhcmFtIHtBcnJheX0gYXJyMlxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzdGFiaWxpemUoY29tcGFyYXRvciwgZGVzY2VuZGluZywgYXJyMSwgYXJyMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuICAgIHZhciB4ID0gYXJyMVswXTtcbiAgICB2YXIgeSA9IGFycjJbMF07XG5cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICB4ID0gZGVzY2VuZGluZyA/IGFycjJbMV0gOiBhcnIxWzFdO1xuICAgICAgICB5ID0gZGVzY2VuZGluZyA/IGFycjFbMV0gOiBhcnIyWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBhcmF0b3IoeCwgeSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBhc2NlbmRpbmdOdW1iZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geCAtIHk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZXNjZW5kaW5nTnVtYmVycyh4LCB5KSB7XG4gICAgcmV0dXJuIHkgLSB4O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gYXNjZW5kaW5nQWxsT3RoZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geCA8IHkgPyAtMSA6IDE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZXNjZW5kaW5nQWxsT3RoZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geSA8IHggPyAtMSA6IDE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHR5cGVPZkRhdGFcbiAqIEByZXR1cm5zIHtmdW5jdGlvbih0aGlzOmFzY2VuZGluZyl9XG4gKi9cbmZ1bmN0aW9uIGFzY2VuZGluZyh0eXBlT2ZEYXRhKSB7XG4gICAgcmV0dXJuIHN0YWJpbGl6ZS5iaW5kKHRoaXMsIHR5cGVPZkRhdGEgPT09ICdudW1iZXInID8gYXNjZW5kaW5nTnVtYmVycyA6IGFzY2VuZGluZ0FsbE90aGVycywgZmFsc2UpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB0eXBlT2ZEYXRhXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24odGhpczpkZXNjZW5kaW5nKX1cbiAqL1xuZnVuY3Rpb24gZGVzY2VuZGluZyh0eXBlT2ZEYXRhKSB7XG4gICAgcmV0dXJuIHN0YWJpbGl6ZS5iaW5kKHRoaXMsIHR5cGVPZkRhdGEgPT09ICdudW1iZXInID8gZGVzY2VuZGluZ051bWJlcnMgOiBkZXNjZW5kaW5nQWxsT3RoZXJzLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0VmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGlyZWN0aW9uPTFdXG4gKi9cbmZ1bmN0aW9uIHNvcnQoaW5kZXgsIGdldFZhbHVlLCBkaXJlY3Rpb24sIHR5cGUpIHtcblxuICAgIHZhciBjb21wYXJlLCBpO1xuXG4gICAgLy8gYXBwbHkgZGVmYXVsdHNcbiAgICBpZiAoZGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXgubGVuZ3RoKSB7IC8vIHNvbWV0aGluZyB0byBkb1xuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gYmFpbDogbm90aGluZyB0byBzb3J0XG5cbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTogIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gYXNjZW5kaW5nKHR5cGUgfHwgdHlwZW9mIGdldFZhbHVlKDApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gZGVzY2VuZGluZyh0eXBlIHx8IHR5cGVvZiBnZXRWYWx1ZSgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdXAgdGhlIHNvcnQuLi4uLlxuICAgICAgICB2YXIgdG1wID0gbmV3IEFycmF5KGluZGV4Lmxlbmd0aCk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBpbmRleCBmb3IgXCJzdGFiaWxpdHlcIlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRtcFtpXSA9IFtnZXRWYWx1ZShpKSwgaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyB0aGUgYWN0dWFsIHNvcnRcbiAgICAgICAgdG1wLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgLy8gY29weSB0aGUgc29ydGVkIHZhbHVlcyBpbnRvIG91ciBpbmRleCB2ZWN0b3JcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleFtpXSA9IHRtcFtpXVsxXTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnRzLnNvcnQgPSBzb3J0O1xuIiwiLyohXG4gKiBtdXN0YWNoZS5qcyAtIExvZ2ljLWxlc3Mge3ttdXN0YWNoZX19IHRlbXBsYXRlcyB3aXRoIEphdmFTY3JpcHRcbiAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAqL1xuXG4vKmdsb2JhbCBkZWZpbmU6IGZhbHNlIE11c3RhY2hlOiB0cnVlKi9cblxuKGZ1bmN0aW9uIGRlZmluZU11c3RhY2hlIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmIHR5cGVvZiBleHBvcnRzLm5vZGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTsgLy8gQU1EXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLk11c3RhY2hlID0ge307XG4gICAgZmFjdG9yeShNdXN0YWNoZSk7IC8vIHNjcmlwdCwgd3NoLCBhc3BcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiBtdXN0YWNoZUZhY3RvcnkgKG11c3RhY2hlKSB7XG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICAgKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgKi9cbiAgZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG4gIH1cblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG4gIHZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuICBmdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBub25TcGFjZVJlID0gL1xcUy87XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnLyc6ICcmI3gyRjsnXG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2hpdGVSZSA9IC9cXHMqLztcbiAgdmFyIHNwYWNlUmUgPSAvXFxzKy87XG4gIHZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG4gIHZhciBjdXJseVJlID0gL1xccypcXH0vO1xuICB2YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuICAvKipcbiAgICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAgICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICAgKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAgICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICAgKlxuICAgKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gICAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gICAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAgICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gICAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAgICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gICAqXG4gICAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAgICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAgICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gICAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgaWYgKCF0ZW1wbGF0ZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZWN0aW9ucyA9IFtdOyAgICAgLy8gU3RhY2sgdG8gaG9sZCBzZWN0aW9uIHRva2Vuc1xuICAgIHZhciB0b2tlbnMgPSBbXTsgICAgICAgLy8gQnVmZmVyIHRvIGhvbGQgdGhlIHRva2Vuc1xuICAgIHZhciBzcGFjZXMgPSBbXTsgICAgICAgLy8gSW5kaWNlcyBvZiB3aGl0ZXNwYWNlIHRva2VucyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgdmFyIGhhc1RhZyA9IGZhbHNlOyAgICAvLyBJcyB0aGVyZSBhIHt7dGFnfX0gb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgICB2YXIgbm9uU3BhY2UgPSBmYWxzZTsgIC8vIElzIHRoZXJlIGEgbm9uLXNwYWNlIGNoYXIgb24gdGhlIGN1cnJlbnQgbGluZT9cblxuICAgIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gICAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGFzVGFnID0gZmFsc2U7XG4gICAgICBub25TcGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gICAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIH1cblxuICAgIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICAgIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICAgIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaChbICd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxIF0pO1xuICAgICAgICAgIHN0YXJ0ICs9IDE7XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3Igd2hpdGVzcGFjZSBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAgIGlmIChjaHIgPT09ICdcXG4nKVxuICAgICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBvcGVuaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKG9wZW5pbmdUYWdSZSkpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdDdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgICB0eXBlID0gJyYnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihjbG9zaW5nVGFnUmUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHRhZyBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcyBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJyMnIHx8IHR5cGUgPT09ICdeJykge1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIENoZWNrIHNlY3Rpb24gbmVzdGluZy5cbiAgICAgICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgICAgICBpZiAoIW9wZW5TZWN0aW9uKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5vcGVuZWQgc2VjdGlvbiBcIicgKyB2YWx1ZSArICdcIiBhdCAnICsgc3RhcnQpO1xuXG4gICAgICAgIGlmIChvcGVuU2VjdGlvblsxXSAhPT0gdmFsdWUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduYW1lJyB8fCB0eXBlID09PSAneycgfHwgdHlwZSA9PT0gJyYnKSB7XG4gICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIC8vIFNldCB0aGUgdGFncyBmb3IgdGhlIG5leHQgdGltZSBhcm91bmQuXG4gICAgICAgIGNvbXBpbGVUYWdzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG9wZW4gc2VjdGlvbnMgd2hlbiB3ZSdyZSBkb25lLlxuICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICBpZiAob3BlblNlY3Rpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICAgKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNxdWFzaFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIHNxdWFzaGVkVG9rZW5zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIGxhc3RUb2tlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbiAmJiBsYXN0VG9rZW5bMF0gPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlblsxXSArPSB0b2tlblsxXTtcbiAgICAgICAgICBsYXN0VG9rZW5bM10gPSB0b2tlblszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcXVhc2hlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcXVhc2hlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgaW50byBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZSB3aGVyZVxuICAgKiB0b2tlbnMgdGhhdCByZXByZXNlbnQgYSBzZWN0aW9uIGhhdmUgdHdvIGFkZGl0aW9uYWwgaXRlbXM6IDEpIGFuIGFycmF5IG9mXG4gICAqIGFsbCB0b2tlbnMgdGhhdCBhcHBlYXIgaW4gdGhhdCBzZWN0aW9uIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsXG4gICAqIHRlbXBsYXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoYXQgc2VjdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG5lc3RUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBuZXN0ZWRUb2tlbnMgPSBbXTtcbiAgICB2YXIgY29sbGVjdG9yID0gbmVzdGVkVG9rZW5zO1xuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBzZWN0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICBjYXNlICcjJzpcbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgIHNlY3Rpb25bNV0gPSB0b2tlblsyXTtcbiAgICAgICAgY29sbGVjdG9yID0gc2VjdGlvbnMubGVuZ3RoID4gMCA/IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdWzRdIDogbmVzdGVkVG9rZW5zO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVzdGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIHN0cmluZyBzY2FubmVyIHRoYXQgaXMgdXNlZCBieSB0aGUgdGVtcGxhdGUgcGFyc2VyIHRvIGZpbmRcbiAgICogdG9rZW5zIGluIHRlbXBsYXRlIHN0cmluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBTY2FubmVyIChzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhaWwgPSBzdHJpbmc7XG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0YWlsIGlzIGVtcHR5IChlbmQgb2Ygc3RyaW5nKS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLmVvcyA9IGZ1bmN0aW9uIGVvcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCA9PT0gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIG1hdGNoIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIFJldHVybnMgdGhlIG1hdGNoZWQgdGV4dCBpZiBpdCBjYW4gbWF0Y2gsIHRoZSBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIHNjYW4gKHJlKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy50YWlsLm1hdGNoKHJlKTtcblxuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggIT09IDApXG4gICAgICByZXR1cm4gJyc7XG5cbiAgICB2YXIgc3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpO1xuICAgIHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTa2lwcyBhbGwgdGV4dCB1bnRpbCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGNhbiBiZSBtYXRjaGVkLiBSZXR1cm5zXG4gICAqIHRoZSBza2lwcGVkIHN0cmluZywgd2hpY2ggaXMgdGhlIGVudGlyZSB0YWlsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblVudGlsID0gZnVuY3Rpb24gc2NhblVudGlsIChyZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFpbC5zZWFyY2gocmUpLCBtYXRjaDtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICBjYXNlIC0xOlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWw7XG4gICAgICB0aGlzLnRhaWwgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDpcbiAgICAgIG1hdGNoID0gJyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIH1cblxuICAgIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gICAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICAgKiBhcyB0aGUgcGFyZW50LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICAgKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgbmFtZXMsIGluZGV4LCBsb29rdXBIaXQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpID4gMCkge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3O1xuICAgICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgIGluZGV4ID0gMDtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzaW5nIHRoZSBkb3Qgbm90aW9uIHBhdGggaW4gYG5hbWVgLCB3ZSBkZXNjZW5kIHRocm91Z2ggdGhlXG4gICAgICAgICAgICogbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUbyBiZSBjZXJ0YWluIHRoYXQgdGhlIGxvb2t1cCBoYXMgYmVlbiBzdWNjZXNzZnVsLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICogY2hlY2sgaWYgdGhlIGxhc3Qgb2JqZWN0IGluIHRoZSBwYXRoIGFjdHVhbGx5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgKiB3ZSBhcmUgbG9va2luZyBmb3IuIFdlIHN0b3JlIHRoZSByZXN1bHQgaW4gYGxvb2t1cEhpdGAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGlzIHNwZWNpYWxseSBuZWNlc3NhcnkgZm9yIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHNldCB0b1xuICAgICAgICAgICAqIGB1bmRlZmluZWRgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGxvb2tpbmcgdXAgcGFyZW50IGNvbnRleHRzLlxuICAgICAgICAgICAqKi9cbiAgICAgICAgICB3aGlsZSAodmFsdWUgIT0gbnVsbCAmJiBpbmRleCA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBuYW1lcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eSh2YWx1ZSwgbmFtZXNbaW5kZXhdKTtcblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtuYW1lc1tpbmRleCsrXV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuICAgICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KGNvbnRleHQudmlldywgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va3VwSGl0KVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcy52aWV3KTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBXcml0ZXIga25vd3MgaG93IHRvIHRha2UgYSBzdHJlYW0gb2YgdG9rZW5zIGFuZCByZW5kZXIgdGhlbSB0byBhXG4gICAqIHN0cmluZywgZ2l2ZW4gYSBjb250ZXh0LiBJdCBhbHNvIG1haW50YWlucyBhIGNhY2hlIG9mIHRlbXBsYXRlcyB0b1xuICAgKiBhdm9pZCB0aGUgbmVlZCB0byBwYXJzZSB0aGUgc2FtZSB0ZW1wbGF0ZSB0d2ljZS5cbiAgICovXG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGlzIHdyaXRlci5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHRva2Vuc1xuICAgKiB0aGF0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXJzZS5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgIHZhciB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV07XG5cbiAgICBpZiAodG9rZW5zID09IG51bGwpXG4gICAgICB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV0gPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0YWdzKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZ2gtbGV2ZWwgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgd2l0aFxuICAgKiB0aGUgZ2l2ZW4gYHZpZXdgLlxuICAgKlxuICAgKiBUaGUgb3B0aW9uYWwgYHBhcnRpYWxzYCBhcmd1bWVudCBtYXkgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIG5hbWVzIGFuZCB0ZW1wbGF0ZXMgb2YgcGFydGlhbHMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuIEl0IG1heVxuICAgKiBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGxvYWQgcGFydGlhbCB0ZW1wbGF0ZXMgb24gdGhlIGZseVxuICAgKiB0aGF0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGUgbmFtZSBvZiB0aGUgcGFydGlhbC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvdy1sZXZlbCBtZXRob2QgdGhhdCByZW5kZXJzIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCB1c2luZ1xuICAgKiB0aGUgZ2l2ZW4gYGNvbnRleHRgIGFuZCBgcGFydGlhbHNgLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG9yaWdpbmFsVGVtcGxhdGVgIGlzIG9ubHkgZXZlciB1c2VkIHRvIGV4dHJhY3QgdGhlIHBvcnRpb25cbiAgICogb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgd2FzIGNvbnRhaW5lZCBpbiBhIGhpZ2hlci1vcmRlciBzZWN0aW9uLlxuICAgKiBJZiB0aGUgdGVtcGxhdGUgZG9lc24ndCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLCB0aGlzIGFyZ3VtZW50IG1heVxuICAgKiBiZSBvbWl0dGVkLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbnMgPSBmdW5jdGlvbiByZW5kZXJUb2tlbnMgKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgICB2YXIgdG9rZW4sIHN5bWJvbCwgdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHN5bWJvbCA9IHRva2VuWzBdO1xuXG4gICAgICBpZiAoc3ltYm9sID09PSAnIycpIHZhbHVlID0gdGhpcy5yZW5kZXJTZWN0aW9uKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICdeJykgdmFsdWUgPSB0aGlzLnJlbmRlckludmVydGVkKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICc+JykgdmFsdWUgPSB0aGlzLnJlbmRlclBhcnRpYWwodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJyYnKSB2YWx1ZSA9IHRoaXMudW5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnbmFtZScpIHZhbHVlID0gdGhpcy5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAndGV4dCcpIHZhbHVlID0gdGhpcy5yYXdWYWx1ZSh0b2tlbik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiByZW5kZXJTZWN0aW9uICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW5kZXIgYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgY29udGV4dCBieSBoaWdoZXItb3JkZXIgc2VjdGlvbnMuXG4gICAgZnVuY3Rpb24gc3ViUmVuZGVyICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHNlbGYucmVuZGVyKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscyk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGogPCB2YWx1ZUxlbmd0aDsgKytqKSB7XG4gICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB0aGUgc2VjdGlvbiBjb250YWlucy5cbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJJbnZlcnRlZCA9IGZ1bmN0aW9uIHJlbmRlckludmVydGVkICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg2XG4gICAgaWYgKCF2YWx1ZSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSlcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyUGFydGlhbCA9IGZ1bmN0aW9uIHJlbmRlclBhcnRpYWwgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscykge1xuICAgIGlmICghcGFydGlhbHMpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24ocGFydGlhbHMpID8gcGFydGlhbHModG9rZW5bMV0pIDogcGFydGlhbHNbdG9rZW5bMV1dO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRoaXMucGFyc2UodmFsdWUpLCBjb250ZXh0LCBwYXJ0aWFscywgdmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG11c3RhY2hlLmVzY2FwZSh2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICAgIHJldHVybiB0b2tlblsxXTtcbiAgfTtcblxuICBtdXN0YWNoZS5uYW1lID0gJ211c3RhY2hlLmpzJztcbiAgbXVzdGFjaGUudmVyc2lvbiA9ICcyLjIuMCc7XG4gIG11c3RhY2hlLnRhZ3MgPSBbICd7eycsICd9fScgXTtcblxuICAvLyBBbGwgaGlnaC1sZXZlbCBtdXN0YWNoZS4qIGZ1bmN0aW9ucyB1c2UgdGhpcyB3cml0ZXIuXG4gIHZhciBkZWZhdWx0V3JpdGVyID0gbmV3IFdyaXRlcigpO1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgbXVzdGFjaGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAgICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gICAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgIGFuZCBgcGFydGlhbHNgIHVzaW5nIHRoZVxuICAgKiBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUhIFRlbXBsYXRlIHNob3VsZCBiZSBhIFwic3RyaW5nXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdidXQgXCInICsgdHlwZVN0cih0ZW1wbGF0ZSkgKyAnXCIgd2FzIGdpdmVuIGFzIHRoZSBmaXJzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50IGZvciBtdXN0YWNoZSNyZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjQueC4sXG4gIC8qZXNsaW50LWRpc2FibGUgKi8gLy8gZXNsaW50IHdhbnRzIGNhbWVsIGNhc2VkIGZ1bmN0aW9uIG5hbWVcbiAgbXVzdGFjaGUudG9faHRtbCA9IGZ1bmN0aW9uIHRvX2h0bWwgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgc2VuZCkge1xuICAgIC8qZXNsaW50LWVuYWJsZSovXG5cbiAgICB2YXIgcmVzdWx0ID0gbXVzdGFjaGUucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZW5kKSkge1xuICAgICAgc2VuZChyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIGVzY2FwaW5nIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHVzZXIgbWF5IG92ZXJyaWRlIGl0LlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzI0NFxuICBtdXN0YWNoZS5lc2NhcGUgPSBlc2NhcGVIdG1sO1xuXG4gIC8vIEV4cG9ydCB0aGVzZSBtYWlubHkgZm9yIHRlc3RpbmcsIGJ1dCBhbHNvIGZvciBhZHZhbmNlZCB1c2FnZS5cbiAgbXVzdGFjaGUuU2Nhbm5lciA9IFNjYW5uZXI7XG4gIG11c3RhY2hlLkNvbnRleHQgPSBDb250ZXh0O1xuICBtdXN0YWNoZS5Xcml0ZXIgPSBXcml0ZXI7XG5cbn0pKTtcbiIsIi8qIG9iamVjdC1pdGVyYXRvcnMuanMgLSBNaW5pIFVuZGVyc2NvcmUgbGlicmFyeVxuICogYnkgSm9uYXRoYW4gRWl0ZW5cbiAqXG4gKiBUaGUgbWV0aG9kcyBiZWxvdyBvcGVyYXRlIG9uIG9iamVjdHMgKGJ1dCBub3QgYXJyYXlzKSBzaW1pbGFybHlcbiAqIHRvIFVuZGVyc2NvcmUgKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNjb2xsZWN0aW9ucykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L29iamVjdC1pdGVyYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3Igb25lIG1ldGhvZCBjYWxsLlxuICogQERlc2MgTm90ZSB0aGF0IHRoZSBgbmV3YCBrZXl3b3JkIGlzIG5vdCBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gb2JqZWN0IC0gYG51bGxgIG9yIGB1bmRlZmluZWRgIGlzIHRyZWF0ZWQgYXMgYW4gZW1wdHkgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybiB7V3JhcHBlcn0gVGhlIHdyYXBwZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBXcmFwcGVyKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyYXBwZXIob2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5vcmlnaW5hbFZhbHVlID0gb2JqZWN0O1xuICAgIHRoaXMubyA9IG9iamVjdCB8fCB7fTtcbn1cblxuLyoqXG4gKiBAbmFtZSBXcmFwcGVyLmNoYWluXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3IgYSBjaGFpbiBvZiBtZXRob2QgY2FsbHMuXG4gKiBARGVzYyBDYWxscyB0aGUgY29uc3RydWN0b3IgYFdyYXBwZXIoKWAgYW5kIG1vZGlmaWVzIHRoZSB3cmFwcGVyIGZvciBjaGFpbmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1dyYXBwZXJ9IFRoZSB3cmFwcGVkIG9iamVjdC5cbiAqL1xuV3JhcHBlci5jaGFpbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgd3JhcHBlZCA9IFdyYXBwZXIob2JqZWN0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgd3JhcHBlZC5jaGFpbmluZyA9IHRydWU7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG5XcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBVbndyYXAgYW4gb2JqZWN0IHdyYXBwZWQgd2l0aCB7QGxpbmsgV3JhcHBlci5jaGFpbnxXcmFwcGVyLmNoYWluKCl9LlxuICAgICAqIEByZXR1cm4ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gVGhlIHZhbHVlIG9yaWdpbmFsbHkgd3JhcHBlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZWFjaF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2VhY2gpIG1ldGhvZDogSXRlcmF0ZSBvdmVyIHRoZSBtZW1iZXJzIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgY2FsbGluZyBgaXRlcmF0ZWUoKWAgd2l0aCBlYWNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGAodmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBpcyB1bmRlZmluZWQ7IGFuIGAuZWFjaGAgbG9vcCBjYW5ub3QgYmUgYnJva2VuIG91dCBvZiAodXNlIHtAbGluayBXcmFwcGVyI2ZpbmR8LmZpbmR9IGluc3RlYWQpLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uIChpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpdGVyYXRlZS5jYWxsKHRoaXMsIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2ZpbmRdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNmaW5kKSBtZXRob2Q6IExvb2sgdGhyb3VnaCBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHJldHVybmluZyB0aGUgZmlyc3Qgb25lIHRoYXQgcGFzc2VzIGEgdHJ1dGggdGVzdCAoYHByZWRpY2F0ZWApLCBvciBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYWNjZXB0YWJsZSBtZW1iZXIsIGFuZCBkb2Vzbid0IG5lY2Vzc2FyaWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmb3VuZCBwcm9wZXJ0eSdzIHZhbHVlLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPYmplY3Qua2V5cyhvKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pO1xuICAgICAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9bcmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtmaWx0ZXJdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNmaWx0ZXIpIG1ldGhvZDogTG9vayB0aHJvdWdoIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgcmV0dXJuaW5nIHRoZSB2YWx1ZXMgb2YgYWxsIG1lbWJlcnMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdCAoYHByZWRpY2F0ZWApLCBvciBlbXB0eSBhcnJheSBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiBhbHdheXMgdHJhdmVyc2VzIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzLCBvW2tleV0sIGtleSwgbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjb250ZXh0IHx8IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW21hcF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI21hcCkgbWV0aG9kOiBQcm9kdWNlcyBhIG5ldyBhcnJheSBvZiB2YWx1ZXMgYnkgbWFwcGluZyBlYWNoIHZhbHVlIGluIGxpc3QgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIChgaXRlcmF0ZWVgKS4gVGhlIGZ1bmN0aW9uIGFsd2F5cyB0cmF2ZXJzZXMgdGhlIGVudGlyZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBGb3IgZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogYCh2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGNvbmNhdGVuYXRlZCB0byB0aGUgZW5kIG9mIHRoZSBuZXcgYXJyYXkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGdpdmVuLCBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBvYmplY3QgYmVjb21lcyB0aGUgYHRoaXNgIHZhbHVlIGluIHRoZSBjYWxscyB0byBgcHJlZGljYXRlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFwOiBmdW5jdGlvbiAoaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdGVlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbcmVkdWNlXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jcmVkdWNlKSBtZXRob2Q6IEJvaWwgZG93biB0aGUgdmFsdWVzIG9mIGFsbCB0aGUgbWVtYmVycyBvZiB0aGUgd3JhcHBlZCBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZS4gYG1lbW9gIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24sIGFuZCBlYWNoIHN1Y2Nlc3NpdmUgc3RlcCBvZiBpdCBzaG91bGQgYmUgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlKClgLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogYChtZW1vLCB2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgdGhlIG5ldyB2YWx1ZSBvZiBgbWVtb2AgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFttZW1vXSAtIElmIG5vIG1lbW8gaXMgcGFzc2VkIHRvIHRoZSBpbml0aWFsIGludm9jYXRpb24gb2YgcmVkdWNlLCB0aGUgaXRlcmF0ZWUgaXMgbm90IGludm9rZWQgb24gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3QuIFRoZSBmaXJzdCBlbGVtZW50IGlzIGluc3RlYWQgcGFzc2VkIGFzIHRoZSBtZW1vIGluIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBpdGVyYXRlZSBvbiB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgYG1lbW9gIFwicmVkdWNlZFwiIGFzIHBlciBgaXRlcmF0ZWVgLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlZHVjZTogZnVuY3Rpb24gKGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gKCFpZHggJiYgbWVtbyA9PT0gdW5kZWZpbmVkKSA/IG9ba2V5XSA6IGl0ZXJhdGVlKG1lbW8sIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2V4dGVuZF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2V4dGVuZCkgbWV0aG9kOiBDb3B5IGFsbCBvZiB0aGUgcHJvcGVydGllcyBpbiBlYWNoIG9mIHRoZSBgc291cmNlYCBvYmplY3QgcGFyYW1ldGVyKHMpIG92ZXIgdG8gdGhlICh3cmFwcGVkKSBkZXN0aW5hdGlvbiBvYmplY3QgKHRodXMgbXV0YXRpbmcgaXQpLiBJdCdzIGluLW9yZGVyLCBzbyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBgc291cmNlYCBvYmplY3Qgd2lsbCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZSBpbiBwcmV2aW91cyBhcmd1bWVudHMgb3IgaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiA+IFRoaXMgbWV0aG9kIGNvcGllcyBvd24gbWVtYmVycyBhcyB3ZWxsIGFzIG1lbWJlcnMgaW5oZXJpdGVkIGZyb20gcHJvdG90eXBlIGNoYWluLlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzb3VyY2UgLSBWYWx1ZXMgb2YgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFyZSB0cmVhdGVkIGFzIGVtcHR5IHBsYWluIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7V3JhcHBlcnxvYmplY3R9IFRoZSB3cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdCBpZiBjaGFpbmluZyBpcyBpbiBlZmZlY3Q7IG90aGVyd2lzZSB0aGUgdW53cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmluZyA/IHRoaXMgOiBvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtleHRlbmRPd25dKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNleHRlbmRPd24pIG1ldGhvZDogTGlrZSB7QGxpbmsgV3JhcHBlciNleHRlbmR8ZXh0ZW5kfSwgYnV0IG9ubHkgY29waWVzIGl0cyBcIm93blwiIHByb3BlcnRpZXMgb3ZlciB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzb3VyY2UgLSBWYWx1ZXMgb2YgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFyZSB0cmVhdGVkIGFzIGVtcHR5IHBsYWluIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7V3JhcHBlcnxvYmplY3R9IFRoZSB3cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdCBpZiBjaGFpbmluZyBpcyBpbiBlZmZlY3Q7IG90aGVyd2lzZSB0aGUgdW53cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRlbmRPd246IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBXcmFwcGVyKG9iamVjdCkuZWFjaChmdW5jdGlvbiAodmFsLCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgICAgICAgICAgb1trZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmluZyA/IHRoaXMgOiBvO1xuICAgIH1cbn07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRcbmlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRlbmQtbmF0aXZlXG4gICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEBtb2R1bGUgb3ZlcnJpZGVyICovXG5cbi8qKlxuICogTWl4ZXMgbWVtYmVycyBvZiBhbGwgYHNvdXJjZXNgIGludG8gYHRhcmdldGAsIGhhbmRsaW5nIGdldHRlcnMgYW5kIHNldHRlcnMgcHJvcGVybHkuXG4gKlxuICogQW55IG51bWJlciBvZiBgc291cmNlc2Agb2JqZWN0cyBtYXkgYmUgZ2l2ZW4gYW5kIGVhY2ggaXMgY29waWVkIGluIHR1cm4uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBvdmVycmlkZXIgPSByZXF1aXJlKCdvdmVycmlkZXInKTtcbiAqIHZhciB0YXJnZXQgPSB7IGE6IDEgfSwgc291cmNlMSA9IHsgYjogMiB9LCBzb3VyY2UyID0geyBjOiAzIH07XG4gKiB0YXJnZXQgPT09IG92ZXJyaWRlcih0YXJnZXQsIHNvdXJjZTEsIHNvdXJjZTIpOyAvLyB0cnVlXG4gKiAvLyB0YXJnZXQgb2JqZWN0IG5vdyBoYXMgYSwgYiwgYW5kIGM7IHNvdXJjZSBvYmplY3RzIHVudG91Y2hlZFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byByZWNlaXZlIHNvdXJjZXMuXG4gKiBAcGFyYW0gey4uLm9iamVjdH0gW3NvdXJjZXNdIC0gT2JqZWN0KHMpIGNvbnRhaW5pbmcgbWVtYmVycyB0byBjb3B5IHRvIGB0YXJnZXRgLiAoT21pdHRpbmcgaXMgYSBuby1vcC4pXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgdGFyZ2V0IG9iamVjdCAoYHRhcmdldGApXG4gKi9cbmZ1bmN0aW9uIG92ZXJyaWRlcih0YXJnZXQsIHNvdXJjZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1peEluLmNhbGwodGFyZ2V0LCBhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWl4IGB0aGlzYCBtZW1iZXJzIGludG8gYHRhcmdldGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEEuIFNpbXBsZSB1c2FnZSAodXNpbmcgLmNhbGwpOlxuICogdmFyIG1peEluVG8gPSByZXF1aXJlKCdvdmVycmlkZXInKS5taXhJblRvO1xuICogdmFyIHRhcmdldCA9IHsgYTogMSB9LCBzb3VyY2UgPSB7IGI6IDIgfTtcbiAqIHRhcmdldCA9PT0gb3ZlcnJpZGVyLm1peEluVG8uY2FsbChzb3VyY2UsIHRhcmdldCk7IC8vIHRydWVcbiAqIC8vIHRhcmdldCBvYmplY3Qgbm93IGhhcyBib3RoIGEgYW5kIGI7IHNvdXJjZSBvYmplY3QgdW50b3VjaGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEIuIFNlbWFudGljIHVzYWdlICh3aGVuIHRoZSBzb3VyY2UgaG9zdHMgdGhlIG1ldGhvZCk6XG4gKiB2YXIgbWl4SW5UbyA9IHJlcXVpcmUoJ292ZXJyaWRlcicpLm1peEluVG87XG4gKiB2YXIgdGFyZ2V0ID0geyBhOiAxIH0sIHNvdXJjZSA9IHsgYjogMiwgbWl4SW5UbzogbWl4SW5UbyB9O1xuICogdGFyZ2V0ID09PSBzb3VyY2UubWl4SW5Ubyh0YXJnZXQpOyAvLyB0cnVlXG4gKiAvLyB0YXJnZXQgb2JqZWN0IG5vdyBoYXMgYm90aCBhIGFuZCBiOyBzb3VyY2Ugb2JqZWN0IHVudG91Y2hlZFxuICpcbiAqIEB0aGlzIHtvYmplY3R9IFRhcmdldC5cbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSB0YXJnZXQgb2JqZWN0IChgdGFyZ2V0YClcbiAqIEBtZW1iZXJPZiBtb2R1bGU6b3ZlcnJpZGVyXG4gKi9cbmZ1bmN0aW9uIG1peEluVG8odGFyZ2V0KSB7XG4gICAgdmFyIGRlc2NyaXB0b3I7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgaWYgKChkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBrZXkpKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1peCBgc291cmNlYCBtZW1iZXJzIGludG8gYHRoaXNgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBLiBTaW1wbGUgdXNhZ2UgKHVzaW5nIC5jYWxsKTpcbiAqIHZhciBtaXhJbiA9IHJlcXVpcmUoJ292ZXJyaWRlcicpLm1peEluO1xuICogdmFyIHRhcmdldCA9IHsgYTogMSB9LCBzb3VyY2UgPSB7IGI6IDIgfTtcbiAqIHRhcmdldCA9PT0gb3ZlcnJpZGVyLm1peEluLmNhbGwodGFyZ2V0LCBzb3VyY2UpIC8vIHRydWVcbiAqIC8vIHRhcmdldCBvYmplY3Qgbm93IGhhcyBib3RoIGEgYW5kIGI7IHNvdXJjZSBvYmplY3QgdW50b3VjaGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEIuIFNlbWFudGljIHVzYWdlICh3aGVuIHRoZSB0YXJnZXQgaG9zdHMgdGhlIG1ldGhvZCk6XG4gKiB2YXIgbWl4SW4gPSByZXF1aXJlKCdvdmVycmlkZXInKS5taXhJbjtcbiAqIHZhciB0YXJnZXQgPSB7IGE6IDEsIG1peEluOiBtaXhJbiB9LCBzb3VyY2UgPSB7IGI6IDIgfTtcbiAqIHRhcmdldCA9PT0gdGFyZ2V0Lm1peEluKHNvdXJjZSkgLy8gdHJ1ZVxuICogLy8gdGFyZ2V0IG5vdyBoYXMgYm90aCBhIGFuZCBiIChhbmQgbWl4SW4pOyBzb3VyY2UgdW50b3VjaGVkXG4gKlxuICogQHBhcmFtIHNvdXJjZVxuICogQHJldHVybnMge29iamVjdH0gVGhlIHRhcmdldCBvYmplY3QgKGB0aGlzYClcbiAqIEBtZW1iZXJPZiBvdmVycmlkZXJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6b3ZlcnJpZGVyXG4gKi9cbmZ1bmN0aW9uIG1peEluKHNvdXJjZSkge1xuICAgIHZhciBkZXNjcmlwdG9yO1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKChkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxub3ZlcnJpZGVyLm1peEluVG8gPSBtaXhJblRvO1xub3ZlcnJpZGVyLm1peEluID0gbWl4SW47XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlcnJpZGVyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJFR0VYUF9JTkRJUkVDVElPTiA9IC9eKFxcdyspXFwoKFxcdyspXFwpJC87ICAvLyBmaW5kcyBjb21wbGV0ZSBwYXR0ZXJuIGEoYikgd2hlcmUgYm90aCBhIGFuZCBiIGFyZSByZWdleCBcIndvcmRzXCJcblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IHZhbHVlSXRlbVxuICogWW91IHNob3VsZCBzdXBwbHkgYm90aCBgbmFtZWAgYW5kIGBhbGlhc2AgYnV0IHlvdSBjb3VsZCBvbWl0IG9uZSBvciB0aGUgb3RoZXIgYW5kIHdoaWNoZXZlciB5b3UgcHJvdmlkZSB3aWxsIGJlIHVzZWQgZm9yIGJvdGguXG4gKiA+IElmIHlvdSBvbmx5IGdpdmUgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgeW91IG1pZ2h0IGFzIHdlbGwganVzdCBnaXZlIGEgc3RyaW5nIGZvciB7QGxpbmsgbWVudUl0ZW19IHJhdGhlciB0aGFuIHRoaXMgb2JqZWN0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lPWFsaWFzXSAtIFZhbHVlIG9mIGB2YWx1ZWAgYXR0cmlidXRlIG9mIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWxpYXM9bmFtZV0gLSBUZXh0IG9mIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZV0gT25lIG9mIHRoZSBrZXlzIG9mIGB0aGlzLmNvbnZlcnRlcnNgLiBJZiBub3Qgb25lIG9mIHRoZXNlIChpbmNsdWRpbmcgYHVuZGVmaW5lZGApLCBmaWVsZCB2YWx1ZXMgd2lsbCBiZSB0ZXN0ZWQgd2l0aCBhIHN0cmluZyBjb21wYXJpc29uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaGlkZGVuPWZhbHNlXVxuICovXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fG1lbnVJdGVtW119IHN1Ym1lbnVJdGVtXG4gKiBAc3VtbWFyeSBIaWVyYXJjaGljYWwgYXJyYXkgb2Ygc2VsZWN0IGxpc3QgaXRlbXMuXG4gKiBAZGVzYyBEYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgYDxvcHRpb24+Li4uPC9vcHRpb24+YCBhbmQgYDxvcHRncm91cD4uLi48L29wdGdyb3VwPmAgZWxlbWVudHMgdGhhdCBtYWtlIHVwIGEgYDxzZWxlY3Q+Li4uPC9zZWxlY3Q+YCBlbGVtZW50LlxuICpcbiAqID4gQWx0ZXJuYXRlIGZvcm06IEluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggYSBgbWVudWAgcHJvcGVydHkgY29udGFpbmluZyBhbiBhcnJheSwgbWF5IGl0c2VsZiBiZSB0aGF0IGFycmF5LiBCb3RoIGZvcm1zIGhhdmUgdGhlIG9wdGlvbmFsIGBsYWJlbGAgcHJvcGVydHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xhYmVsXSAtIERlZmF1bHRzIHRvIGEgZ2VuZXJhdGVkIHN0cmluZyBvZiB0aGUgZm9ybSBcIkdyb3VwIG5bLm1dLi4uXCIgd2hlcmUgZWFjaCBkZWNpbWFsIHBvc2l0aW9uIHJlcHJlc2VudHMgYSBsZXZlbCBvZiB0aGUgb3B0Z3JvdXAgaGllcmFyY2h5LlxuICogQHByb3BlcnR5IHttZW51SXRlbVtdfSBzdWJtZW51XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtzdHJpbmd8dmFsdWVJdGVtfHN1Ym1lbnVJdGVtfSBtZW51SXRlbVxuICogTWF5IGJlIG9uZSBvZiB0aHJlZSBwb3NzaWJsZSB0eXBlcyB0aGF0IHNwZWNpZnkgZWl0aGVyIGFuIGA8b3B0aW9uPi4uLi48L29wdGlvbj5gIGVsZW1lbnQgb3IgYW4gYDxvcHRncm91cD4uLi4uPC9vcHRncm91cD5gIGVsZW1lbnQgYXMgZm9sbG93czpcbiAqICogSWYgYSBgc3RyaW5nYCwgc3BlY2lmaWVzIHRoZSB0ZXh0IG9mIGFuIGA8b3B0aW9uPi4uLi48L29wdGlvbj5gIGVsZW1lbnQgd2l0aCBubyBgdmFsdWVgIGF0dHJpYnV0ZS4gKEluIHRoZSBhYnNlbmNlIG9mIGEgYHZhbHVlYCBhdHRyaWJ1dGUsIHRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIHRoZSBlbGVtZW50IGRlZmF1bHRzIHRvIHRoZSB0ZXh0LilcbiAqICogSWYgc2hhcGVkIGxpa2UgYSB7QGxpbmsgdmFsdWVJdGVtfSBvYmplY3QsIHNwZWNpZmllcyBib3RoIHRoZSB0ZXh0IGFuZCB2YWx1ZSBvZiBhbiBgPG9wdGlvbi4uLi48L29wdGlvbj5gIGVsZW1lbnQuXG4gKiAqIElmIHNoYXBlZCBsaWtlIGEge0BsaW5rIHN1Ym1lbnVJdGVtfSBvYmplY3QgKG9yIGl0cyBhbHRlcm5hdGUgYXJyYXkgZm9ybSksIHNwZWNpZmllcyBhbiBgPG9wdGdyb3VwPi4uLi48L29wdGdyb3VwPmAgZWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIEBzdW1tYXJ5IEJ1aWxkcyBhIG5ldyBtZW51IHByZS1wb3B1bGF0ZWQgd2l0aCBpdGVtcyBhbmQgZ3JvdXBzLlxuICogQGRlc2MgVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IHBvcC11cCBtZW51IChhLmsuYS4gXCJkcm9wLWRvd25cIikuIFRoaXMgaXMgYSBgPHNlbGVjdD4uLi48L3NlbGVjdD5gIGVsZW1lbnQsIHByZS1wb3B1bGF0ZWQgd2l0aCBpdGVtcyAoYDxvcHRpb24+Li4uPC9vcHRpb24+YCBlbGVtZW50cykgYW5kIGdyb3VwcyAoYDxvcHRncm91cD4uLi48L29wdGdyb3VwPmAgZWxlbWVudHMpLlxuICogPiBCb251czogVGhpcyBmdW5jdGlvbiBhbHNvIGJ1aWxkcyBgaW5wdXQgdHlwZT10ZXh0YCBlbGVtZW50cy5cbiAqID4gTk9URTogVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgT1BUR1JPVVAgZWxlbWVudHMgZm9yIHN1YnRyZWVzLiBIb3dldmVyLCBub3RlIHRoYXQgSFRNTDUgc3BlY2lmaWVzIHRoYXQgT1BUR1JPVVAgZWxlbW5lbnRzIG1hZGUgbm90IG5lc3QhIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIHRoZSBtYXJrdXAgZm9yIHRoZW0gYnV0IHRoZXkgYXJlIG5vdCByZW5kZXJlZCBieSBtb3N0IGJyb3dzZXJzLCBvciBub3QgY29tcGxldGVseS4gVGhlcmVmb3JlLCBmb3Igbm93LCBkbyBub3Qgc3BlY2lmeSBtb3JlIHRoYW4gb25lIGxldmVsIHN1YnRyZWVzLiBGdXR1cmUgdmVyc2lvbnMgb2YgSFRNTCBtYXkgc3VwcG9ydCBpdC4gSSBhbHNvIHBsYW4gdG8gYWRkIGhlcmUgb3B0aW9ucyB0byBhdm9pZCBPUFRHUk9VUFMgZW50aXJlbHkgZWl0aGVyIGJ5IGluZGVudGluZyBvcHRpb24gdGV4dCwgb3IgYnkgY3JlYXRpbmcgYWx0ZXJuYXRlIERPTSBub2RlcyB1c2luZyBgPGxpPmAgaW5zdGVhZCBvZiBgPHNlbGVjdD5gLCBvciBib3RoLlxuICogQG1lbWJlck9mIHBvcE1lbnVcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbCAtIE11c3QgYmUgb25lIG9mIChjYXNlLXNlbnNpdGl2ZSk6XG4gKiAqIHRleHQgYm94IC0gYW4gYEhUTUxJbnB1dEVsZW1lbnRgIHRvIHVzZSBhbiBleGlzdGluZyBlbGVtZW50IG9yIGAnSU5QVVQnYCB0byBjcmVhdGUgYSBuZXcgb25lXG4gKiAqIGRyb3AtZG93biAtIGFuIGBIVE1MU2VsZWN0RWxlbWVudGAgdG8gdXNlIGFuIGV4aXN0aW5nIGVsZW1lbnQgb3IgYCdTRUxFQ1QnYCB0byBjcmVhdGUgYSBuZXcgb25lXG4gKiAqIHN1Ym1lbnUgLSBhbiBgSFRNTE9wdEdyb3VwRWxlbWVudGAgdG8gdXNlIGFuIGV4aXN0aW5nIGVsZW1lbnQgb3IgYCdPUFRHUk9VUCdgIHRvIGNyZWF0ZSBhIG5ldyBvbmUgKG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seSlcbiAqXG4gKiBAcGFyYW0ge21lbnVJdGVtW119IFttZW51XSAtIEhpZXJhcmNoaWNhbCBsaXN0IG9mIHN0cmluZ3MgdG8gYWRkIGFzIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgb3IgYDxvcHRncm91cD4uLi4uPC9vcHRncm91cD5gIGVsZW1lbnRzLiBPbWl0dGluZyBjcmVhdGVzIGEgdGV4dCBib3guXG4gKlxuICogQHBhcmFtIHtudWxsfHN0cmluZ30gW29wdGlvbnMucHJvbXB0PScnXSAtIEFkZHMgYW4gaW5pdGlhbCBgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnQgdG8gdGhlIGRyb3AtZG93biB3aXRoIHRoaXMgdmFsdWUgaW4gcGFyZW50aGVzZXMgYXMgaXRzIGB0ZXh0YDsgYW5kIGVtcHR5IHN0cmluZyBhcyBpdHMgYHZhbHVlYC4gRGVmYXVsdCBpcyBlbXB0eSBzdHJpbmcsIHdoaWNoIGNyZWF0ZXMgYSBibGFuayBwcm9tcHQ7IGBudWxsYCBzdXBwcmVzc2VzIHByb21wdCBhbHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc29ydF0gLSBXaGV0aGVyIHRvIGFscGhhIHNvcnQgb3Igbm90LiBJZiB0cnV0aHksIHNvcnRzIGVhY2ggb3B0Z3JvdXAgb24gaXRzIGBsYWJlbGA7IGFuZCBlYWNoIHNlbGVjdCBvcHRpb24gb24gaXRzIHRleHQgKGl0cyBgYWxpYXNgIGlmIGdpdmVuOyBvciBpdHMgYG5hbWVgIGlmIG5vdCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuYmxhY2tsaXN0XSAtIE9wdGlvbmFsIGxpc3Qgb2YgbWVudSBpdGVtIG5hbWVzIHRvIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gW29wdGlvbnMuYnJlYWRjcnVtYnNdIC0gTGlzdCBvZiBvcHRpb24gZ3JvdXAgc2VjdGlvbiBudW1iZXJzIChyb290IGlzIHNlY3Rpb24gMCkuIChGb3IgaW50ZXJuYWwgdXNlLilcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGVuZD1mYWxzZV0gLSBXaGVuIGBlbGAgaXMgYW4gZXhpc3RpbmcgYDxzZWxlY3Q+YCBFbGVtZW50LCBnaXZpbmcgdHJ1dGh5IHZhbHVlIGFkZHMgdGhlIG5ldyBjaGlsZHJlbiB3aXRob3V0IGZpcnN0IHJlbW92aW5nIGV4aXN0aW5nIGNoaWxkcmVuLlxuICpcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBFaXRoZXIgYSBgPHNlbGVjdD5gIG9yIGA8b3B0Z3JvdXA+YCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBidWlsZChlbCwgbWVudSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHByb21wdCA9IG9wdGlvbnMucHJvbXB0LFxuICAgICAgICBibGFja2xpc3QgPSBvcHRpb25zLmJsYWNrbGlzdCxcbiAgICAgICAgc29ydCA9IG9wdGlvbnMuc29ydCxcbiAgICAgICAgYnJlYWRjcnVtYnMgPSBvcHRpb25zLmJyZWFkY3J1bWJzIHx8IFtdLFxuICAgICAgICBwYXRoID0gYnJlYWRjcnVtYnMubGVuZ3RoID8gYnJlYWRjcnVtYnMuam9pbignLicpICsgJy4nIDogJycsXG4gICAgICAgIHN1YnRyZWVOYW1lID0gcG9wTWVudS5zdWJ0cmVlLFxuICAgICAgICBncm91cEluZGV4ID0gMCxcbiAgICAgICAgdGFnTmFtZTtcblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgdGFnTmFtZSA9IGVsLnRhZ05hbWU7XG4gICAgICAgIGlmICghb3B0aW9ucy5hcHBlbmQpIHtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9ICcnOyAvLyByZW1vdmUgYWxsIDxvcHRpb24+IGFuZCA8b3B0Z3JvdXA+IGVsZW1lbnRzXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0YWdOYW1lID0gZWw7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAobWVudSkge1xuICAgICAgICB2YXIgYWRkLCBuZXdPcHRpb247XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgICAgYWRkID0gZWwuYWRkO1xuICAgICAgICAgICAgaWYgKHByb21wdCkge1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbiA9IG5ldyBPcHRpb24ocHJvbXB0LCAnJyk7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uLmlubmVySFRNTCArPSAnJmhlbGxpcDsnO1xuICAgICAgICAgICAgICAgIGVsLmFkZChuZXdPcHRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9tcHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbC5hZGQobmV3IE9wdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZCA9IGVsLmFwcGVuZENoaWxkO1xuICAgICAgICAgICAgZWwubGFiZWwgPSBwcm9tcHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgbWVudSA9IG1lbnUuc2xpY2UoKS5zb3J0KGl0ZW1Db21wYXJhdG9yKTsgLy8gc29ydGVkIGNsb25lXG4gICAgICAgIH1cblxuICAgICAgICBtZW51LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gaWYgaXRlbSBpcyBvZiBmb3JtIGEoYikgYW5kIHRoZXJlIGlzIGFuIGZ1bmN0aW9uIGEgaW4gb3B0aW9ucywgdGhlbiBpdGVtID0gb3B0aW9ucy5hKGIpXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kaXJlY3Rpb24gPSBpdGVtLm1hdGNoKFJFR0VYUF9JTkRJUkVDVElPTik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5kaXJlY3Rpb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gaW5kaXJlY3Rpb25bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gb3B0aW9uc1thXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gZihiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdidWlsZDogRXhwZWN0ZWQgb3B0aW9ucy4nICsgYSArICcgdG8gYmUgYSBmdW5jdGlvbi4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3VidHJlZSA9IGl0ZW1bc3VidHJlZU5hbWVdIHx8IGl0ZW07XG4gICAgICAgICAgICBpZiAoc3VidHJlZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBicmVhZGNydW1iczogYnJlYWRjcnVtYnMuY29uY2F0KCsrZ3JvdXBJbmRleCksXG4gICAgICAgICAgICAgICAgICAgIHByb21wdDogaXRlbS5sYWJlbCB8fCAnR3JvdXAgJyArIHBhdGggKyBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBzb3J0LFxuICAgICAgICAgICAgICAgICAgICBibGFja2xpc3Q6IGJsYWNrbGlzdFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgb3B0Z3JvdXAgPSBidWlsZCgnT1BUR1JPVVAnLCBzdWJ0cmVlLCBncm91cE9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGdyb3VwLmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG9wdGdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShibGFja2xpc3QgJiYgYmxhY2tsaXN0LmluZGV4T2YoaXRlbSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkLmNhbGwoZWwsIG5ldyBPcHRpb24oaXRlbSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5oaWRkZW4pIHtcblxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gaXRlbS5uYW1lIHx8IGl0ZW0uYWxpYXM7XG4gICAgICAgICAgICAgICAgaWYgKCEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdC5pbmRleE9mKG5hbWUpID49IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZC5jYWxsKGVsLCBuZXcgT3B0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hbGlhcyB8fCBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbC50eXBlID0gJ3RleHQnO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gaXRlbUNvbXBhcmF0b3IoYSwgYikge1xuICAgIGEgPSBhLmFsaWFzIHx8IGEubmFtZSB8fCBhLmxhYmVsIHx8IGE7XG4gICAgYiA9IGIuYWxpYXMgfHwgYi5uYW1lIHx8IGIubGFiZWwgfHwgYjtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgUmVjdXJzaXZlbHkgc2VhcmNoZXMgdGhlIGNvbnRleHQgYXJyYXkgb2YgYG1lbnVJdGVtYHMgZm9yIGEgbmFtZWQgYGl0ZW1gLlxuICogQG1lbWJlck9mIHBvcE1lbnVcbiAqIEB0aGlzIEFycmF5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2V5cz1bcG9wTWVudS5kZWZhdWx0S2V5XV0gLSBQcm9wZXJ0aWVzIHRvIHNlYXJjaCBlYWNoIG1lbnVJdGVtIHdoZW4gaXQgaXMgYW4gb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jYXNlU2Vuc2l0aXZlPWZhbHNlXSAtIElnbm9yZSBjYXNlIHdoaWxlIHNlYXJjaGluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfG1lbnVJdGVtfSBUaGUgZm91bmQgaXRlbSBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cChvcHRpb25zLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhbHVlID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgc2hhbGxvdywgZGVlcCwgaXRlbSwgcHJvcCxcbiAgICAgICAga2V5cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5rZXlzIHx8IFtwb3BNZW51LmRlZmF1bHRLZXldLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhc2VTZW5zaXRpdmU7XG5cbiAgICB2YWx1ZSA9IHRvU3RyaW5nKHZhbHVlLCBjYXNlU2Vuc2l0aXZlKTtcblxuICAgIHNoYWxsb3cgPSB0aGlzLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgc3VidHJlZSA9IGl0ZW1bcG9wTWVudS5zdWJ0cmVlXSB8fCBpdGVtO1xuXG4gICAgICAgIGlmIChzdWJ0cmVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZGVlcCA9IGxvb2t1cC5jYWxsKHN1YnRyZWUsIG9wdGlvbnMsIHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcoaXRlbSwgY2FzZVNlbnNpdGl2ZSkgPT09IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGl0ZW1ba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgJiYgdG9TdHJpbmcocHJvcCwgY2FzZVNlbnNpdGl2ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXRlbSA9IGRlZXAgfHwgc2hhbGxvdztcblxuICAgIHJldHVybiBpdGVtICYmIChpdGVtLm5hbWUgPyBpdGVtIDogeyBuYW1lOiBpdGVtIH0pO1xufVxuXG5mdW5jdGlvbiB0b1N0cmluZyhzLCBjYXNlU2Vuc2l0aXZlKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGlmIChzKSB7XG4gICAgICAgIHJlc3VsdCArPSBzOyAvLyBjb252ZXJ0IHMgdG8gc3RyaW5nXG4gICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBSZWN1cnNpdmVseSB3YWxrcyB0aGUgY29udGV4dCBhcnJheSBvZiBgbWVudUl0ZW1gcyBhbmQgY2FsbHMgYGl0ZXJhdGVlYCBvbiBlYWNoIGl0ZW0gdGhlcmVpbi5cbiAqIEBkZXNjIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggZWFjaCBpdGVtICh0ZXJtaW5hbCBub2RlKSBpbiB0aGUgbWVudSB0cmVlIGFuZCBhIGZsYXQgMC1iYXNlZCBpbmRleC4gUmVjdXJzZXMgb24gbWVtYmVyIHdpdGggbmFtZSBvZiBgcG9wTWVudS5zdWJ0cmVlYC5cbiAqXG4gKiBUaGUgbm9kZSB3aWxsIGFsd2F5cyBiZSBhIHtAbGluayB2YWx1ZUl0ZW19IG9iamVjdDsgd2hlbiBhIGBzdHJpbmdgLCBpdCBpcyBib3hlZCBmb3IgeW91LlxuICpcbiAqIEBtZW1iZXJPZiBwb3BNZW51XG4gKlxuICogQHRoaXMgQXJyYXlcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIEZvciBlYWNoIGl0ZW0gaW4gdGhlIG1lbnUsIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGg6XG4gKiAqIHRoZSBgdmFsdWVJdGVtYCAoaWYgdGhlIGl0ZW0gaXMgYSBwcmltYXRpdmUgc3RyaW5nLCBpdCBpcyB3cmFwcGVkIHVwIGZvciB5b3UpXG4gKiAqIGEgMC1iYXNlZCBgb3JkaW5hbGBcbiAqXG4gKiBUaGUgYGl0ZXJhdGVlYCByZXR1cm4gdmFsdWUgY2FuIGJlIHVzZWQgdG8gcmVwbGFjZSB0aGUgaXRlbSwgYXMgZm9sbG93czpcbiAqICogYHVuZGVmaW5lZGAgLSBkbyBub3RoaW5nXG4gKiAqIGBudWxsYCAtIHNwbGljZSBvdXQgdGhlIGl0ZW07IHJlc3VsdGluZyBlbXB0eSBzdWJtZW51cyBhcmUgYWxzbyBzcGxpY2VkIG91dCAoc2VlIG5vdGUpXG4gKiAqIGFueXRoaW5nIGVsc2UgLSByZXBsYWNlIHRoZSBpdGVtIHdpdGggdGhpcyB2YWx1ZTsgaWYgdmFsdWUgaXMgYSBzdWJ0cmVlIChpLmUuLCBhbiBhcnJheSkgYGl0ZXJhdGVlYCB3aWxsIHRoZW4gYmUgY2FsbGVkIHRvIHdhbGsgaXQgYXMgd2VsbCAoc2VlIG5vdGUpXG4gKlxuICogPiBOb3RlOiBSZXR1cm5pbmcgYW55dGhpbmcgKG90aGVyIHRoYW4gYHVuZGVmaW5lZGApIGZyb20gYGl0ZXJhdGVlYCB3aWxsIChkZWVwbHkpIG11dGF0ZSB0aGUgb3JpZ2luYWwgYG1lbnVgIHNvIHlvdSBtYXkgd2FudCB0byBjb3B5IGl0IGZpcnN0IChkZWVwbHksIGluY2x1ZGluZyBhbGwgbGV2ZWxzIG9mIGFycmF5IG5lc3RpbmcgYnV0IG5vdCB0aGUgdGVybWluYWwgbm9kZSBvYmplY3RzKS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgaXRlbXMgKHRlcm1pbmFsIG5vZGVzKSBpbiB0aGUgbWVudSB0cmVlLlxuICovXG5mdW5jdGlvbiB3YWxrKGl0ZXJhdGVlKSB7XG4gICAgdmFyIG1lbnUgPSB0aGlzLFxuICAgICAgICBvcmRpbmFsID0gMCxcbiAgICAgICAgc3VidHJlZU5hbWUgPSBwb3BNZW51LnN1YnRyZWUsXG4gICAgICAgIGksIGl0ZW0sIHN1YnRyZWUsIG5ld1ZhbDtcblxuICAgIGZvciAoaSA9IG1lbnUubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IG1lbnVbaV07XG4gICAgICAgIHN1YnRyZWUgPSBpdGVtW3N1YnRyZWVOYW1lXSB8fCBpdGVtO1xuXG4gICAgICAgIGlmICghKHN1YnRyZWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIHN1YnRyZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN1YnRyZWUpIHtcbiAgICAgICAgICAgIG5ld1ZhbCA9IGl0ZXJhdGVlKGl0ZW0ubmFtZSA/IGl0ZW0gOiB7IG5hbWU6IGl0ZW0gfSwgb3JkaW5hbCk7XG4gICAgICAgICAgICBvcmRpbmFsICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIG9yZGluYWwgLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZW51W2ldID0gaXRlbSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgc3VidHJlZSA9IGl0ZW1bc3VidHJlZU5hbWVdIHx8IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHN1YnRyZWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VidHJlZSkge1xuICAgICAgICAgICAgb3JkaW5hbCArPSB3YWxrLmNhbGwoc3VidHJlZSwgaXRlcmF0ZWUpO1xuICAgICAgICAgICAgaWYgKHN1YnRyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWVudS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgb3JkaW5hbCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZGluYWw7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgRm9ybWF0IGl0ZW0gbmFtZSB3aXRoIGl0J3MgYWxpYXMgd2hlbiBhdmFpbGFibGUuXG4gKiBAbWVtYmVyT2YgcG9wTWVudVxuICogQHBhcmFtIHtzdHJpbmd8dmFsdWVJdGVtfSBpdGVtXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIG5hbWUgYW5kIGFsaWFzLlxuICovXG5mdW5jdGlvbiBmb3JtYXRJdGVtKGl0ZW0pIHtcbiAgICB2YXIgcmVzdWx0ID0gaXRlbS5uYW1lIHx8IGl0ZW07XG4gICAgaWYgKGl0ZW0uYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0ID0gJ1wiJyArIGl0ZW0uYWxpYXMgKyAnXCIgKCcgKyByZXN1bHQgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNHcm91cFByb3h5KHMpIHtcbiAgICByZXR1cm4gUkVHRVhQX0lORElSRUNUSU9OLnRlc3Qocyk7XG59XG5cbi8qKlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcG9wTWVudSA9IHtcbiAgICBidWlsZDogYnVpbGQsXG4gICAgd2Fsazogd2FsayxcbiAgICBsb29rdXA6IGxvb2t1cCxcbiAgICBmb3JtYXRJdGVtOiBmb3JtYXRJdGVtLFxuICAgIGlzR3JvdXBQcm94eTogaXNHcm91cFByb3h5LFxuICAgIHN1YnRyZWU6ICdzdWJtZW51JyxcbiAgICBkZWZhdWx0S2V5OiAnbmFtZSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcG9wTWVudTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkLW9ubHkgcHJvcGVydHkgYW5kIGF0dGFjaGVzIGl0IHRvIHRoZSBwcm92aWRlZCBjb250ZXh0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBmb3IgbmV3IHByb3BlcnR5LlxuICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gVmFsdWUgb2YgbmV3IHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBhZGRSZWFkT25seVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUG9pbnRcbiAqXG4gKiBAZGVzYyBUaGlzIG9iamVjdCByZXByZXNlbnRzIGEgc2luZ2xlIHBvaW50IGluIGFuIGFic3RyYWN0IDItZGltZW5zaW9uYWwgbWF0cml4LlxuICpcbiAqIFRoZSB1bml0IG9mIG1lYXN1cmUgaXMgdHlwaWNhbGx5IHBpeGVscy5cbiAqIChJZiB1c2VkIHRvIG1vZGVsIGNvbXB1dGVyIGdyYXBoaWNzLCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBhcmUgdHlwaWNhbGx5IG1lYXN1cmVkIGRvd253YXJkc1xuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB3aW5kb3cuIFRoaXMgY29udmVudGlvbiBob3dldmVyIGlzIG5vdCBpbmhlcmVudCBpbiB0aGlzIG9iamVjdC4pXG4gKlxuICogTm90ZTogVGhpcyBvYmplY3Qgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIG5ldyBwb2ludCdzIGB4YCBwcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgbmV3IHBvaW50J3MgYHlgIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBzdW1tYXJ5IFRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBQb2ludHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAneCcsIE51bWJlcih4KSB8fCAwKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBzdW1tYXJ5IFRoaXMgcG9pbnQncyB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgUG9pbnR8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ3knLCBOdW1iZXIoeSkgfHwgMCk7XG5cbn1cblxuUG9pbnQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBwb2ludCB3aGljaCBpcyB0aGlzIHBvaW50J3MgcG9zaXRpb24gaW5jcmVhc2VkIGJ5IGNvb3JkaW5hdGVzIG9mIGdpdmVuIGBvZmZzZXRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IG9mZnNldCAtIEhvcml6b250YWwgYW5kIHZlcnRpY2FsIHZhbHVlcyB0byBhZGQgdG8gdGhpcyBwb2ludCdzIGNvb3JkaW5hdGVzLlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwbHVzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMueCArIG9mZnNldC54LFxuICAgICAgICAgICAgdGhpcy55ICsgb2Zmc2V0LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBwb2ludCB3aGljaCBpcyB0aGlzIHBvaW50J3MgcG9zaXRpb24gaW5jcmVhc2VkIGJ5IGdpdmVuIG9mZnNldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRYPTBdIC0gVmFsdWUgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRZPTBdIC0gVmFsdWUgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBsdXNYWTogZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy54ICsgKG9mZnNldFggfHwgMCksXG4gICAgICAgICAgICB0aGlzLnkgKyAob2Zmc2V0WSB8fCAwKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBkZWNyZWFzZWQgYnkgY29vcmRpbmF0ZXMgb2YgZ2l2ZW4gYG9mZnNldGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb2Zmc2V0IC0gSG9yaXpvbnRhbCBhbmQgdmVydGljYWwgdmFsdWVzIHRvIHN1YnRyYWN0IGZyb20gdGhpcyBwb2ludCdzIGNvb3JkaW5hdGVzLlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtaW51czogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggLSBvZmZzZXQueCxcbiAgICAgICAgICAgIHRoaXMueSAtIG9mZnNldC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgYFBvaW50YCBwb3NpdGlvbmVkIHRvIGxlYXN0IHggYW5kIGxlYXN0IHkgb2YgdGhpcyBwb2ludCBhbmQgZ2l2ZW4gYG9mZnNldGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbWluOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMueSwgcG9pbnQueSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBgUG9pbnRgIHBvc2l0aW9uZWQgdG8gZ3JlYXRlc3QgeCBhbmQgZ3JlYXRlc3QgeSBvZiB0aGlzIHBvaW50IGFuZCBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIE1hdGgubWF4KHRoaXMueCwgcG9pbnQueCksXG4gICAgICAgICAgICBNYXRoLm1heCh0aGlzLnksIHBvaW50LnkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IERpc3RhbmNlIGJldHdlZW4gZ2l2ZW4gYHBvaW50YCBhbmQgdGhpcyBwb2ludCB1c2luZyBQeXRoYWdvcmVhbiBUaGVvcmVtIGZvcm11bGEuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IGZyb20gd2hpY2ggdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBwb2ludC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZGVsdGFZID0gcG9pbnQueSAtIHRoaXMueTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgZGVsdGFYICogZGVsdGFYICtcbiAgICAgICAgICAgIGRlbHRhWSAqIGRlbHRhWVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5OiBgZXF1YWxgLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGV4YWN0bHkgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgdGhpcy54ID09PSBwb2ludC54ICYmXG4gICAgICAgICAgICAgICAgdGhpcy55ID09PSBwb2ludC55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGdyZWF0ZXIgdGhhbiB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3JlYXRlclRoYW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPiBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPiBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50XG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxlc3NUaGFuOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy54IDwgcG9pbnQueCAmJlxuICAgICAgICAgICAgdGhpcy55IDwgcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBncmVhdGVyVGhhbkVxdWFsVG9gLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3JlYXRlclRoYW5PckVxdWFsVG86IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPj0gcG9pbnQueCAmJlxuICAgICAgICAgICAgdGhpcy55ID49IHBvaW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseSBgbGVzc1RoYW5FcXVhbFRvYC4pX1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsZXNzVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueCA8PSBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPD0gcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBpc0NvbnRhaW5lZFdpdGhpblJlY3RhbmdsZWAuKV9cbiAgICAgKiBAcGFyYW0gcmVjdCB7UmVjdGFuZ2xlfSAtIFJlY3RhbmdsZSB0byB0ZXN0IHRoaXMgcG9pbnQgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiB0aGlzIHBvaW50IGlzIHdpdGhpbiBnaXZlbiBgcmVjdGAuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIHdpdGhpbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICB2YXIgbWluWCA9IHJlY3Qub3JpZ2luLngsXG4gICAgICAgICAgICBtYXhYID0gbWluWCArIHJlY3QuZXh0ZW50Lng7XG4gICAgICAgIHZhciBtaW5ZID0gcmVjdC5vcmlnaW4ueSxcbiAgICAgICAgICAgIG1heFkgPSBtaW5ZICsgcmVjdC5leHRlbnQueTtcblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueCA8IDApIHtcbiAgICAgICAgICAgIG1pblggPSBtYXhYO1xuICAgICAgICAgICAgbWF4WCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueSA8IDApIHtcbiAgICAgICAgICAgIG1pblkgPSBtYXhZO1xuICAgICAgICAgICAgbWF4WSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbWluWCA8PSB0aGlzLnggJiYgdGhpcy54IDwgbWF4WCAmJlxuICAgICAgICAgICAgbWluWSA8PSB0aGlzLnkgJiYgdGhpcy55IDwgbWF4WVxuICAgICAgICApO1xuICAgIH1cbn07XG5cblBvaW50LnByb3RvdHlwZS5FUSA9IFBvaW50LnByb3RvdHlwZS5lcXVhbHM7XG5Qb2ludC5wcm90b3R5cGUuR1QgPSBQb2ludC5wcm90b3R5cGUuZ3JlYXRlclRoYW47XG5Qb2ludC5wcm90b3R5cGUuTFQgPSBQb2ludC5wcm90b3R5cGUubGVzc1RoYW47XG5Qb2ludC5wcm90b3R5cGUuR0UgPSBQb2ludC5wcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsVG87XG5Qb2ludC5wcm90b3R5cGUuTEUgPSBQb2ludC5wcm90b3R5cGUubGVzc1RoYW5PckVxdWFsVG87XG5cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUmVjdGFuZ2xlXG4gKlxuICogQGRlc2MgVGhpcyBvYmplY3QgcmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgd2l0aGluIGFuIGFic3RyYWN0IDItZGltZW5zaW9uYWwgbWF0cml4LlxuICpcbiAqIFRoZSB1bml0IG9mIG1lYXN1cmUgaXMgdHlwaWNhbGx5IHBpeGVscy5cbiAqIChJZiB1c2VkIHRvIG1vZGVsIGNvbXB1dGVyIGdyYXBoaWNzLCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBhcmUgdHlwaWNhbGx5IG1lYXN1cmVkIGRvd253YXJkc1xuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB3aW5kb3cuIFRoaXMgY29udmVudGlvbiBob3dldmVyIGlzIG5vdCBpbmhlcmVudCBpbiB0aGlzIG9iamVjdC4pXG4gKlxuICogTm9ybWFsbHksIHRoZSBgeGAgYW5kIGB5YCBwYXJhbWV0ZXJzIHRvIHRoZSBjb25zdHJ1Y3RvciBkZXNjcmliZSB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gKiBIb3dldmVyLCBuZWdhdGl2ZSB2YWx1ZXMgb2YgYHdpZHRoYCBhbmQgYGhlaWdodGAgd2lsbCBiZSBhZGRlZCB0byB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAuIFRoYXQgaXMsXG4gKiBhIG5lZ2F0aXZlIHZhbHVlIG9mIHRoZSBgd2lkdGhgIHBhcmFtZXRlciB3aWxsIGV4dGVuZCB0aGUgcmVjdCB0byB0aGUgbGVmdCBvZiB0aGUgZ2l2ZW4gYHhgIGFuZFxuICogYSBuZWdhdGl2ZSB2YWx1ZSBvZiB0aGUgYGhlaWdodGAgcGFyYW1ldGVyIHdpbGwgZXh0ZW5kIHRoZSByZWN0IGFib3ZlIHRoZSBnaXZlbiBgeWAuXG4gKiBJbiBhbnkgY2FzZSwgYWZ0ZXIgaW5zdGFudGlhdGlvbiB0aGUgZm9sbG93aW5nIGFyZSBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSB0cnVlOlxuICogKiBUaGUgYGV4dGVudGAsIGB3aWR0aGAsIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIF9hbHdheXNfIGdpdmUgcG9zaXRpdmUgdmFsdWVzLlxuICogKiBUaGUgYG9yaWdpbmAsIGB0b3BgLCBhbmQgYGxlZnRgIHByb3BlcnRpZXMgX2Fsd2F5c18gcmVmbGVjdCB0aGUgdXBwZXIgbGVmdCBjb3JuZXIuXG4gKiAqIFRoZSBgY29ybmVyYCwgYGJvdHRvbWAsIGFuZCBgcmlnaHRgIHByb3BlcnRpZXMgX2Fsd2F5c18gcmVmbGVjdCB0aGUgbG93ZXIgcmlnaHQgY29ybmVyLlxuICpcbiAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIGNvb3JkaW5hdGUgb2Ygc29tZSBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBjb29yZGluYXRlIG9mIHNvbWUgY29ybmVyIG9mIHRoZSByZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFdpZHRoIG9mIHRoZSBuZXcgcmVjdC4gTWF5IGJlIG5lZ2F0aXZlIChzZWUgYWJvdmUpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MF0gLSBIZWlnaHQgb2YgdGhlIG5ldyByZWN0LiBNYXkgYmUgbmVnYXRpdmUgKHNlZSBhYm92ZSkuXG4gKi9cbmZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICB4ID0gTnVtYmVyKHgpIHx8IDA7XG4gICAgeSA9IE51bWJlcih5KSB8fCAwO1xuICAgIHdpZHRoID0gTnVtYmVyKHdpZHRoKSB8fCAwO1xuICAgIGhlaWdodCA9IE51bWJlcihoZWlnaHQpIHx8IDA7XG5cbiAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgIHggKz0gd2lkdGg7XG4gICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgIH1cblxuICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgIHkgKz0gaGVpZ2h0O1xuICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIG9yaWdpblxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSBVcHBlciBsZWZ0IGNvcm5lciBvZiB0aGlzIHJlY3QuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ29yaWdpbicsIG5ldyBQb2ludCh4LCB5KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBleHRlbnRcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHN1bW1hcnkgdGhpcyByZWN0J3Mgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKiBAZGVzYyBVbmxpa2UgdGhlIG90aGVyIGBQb2ludGAgcHJvcGVydGllcywgYGV4dGVudGAgaXMgbm90IGEgZ2xvYmFsIGNvb3JkaW5hdGUgcGFpcjsgcmF0aGVyIGl0IGNvbnNpc3RzIG9mIGEgX3dpZHRoXyAoYHhgLCBhbHdheXMgcG9zaXRpdmUpIGFuZCBhIF9oZWlnaHRfIChgeWAsIGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIG9iamVjdCBtaWdodCBiZSBtb3JlIGxlZ2l0aW1hdGVseSB0eXBlZCBhcyBzb21ldGhpbmcgbGlrZSBgQXJlYWAgd2l0aCBwcm9wZXJ0aWVzIGB3aWR0aGAgYW5kIGBoZWlnaHRgOyBob3dldmVyIHdlIHdhbnRlZCBpdCB0byBiZSBhYmxlIHRvIHVzZSBpdCBlZmZpY2llbnRseSB3aXRoIGEgcG9pbnQncyBgcGx1c2AgYW5kIGBtaW51c2AgbWV0aG9kcyAodGhhdCBpcywgd2l0aG91dCB0aG9zZSBtZXRob2RzIGhhdmluZyB0byBjaGVjayBhbmQgYnJhbmNoIG9uIHRoZSB0eXBlIG9mIGl0cyBwYXJhbWV0ZXIpLlxuICAgICAqXG4gICAgICogQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNjb3JuZXJ8Y29ybmVyfSBtZXRob2QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2V4dGVudCcsIG5ldyBQb2ludCh3aWR0aCwgaGVpZ2h0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBjb3JuZXJcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHN1bW1hcnkgTG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAZGVzYyBUaGlzIGlzIGEgY2FsY3VsYXRlZCB2YWx1ZSBjcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS4gSXQgaXMgYG9yaWdpbmAgb2Zmc2V0IGJ5IGBleHRlbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZXNlIGNvb3JkaW5hdGVzIGFjdHVhbGx5IHBvaW50IHRvIHRoZSBwaXhlbCBvbmUgYmVsb3cgYW5kIG9uZSB0byB0aGUgcmlnaHQgb2YgdGhlIHJlY3QncyBhY3R1YWwgbG93ZXIgcmlnaHQgcGl4ZWwuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2Nvcm5lcicsIG5ldyBQb2ludCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGNlbnRlclxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSBDZW50ZXIgb2YgdGhpcyByZWN0LlxuICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdjZW50ZXInLCBuZXcgUG9pbnQoeCArICh3aWR0aCAvIDIpLCB5ICsgKGhlaWdodCAvIDIpKSk7XG5cbn1cblxuUmVjdGFuZ2xlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNaW5pbXVtIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNaW5pbXVtIGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNYXhpbXVtIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0ICsgMS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcm5lci55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgTWF4aW11bSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0ICsgMS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ybmVyLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBXaWR0aCBvZiB0aGlzIHJlY3QgKGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVudC54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgSGVpZ2h0IG9mIHRoaXMgcmVjdCAoYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVudC55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgQXJlYSBvZiB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgYXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQSBjb3B5IG9mIHRoaXMgcmVjdCBidXQgd2l0aCBob3Jpem9udGFsIHBvc2l0aW9uIHJlc2V0IHRvIGdpdmVuIGB4YCBhbmQgbm8gd2lkdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBIb3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhlIG5ldyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxhdHRlblhBdDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB0aGlzLm9yaWdpbi55LCAwLCB0aGlzLmV4dGVudC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQSBjb3B5IG9mIHRoaXMgcmVjdCBidXQgd2l0aCB2ZXJ0aWNhbCBwb3NpdGlvbiByZXNldCB0byBnaXZlbiBgeWAgYW5kIG5vIGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIG5ldyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxhdHRlbllBdDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLm9yaWdpbi54LCB5LCB0aGlzLmV4dGVudC54LCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgZ2l2ZW4gYHBvaW50YCBlbnRpcmVseSBjb250YWluZWQgd2l0aGluIHRoaXMgcmVjdC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludE9yUmVjdCAtIFRoZSBwb2ludCBvciByZWN0IHRvIHRlc3QgZm9yIGNvbnRhaW5tZW50LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50T3JSZWN0KSB7XG4gICAgICAgIHJldHVybiBwb2ludE9yUmVjdC53aXRoaW4odGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHkgYGlzQ29udGFpbmVkV2l0aGluUmVjdGFuZ2xlYC4pX1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGB0aGlzYCByZWN0IGlzIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gZ2l2ZW4gYHJlY3RgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gUmVjdGFuZ2xlIHRvIHRlc3QgYWdhaW5zdCB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB3aXRoaW46IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY3Qub3JpZ2luLmxlc3NUaGFuT3JFcXVhbFRvKHRoaXMub3JpZ2luKSAmJlxuICAgICAgICAgICAgcmVjdC5jb3JuZXIuZ3JlYXRlclRoYW5PckVxdWFsVG8odGhpcy5jb3JuZXIpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHk6IGBpbnNldEJ5YC4pX1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoYXQgaXMgZW5sYXJnZWQvc2hydW5rIGJ5IGdpdmVuIGBwYWRkaW5nYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIEFtb3VudCBieSB3aGljaCB0byBpbmNyZWFzZSAoKykgb3IgZGVjcmVhc2UgKC0pIHRoaXMgcmVjdFxuICAgICAqIEBzZWUgVGhlIHtAbGluayBSZWN0YW5nbGUjc2hyaW5rQnl8c2hyaW5rQnl9IG1ldGhvZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdyb3dCeTogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLnggKyBwYWRkaW5nLFxuICAgICAgICAgICAgdGhpcy5vcmlnaW4ueSArIHBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLmV4dGVudC54IC0gcGFkZGluZyAtIHBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLmV4dGVudC55IC0gcGFkZGluZyAtIHBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGF0IGlzIGVubGFyZ2VkL3NocnVuayBieSBnaXZlbiBgcGFkZGluZ2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgLSBBbW91bnQgYnkgd2hpY2ggdG8gZGVjcmVhc2UgKCspIG9yIGluY3JlYXNlICgtKSB0aGlzIHJlY3QuXG4gICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNncm93Qnl8Z3Jvd0J5fSBtZXRob2QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzaHJpbmtCeTogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm93QnkoLXBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBCb3VuZGluZyByZWN0IHRoYXQgY29udGFpbnMgYm90aCB0aGlzIHJlY3QgYW5kIHRoZSBnaXZlbiBgcmVjdGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIHVuaW9uIHdpdGggdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgdW5pb246IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luLm1pbihyZWN0Lm9yaWdpbiksXG4gICAgICAgICAgICBjb3JuZXIgPSB0aGlzLmNvcm5lci5tYXgocmVjdC5jb3JuZXIpLFxuICAgICAgICAgICAgZXh0ZW50ID0gY29ybmVyLm1pbnVzKG9yaWdpbik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICBvcmlnaW4ueCwgb3JpZ2luLnksXG4gICAgICAgICAgICBleHRlbnQueCwgZXh0ZW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaXRlcmF0ZSBvdmVyIGFsbCBwb2ludHMgd2l0aGluIHRoaXMgcmVjdCwgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpfSBpdGVyYXRlZSAtIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggcG9pbnQuXG4gICAgICogQm91bmQgdG8gYGNvbnRleHRgIHdoZW4gZ2l2ZW47IG90aGVyd2lzZSBpdCBpcyBib3VuZCB0byB0aGlzIHJlY3QuXG4gICAgICogRWFjaCBpbnZvY2F0aW9uIG9mIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgKiB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dD10aGlzXSAtIENvbnRleHQgdG8gYmluZCB0byBgaXRlcmF0ZWVgICh3aGVuIG5vdCBgdGhpc2ApLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgZm9yICh2YXIgeCA9IHRoaXMub3JpZ2luLngsIHgyID0gdGhpcy5jb3JuZXIueDsgeCA8IHgyOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSB0aGlzLm9yaWdpbi55LCB5MiA9IHRoaXMuY29ybmVyLnk7IHkgPCB5MjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUuY2FsbChjb250ZXh0LCB4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBPbmUgb2Y6XG4gICAgICogKiBfSWYgdGhpcyByZWN0IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gYHJlY3RgOl9cbiAgICAgKiAgICAgIGEgbmV3IHJlY3QgcmVwcmVzZW50aW5nIHRoYXQgaW50ZXJzZWN0aW9uLlxuICAgICAqICogX0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IGFuZCBgaWZOb25lQWN0aW9uYCBkZWZpbmVkOl9cbiAgICAgKiAgICAgIHJlc3VsdCBvZiBjYWxsaW5nIGBpZk5vbmVBY3Rpb25gLlxuICAgICAqICogX0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IGFuZCBgaWZOb25lQWN0aW9uYCB1bmRlZmluZWQ6X1xuICAgICAqICAgICAgYG51bGxgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHJlY3QuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihSZWN0YW5nbGUpfSBbaWZOb25lQWN0aW9uXSAtIFdoZW4gbm8gaW50ZXJzZWN0aW9uLCBpbnZva2UgYW5kIHJldHVybiByZXN1bHQuXG4gICAgICogQm91bmQgdG8gYGNvbnRleHRgIHdoZW4gZ2l2ZW47IG90aGVyd2lzZSBib3VuZCB0byB0aGlzIHJlY3QuXG4gICAgICogSW52b2tlZCB3aXRoIGByZWN0YCBhcyBzb2xlIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHQ9dGhpc10gLSBDb250ZXh0IHRvIGJpbmQgdG8gYGlmTm9uZUFjdGlvbmAgKHdoZW4gbm90IGB0aGlzYCkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKHJlY3QsIGlmTm9uZUFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCxcbiAgICAgICAgICAgIG9yaWdpbiA9IHRoaXMub3JpZ2luLm1heChyZWN0Lm9yaWdpbiksXG4gICAgICAgICAgICBjb3JuZXIgPSB0aGlzLmNvcm5lci5taW4ocmVjdC5jb3JuZXIpLFxuICAgICAgICAgICAgZXh0ZW50ID0gY29ybmVyLm1pbnVzKG9yaWdpbik7XG5cbiAgICAgICAgaWYgKGV4dGVudC54ID4gMCAmJiBleHRlbnQueSA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgICAgIGV4dGVudC54LCBleHRlbnQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWZOb25lQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpZk5vbmVBY3Rpb24uY2FsbChjb250ZXh0IHx8IHRoaXMsIHJlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgdGhpcyByZWN0IG92ZXJsYXBzIHdpdGggZ2l2ZW4gYHJlY3RgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWN0LmNvcm5lci54ID4gdGhpcy5vcmlnaW4ueCAmJlxuICAgICAgICAgICAgcmVjdC5jb3JuZXIueSA+IHRoaXMub3JpZ2luLnkgJiZcbiAgICAgICAgICAgIHJlY3Qub3JpZ2luLnggPCB0aGlzLmNvcm5lci54ICYmXG4gICAgICAgICAgICByZWN0Lm9yaWdpbi55IDwgdGhpcy5jb3JuZXIueVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbi8vIEludGVyZmFjZVxuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIC8vIFRoaXMgY2xvc3VyZSBzdXBwb3J0cyBOb2RlSlMtbGVzcyBjbGllbnQgc2lkZSBpbmNsdWRlcyB3aXRoIDxzY3JpcHQ+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L21ubS5cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBSYW5nZVNlbGVjdGlvbk1vZGVsXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG9iamVjdCBtb2RlbHMgc2VsZWN0aW9uIG9mIFwiY2VsbHNcIiB3aXRoaW4gYW4gYWJzdHJhY3Qgc2luZ2xlLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIERpc2pvaW50IHNlbGVjdGlvbnMgY2FuIGJlIGJ1aWx0IHdpdGggY2FsbHMgdG8gdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjc2VsZWN0fHNlbGVjdChzdGFydCwgc3RvcCl9IC0gQWRkIGEgcmFuZ2UgdG8gdGhlIG1hdHJpeC5cbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2Rlc2VsZWN0fGRlc2VsZWN0KHN0YXJ0LCBzdG9wKX0gLSBSZW1vdmUgYSByYW5nZSBmcm9tIHRoZSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUd28gbW9yZSBtZXRob2RzIGFyZSBhdmFpbGFibGU6XG4gICAgICogKiBUZXN0IGEgY2VsbCB0byBzZWUgaWYgaXQge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjaXNTZWxlY3RlZHxpc1NlbGVjdGVkKGNlbGwpfVxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjY2xlYXJ8Y2xlYXIoKX0gdGhlIG1hdHJpeFxuICAgICAqXG4gICAgICogSW50ZXJuYWxseSwgdGhlIHNlbGVjdGlvbiBpcyBydW4tbGVuZ3RoLWVuY29kZWQuIEl0IGlzIHRoZXJlZm9yZSBhIFwic3BhcnNlXCIgbWF0cml4XG4gICAgICogd2l0aCB1bmRlZmluZWQgYm91bmRzLiBBIHNpbmdsZSBkYXRhIHByb3BlcnR5IGNhbGxlZCBgc2VsZWN0aW9uYCBpcyBhbiBhcnJheSB0aGF0XG4gICAgICogY29udGFpbnMgYWxsIHRoZSBcInJ1bnNcIiAocmFuZ2VzKSBvZiBzZWxlY3RlZCBjZWxscyBhbGJlaXQgaW4gbm8gcGFydGljdWxhciBvcmRlci5cbiAgICAgKiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3Qgbm9ybWFsbHkgbmVlZCB0byBiZSBhY2Nlc3NlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2Agb2JqZWN0KS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZVNlbGVjdGlvbk1vZGVsKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgc2VsZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS5BcnJheS5udW1iZXJ9XG4gICAgICAgICAqIEBzdW1tYXJ5IFVub3JkZXJlZCBsaXN0IG9mIHJ1bnMuXG4gICAgICAgICAqIEBkZXNjIEEgXCJydW5cIiBpcyBkZWZpbmVkIGFzIGFuIEFycmF5KDIpIHdoZXJlOlxuICAgICAgICAgKiAqIGVsZW1lbnQgWzBdIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJ1blxuICAgICAgICAgKiAqIGVsZW1lbnQgWzFdIGlzIHRoZSBlbmQgb2YgdGhlIHJ1biAoaW5jbHVzaXZlKSBhbmQgaXMgYWx3YXlzID49IGVsZW1lbnQgWzBdXG4gICAgICAgICAqIFRoZSBvcmRlciBvZiB0aGUgcnVucyB3aXRoaW4gaXMgdW5kZWZpbmVkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtdO1xuXG4gICAgICAgIC8vd2UgbmVlZCB0byBiZSBhYmxlIHRvIGdvIGJhY2sgaW4gdGltZVxuICAgICAgICAvL3RoZSBzdGF0ZXMgZmllbGRcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcblxuICAgICAgICAvL2Nsb25lIGFuZCBzdG9yZSBteSBjdXJyZW50IHN0YXRlXG4gICAgICAgIC8vc28gd2UgY2FuIHVud2luZCBjaGFuZ2VzIGlmIG5lZWQgYmVcbiAgICAgICAgdGhpcy5zdG9yZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvcHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5ID0gW10uY29uY2F0KHNlbHNbaV0pO1xuICAgICAgICAgICAgICAgIHN0YXRlLnB1c2goY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgQWRkIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIHRvIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBkZXNjIEluc2VydCBhIG5ldyBydW4gaW50byBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBUaGUgbmV3IHJ1biB3aWxsIGJlIG1lcmdlZCB3aXRoIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBydW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdHdvIHBhcmFtZXRlcnMgbWF5IGJlIGdpdmVuIGluIGVpdGhlciBvcmRlci5cbiAgICAgICAgICogVGhlIHN0YXJ0IGFuZCBzdG9wIGVsZW1lbnRzIGluIHRoZSByZXN1bHRpbmcgcnVuIHdpbGwgaG93ZXZlciBhbHdheXMgYmUgb3JkZXJlZC5cbiAgICAgICAgICogKEhvd2V2ZXIsIG5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIHJ1bnMgd2l0aGluIGB0aGlzLnNlbGVjdGlvbmAgaXMgaXRzZWxmIGFsd2F5cyB1bm9yZGVyZWQuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMV07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikgfHwgYWJ1dHMoZWFjaCwgcnVuKSkge1xuICAgICAgICAgICAgICAgICAgICBydW4gPSBtZXJnZShlYWNoLCBydW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXIucHVzaChydW4pO1xuICAgICAgICAgICAgc3BsaWNlclsxXSA9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNwbGljZS5hcHBseSh0aGlzLnNlbGVjdGlvbiwgc3BsaWNlcik7IC8vIHVwZGF0ZSBpbiBwbGFjZSB0byBwcmVzZXJ2ZSBleHRlcm5hbCByZWZlcmVuY2VzXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgUmVtb3ZlIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIGZyb20gdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICogQGRlc2MgVHJ1bmNhdGUgYW5kL29yIHJlbW92ZSBydW4ocykgZnJvbSBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBSZW1vdmluZyBwYXJ0IG9mIGV4aXN0aW5nIHJ1bnMgd2lsbCAoY29ycmVjdGx5KSBzaG9ydGVuIHRoZW0gb3IgYnJlYWsgdGhlbSBpbnRvIHR3byBmcmFnbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0d28gcGFyYW1ldGVycyBtYXkgYmUgZ2l2ZW4gaW4gZWl0aGVyIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIChzdGFydCwgc3RvcCkge1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMF07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZWNlcyA9IHN1YnRyYWN0KGVhY2gsIHJ1bik7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIgPSBzcGxpY2VyLmNvbmNhdChwaWVjZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXJbMV0gPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UuYXBwbHkodGhpcy5zZWxlY3Rpb24sIHNwbGljZXIpOyAvLyB1cGRhdGUgaW4gcGxhY2UgdG8gcHJlc2VydmUgZXh0ZXJuYWwgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEVtcHRpZXMgYHRoaXMuc2VsZWN0aW9uYCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmcgYWxsIHJ1bnMuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYGNlbGxgIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBnaXZlbiBgY2VsbGAgaXMgd2l0aGluIGFueSBvZiB0aGUgcnVucyBpbiBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VsbCAtIFRoZSBjZWxsIHRvIHRlc3QgZm9yIGluY2x1c2lvbiBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uc29tZShmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYWNoWzBdIDw9IGNlbGwgJiYgY2VsbCA8PSBlYWNoWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGluZGV4ZXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAqIEBkZXNjIFJldHVybiB0aGUgaW5kZXhlcyB0aGF0IGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZWFjaFswXTsgaSA8PSBlYWNoWzFdOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBQcmVwcyBgc3RhcnRgIGFuZCBgc3RvcGAgcGFyYW1zIGludG8gb3JkZXIgYXJyYXlcbiAgICAgKiBAZnVuY3Rpb24gbWFrZVJ1blxuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gY2FsbGVkIGJ5IGJvdGggYHNlbGVjdCgpYCBhbmQgYGRlc2VsZWN0KClgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBzdGFydCAtIFN0YXJ0IG9mIHJ1bi4gaWYgYXJyYXksIGBzdGFydGAgYW5kIGBzdG9wYCBhcmUgdGFrZW4gZnJvbSBmaXJzdCB0d28gZWxlbWVudHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0YXJ0XSAtIEVuZCBvZiBydW4gKGluY2x1c2l2ZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZVJ1bihzdGFydCwgc3RvcCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc3RhcnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgID8gbWFrZVJ1bi5hcHBseSh0aGlzLCBzdGFydCkgLy8gZXh0cmFjdCBwYXJhbXMgZnJvbSBnaXZlbiBhcnJheVxuICAgICAgICAgICAgICAgIDogc3RvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBbIHN0YXJ0LCBzdGFydCBdIC8vIHNpbmdsZSBwYXJhbSBpcyBhIHJ1biB0aGF0IHN0b3BzIHdoZXJlIGl0IHN0YXJ0c1xuICAgICAgICAgICAgICAgIDogc3RhcnQgPD0gc3RvcFxuICAgICAgICAgICAgICAgID8gWyBzdGFydCwgc3RvcCBdXG4gICAgICAgICAgICAgICAgOiBbIHN0b3AsIHN0YXJ0IF0gLy8gcmV2ZXJzZSBkZXNjZW5kaW5nIHBhcmFtcyBpbnRvIGFzY2VuZGluZyBvcmRlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIG92ZXJsYXBzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIG92ZXJsYXBzIGBydW4yYFxuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgb3ZlcmxhcCB3aXRoIG9uZSBhbm90aGVyLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogT3ZlcmxhcCBpcyBkZWZpbmVkIHRvIGluY2x1ZGUgdGhlIGNhc2Ugd2hlcmUgb25lIHJ1biBjb21wbGV0ZWx5IGNvbnRhaW5zIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb3BlcmF0b3IgaXMgY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMSAtIGZpcnN0IHJ1blxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBzZWNvbmQgcnVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcmxhcHMocnVuMSwgcnVuMikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcnVuMVswXSA8PSBydW4yWzBdICYmIHJ1bjJbMF0gPD0gcnVuMVsxXSB8fCAvLyBydW4yJ3Mgc3RhcnQgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjFbMF0gPD0gcnVuMlsxXSAmJiBydW4yWzFdIDw9IHJ1bjFbMV0gfHwgLy8gcnVuMidzIHN0b3AgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjJbMF0gPCAgcnVuMVswXSAmJiBydW4xWzFdIDwgIHJ1bjJbMV0gICAgLy8gcnVuMiBjb21wbGV0ZWx5IGNvbnRhaW5zIHJ1bjFcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBhYnV0c1xuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgYXJlIGNvbnNlY3V0aXZlIHdpdGggb25lIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIGlzIGNvbnNlY3V0aXZlIHdpdGggYHJ1bjJgXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBmaXJzdCBydW5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gc2Vjb25kIHJ1blxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFidXRzKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJ1bjFbMV0gPT09IHJ1bjJbMF0gLSAxIHx8IC8vIHJ1bjEncyB0b3AgaW1tZWRpYXRlbHkgcHJlY2VkZXMgcnVuMidzIHN0YXJ0IE9SLi4uXG4gICAgICAgICAgICBydW4yWzFdID09PSBydW4xWzBdIC0gMSAgICAvLyBydW4yJ3MgdG9wIGltbWVkaWF0ZWx5IHByZWNlZGVzIHJ1bjEncyBzdGFydFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIHN1YnRyYWN0XG4gICAgICogQHN1bW1hcnkgT3BlcmF0b3IgdGhhdCBzdWJ0cmFjdHMgb25lIHJ1biBmcm9tIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn0gVGhlIHJlbWFpbmluZyBwaWVjZXMgb2YgYG1pbnVlbmRgIGFmdGVyIHJlbW92aW5nIGBzdWJ0cmFoZW5kYC5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gX2RvZXMgbm90IGFzc3VtZXNfIHRoYXQgYG92ZXJsYXAoKWAgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBydW5zIGFuZCBoYXMgcmV0dXJuZWQgYHRydWVgLlxuICAgICAqXG4gICAgICogUmV0dXJuZWQgYXJyYXkgY29udGFpbnMgMCwgMSwgb3IgMiBydW5zIHdoaWNoIGFyZSB0aGUgcG9ydGlvbihzKSBvZiBgbWludWVuZGAgdGhhdCBkbyBfbm90XyBpbmNsdWRlIGBzdWJ0cmFoZW5kYC5cbiAgICAgKlxuICAgICAqIENhdmVhdDogVGhpcyBvcGVyYXRvciBpcyAqbm90KiBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtaW51ZW5kIC0gYSBydW4gZnJvbSB3aGljaCB0byBcInN1YnRyYWN0XCIgYHN1YnRyYWhlbmRgXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gc3VidHJhaGVuZCAtIGEgcnVuIHRvIFwic3VidHJhY3RlZFwiIGZyb20gYG1pbnVlbmRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VidHJhY3QobWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgICB2YXIgbTAgPSBtaW51ZW5kWzBdO1xuICAgICAgICB2YXIgbTEgPSBtaW51ZW5kWzFdO1xuICAgICAgICB2YXIgczAgPSBzdWJ0cmFoZW5kWzBdO1xuICAgICAgICB2YXIgczEgPSBzdWJ0cmFoZW5kWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHMwIDw9IG0wICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vc3VidHJhaGVuZCBleHRlbmRzIGJlZm9yZSBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMCA+IG0wICYmIHMxID49IG0xKSB7XG4gICAgICAgICAgICAvL3N1YnRyYWhlbmQgZXh0ZW5kcyBhZnRlciBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW20wLCBzMCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChtMCA8IHMwICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vY29tcGxldGVseSBpbnNpZGU6IHJldHVybiAyIHNtYWxsZXIgcGllY2VzIHJlc3VsdGluZyBmcm9tIHRoZSBob2xlXG4gICAgICAgICAgICByZXN1bHQucHVzaChbbTAsIHMwIC0gMV0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMSA8IG0wIHx8IHMwID4gbTEpIHtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgb3V0c2lkZTogcmV0dXJuIGBtaW51ZW5kYCB1bnRvdWNoZWRcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pbnVlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbHNlIHN1YnRyYWhlbmQgbXVzdCBjb21wbGV0ZWx5IG92ZXJsYXAgbWludWVuZCBzbyByZXR1cm4gbm8gcGllY2VzXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuICAgIC8vIExvY2FsIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBtZXJnZVxuICAgICAqIEBzdW1tYXJ5IE9wZXJhdG9yIHRoYXQgbWVyZ2VzIGdpdmVuIHJ1bnMuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBIHNpbmdsZSBtZXJnZWQgcnVuLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogVGhlIHJ1bnMgYXJlIGFzc3VtZWQgdG8gYmUgb3ZlcmxhcHBpbmcgb3IgYWRqYWNlbnQgdG8gb25lIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4yYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4xYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluLmFwcGx5KE1hdGgsIHJ1bjEpLCBNYXRoLm1pbi5hcHBseShNYXRoLCBydW4yKSk7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heC5hcHBseShNYXRoLCBydW4xKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgcnVuMikpO1xuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcmZhY2VcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlU2VsZWN0aW9uTW9kZWw7XG59KShcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgfHwgKHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsID0ge30pLFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzIHx8ICh3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzID0ge30pXG4pIHx8IChcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyB8fCAod2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwgPSB3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzKVxuKTtcblxuLyogQWJvdXQgdGhlIGFib3ZlIElJRkU6XG4gKiBUaGlzIGZpbGUgaXMgYSBcIm1vZGlmaWVkIG5vZGUgbW9kdWxlLlwiIEl0IGZ1bmN0aW9ucyBhcyB1c3VhbCBpbiBOb2RlLmpzICphbmQqIGlzIGFsc28gdXNhYmxlIGRpcmVjdGx5IGluIHRoZSBicm93c2VyLlxuICogMS4gTm9kZS5qczogVGhlIElJRkUgaXMgc3VwZXJmbHVvdXMgYnV0IGlubm9jdW91cy5cbiAqIDIuIEluIHRoZSBicm93c2VyOiBUaGUgSUlGRSBjbG9zdXJlIHNlcnZlcyB0byBrZWVwIGludGVybmFsIGRlY2xhcmF0aW9ucyBwcml2YXRlLlxuICogMi5hLiBJbiB0aGUgYnJvd3NlciBhcyBhIGdsb2JhbDogVGhlIGxvZ2ljIGluIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zICsgdGhlIHBvc3QtaW52b2NhdGlvbiBleHByZXNzaW9uXG4gKiB3aWxsIHB1dCB5b3VyIEFQSSBpbiBgd2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWxgLlxuICogMi5iLiBJbiB0aGUgYnJvd3NlciBhcyBhIG1vZHVsZTogSWYgeW91IHByZWRlZmluZSBhIGB3aW5kb3cubW9kdWxlYCBvYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgaW4gYG1vZHVsZS5leHBvcnRzYC5cbiAqIFRoZSBib3dlciBjb21wb25lbnQgYG1ubWAgbWFrZXMgdGhpcyBlYXN5IGFuZCBhbHNvIHByb3ZpZGVzIGEgZ2xvYmFsIGByZXF1aXJlKClgIGZ1bmN0aW9uIGZvciByZWZlcmVuY2luZyB5b3VyIG1vZHVsZVxuICogZnJvbSBvdGhlciBjbG9zdXJlcy4gSW4gZWl0aGVyIGNhc2UsIHRoaXMgd29ya3Mgd2l0aCBib3RoIE5vZGVKcy1zdHlsZSBleHBvcnQgbWVjaGFuaXNtcyAtLSBhIHNpbmdsZSBBUEkgYXNzaWdubWVudCxcbiAqIGBtb2R1bGUuZXhwb3J0cyA9IHlvdXJBUElgICpvciogYSBzZXJpZXMgb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBhc3NpZ25tZW50cywgYG1vZHVsZS5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHlgLlxuICpcbiAqIEJlZm9yZSB0aGUgSUlGRSBydW5zLCB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyBhcmUgZXhlY3V0ZWQ6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIHByb3BlcnR5XG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgdXNlIGl0XG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIGNyZWF0ZSBhIGBSYW5nZVNlbGVjdGlvbk1vZGVsYCBvYmplY3RcbiAqXG4gKiBBZnRlciB0aGUgSUlGRSByZXR1cm5zOlxuICogQmVjYXVzZSBpdCBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHRoZSBleHByZXNzaW9uIGFmdGVyIHRoZSB8fCB3aWxsIGV4ZWN1dGU6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB0aGVuIHdlJ3JlIGluIE5vZGVKcyBzbyB3ZSdyZSBkb25lXG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBicm93c2VyXG4gKiAyLmEuIElmIGBtb2R1bGVgIG9iamVjdCBwcmVkZWZpbmVkLCB3ZSdyZSBkb25lOyByZXN1bHRzIGFyZSBpbiBgbW91ZHVsZS5leHBvcnRzYFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCByZWRlZmluZWBSYW5nZVNlbGVjdGlvbk1vZGVsYCB0byBiZSB0aGUgYFJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0c2Agb2JqZWN0XG4gKi9cbiIsIi8qIGdsb2JhbHMgYWxlcnQgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgRXh0ZW5kIGZyb20gdGhpcyBiYXNlIGNsYXNzIHVzaW5nIGBCYXNlLmV4dGVuZGAgcGVyIGV4YW1wbGUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHByb3RvdHlwZSA9IHsgLi4uIH07XG4gKiB2YXIgZGVzY2VuZGFudENsYXNzID0gQmFzZS5leHRlbmQocHJvdG90eXBlfTtcbiAqIEBjbGFzc2Rlc2MgVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzIGF2YWlsYWJsZSBmb3IgYWxsIEh5cGVyZ3JpZCBjbGFzc2VzLlxuICovXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG5cbkJhc2UucHJvdG90eXBlLmRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2xpYi9kZXByZWNhdGVkJyk7XG5CYXNlLnByb3RvdHlwZS5IeXBlcmdyaWRFcnJvciA9IHJlcXVpcmUoJy4vbGliL2Vycm9yJyk7XG5cbkJhc2UucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG9uZXJyb3IpIHtcbiAgICBzd2l0Y2ggKG9uZXJyb3IpIHtcbiAgICAgICAgY2FzZSAnd2Fybic6IGNvbnNvbGUud2FybihtZXNzYWdlKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FsZXJ0JzogYWxlcnQobWVzc2FnZSk7IGJyZWFrOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyB0aGlzLkh5cGVyZ3JpZEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGdldHRpbmcgdGhlIHZhbHVlIHdoZW4gdGhhdCB2YWx1ZSBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHRoYXQgbmVlZHMgdG8gYmUgY2FsbGVkIHRvIGdldCB0aGUgYWN0dWFsIChwcmltaXRpdmUpIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuQmFzZS5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoKHR5cGVvZiB2YWx1ZSlbMF0gPT09ICdmJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZFxuICogQHN1bW1hcnkgTWl4ZXMgc291cmNlIG1lbWJlcnMgaW50byBjYWxsaW5nIGNvbnRleHQuXG4gKiBAZGVzYyBDb250ZXh0IGlzIHR5cGljYWxseSBlaXRoZXIgYW4gaW5zdGFuY2Ugb3IgdGhlIChzaGFyZWQpIHByb3RvdHlwZSBvZiBhIFwiY2xhc3NcIiBleHRlbmRlZCBmcm9tIHtAbGluayBCYXNlfSAoc2VlIGV4YW1wbGVzKS5cbiAqXG4gKiBUeXBpY2FsbHkgdXNlZCBieSBwbHVnLWlucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBkZWZpbmUgaW5zdGFuY2UgbWVtYmVyczogbXlHcmlkLmZpeCgpLCBldGMuXG4gKiBteUdyaWQubWl4SW4oeyBmaXg6IGZ1bmN0aW9uKCkgey4uLn0sIC4uLiB9KTtcbiAqIEBleGFtcGxlXG4gKiAvLyBkZWZpbmUgcHJvdG90eXBlIG1lbWJlcnM6IEh5cGVyZ3JpZC5wcm90b3R5cGUuZml4KCksIGV0Yy5cbiAqIEh5cGVyZ3JpZC5wcm90b3R5cGUubWl4SW4oeyBmaXg6IGZ1bmN0aW9uKCkgey4uLn0sIC4uLiB9KTtcbiAqIEBTZWUge0BsaW5rIGh0dHBzOi8vam9uZWl0LmdpdGh1Yi5pby9vdmVycmlkZXIvbW9kdWxlLW92ZXJyaWRlci5odG0jLm1peElufVxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICovXG5CYXNlLnByb3RvdHlwZS5taXhJbiA9IHJlcXVpcmUoJ292ZXJyaWRlcicpLm1peEluO1xuXG5cbi8qKlxuICogQG1ldGhvZFxuICogQHN1bW1hcnkgSW5zdGFudGlhdGUgYW4gb2JqZWN0IHdpdGggZGlzY3JldGUgKyB2YXJpYWJsZSBhcmdzLlxuICogQGRlc2MgVGhlIGRpc2NyZXRlIGFyZ3MgYXJlIHBhc3NlZCBmaXJzdCwgZm9sbG93ZWQgYnkgdGhlIHZhcmlhYmxlIGFyZ3MuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gdmFyaWFibGVBcmdBcnJheVxuICogQHBhcmFtIHsuLi4qfSBkaXNjcmV0ZUFyZ3NcbiAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCBvZiB0eXBlIGBDb25zdHJ1Y3RvcmAgbmV3bHkgY29uc3RydWN0b3IgdXNpbmcgdGhlIGFyZ3VtZW50cyBpbiBgYXJyYXlPZkFyZ3NgLlxuICovXG5CYXNlLnByb3RvdHlwZS5jcmVhdGVBcHBseSA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCB2YXJpYWJsZUFyZ0FycmF5LCBkaXNjcmV0ZUFyZ3MpIHtcbiAgICB2YXIgZGlzY3JldGVBcmdBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgIGFyZ3MgPSBbbnVsbF0gLy8gbnVsbCBpcyBjb250ZXh0IGZvciBgYmluZGAgY2FsbCBiZWxvd1xuICAgICAgICAgICAgLmNvbmNhdChkaXNjcmV0ZUFyZ0FycmF5KSAvLyBkaXNjcmV0ZSBhcmd1bWVudHNcbiAgICAgICAgICAgIC5jb25jYXQodmFyaWFibGVBcmdBcnJheSksIC8vIHZhcmlhYmxlIGFyZ3VtZW50c1xuICAgICAgICBCb3VuZENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuYmluZC5hcHBseShDb25zdHJ1Y3RvciwgYXJncyk7XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kQ29uc3RydWN0b3I7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vbGliL3BvbHlmaWxscycpOyAvLyBJbnN0YWxscyBtaXNjLiBwb2x5ZmlsbHMgaW50byBnbG9iYWwgb2JqZWN0cywgYXMgbmVlZGVkXG5cbnZhciBGaW5CYXIgPSByZXF1aXJlKCdmaW5iYXJzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpLlBvaW50O1xudmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUmVjdGFuZ2xlO1xudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7IC8vIGZ5aTogaW5zdGFsbHMgdGhlIEFycmF5LnByb3RvdHlwZS5maW5kIHBvbHlmaWxsLCBhcyBuZWVkZWRcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcbnZhciBkeW5hbWljUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vbGliL2R5bmFtaWNQcm9wZXJ0aWVzJyk7XG52YXIgQ2FudmFzID0gcmVxdWlyZSgnLi9saWIvQ2FudmFzJyk7XG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7XG52YXIgU2VsZWN0aW9uTW9kZWwgPSByZXF1aXJlKCcuL2xpYi9TZWxlY3Rpb25Nb2RlbCcpO1xudmFyIHN0eWxlc2hlZXQgPSByZXF1aXJlKCcuL2xpYi9zdHlsZXNoZWV0Jyk7XG52YXIgTG9jYWxpemF0aW9uID0gcmVxdWlyZSgnLi9saWIvTG9jYWxpemF0aW9uJyk7XG52YXIgYmVoYXZpb3JzID0gcmVxdWlyZSgnLi9iZWhhdmlvcnMnKTtcbnZhciBDZWxsUmVuZGVyZXJzID0gcmVxdWlyZSgnLi9jZWxsUmVuZGVyZXJzJyk7XG52YXIgQ2VsbEVkaXRvcnMgPSByZXF1aXJlKCcuL2NlbGxFZGl0b3JzJyk7XG5cbnZhciBFREdFX1NUWUxFUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10sXG4gICAgUkVDVF9TVFlMRVMgPSBFREdFX1NUWUxFUy5jb25jYXQoWyd3aWR0aCcsICdoZWlnaHQnLCAncG9zaXRpb24nXSk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBbY29udGFpbmVyXSAtIENTUyBzZWxlY3RvciBvciBFbGVtZW50XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5CZWhhdmlvcj1iZWhhdmlvcnMuSlNPTl0gLSBBIGJlaGF2aW9yIGNvbnN0cnVjdG9yIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uW119IFtvcHRpb25zLnBpcGVsaW5lXSAtIEEgbGlzdCBmdW5jdGlvbiBjb25zdHJ1Y3RvcnMgdG8gdXNlIGZvciBwYXNzaW5nIGRhdGEgdGhyb3VnaCBhIHNlcmllcyBvZiB0cmFuc2Zvcm1zIHRvIG9jY3VyIG9uIHJlaW5kZXggY2FsbFxuICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gW29wdGlvbnMuZGF0YV0gLSBQYXNzZWQgdG8gYmVoYXZpb3IgY29uc3RydWN0b3IuIE1heSBiZTpcbiAqICogQW4gYXJyYXkgb2YgY29uZ3J1ZW50IHJhdyBkYXRhIG9iamVjdHNcbiAqICogQSBmdW5jdGlvbiByZXR1cm5pbmcgc2FtZVxuICogQHBhcmFtIHtmdW5jdGlvbnxtZW51SXRlbVtdfSBbb3B0aW9ucy5zY2hlbWE9ZGVyaXZlZFNjaGVtYV0gLSBQYXNzZWQgdG8gYmVoYXZpb3IgY29uc3RydWN0b3IuIE1heSBiZTpcbiAqICogQSBzY2hlbWEgYXJyYXlcbiAqICogQSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzY2hlbWEgYXJyYXkuIENhbGxlZCBhdCBmaWx0ZXIgcmVzZXQgdGltZSB3aXRoIGJlaGF2aW9yIGFzIGNvbnRleHQuXG4gKiAqIE9taXQgdG8gZ2VuZXJhdGUgYSBiYXNpYyBzY2hlbWEgZnJvbSBgdGhpcy5iZWhhdmlvci5jb2x1bW5zYC5cbiAqIEBwYXJhbSB7QmVoYXZpb3J9IFtvcHRpb25zLkJlaGF2aW9yPUpTT05dIC0gQSBncmlkIGJlaGF2aW9yIChkZXNjZW5kYW50IG9mIEJlaGF2aW9yIFwiY2xhc3NcIikuXG4gKlxuICogQHBhcmFtIHtwbHVnaW5TcGVjfHBsdWdpblNwZWNbXX0gW29wdGlvbnMucGx1Z2luc11cbiAqXG4gKiBAcGFyYW0ge3N1YmdyaWRTcGVjW119IFtvcHRpb25zLnN1YmdyaWRzXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IFtvcHRpb25zLmNvbnRhaW5lcl0gLSBDU1Mgc2VsZWN0b3Igb3IgRWxlbWVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGl6YXRpb249SHlwZXJncmlkLmxvY2FsaXphdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbb3B0aW9ucy5sb2NhbGl6YXRpb24ubG9jYWxlPUh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubG9jYWxlXSAtIFRoZSBkZWZhdWx0IGxvY2FsZSB0byB1c2Ugd2hlbiBhbiBleHBsaWNpdCBgbG9jYWxlYCBpcyBvbWl0dGVkIGZyb20gbG9jYWxpemVyIGNvbnN0cnVjdG9yIGNhbGxzLiBQYXNzZWQgdG8gSW50bC5OdW1iZXJGb21yYXRgIGFuZCBgSW50bC5EYXRlRm9tcmF0YC4gU2VlIHtAIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwjTG9jYWxlX2lkZW50aWZpY2F0aW9uX2FuZF9uZWdvdGlhdGlvbnxMb2NhbGUgaWRlbnRpZmljYXRpb24gYW5kIG5lZ290aWF0aW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGl6YXRpb24ubnVtYmVyT3B0aW9ucz1IeXBlcmdyaWQubG9jYWxpemF0aW9uLm51bWJlck9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuTnVtYmVyRm9ybWF0YCBmb3IgY3JlYXRpbmcgdGhlIGJhc2ljIFwibnVtYmVyXCIgbG9jYWxpemVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsaXphdGlvbi5kYXRlT3B0aW9ucz1IeXBlcmdyaWQubG9jYWxpemF0aW9uLmRhdGVPcHRpb25zXSAtIE9wdGlvbnMgcGFzc2VkIHRvIGBJbnRsLkRhdGVGb21yYXRgIGZvciBjcmVhdGluZyB0aGUgYmFzaWMgXCJkYXRlXCIgbG9jYWxpemVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5zY2hlbWFdXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1hcmdpbl0gLSBPcHRpb25hbCBjYW52YXMgXCJtYXJnaW5zXCIgYXBwbGllZCB0byBjb250YWluaW5nIGRpdiBhcyAubGVmdCwgLnRvcCwgLnJpZ2h0LCAuYm90dG9tLiAoRGVmYXVsdCB2YWx1ZXMgYWN0dWFsbHkgZGVyaXZlIGZyb20gJ2dyaWQnIHN0eWxlc2hlZXQncyBgLmh5cGVyZ3JpZC1jb250YWluZXJgIHJ1bGUuKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi50b3A9JzBweCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luLnJpZ2h0PScwcHgnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi5ib3R0b209JzBweCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luLmxlZnQ9JzBweCddXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmJvdW5kaW5nUmVjdF0gLSBPcHRpb25hbCBncmlkIGNvbnRhaW5lciBzaXplICYgcG9zaXRpb24uIChEZWZhdWx0IHZhbHVlcyBhY3R1YWxseSBkZXJpdmUgZnJvbSAnZ3JpZCcgc3R5bGVzaGVldCdzIGAuaHlwZXJncmlkLWNvbnRhaW5lciA+IGRpdjpmaXJzdC1jaGlsZGAgcnVsZS4pXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm91bmRpbmdSZWN0LmhlaWdodD0nNTAwcHgnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdW5kaW5nUmVjdC53aWR0aD0nYXV0byddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm91bmRpbmdSZWN0LmxlZnQ9J2F1dG8nXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdW5kaW5nUmVjdC50b3A9J2F1dG8nXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdW5kaW5nUmVjdC5yaWdodD0nYXV0byddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm91bmRpbmdSZWN0LmJvdHRvbT0nYXV0byddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm91bmRpbmdSZWN0LnBvc2l0aW9uPSdyZWxhdGl2ZSddXG4gKi9cbnZhciBIeXBlcmdyaWQgPSBCYXNlLmV4dGVuZCgnSHlwZXJncmlkJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgICAgICAvL09wdGlvbmFsIGNvbnRhaW5lciBhcmd1bWVudFxuICAgICAgICBpZiAoISh0eXBlb2YgY29udGFpbmVyID09PSAnc3RyaW5nJykgJiYgIShjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb250YWluZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5jbGVhclN0YXRlKCk7XG5cbiAgICAgICAgLy9TZXQgdXAgdGhlIGNvbnRhaW5lciBmb3IgYSBncmlkIGluc3RhbmNlXG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyKFxuICAgICAgICAgICAgY29udGFpbmVyIHx8XG4gICAgICAgICAgICBvcHRpb25zLmNvbnRhaW5lciB8fFxuICAgICAgICAgICAgZmluZE9yQ3JlYXRlQ29udGFpbmVyKG9wdGlvbnMuYm91bmRpbmdSZWN0KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEluc3RhbGwgc2hhcmVkIHBsdWctaW5zICh0aG9zZSB3aXRoIGEgYHByZWluc3RhbGxgIG1ldGhvZClcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmluc3RhbGxQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG5cbiAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvbiA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5pc1dlYmtpdCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3ZWJraXQnKSA+IC0xO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuYWxsb3dFdmVudEhhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLm51bVJvd3MgPSAwO1xuICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSAwO1xuICAgICAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgICAgIHRoaXMuc2V0Rm9ybWF0dGVyKG9wdGlvbnMubG9jYWxpemF0aW9uKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgY2VsbFJlbmRlcmVyc1xuICAgICAgICAgKiBAdHlwZSB7Q2VsbFJlbmRlcmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWxsUmVuZGVyZXJzID0gbmV3IENlbGxSZW5kZXJlcnMoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgY2VsbEVkaXRvcnNcbiAgICAgICAgICogQHR5cGUge0NlbGxFZGl0b3J9XG4gICAgICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNlbGxFZGl0b3JzID0gbmV3IENlbGxFZGl0b3JzKHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuQmVoYXZpb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QmVoYXZpb3IodGhpcy5vcHRpb25zKTsgLy8gYWxzbyBzZXRzIHRoaXMub3B0aW9ucy5waXBlbGluZSBhbmQgdGhpcy5vcHRpb25zLmRhdGFcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhKHRoaXMub3B0aW9ucy5kYXRhLCB0aGlzLm9wdGlvbnMpOyAvLyBpZiBubyBiZWhhdmlvciBoYXMgeWV0IGJlZW4gc2V0LCBgc2V0RGF0YWAgc2V0cyBhIGRlZmF1bHQgYmVoYXZpb3IgYW5kIHRoaXMub3B0aW9ucy5waXBlbGluZVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIHBsdWdpbnNcbiAgICAgICAgICogQHN1bW1hcnkgRGljdGlvbmFyeSBvZiBuYW1lZCBpbnN0YW5jZSBwbHVnLWlucy5cbiAgICAgICAgICogQGRlc2MgU2VlIGV4YW1wbGVzIGZvciBob3cgdG8gcmVmZXJlbmNlIChhbGJlaXQgdGhlcmUgaXMgbm9ybWFsbHkgbm8gbmVlZCB0byByZWZlcmVuY2UgcGx1Z2lucyBkaXJlY3RseSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgZGljdGlvbmFyeSBvZiBfc2hhcmVkXyBwbHVnaW5zLCBzZWUge0BsaW5rIEh5cGVyZ3JpZC5wbHVnaW5zfHBsdWdpbnN9IChhIHByb3BlcnR5IG9mIHRoZSBjb25zdHJ1Y3RvcikuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBpbnN0YW5jZVBsdWdpbnMgPSBteUdyaWQucGx1Z2lucztcbiAgICAgICAgICogdmFyIGluc3RhbmNlUGx1Z2lucyA9IHRoaXMucGx1Z2luczsgLy8gaW50ZXJuYWwgdXNlXG4gICAgICAgICAqIHZhciBteUluc3RhbmNlUGx1Z2luID0gbXlHcmlkLnBsdWdpbnMubXlJbnN0YW5jZVBsdWdpbjtcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuXG4gICAgICAgIC8vIEluc3RhbGwgaW5zdGFuY2UgcGx1Zy1pbnMgKHRob3NlIHRoYXQgYXJlIGNvbnN0cnVjdG9ycyBPUiBoYXZlIGFuIGBpbnN0YWxsYCBtZXRob2QpXG4gICAgICAgIHRoaXMuaW5zdGFsbFBsdWdpbnMob3B0aW9ucy5wbHVnaW5zKTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIHByb3BhZ2F0ZWQgbW91c2VjbGlja3MuIFVzZWQgZm9yIGFib3J0aW5nIGVkaXQgbW9kZS5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZUNhdGNoZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRFZGl0aW5nKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VDYXRjaGVyKTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJDZWxsRWRpdG9yOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdyZWdpc3RlckNlbGxFZGl0b3IoQ29uc3RydWN0b3IsIG5hbWUpJywgJ2NlbGxFZGl0b3JzLmFkZChuYW1lLCBDb25zdHJ1Y3RvciknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2VsbEVkaXRvcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdjcmVhdGVDZWxsRWRpdG9yKG5hbWUpJywgJ2NlbGxFZGl0b3JzLmNyZWF0ZShuYW1lKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRDZWxsUHJvdmlkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q2VsbFByb3ZpZGVyKCknLCAnY2VsbFJlbmRlcmVycycsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWdpc3RlckxvY2FsaXplcjogZnVuY3Rpb24obmFtZSwgbG9jYWxpemVyLCBiYXNlQ2xhc3NOYW1lLCBuZXdDbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgncmVnaXN0ZXJMb2NhbGl6ZXIobmFtZSwgbG9jYWxpemVyLCBiYXNlQ2xhc3NOYW1lLCBuZXdDbGFzc05hbWUpJywgJ2xvY2FsaXphdGlvbi5hZGQobmFtZSwgbG9jYWxpemVyKScsICcxLjAuNicsIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICdTVFJVQ1RVUkFMIENIQU5HRTogTm8gbG9uZ2VyIHN1cHBvcnRzIGRlcml2aW5nIGFuZCByZWdpc3RlcmluZyBhIG5ldyBjZWxsIGVkaXRvciBjbGFzcy4gVXNlIC5jZWxsRWRpdG9ycy5nZXQoYmFzZUNsYXNzTmFtZSkuZXh0ZW5kKG5ld0NsYXNzTmFtZSB8fCBuYW1lLCB7Li4ufSkgZm9yIHRoYXQuJyk7XG4gICAgfSxcbiAgICBnZXRSZW5kZXJlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFJlbmRlcmVyKCknLCAncmVuZGVyZXInLCAnMS4xLjAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIG51bGwgb2JqZWN0IGJlaGF2aW9yIHNlcnZlcyBhcyBhIHBsYWNlIGhvbGRlci5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgYmVoYXZpb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgcmVzdWxhbn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGlzV2Via2l0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIGFuIGluaXRpYWwgbW91c2Vkb3duIGNsaWNrLCBlaXRoZXIgZm9yIGVkaXRpbmcgYSBjZWxsIG9yIGZvciBkcmFnZ2luZyBhIHNlbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBtb3VzZURvd246IFtdLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBmcm9tIHRoZSBtb3VzZWRvd24gcG9pbnQgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG5cbiAgICBkcmFnRXh0ZW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQSBmbG9hdCB2YWx1ZSBiZXR3ZWVuIDAuMCAtIDEuMCBvZiB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICB2U2Nyb2xsVmFsdWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIGZsb2F0IHZhbHVlIGJldHdlZW4gMC4wIC0gMS4wIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgaFNjcm9sbFZhbHVlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbH0gc2VsZWN0aW9uTW9kZWwgLSBBIFtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbF0obW9kdWxlLS5fc2VsZWN0aW9uLW1vZGVsLmh0bWwpIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgc2VsZWN0aW9uTW9kZWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3J9IGNlbGxFZGl0b3IgLSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiBbZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvcl0obW9kdWxlLWNlbGwtZWRpdG9yc19iYXNlLmh0bWwpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgY2VsbEVkaXRvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYkhTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9maW5iYXJzfEZpbkJhcn0uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBzYkhTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYlZTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9maW5iYXJzfEZpbkJhcn0uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBzYlZTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiBzYlZTY3JvbGxWYWwuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHNiUHJldlZTY3JvbGxWYWx1ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiBzYkhTY3JvbGxWYWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgc2JQcmV2SFNjcm9sbFZhbHVlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIHNob3J0IHRlcm0gbWVtb3J5IG9mIHdoYXQgY29sdW1uIEkgbWlnaHQgYmUgZHJhZ2dpbmcgYXJvdW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuXG4gICAgcmVuZGVyT3ZlcnJpZGVzQ2FjaGU6IHt9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGhvdmVyZWQgY2VsbC5cbiAgICAgKiBAdG9kbyBOZWVkIHRvIGRldGVjdCBob3ZlcmluZyBvdmVyIGJvdHRvbSB0b3RhbHMuXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgaG92ZXJDZWxsOiBudWxsLFxuXG4gICAgc2Nyb2xsaW5nTm93OiBmYWxzZSxcblxuICAgIGxhc3RFZGdlU2VsZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGNsZWFyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgcHJvcGVydGllc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAc3VtbWFyeSBPYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICogQGRlc2MgR3JpZCBwcm9wZXJ0aWVzIG9iamVjdHMgaGF2ZSB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAgICAgICAgICogMS4gVXNlci1jb25maWd1cmVkIHByb3BlcnRpZXMgYXJlIGluIHRoZSBcIm93blwiIGxheWVyLlxuICAgICAgICAgKiAyLiBFeHRlbmRzIGZyb20gKGhhcyBhcyBpdHMgcHJvdG90eXBlKSB0aGUge0BsaW5rIG1vZHVsZTpkeW5hbWljUHJvcGVydGllc3xkeW5hbWljUHJvcGVydGllc30gb2JqZWN0LlxuICAgICAgICAgKiAzLiBUaGUgZHluYW1pYyBwcm9wZXJ0aWVzIG9iamVjdCBleHRlbmRzIGZyb20gdGhlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHN8ZGVmYXVsdHN9IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogQW55IGNoYW5nZXMgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciBtYXkgd2lzaCB0byBtYWtlIHRvIHRoZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzfGRlZmF1bHRzfSBvYmplY3Qgc2hvdWxkIGJlIG1hZGUgX2JlZm9yZV8gcmVhY2hpbmcgdGhpcyBwb2ludCAoX2kuZS4sXyBwcmlvciB0byBhbnkgZ3JpZCBpbnN0YW50aWF0aW9ucykuXG4gICAgICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGR5bmFtaWNQcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBncmlkOiB7IHZhbHVlOiB0aGlzIH0sXG4gICAgICAgICAgICB2YXI6IHsgdmFsdWU6IG5ldyBWYXIoKSB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBDbGVhciBvdXQgYWxsIHN0YXRlIHNldHRpbmdzLCBkYXRhIChyb3dzKSwgYW5kIHNjaGVtYSAoY29sdW1ucykgb2YgYSBncmlkIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc3ViZ3JpZHNdIC0gQ29uc3VtZWQgYnkge0BsaW5rIEJlaGF2aW9yI3Jlc2V0fS5cbiAgICAgKiBJZiBvbWl0dGVkLCBwcmV2aW91c2x5IGVzdGFibGlzaGVkIHN1YmdyaWRzIGxpc3QgaXMgcmV1c2VkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5waXBlbGluZV0gLSBDb25zdW1lZCBieSB7QGxpbmsgZGF0YU1vZGVscy5KU09OI3Jlc2V0fS5cbiAgICAgKiBJZiBvbWl0dGVkLCBwcmV2aW91c2x5IGVzdGFibGlzaGVkIHBpcGVsaW5lIGlzIHJldXNlZC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuY29udHJvbGxlcnNdIC0gQ29uc3VtZWQgYnkge0BsaW5rIGRhdGFNb2RlbHMuSlNPTiNyZXNldH0uXG4gICAgICogSWYgb21pdHRlZCwgcHJldmlvdXNseSBlc3RhYmxpc2hlZCBjb250cm9sbGVycyBsaXN0IGlzIHJldXNlZC5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnJlc2V0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyT3ZlcnJpZGVzQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5jbGVhck1vdXNlRG93bigpO1xuICAgICAgICB0aGlzLmRyYWdFeHRlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG5cbiAgICAgICAgdGhpcy5udW1Sb3dzID0gMDtcbiAgICAgICAgdGhpcy5udW1Db2x1bW5zID0gMDtcblxuICAgICAgICB0aGlzLnZTY3JvbGxWYWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuaFNjcm9sbFZhbHVlID0gMDtcblxuICAgICAgICB0aGlzLmNhbmNlbEVkaXRpbmcoKTtcblxuICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2JQcmV2SFNjcm9sbFZhbHVlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmhvdmVyQ2VsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nTm93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb24gPSBbMCwgMF07XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuYmVoYXZpb3IucmVzZXQoe1xuICAgICAgICAgICAgc3ViZ3JpZHM6IG9wdGlvbnMuc3ViZ3JpZHMsXG4gICAgICAgICAgICBwaXBlbGluZTogb3B0aW9ucy5waXBlbGluZSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJzOiBvcHRpb25zLmNvbnRyb2xsZXJzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JDaGFuZ2VkKCk7XG5cbiAgICAgICAgdGhpcy5yZWZyZXNoUHJvcGVydGllcygpO1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGVkZWYge29iamVjdHxmdW5jdGlvbnxBcnJheX0gcGx1Z2luU3BlY1xuICAgICAqIEBkZXNjIE9uZSBvZjpcbiAgICAgKiAqIHNpbXBsZSBBUEkgLSBhIHBsYWluIG9iamVjdCB3aXRoIGFuIGBpbnN0YWxsYCBtZXRob2RcbiAgICAgKiAqIG9iamVjdCBBUEkgLSBhbiBvYmplY3QgY29uc3RydWN0b3JcbiAgICAgKiAqIGFycmF5OlxuICAgICAqICAgICogZmlyc3QgZWxlbWVudCBpcyBhbiBvcHRpb25hbCBuYW1lIGZvciB0aGUgQVBJIG9yIHRoZSBuZXdseSBpbnN0YW50aWF0ZWQgb2JqZWN0XG4gICAgICogICAgKiBuZXh0IGVsZW1lbnQgKG9yIGZpcnN0IGVsZW1lbnQgd2hlbiBub3QgYSBzdHJpbmcpIGlzIHRoZSBzaW1wbGUgb3Igb2JqZWN0IEFQSVxuICAgICAqICAgICogcmVtYWluaW5nIGFyZ3VtZW50cyBhcmUgb3B0aW9uYWwgYXJndW1lbnRzIGZvciB0aGUgb2JqZWN0IGNvbnN0cnVjdG9yXG4gICAgICogKiBmYWxzeSB2YWx1ZSBzdWNoIGFzIGB1bmRlZmluZWRgIC0gaWdub3JlZFxuICAgICAqXG4gICAgICogVGhlIEFQSSBtYXkgaGF2ZSBhIGBuYW1lYCBvciBgJCRDTEFTU19OQU1FYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbnN0YWxsIHBsdWdpbnMuXG4gICAgICogQGRlc2MgUGx1Z2luIGluc3RhbGxhdGlvbjpcbiAgICAgKiAqIEVhY2ggc2ltcGxlIEFQSSBpcyBpbnN0YWxsZWQgYnkgY2FsbGluZyBpdCdzIGBpbnN0YWxsYCBtZXRob2Qgd2l0aCBgdGhpc2AgYXMgZmlyc3QgYXJnICsgYW55IGFkZGl0aW9uYWwgYXJncyBsaXN0ZWQgaW4gdGhlIGBwbHVnaW5TcGVjYCAod2hlbiBpdCBpcyBhbiBhcnJheSkuXG4gICAgICogKiBFYWNoIG9iamVjdCBBUEkgaXMgaW5zdGFsbGVkIGJ5IGluc3RhbnRpYXRpbmcgaXQncyBjb25zdHJ1Y3RvciB3aXRoIGB0aGlzYCBhcyBmaXJzdCBhcmcgKyBhbnkgYWRkaXRpb25hbCBhcmdzIGxpc3RlZCBpbiB0aGUgYHBsdWdpblNwZWNgICh3aGVuIGl0IGlzIGFuIGFycmF5KS5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHRpbmcgcGxhaW4gb2JqZWN0IG9yIGluc3RhbnRpYXRlZCBvYmplY3RzIG1heSBiZSBuYW1lZCBieSAoaW4gcHJpb3JpdHkgb3JkZXIpOlxuICAgICAqIDEuIGlmIGBwbHVnaW5TcGVjYCBjb250YWlucyBhbiBhcnJheSBhbmQgZmlyc3QgZWxlbWVudCBpcyBhIHN0cmluZ1xuICAgICAqIDIuIG9iamVjdCBoYXMgYSBgbmFtZWAgcHJvcGVydHlcbiAgICAgKiAzLiBvYmplY3QgaGFzIGEgYCQkQ0xBU1NfTkFNRWAgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIElmIG5hbWVkLCBhIHJlZmVyZW5jZSB0byBlYWNoIG9iamVjdCBpcyBzYXZlZCBpbiBgdGhpcy5wbHVnaW5zYC4gSWYgdGhlIHBsdWctaW4gaXMgdW5uYW1lZCwgbm8gcmVmZXJlbmNlIGlzIGtlcHQuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIHBsdWdpbiBpbnN0YWxsYXRpb25zOlxuICAgICAqICogUHJlaW5zdGFsbGVkIHBsdWdpbnMgd2hpY2ggYXJlIGluc3RhbGxlZCBvbiB0aGUgcHJvdG90eXBlLiBUaGVzZSBhcmUgc2ltcGxlIEFQSSBwbHVnaW5zIHdpdGggYSBgcHJlaW5zdGFsbGAgbWV0aG9kIGNhbGxlZCB3aXRoIHRoZSBgaW5zdGFsbFBsdWdpbnNgIGNhbGxpbmcgY29udGV4dCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIFByZWluc3RhbGxhdGlvbnMgYXJlIGF1dG9tYXRpY2FsbHkgcGVyZm9ybWVkIHdoZW5ldmVyIGEgZ3JpZCBpcyBpbnN0YW50aWF0ZWQgKGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbnN0cnVjdG9yKSwgYnkgY2FsbGluZyBgaW5zdGFsbFBsdWdpbnNgIHdpdGggYEh5cGVyZ3JpZC5wcm90b3R5cGVgIGFzIHRoZSBjYWxsaW5nIGNvbnRleHQuXG4gICAgICogKiBSZWd1bGFyIHBsdWdpbnMgd2hpY2ggYXJlIGluc3RhbGxlZCBvbiB0aGUgaW5zdGFuY2UuIFRoZXNlIGFyZSBzaW1wbGUgQVBJIHBsdWdpbnMgd2l0aCBhbiBgaW5zdGFsbGAgbWV0aG9kLCBhcyB3ZWxsIGFzIGFsbCBvYmplY3QgQVBJIHBsdWdpbnMgKGNvbnN0cnVjdG9ycyksIGNhbGxlZCB3aXRoIHRoZSBgaW5zdGFsbFBsdWdpbnNgIGNhbGxpbmcgY29udGV4dCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIFRoZXNlIGluc3RhbGxhdGlvbnMgYXJlIGF1dG9tYXRpY2FsbHkgcGVyZm9ybWVkIHdoZW5ldmVyIGEgZ3JpZCBpcyBpbnN0YW50aWF0ZWQgKGF0IHRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdG9yKSwgY2FsbGVkIHdpdGggdGhlIG5ldyBncmlkIGluc3RhbmNlIGFzIHRoZSBjYWxsaW5nIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBUaGUgXCJgaW5zdGFsbFBsdWdpbnNgIGNhbGxpbmcgY29udGV4dFwiIG1lYW5zIGVpdGhlciB0aGUgZ3JpZCBpbnN0YW5jZSBvciBpdHMgcHJvdG90eXBlLCBkZXBlbmRpbmcgb24gaG93IHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFBsdWdpbnMgbWF5IGhhdmUgYm90aCBgcHJlaW5zdGFsbGAgX2FuZF8gYGluc3RhbGxgIG1ldGhvZHMsIGluIHdoaWNoIGNhc2UgYm90aCB3aWxsIGJlIGNhbGxlZC4gSG93ZXZlciwgbm90ZSB0aGF0IGluIGFueSBjYXNlLCBgaW5zdGFsbGAgbWV0aG9kcyBvbiBvYmplY3QgQVBJIHBsdWdpbnMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAdGhpcyB7SHlwZXJncmlkfVxuICAgICAqIEBwYXJhbSB7cGx1Z2luU3BlY3xwbHVnaW5TcGVjW119IFtwbHVnaW5zXSAtIFRoZSBwbHVnaW5zIHRvIGluc3RhbGwuIElmIG9taXR0ZWQsIHRoZSBjYWxsIGlzIGEgbm8tb3AuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBpbnN0YWxsUGx1Z2luczogZnVuY3Rpb24ocGx1Z2lucykge1xuICAgICAgICB2YXIgc2hhcmVkID0gdGhpcyA9PT0gSHlwZXJncmlkLnByb3RvdHlwZTsgLy8gRG8gc2hhcmVkIChcInByZWluc3RhbGxlZFwiKSBwbHVnaW5zIChpZiBhbnkpXG5cbiAgICAgICAgaWYgKCFwbHVnaW5zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XG4gICAgICAgIH1cblxuICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSwgYXJncywgaGFzaDtcblxuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBmYWxzeSBwbHVnaW4gc3BlY1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgZmlyc3QgYXJnIG9mIGNvbnN0cnVjdG9yIHRvIGB0aGlzYCAodGhlIGdyaWQgaW5zdGFuY2UpXG4gICAgICAgICAgICAvLyBzZXQgZmlyc3QgYXJnIG9mIGBpbnN0YWxsYCBtZXRob2QgdG8gYHRoaXNgICh0aGUgZ3JpZCBpbnN0YW5jZSlcbiAgICAgICAgICAgIC8vIHNldCBmaXJzdCB0d28gYXJncyBvZiBgcHJlaW5zdGFsbGAgbWV0aG9kIHRvIGB0aGlzYCAodGhlIEh5cGVyZ3JpZCBwcm90b3R5cGUpIGFuZCB0aGUgQmVoYXZpb3IgcHJvdG90eXBlXG4gICAgICAgICAgICBhcmdzID0gW3RoaXNdO1xuICAgICAgICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChiZWhhdmlvcnMuQmVoYXZpb3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGx1Z2luLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQocGx1Z2luLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luID0gcGx1Z2luWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChwbHVnaW4uc2xpY2UoMikpO1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGx1Z2luWzBdO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSBwbHVnaW5bMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBlbXB0eSBhcnJheSBvciBhcnJheSB3aXRoIHNpbmdsZSBzdHJpbmcgZWxlbWVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXJpdmUgQVBJIG5hbWUgaWYgbm90IGdpdmVuIGluIHBsdWdpblNwZWNcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IHBsdWdpbi5uYW1lIHx8IHBsdWdpbi4kJENMQVNTX05BTUU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBmaXJzdCBjaGFyYWN0ZXIgdG8gbG93ZXIgY2FzZVxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBgcHJlaW5zdGFsbGAgbWV0aG9kXG4gICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuY29uc3RydWN0b3IucGx1Z2lucztcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnByZWluc3RhbGwgJiYgIWhhc2hbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnByZWluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpbnN0YW5jZSBwbHVnLWluczpcbiAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5wbHVnaW5zO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RhbGwgXCJvYmplY3QgQVBJXCIgYnkgaW5zdGFudGlhdGluZ1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSB0aGlzLmNyZWF0ZUFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4uaW5zdGFsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0YWxsIFwic2ltcGxlIEFQSVwiIGJ5IGNhbGxpbmcgaXRzIGBpbnN0YWxsYCBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwbHVnaW4ucHJlaW5zdGFsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQmFzZS5wcm90b3R5cGUuSHlwZXJncmlkRXJyb3IoJ0V4cGVjdGVkIHBsdWdpbiAoYSBjb25zdHJ1Y3Rvcjsgb3IgYW4gQVBJIHdpdGggYSBgcHJlaW5zdGFsbGAgbWV0aG9kIGFuZC9vciBhbiBgaW5zdGFsbGAgbWV0aG9kKS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaGFzaFtuYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVW5pbnN0YWxsIGFsbCB1bmluc3RhbGxhYmxlIHBsdWdpbnMgb3IganVzdCBuYW1lZCBwbHVnaW5zLlxuICAgICAqIEBkZXNjIENhbGxzIGB1bmluc3RhbGxgIG9uIHBsdWdpbnMgdGhhdCBkZWZpbmUgc3VjaCBhIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRvIHVuaW5zdGFsbCBcInByZWluc3RhbGxlZFwiIHBsdWdpbnMsIGNhbGwgd2l0aCBgSHlwZXJncmlkLnByb3RvdHlwZWAgYXMgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEZvciBjb252ZW5pZW5jZSwgdGhlIGZvbGxvd2luZyBhcmdzIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGw6XG4gICAgICogKiBgdGhpc2AgLSB0aGUgcGx1Z2luIHRvIGJlIHVuaW5zdGFsbGVkXG4gICAgICogKiBgZ3JpZGAgLSB0aGUgaHlwZXJncmlkIG9iamVjdFxuICAgICAqICogYGtleWAgLSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgdW5pbnN0YWxsZWQgKF9pLmUuLF8ga2V5IGluIGBwbHVnaW5zYClcbiAgICAgKiAqIGBwbHVnaW5zYCAtIHRoZSBwbHVnaW5zIGhhc2ggKGEuay5hLiBgZ3JpZC5wbHVnaW5zYClcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdGlybmdbXX0gW3BsdWdpbk5hbWVzXSBJZiBwcm92aWRlZCwgbGltaXQgdW5pbnN0YWxsIHRvIHRoZSBuYW1lZCBwbHVnaW4gKHN0cmluZykgb3IgcGx1Z2lucyAoc3RyaW5nW10pLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgdW5pbnN0YWxsUGx1Z2luczogZnVuY3Rpb24ocGx1Z2luTmFtZXMpIHtcbiAgICAgICAgaWYgKCFwbHVnaW5OYW1lcykge1xuICAgICAgICAgICAgcGx1Z2luTmFtZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwbHVnaW5OYW1lcykpIHtcbiAgICAgICAgICAgIHBsdWdpbk5hbWVzID0gW3BsdWdpbk5hbWVzXTtcbiAgICAgICAgfVxuICAgICAgICBfKHRoaXMucGx1Z2lucykuZWFjaChmdW5jdGlvbihwbHVnaW4sIGtleSwgcGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBsdWdpbnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgICAgICAgIHBsdWdpbk5hbWVzLmluZGV4T2Yoa2V5KSA+PSAwICYmXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVuaW5zdGFsbFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLnVuaW5zdGFsbCh0aGlzLCBrZXksIHBsdWdpbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFByb3BlcnRpZXMoKScsICdwcm9wZXJ0aWVzJywgJzEuMi4wJyk7XG4gICAgfSxcblxuICAgIGNvbXB1dGVDZWxsc0JvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIHNldEZvcm1hdHRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24gPSBuZXcgTG9jYWxpemF0aW9uKFxuICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgfHwgSHlwZXJncmlkLmxvY2FsaXphdGlvbi5sb2NhbGUsXG4gICAgICAgICAgICBvcHRpb25zLm51bWJlck9wdGlvbnMgfHwgSHlwZXJncmlkLmxvY2FsaXphdGlvbi5udW1iZXJPcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucy5kYXRlT3B0aW9ucyB8fCBIeXBlcmdyaWQubG9jYWxpemF0aW9uLmRhdGVPcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb24uaGVhZGVyID0ge1xuICAgICAgICAgICAgZm9ybWF0OiBoZWFkZXJGb3JtYXR0ZXIuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uKGxvY2FsaXplck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemF0aW9uLmdldChsb2NhbGl6ZXJOYW1lKS5mb3JtYXQ7XG4gICAgfSxcblxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbihsb2NhbGl6ZXJOYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gdGhpcy5nZXRGb3JtYXR0ZXIobG9jYWxpemVyTmFtZSk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgIH0sXG5cbiAgICBpc1Jvd1Jlc2l6ZWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdpc1Jvd1Jlc2l6ZWFibGUoKScsICdwcm9wZXJ0aWVzLnJvd1Jlc2l6ZScsICd2MS4yLjEwJyk7XG4gICAgfSxcblxuICAgIGlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2lzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucygpJywgJ3Byb3BlcnRpZXMuY2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucycsICd2MS4yLjEwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgY2VsbCBvdmVyIHdoaWNoIHRoZSBjdXJzb3IgaXMgaG92ZXJpbmcuXG4gICAgICovXG4gICAgZ2V0SG92ZXJDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0SG92ZXJDZWxsKCknLCAnaG92ZXJDZWxsJywgJ3YxLjIuMCcpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU2V0IHRoZSBjZWxsIHVuZGVyIHRoZSBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGNlbGxFdmVudFxuICAgICAqL1xuICAgIHNldEhvdmVyQ2VsbDogZnVuY3Rpb24oY2VsbEV2ZW50KSB7XG4gICAgICAgIHZhciBob3ZlckNlbGwgPSB0aGlzLmhvdmVyQ2VsbDtcbiAgICAgICAgaWYgKCFob3ZlckNlbGwgfHwgIWhvdmVyQ2VsbC5lcXVhbHMoY2VsbEV2ZW50LmdyaWRDZWxsKSkge1xuICAgICAgICAgICAgdGhpcy5ob3ZlckNlbGwgPSBjZWxsRXZlbnQuZ3JpZENlbGw7XG4gICAgICAgICAgICBpZiAoaG92ZXJDZWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlU3ludGhldGljT25DZWxsRXhpdEV2ZW50KGNlbGxFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNPbkNlbGxFbnRlckV2ZW50KGNlbGxFdmVudCk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIEFtZW5kIHByb3BlcnRpZXMgZm9yIHRoaXMgaHlwZXJncmlkIG9ubHkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1vcmVQcm9wZXJ0aWVzIC0gQSBzaW1wbGUgcHJvcGVydGllcyBoYXNoLlxuICAgICAqL1xuICAgIGFkZFByb3BlcnRpZXM6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnByb3BlcnRpZXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0b2RvIGRlcHJlY2F0ZSB0aGlzIGluIGZhdm9yIG9mIG1ha2luZyBwcm9wZXJ0aWVzIGR5bmFtaWMgaW5zdGVhZCAoZm9yIHRob3NlIHRoYXQgbmVlZCB0byBiZSlcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gdG8gcHVzaCBvdXQgcHJvcGVydGllcyBpZiB3ZSBjaGFuZ2UgdGhlbS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIEFuIG9iamVjdCBvZiB2YXJpb3VzIGtleSB2YWx1ZSBwYWlycy5cbiAgICAgKi9cbiAgICByZWZyZXNoUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgICAgIHRoaXMuY2hlY2tTY3JvbGxiYXJWaXNpYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZGVmYXVsdFJvd0hlaWdodCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuYXV0b3NpemVBbGxDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIHN0YXRlIG9iamVjdCBmb3IgcmVtZW1iZXJpbmcgb3VyIHN0YXRlLlxuICAgICAqIEBzZWUgW01lbWVudG8gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1lbnRvX3BhdHRlcm4pXG4gICAgICovXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0UHJpdmF0ZVN0YXRlKCknLCAncHJvcGVydGllcycsICcxLjIuMCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNldCB0aGUgc3RhdGUgb2JqZWN0IHRvIHJldHVybiB0byB0aGUgZ2l2ZW4gdXNlciBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIEEgbWVtZW50byBvYmplY3QuXG4gICAgICogQHNlZSBbTWVtZW50byBwYXR0ZXJuXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lbWVudG9fcGF0dGVybilcbiAgICAgKi9cbiAgICBzZXRTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoUHJvcGVydGllcygpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICAgICAgICAgIHNlbGYuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZGFyaWVzKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfSxcblxuICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U3RhdGUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIGluaXRpYWwgbW91c2UgcG9zaXRpb24gb24gYSBtb3VzZSBkb3duIGV2ZW50IGZvciBjZWxsIGVkaXRpbmcgb3IgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGdldE1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93blt0aGlzLm1vdXNlRG93bi5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFJlbW92ZSB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgcG9wTW91c2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXMubW91c2VEb3duLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tb3VzZURvd24ucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBFbXB0eSBvdXQgdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgY2xlYXJNb3VzZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IFtuZXcgUG9pbnQoLTEsIC0xKV07XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbW91c2UgcG9pbnQgdGhhdCBpbml0aWF0ZWQgYSBjZWxsIGVkaXQgb3IgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHNldE1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5tb3VzZURvd24ucHVzaChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgZXh0ZW50IHBvaW50IG9mIHRoZSBjdXJyZW50IGRyYWcgc2VsZWN0aW9uIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXREcmFnRXh0ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0V4dGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGV4dGVudCBwb2ludCBvZiB0aGUgY3VycmVudCBkcmFnIHNlbGVjdGlvbiBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBzZXREcmFnRXh0ZW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB0aGlzLmRyYWdFeHRlbnQgPSBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgY2FsbGJhY2sgZnJvbSB0aGUgSHlwZXJncmlkUmVuZGVyZXIgc3ViLWNvbXBvbmVudC4gSXQgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcGFpbnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3IuZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0NvbHVtbkF1dG9zaXppbmcoKTtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljR3JpZFJlbmRlcmVkRXZlbnQoKTtcbiAgICB9LFxuXG4gICAgdGlja05vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY1RpY2tFdmVudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFRoZSBncmlkIGhhcyBqdXN0IGJlZW4gcmVuZGVyZWQsIG1ha2Ugc3VyZSB0aGUgY29sdW1uIHdpZHRocyBhcmUgb3B0aW1hbC5cbiAgICAgKi9cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmJlaGF2aW9yO1xuICAgICAgICBiZWhhdmlvci5hdXRvU2l6ZVJvd051bWJlckNvbHVtbigpO1xuICAgICAgICBpZiAoYmVoYXZpb3IuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZhbHNlKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5ncmlkLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRhcmllcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBDb25kaXRpb25hbGx5IGNvcHkgdG8gY2xpcGJvYXJkLlxuICAgICAqIEBkZXNjIElmIHdlIGhhdmUgZm9jdXMsIGNvcHkgb3VyIGN1cnJlbnQgc2VsZWN0aW9uIGRhdGEgdG8gdGhlIHN5c3RlbSBjbGlwYm9hcmQuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgY29weSBzeXN0ZW0gZXZlbnQuXG4gICAgICovXG4gICAgY2hlY2tDbGlwYm9hcmRDb3B5OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGNzdkRhdGEgPSB0aGlzLmdldFNlbGVjdGlvbkFzVFNWKCk7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBjc3ZEYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXZSBoYXZlIGZvY3VzLlxuICAgICAqL1xuICAgIGhhc0ZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhhc0ZvY3VzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBCZWhhdmlvciAobW9kZWwpIG9iamVjdCBmb3IgdGhpcyBncmlkIGNvbnRyb2wuXG4gICAgICogQGRlc2MgVGhpcyBjYW4gYmUgZG9uZSBkeW5hbWljYWxseS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIF8oU2VlIHtAbGluayBiZWhhdmlvcnMuSlNPTiNzZXREYXRhfS4pX1xuICAgICAqIEBwYXJhbSB7QmVoYXZpb3J9IFtvcHRpb25zLmJlaGF2aW9yPWJlaGF2aW9ycy5KU09OXSAtIFRoZSBiZWhhdmlvciAobW9kZWwpIGNhbiBiZSBlaXRoZXIgYSBjb25zdHJ1Y3RvciBvciBhbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2RhdGFSb3dPYmplY3RbXX0gW29wdGlvbnMuZGF0YV0gLSBfKFNlZSB7QGxpbmsgYmVoYXZpb3JzLkpTT04jc2V0RGF0YX0uKV9cbiAgICAgKiBAcGFyYW0ge3BpcGVsaW5lU2NoZW1hfSBbb3B0aW9ucy5waXBlbGluZV0gLSBOZXcgcGlwZWxpbmUgZGVzY3JpcHRpb24uXG4gICAgICovXG4gICAgc2V0QmVoYXZpb3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJlaGF2aW9yKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBpdCBtZWFuczpcbiAgICAgICAgICAgIC8vIDEuIENhbGxlZCBmcm9tIGNvbnN0cnVjdG9yIGJlY2F1c2UgYmVoYXZpb3IgaW5jbHVkZWQgaW4gb3B0aW9ucyBvYmplY3QuXG4gICAgICAgICAgICAvLyAyLiBDYWxsZWQgZnJvbSBgc2V0RGF0YWAgX2FuZF8gd2Fzbid0IGNhbGxlZCBleHBsaWNpdGx5IHNpbmNlIGluc3RhbnRpYXRpb25cbiAgICAgICAgICAgIHZhciBCZWhhdmlvciA9IG9wdGlvbnMuQmVoYXZpb3IgfHwgYmVoYXZpb3JzLkpTT047XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yID0gbmV3IEJlaGF2aW9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5pbml0Q2FudmFzKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRTY3JvbGxiYXJzKCk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLnJlaW5kZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgdW5kZXJseWluZyBkYXRhc291cmNlLlxuICAgICAqIEBkZXNjIFRoaXMgY2FuIGJlIGRvbmUgZHluYW1pY2FsbHkuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gZGF0YVJvd3MgLSBNYXkgYmU6XG4gICAgICogKiBBbiBhcnJheSBvZiBjb25ncnVlbnQgcmF3IGRhdGEgb2JqZWN0cy5cbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF8oU2VlIHtAbGluayBiZWhhdmlvcnMuSlNPTiNzZXREYXRhfS4pX1xuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGFSb3dzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENhbGwgYHNldEJlaGF2aW9yYCBoZXJlIGp1c3QgaW4gY2FzZSBub3QgcHJldmlvdXNseSBzZXQgYnkgY29uc3RydWN0b3IgX29yXyBleHBsaWNpdGx5IHNpbmNlIGluc3RhbnRpYXRpb25cbiAgICAgICAgdGhpcy5zZXRCZWhhdmlvcih7XG4gICAgICAgICAgICBwaXBlbGluZTogdGhpcy5vcHRpb25zLnBpcGVsaW5lXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldERhdGEoZGF0YVJvd3MsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldEluZm8oZGF0YVJvd3MubGVuZ3RoID8gJycgOiB0aGlzLnByb3BlcnRpZXMubm9EYXRhTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBzZXRJbmZvOiBmdW5jdGlvbihtZXNzYWdlcykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEluZm8obWVzc2FnZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IF8oU2VlIHtAbGluayBIeXBlcmdyaWQucHJvdG90eXBlI3NldERhdGF9LilfXG4gICAgICogQGRlc2MgQmluZHMgdGhlIGRhdGEgYW5kIHJlc2hhcGVzIHRoZSBncmlkIChuZXcgY29sdW1uIG9iamVjdHMgY3JlYXRlZClcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdFtdfSBkYXRhUm93cyAtIE1heSBiZTpcbiAgICAgKiAqIEFuIGFycmF5IG9mIGNvbmdydWVudCByYXcgZGF0YSBvYmplY3RzLlxuICAgICAqICogQSBmdW5jdGlvbiByZXR1cm5pbmcgc2FtZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG4gICAgdXBkYXRlRGF0YTogZnVuY3Rpb24oZGF0YVJvd3MsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ3VwZGF0ZURhdGEoZGF0YVJvd3MsIG9wdGlvbnMpJywgJ3NldERhdGEoZGF0YVJvd3MsIG9wdGlvbnMpJywgJ3YxLjIuMTAnLCBhcmd1bWVudHMsXG4gICAgICAgICAgICAnVG8gdXBkYXRlIGRhdGEgd2l0aG91dCBjaGFuZ2luZyBjb2x1bW4gZGVmaW5pdGlvbnMsIGNhbGwgc2V0RGF0YSBfd2l0aG91dCBhIHNjaGVtYS5fJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwaXBlbGluZXNdIC0gTmV3IHBpcGVsaW5lIGRlc2NyaXB0aW9uLiBfKFNlZSB7QGxpbmsgZGF0YU1vZGVscy5KU09OI3NldFBpcGVsaW5lfS4pX1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBfKFNlZSB7QGxpbmsgZGF0YU1vZGVscy5KU09OI3NldFBpcGVsaW5lfS4pX1xuICAgICAqL1xuICAgIHNldFBpcGVsaW5lOiBmdW5jdGlvbihEYXRhU291cmNlcywgb3B0aW9ucyl7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0UGlwZWxpbmUoRGF0YVNvdXJjZXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIEkndmUgYmVlbiBub3RpZmllZCB0aGF0IHRoZSBiZWhhdmlvciBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBiZWhhdmlvckNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kaXZDYW52YXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm51bUNvbHVtbnMgIT09IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSB8fCB0aGlzLm51bVJvd3MgIT09IHRoaXMuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubnVtQ29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWhhdmlvclNoYXBlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJlaGF2aW9yU3RhdGVDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JTaGFwZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kaXZDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZGFyaWVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kaXZDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IE15IGJvdW5kcy5cbiAgICAgKi9cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdmFsdWUgb2YgYSBsbmYgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIEEgbG9vay1hbmQtZmVlbCBrZXkuXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy8gdG9kbzogd2hlbiB3ZSByZW1vdmUgdGhpcyBtZXRob2QsIGFsc28gcmVtb3ZlIGZvcndhcmRzIGZyb20gQmVoYXZpb3IuanMgYW5kIFJlbmRlcmVyLmpzXG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgncmVzb2x2ZVByb3BlcnR5JywgJy5yZXNvbHZlUHJvcGVydHkoa2V5KSBkZXByZWNhdGVkIGFzIG9mIHYxLjIuMCBpbiBmYXZvciBvZiAucHJvcGVydGllcyBkZXJlZmVyZW5jZWQgYnkgW2tleV0uIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4pJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNba2V5XTtcbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLnByb3BlcnRpZXMucmVwYWludEltbWVkaWF0ZWx5O1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIGlmIChub3cgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMucGFpbnROb3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFBhaW50IGltbWVkaWF0ZWx5IGluIHRoaXMgbWljcm90YXNrLlxuICAgICAqL1xuICAgIHBhaW50Tm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucGFpbnROb3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW4gSGlEUEkgbW9kZSAoaGFzIGFuIGF0dHJpYnV0ZSBhcyBzdWNoKS5cbiAgICAgKi9cbiAgICB1c2VIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ3VzZUhpRFBJKCknLCAncHJvcGVydGllcy51c2VIaURQSScsICd2MS4yLjEwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBjb250YWluZXIgZm9yIGEgZ3JpZCBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0Q29udGFpbmVyOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgdGhpcy5pbml0Q29udGFpbmVyKGRpdik7XG4gICAgICAgIHRoaXMuaW5pdFJlbmRlcmVyKCk7XG4gICAgICAgIC8vIGluamVjdEdyaWRFbGVtZW50cy5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEluaXRpYWxpemUgY29udGFpbmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvL0RlZmF1bHQgUG9zaXRpb24gYW5kIGhlaWdodCB0byBlbnN1cmUgRG5EIHdvcmtzXG4gICAgICAgIGlmICghZGl2LnN0eWxlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBudWxsOyAvLyByZXZlcnQgdG8gc3R5bGVzaGVldCB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpdi5jbGllbnRIZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gbnVsbDsgLy8gcmV2ZXJ0IHRvIHN0eWxlc2hlZXQgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlc2hlZXQuaW5qZWN0KCdncmlkJyk7XG5cbiAgICAgICAgLy9wcmV2ZW50IHRoZSBkZWZhdWx0IGNvbnRleHQgbWVudSBmb3IgYXBwZWFyaW5nXG4gICAgICAgIGRpdi5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBkaXYucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuXG4gICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdoeXBlcmdyaWQtY29udGFpbmVyJyk7XG4gICAgICAgIGRpdi5pZCA9IGRpdi5pZCB8fCAnaHlwZXJncmlkJyArIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaHlwZXJncmlkLWNvbnRhaW5lcicpLmxlbmd0aCAtIDEgfHwgJycpO1xuXG4gICAgICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEluaXRpYWxpemUgZHJhd2luZyBzdXJmYWNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXZDYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBkaXZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgc2V0U3R5bGVzKGRpdkNhbnZhcywgdGhpcy5vcHRpb25zLm1hcmdpbiwgRURHRV9TVFlMRVMpO1xuXG4gICAgICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChkaXZDYW52YXMpO1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gbmV3IENhbnZhcyhkaXZDYW52YXMsIHRoaXMucmVuZGVyZXIsIHRoaXMub3B0aW9ucy5jYW52YXMpO1xuICAgICAgICAgICAgY2FudmFzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdoeXBlcmdyaWQnKTtcblxuICAgICAgICAgICAgdGhpcy5kaXZDYW52YXMgPSBkaXZDYW52YXM7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcblxuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZUNhbnZhc0V2ZW50cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludDogZnVuY3Rpb24odW5zY3JvbGxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5jb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQodW5zY3JvbGxlZCk7XG4gICAgfSxcblxuICAgIGNvbnZlcnREYXRhUG9pbnRUb1ZpZXdQb2ludDogZnVuY3Rpb24oZGF0YVBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmNvbnZlcnREYXRhUG9pbnRUb1ZpZXdQb2ludChkYXRhUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNldCBmb3IgYHNjcm9sbGluZ05vd2AgZmllbGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0l0Tm93IC0gVGhlIHR5cGUgb2YgZXZlbnQgd2UgYXJlIGludGVyZXN0ZWQgaW4uXG4gICAgICovXG4gICAgc2V0U2Nyb2xsaW5nTm93OiBmdW5jdGlvbihpc0l0Tm93KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nTm93ID0gaXNJdE5vdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGBzY3JvbGxpbmdOb3dgIGZpZWxkLlxuICAgICAqL1xuICAgIGlzU2Nyb2xsaW5nTm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsaW5nTm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN3aXRjaCB0aGUgY3Vyc29yIGZvciBhIGdyaWQgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnNvck5hbWUgLSBBIHdlbGwga25vdyBjdXJzb3IgbmFtZS5cbiAgICAgKiBAc2VlIFtjdXJzb3IgbmFtZXNdKGh0dHA6Ly93d3cuamF2YXNjcmlwdGVyLm5ldC9mYXEvc3R5bGVzYy5odG0pXG4gICAgICovXG4gICAgYmVDdXJzb3I6IGZ1bmN0aW9uKGN1cnNvck5hbWUpIHtcbiAgICAgICAgaWYgKCFjdXJzb3JOYW1lKSB7XG4gICAgICAgICAgICBjdXJzb3JOYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IGN1cnNvck5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNodXQgZG93biB0aGUgY3VycmVudCBjZWxsIGVkaXRvciBhbmQgc2F2ZSB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBPbmUgb2Y6XG4gICAgICogKiBgZmFsc2VgIC0gRWRpdGluZyBCVVQgY291bGQgbm90IGFib3J0LlxuICAgICAqICogYHRydWVgIC0gTm90IGVkaXRpbmcgT1Igd2FzIGVkaXRpbmcgQU5EIGFib3J0IHdhcyBzdWNjZXNzZnVsLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgc3RvcEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2VsbEVkaXRvciB8fCB0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2h1dCBkb3duIHRoZSBjdXJyZW50IGNlbGwgZWRpdG9yIHdpdGhvdXQgc2F2aW5nIHRoZSBlZGl0ZWQgdmFsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IE9uZSBvZjpcbiAgICAgKiAqIGBmYWxzZWAgLSBFZGl0aW5nIEJVVCBjb3VsZCBub3QgYWJvcnQuXG4gICAgICogKiBgdHJ1ZWAgLSBOb3QgZWRpdGluZyBPUiB3YXMgZWRpdGluZyBBTkQgYWJvcnQgd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBjYW5jZWxFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNlbGxFZGl0b3IgfHwgdGhpcy5jZWxsRWRpdG9yLmNhbmNlbEVkaXRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2l2ZSBjZWxsIGVkaXRvciBvcHBvcnR1bml0eSB0byBjYW5jZWwgKG9yIHNvbWV0aGluZykgaW5zdGVhZCBvZiBzdG9wIC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gT25lIG9mOlxuICAgICAqICogYGZhbHNlYCAtIEVkaXRpbmcgQlVUIGNvdWxkIG5vdCBhYm9ydC5cbiAgICAgKiAqIGB0cnVlYCAtIE5vdCBlZGl0aW5nIE9SIHdhcyBlZGl0aW5nIEFORCBhYm9ydCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIGFib3J0RWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jZWxsRWRpdG9yIHx8IChcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5hYm9ydEVkaXRpbmcgPyB0aGlzLmNlbGxFZGl0b3IuYWJvcnRFZGl0aW5nKCkgOiB0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcoKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiBqdXN0IHRoZSBjZW50ZXIgJ21haW5cIiBkYXRhIGFyZWEuXG4gICAgICovXG4gICAgZ2V0RGF0YUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5jYW52YXMuYm91bmRzO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCBiLm9yaWdpbi54ICsgYi5leHRlbnQueCwgYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtDYW52YXN9IE91ciBmaW4tY2FudmFzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldENhbnZhcygpJywgJ2NhbnZhcycsICcxLjIuMicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IE9wZW4gdGhlIGNlbGwtZWRpdG9yIGZvciB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGV2ZW50IC0gQ29vcmRpbmF0ZXMgb2YgXCJlZGl0IHBvaW50XCIgKGdyaWRDZWxsLngsIGRhdGFDZWxsLnkpLlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZHxDZWxsRWRpdG9yfSBUaGUgY2VsbEVkaXRvciBkZXRlcm1pbmVkIGZyb20gdGhlIGNlbGwncyByZW5kZXIgcHJvcGVydGllcywgd2hpY2ggbWF5IGJlIG1vZGlmaWVkIGJ5IGxvZ2ljIGFkZGVkIGJ5IG92ZXJyaWRpbmcge0BsaW5rIERhdGFNb2RlbCNnZXRDZWxsRWRpdG9yQXR8Z2V0Q2VsbEVkaXRvckF0fS5cbiAgICAgKi9cbiAgICBlZGl0QXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsRWRpdG9yO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdlZGl0QXQoY2VsbEVkaXRvciwgZXZlbnQpJywgJ2VkaXRBdChldmVudCknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hYm9ydEVkaXRpbmcoKTsgLy8gaWYgYW5vdGhlciBlZGl0b3IgaXMgb3BlbiwgY2xvc2UgaXQgZmlyc3RcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudC5pc0RhdGFDb2x1bW4gJiZcbiAgICAgICAgICAgIGV2ZW50LnByb3BlcnRpZXNbZXZlbnQuaXNEYXRhUm93ID8gJ2VkaXRhYmxlJyA6ICdmaWx0ZXJhYmxlJ10gJiZcbiAgICAgICAgICAgIChjZWxsRWRpdG9yID0gdGhpcy5nZXRDZWxsRWRpdG9yQXQoZXZlbnQpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNlbGxFZGl0b3IuYmVnaW5FZGl0aW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5pc0NvbHVtblZpc2libGUoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gVGhlIHJhdyByb3cgaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFSb3dWaXNpYmxlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmlzUm93VmlzaWJsZShyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYyAtIFRoZSBjb2x1bW4gaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJuIC0gVGhlIGdyaWQgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBmdWxseSBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzRGF0YVZpc2libGU6IGZ1bmN0aW9uKGMsIHJuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRGF0YVJvd1Zpc2libGUocm4pICYmIHRoaXMuaXNDb2x1bW5WaXNpYmxlKGMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBpbiB0aGUgYG9mZnNldFhgIGRpcmVjdGlvbiBpZiBjb2x1bW4gaW5kZXggYGNvbEluZGV4YCBpcyBub3QgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gVGhlIGRpcmVjdGlvbiBhbmQgbWFnbml0dWRlIHRvIHNjcm9sbCBpZiB3ZSBuZWVkIHRvLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGluc3VyZU1vZGVsQ29sSXNWaXNpYmxlOiBmdW5jdGlvbihjb2xJbmRleCwgb2Zmc2V0WCkge1xuICAgICAgICB2YXIgbWF4Q29scyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsIC8vIC0xIGV4Y2x1ZGVzIHBhcnRpYWxseSB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgICAgIGluZGV4VG9DaGVjayA9IGNvbEluZGV4ICsgTWF0aC5zaWduKG9mZnNldFgpLFxuICAgICAgICAgICAgdmlzaWJsZSA9ICF0aGlzLmlzQ29sdW1uVmlzaWJsZShpbmRleFRvQ2hlY2spIHx8IGNvbEluZGV4ID09PSBtYXhDb2xzO1xuXG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAvL3RoZSBzY3JvbGwgcG9zaXRpb24gaXMgdGhlIGxlZnRtb3N0IGNvbHVtblxuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeShvZmZzZXRYLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBpbiB0aGUgYG9mZnNldFlgIGRpcmVjdGlvbiBpZiBjb2x1bW4gaW5kZXggYyBpcyBub3QgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gVGhlIGRpcmVjdGlvbiBhbmQgbWFnbml0dWRlIHRvIHNjcm9sbCBpZiB3ZSBuZWVkIHRvLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJvdyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGluc3VyZU1vZGVsUm93SXNWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCwgb2Zmc2V0WSkge1xuICAgICAgICB2YXIgbWF4Um93cyA9IHRoaXMuZ2V0Um93Q291bnQoKSAtIDEsIC8vIC0xIGV4Y2x1ZGVzIHBhcnRpYWxseSB2aXNpYmxlIHJvd3NcbiAgICAgICAgICAgIGluZGV4VG9DaGVjayA9IHJvd0luZGV4ICsgTWF0aC5zaWduKG9mZnNldFkpLFxuICAgICAgICAgICAgdmlzaWJsZSA9ICF0aGlzLmlzRGF0YVJvd1Zpc2libGUoaW5kZXhUb0NoZWNrKSB8fCByb3dJbmRleCA9PT0gbWF4Um93cztcblxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgLy90aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIHRoZSB0b3Btb3N0IHJvd1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeSgwLCBvZmZzZXRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbGx5IGJ5IHRoZSBwcm92aWRlZCBvZmZzZXRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gU2Nyb2xsIGluIHRoZSB4IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSBTY3JvbGwgaW4gdGhlIHkgZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKi9cbiAgICBzY3JvbGxCeTogZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICB0aGlzLnNjcm9sbEhCeShvZmZzZXRYKTtcbiAgICAgICAgdGhpcy5zY3JvbGxWQnkob2Zmc2V0WSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIHZlcnRpY2FsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFNjcm9sbCBpbiB0aGUgeSBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbFZCeTogZnVuY3Rpb24ob2Zmc2V0WSkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYlZTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgb2xkVmFsdWUgKyBvZmZzZXRZKSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBob3Jpem9udGFsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFNjcm9sbCBpbiB0aGUgeCBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbEhCeTogZnVuY3Rpb24ob2Zmc2V0WCkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYkhTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgb2xkVmFsdWUgKyBvZmZzZXRYKSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzY3JvbGxUb01ha2VWaXNpYmxlOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHZhciBkZWx0YSxcbiAgICAgICAgICAgIGR3ID0gdGhpcy5yZW5kZXJlci5kYXRhV2luZG93LFxuICAgICAgICAgICAgZml4ZWRDb2x1bW5Db3VudCA9IHRoaXMucHJvcGVydGllcy5maXhlZENvbHVtbkNvdW50LFxuICAgICAgICAgICAgZml4ZWRSb3dDb3VudCA9IHRoaXMucHJvcGVydGllcy5maXhlZFJvd0NvdW50O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPj0gZml4ZWRDb2x1bW5Db3VudCAmJiAvLyBzY3JvbGwgb25seSBpZiB0YXJnZXQgbm90IGluIGZpeGVkIGNvbHVtbnNcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgdG8gbGVmdCBvZiBzY3JvbGxhYmxlIGNvbHVtbnM7IG5lZ2F0aXZlIGRlbHRhIHNjcm9sbHMgbGVmdFxuICAgICAgICAgICAgICAgIChkZWx0YSA9IGMgLSBkdy5vcmlnaW4ueCkgPCAwIHx8XG5cbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgdG8gcmlnaHQgb2Ygc2Nyb2xsYWJsZSBjb2x1bW5zOyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIHJpZ2h0XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlICsxIGZvcmNlcyByaWdodC1tb3N0IGNvbHVtbiB0byBzY3JvbGwgbGVmdCAoanVzdCBpbiBjYXNlIGl0IHdhcyBvbmx5IHBhcnRpYWxseSBpbiB2aWV3KVxuICAgICAgICAgICAgICAgIChkZWx0YSA9IGMgLSBkdy5jb3JuZXIueCArIDEpID4gMFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuaW5kZXggKz0gZGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByID49IGZpeGVkUm93Q291bnQgJiYgLy8gc2Nyb2xsIG9ubHkgaWYgdGFyZ2V0IG5vdCBpbiBmaXhlZCByb3dzXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGlzIGFib3ZlIHNjcm9sbGFibGUgcm93czsgbmVnYXRpdmUgZGVsdGEgc2Nyb2xscyB1cFxuICAgICAgICAgICAgICAgIChkZWx0YSA9IHIgLSBkdy5vcmlnaW4ueSkgPCAwIHx8XG5cbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgYmVsb3cgc2Nyb2xsYWJsZSByb3dzOyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIGRvd25cbiAgICAgICAgICAgICAgICAoZGVsdGEgPSByIC0gZHcuY29ybmVyLnkpID4gMFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuaW5kZXggKz0gZGVsdGE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0Q2VsbEFuZFNjcm9sbFRvTWFrZVZpc2libGU6IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb01ha2VWaXNpYmxlKGMsIHIpO1xuICAgICAgICB0aGlzLnNlbGVjdENlbGwoYywgciwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgQW5zd2VyIHdoaWNoIGRhdGEgY2VsbCBpcyB1bmRlciBhIHBpeGVsIHZhbHVlIG1vdXNlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bW91c2VQb2ludH0gbW91c2UgLSBUaGUgbW91c2UgcG9pbnQgdG8gaW50ZXJyb2dhdGUuXG4gICAgICovXG5cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQb2ludH0gZ3JpZENlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIGluIHBoeXNpY2FsIGdyaWQgY29vcmRpbmF0ZXMuXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhlIHBpeGVsIGJhc2VkIGJvdW5kcyByZWN0YW5nbGUgZ2l2ZW4gYSBkYXRhIGNlbGwgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBnZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKGdyaWRDZWxsKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5yZW5kZXJlci5nZXRCb3VuZHNPZkNlbGwoZ3JpZENlbGwueCwgZ3JpZENlbGwueSk7XG5cbiAgICAgICAgLy9jb252ZXJ0IHRvIGEgcHJvcGVyIHJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBmaW4tY2FudmFzIHdoZW4gYSByZXNpemUgb2NjdXJzLlxuICAgICAqL1xuICAgIHJlc2l6ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRhcmllcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEEgY2xpY2sgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQGRlc2MgRGV0ZXJtaW5lIHRoZSBjZWxsIGFuZCBkZWxlZ2F0ZSB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIG1vdXNlIGV2ZW50IHRvIGludGVycm9nYXRlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gQ2hhbmdlZC4gU3BlY2lmaWNhbGx5LCBvbmUgb2Y6XG4gICAgICogKiBgdW5kZWZpbmVkYCByb3cgaGFkIG5vIGRyaWxsLWRvd24gY29udHJvbFxuICAgICAqICogYHRydWVgIGRyaWxsLWRvd24gY2hhbmdlZFxuICAgICAqICogYGZhbHNlYCBkcmlsbC1kb3duIHVuY2hhbmdlZCAod2FzIGFscmVhZHkgaW4gcmVxdWVzdGVkIHN0YXRlKVxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5iZWhhdmlvci5jZWxsQ2xpY2tlZChldmVudCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGludGVyY2VwdCBsaW5rIGNsaWNrcywgb3ZlcnJpZGUgdGhpcyBtZXRob2QgKGVpdGhlciBvbiB0aGUgcHJvdG90eXBlIHRvIGFwcGx5IHRvIGFsbCBncmlkIGluc3RhbmNlcyBvciBvbiBhbiBpbnN0YW5jZSB0byBhcHBseSB0byBhIHNwZWNpZmljIGdyaWQgaW5zdGFuY2UpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgd2luZG93T3BlbjogZnVuY3Rpb24odXJsLCBuYW1lLCBmZWF0dXJlcywgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gd2luZG93Lm9wZW4uYXBwbHkod2luZG93LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JlZ2luXVxuICAgICAqIEBwYXJhbSB7bnVibWVyfSBbZW5kXVxuICAgICAqICogQHJldHVybnMge0NvbHVtbltdfSBBIGNvcHkgb2YgdGhlIGFsbCBjb2x1bW5zIGFycmF5IGJ5IHBhc3NpbmcgdGhlIHBhcmFtcyB0byBgQXJyYXkucHJvdG90eXBlLnNsaWNlYC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5zOiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5zKCk7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLnNsaWNlLmFwcGx5KGNvbHVtbnMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmVnaW5dXG4gICAgICogQHBhcmFtIHtudWJtZXJ9IFtlbmRdXG4gICAgICogKiBAcmV0dXJucyB7Q29sdW1uW119IEEgY29weSBvZiB0aGUgYWN0aXZlIGNvbHVtbnMgYXJyYXkgYnkgcGFzc2luZyB0aGUgcGFyYW1zIHRvIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbnM6IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbnMoKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMuc2xpY2UuYXBwbHkoY29sdW1ucywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZ2V0SGlkZGVuQ29sdW1uczogZnVuY3Rpb24oKXtcbiAgICAgICAgLy9BIG5vbiBpbi1tZW1vcnkgYmVoYXZpb3Igd2lsbCBiZSBtb3JlIHRyb3VibGVzb21lXG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEhpZGRlbkNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgaXNWaWV3YWJsZUJ1dHRvbjogZnVuY3Rpb24oYywgcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5pc1ZpZXdhYmxlQnV0dG9uKGMsIHIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNldCB0aGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHkgPSBNYXRoLm1pbih0aGlzLnNiVlNjcm9sbGVyLnJhbmdlLm1heCwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh5KSkpO1xuICAgICAgICBpZiAoeSAhPT0gdGhpcy52U2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuX3NldFNjcm9sbFBvc2l0aW9uWSh5KTtcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy52U2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnZTY3JvbGxWYWx1ZSA9IHk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxmLnNiVlJhbmdlQWRhcHRlci5zdWJqZWN0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVNjcm9sbEV2ZW50KCdmaW4tc2Nyb2xsLXknLCBvbGRZLCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGdldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZTY3JvbGxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTZXQgdGhlIGhvcml6b250YWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldEhTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHggPSBNYXRoLm1pbih0aGlzLnNiSFNjcm9sbGVyLnJhbmdlLm1heCwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh4KSkpO1xuICAgICAgICBpZiAoeCAhPT0gdGhpcy5oU2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuX3NldFNjcm9sbFBvc2l0aW9uWCh4KTtcbiAgICAgICAgICAgIHZhciBvbGRYID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSA9IHg7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvL3NlbGYuc2JIUmFuZ2VBZGFwdGVyLnN1YmplY3RDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlU2Nyb2xsRXZlbnQoJ2Zpbi1zY3JvbGwteCcsIG9sZFgsIHgpO1xuICAgICAgICAgICAgICAgIC8vc2VsZi5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpOyAvLyB0b2RvOiBDb21tZW50ZWQgb2ZmIHRvIHByZXZlbnQgdGhlIGdyaWQgZnJvbSBib3VuY2luZyBiYWNrLCBidXQgdGhlcmUgbWF5IGJlIHJlcHVyY3Vzc2lvbnMuLi5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMgVGhlIHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRIU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgUmVxdWVzdCBpbnB1dCBmb2N1cy5cbiAgICAgKi9cbiAgICB0YWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2FzQ2VsbEVkaXRvciA9IHRoaXMuY2VsbEVkaXRvcjtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICBpZiAoIXdhc0NlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnRha2VGb2N1cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgUmVxdWVzdCBmb2N1cyBmb3Igb3VyIGNlbGwgZWRpdG9yLlxuICAgICAqL1xuICAgIGVkaXRvclRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGxFZGl0b3IudGFrZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBJbml0aWFsaXplIHRoZSBzY3JvbGwgYmFycy5cbiAgICAgKi9cbiAgICBpbml0U2Nyb2xsYmFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNiSFNjcm9sbGVyICYmIHRoaXMuc2JWU2Nyb2xsZXIpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBob3J6QmFyID0gbmV3IEZpbkJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHNlbGYuc2V0SFNjcm9sbFZhbHVlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICBjc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudDogdGhpcy5kaXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHZlcnRCYXIgPSBuZXcgRmluQmFyKHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiAndmVydGljYWwnLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHNlbGYuc2V0VlNjcm9sbFZhbHVlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICBwYWdpbmc6IHtcbiAgICAgICAgICAgICAgICB1cDogc2VsZi5wYWdlVXAuYmluZChzZWxmKSxcbiAgICAgICAgICAgICAgICBkb3duOiBzZWxmLnBhZ2VEb3duLmJpbmQoc2VsZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlciA9IGhvcnpCYXI7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIgPSB2ZXJ0QmFyO1xuXG4gICAgICAgIHZhciBoUHJlZml4ID0gdGhpcy5wcm9wZXJ0aWVzLmhTY3JvbGxiYXJDbGFzc1ByZWZpeDtcbiAgICAgICAgdmFyIHZQcmVmaXggPSB0aGlzLnByb3BlcnRpZXMudlNjcm9sbGJhckNsYXNzUHJlZml4O1xuXG4gICAgICAgIGlmIChoUHJlZml4ICYmIGhQcmVmaXggIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnNiSFNjcm9sbGVyLmNsYXNzUHJlZml4ID0gaFByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2UHJlZml4ICYmIHZQcmVmaXggIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLmNsYXNzUHJlZml4ID0gdlByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGhvcnpCYXIuYmFyKTtcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodmVydEJhci5iYXIpO1xuXG4gICAgICAgIHRoaXMucmVzaXplU2Nyb2xsYmFycygpO1xuICAgIH0sXG5cbiAgICByZXNpemVTY3JvbGxiYXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5zaG9ydGVuQnkodGhpcy5zYlZTY3JvbGxlcikucmVzaXplKCk7XG4gICAgICAgIC8vdGhpcy5zYlZTY3JvbGxlci5zaG9ydGVuQnkodGhpcy5zYkhTY3JvbGxlcik7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIucmVzaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU2Nyb2xsIHZhbHVlcyBoYXZlIGNoYW5nZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgc2V0VlNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRIU2Nyb2xsYmFyVmFsdWVzOiBmdW5jdGlvbihtYXgpIHtcbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5yYW5nZSA9IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogbWF4XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaFNjcm9sbFZhbHVlICE9PSB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSB8fFxuICAgICAgICAgICAgdGhpcy52U2Nyb2xsVmFsdWUgIT09IHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zYlByZXZIU2Nyb2xsVmFsdWUgPSB0aGlzLmhTY3JvbGxWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlID0gdGhpcy52U2Nyb2xsVmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3Iuc2Nyb2xsVmFsdWVDaGFuZ2VkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBHZXQgZGF0YSB2YWx1ZSBhdCBnaXZlbiBjZWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFZhbHVlLmFwcGx5KHRoaXMuYmVoYXZpb3IsIGFyZ3VtZW50cyk7IC8vIG11c3QgdXNlIC5hcHBseSAoc2VlIHRoaXMuYmVoYXZpb3IuZ2V0VmFsdWUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgU2V0IGEgZGF0YSB2YWx1ZSBvZiBhIGdpdmVuIGNlbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIE5ldyBjZWxsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFZhbHVlLmFwcGx5KHRoaXMuYmVoYXZpb3IsIGFyZ3VtZW50cyk7IC8vIG11c3QgdXNlIC5hcHBseSAoc2VlIHRoaXMuYmVoYXZpb3Iuc2V0VmFsdWUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgVGhlIGRhdGEgZGltZW5zaW9ucyBoYXZlIGNoYW5nZWQsIG9yIG91ciBwaXhlbCBib3VuZGFyaWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKiBBZGp1c3QgdGhlIHNjcm9sbGJhciBwcm9wZXJ0aWVzIGFzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBzeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kYXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG5cbiAgICAgICAgdmFyIG51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1Sb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjcm9sbGFibGVXaWR0aCA9IGJvdW5kcy53aWR0aCAtIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGgoKTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBjb2x1bW5zV2lkdGggPSAwLCBsYXN0UGFnZUNvbHVtbkNvdW50ID0gMDtcbiAgICAgICAgICAgIGxhc3RQYWdlQ29sdW1uQ291bnQgPCBudW1Db2x1bW5zICYmIGNvbHVtbnNXaWR0aCA8IHNjcm9sbGFibGVXaWR0aDtcbiAgICAgICAgICAgIGxhc3RQYWdlQ29sdW1uQ291bnQrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbHVtbnNXaWR0aCArPSB0aGlzLmdldENvbHVtbldpZHRoKG51bUNvbHVtbnMgLSBsYXN0UGFnZUNvbHVtbkNvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbnNXaWR0aCA+IHNjcm9sbGFibGVXaWR0aCkge1xuICAgICAgICAgICAgbGFzdFBhZ2VDb2x1bW5Db3VudC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjcm9sbGFibGVIZWlnaHQgPSB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVTY3JvbGxIZWlnaHQoKTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciByb3dzSGVpZ2h0ID0gMCwgbGFzdFBhZ2VSb3dDb3VudCA9IDA7XG4gICAgICAgICAgICBsYXN0UGFnZVJvd0NvdW50IDwgbnVtUm93cyAmJiByb3dzSGVpZ2h0IDwgc2Nyb2xsYWJsZUhlaWdodDtcbiAgICAgICAgICAgIGxhc3RQYWdlUm93Q291bnQrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJvd3NIZWlnaHQgKz0gdGhpcy5nZXRSb3dIZWlnaHQobnVtUm93cyAtIGxhc3RQYWdlUm93Q291bnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm93c0hlaWdodCA+IHNjcm9sbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgIGxhc3RQYWdlUm93Q291bnQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluZm9ybSBzY3JvbGwgYmFyc1xuICAgICAgICBpZiAodGhpcy5zYkhTY3JvbGxlcikge1xuICAgICAgICAgICAgdmFyIGhNYXggPSBNYXRoLm1heCgwLCBudW1Db2x1bW5zIC0gbnVtRml4ZWRDb2x1bW5zIC0gbGFzdFBhZ2VDb2x1bW5Db3VudCk7XG4gICAgICAgICAgICB0aGlzLnNldEhTY3JvbGxiYXJWYWx1ZXMoaE1heCk7XG4gICAgICAgICAgICB0aGlzLnNldEhTY3JvbGxWYWx1ZShNYXRoLm1pbih0aGlzLmdldEhTY3JvbGxWYWx1ZSgpLCBoTWF4KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2JWU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciB2TWF4ID0gTWF0aC5tYXgoMCwgbnVtUm93cyAtIHRoaXMucHJvcGVydGllcy5maXhlZFJvd0NvdW50IC0gbGFzdFBhZ2VSb3dDb3VudCk7XG4gICAgICAgICAgICB0aGlzLnNldFZTY3JvbGxiYXJWYWx1ZXModk1heCk7XG4gICAgICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShNYXRoLm1pbih0aGlzLmdldFZTY3JvbGxWYWx1ZSgpLCB2TWF4KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoaXMuZ2V0Q2FudmFzKCkucmVzaXplKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JTdGF0ZUNoYW5nZWQoKTtcblxuICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbGJhcnMoKTtcbiAgICB9LFxuICAgIHN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdzeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpJywgJ3N5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRhcmllcygpJywgJzEuMi4wJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgTm90ZSB0aGF0IFwidmlld2FibGUgcm93c1wiIGluY2x1ZGVzIGFueSBwYXJ0aWFsbHkgdmlld2FibGUgcm93cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHZpZXdhYmxlIHJvd3MuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlUm93cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIE5vdGUgdGhhdCBcInZpZXdhYmxlIGNvbHVtbnNcIiBpbmNsdWRlcyBhbnkgcGFydGlhbGx5IHZpZXdhYmxlIGNvbHVtbnMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB2aWV3YWJsZSBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0VmlzaWJsZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBJbml0aWFsaXplIHRoZSByZW5kZXJlciBzdWItY29tcG9uZW50LlxuICAgICAqL1xuICAgIGluaXRSZW5kZXJlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcih0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGdpdmVuIGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgdW50cmFuc2xhdGVkIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNldCB0aGUgd2lkdGggb2YgdGhlIGdpdmVuIGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBUaGUgdW50cmFuc2xhdGVkIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uV2lkdGggLSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldENvbHVtbldpZHRoOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgY29sdW1uV2lkdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRFZGl0aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgsIGNvbHVtbldpZHRoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5FZGdlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtbkVkZ2UoYywgdGhpcy5nZXRSZW5kZXJlcigpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdG90YWwgd2lkdGggb2YgYWxsIHRoZSBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgdW50cmFuc2xhdGVkIGZpeGVkIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHJvd0luZGV4LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Um93SGVpZ2h0KHJvd0luZGV4LCBkYXRhTW9kZWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIHJvdyBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SGVpZ2h0IC0gVGhlIHdpZHRoIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHJvd0luZGV4LCByb3dIZWlnaHQsIGRhdGFNb2RlbCkge1xuICAgICAgICBpZiAodGhpcy5hYm9ydEVkaXRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRSb3dIZWlnaHQocm93SW5kZXgsIHJvd0hlaWdodCwgZGF0YU1vZGVsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBmaXhlZCByb3dzIGhlaWdodFxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkUm93c0hlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgX3Zpc2libGVfIGNvbHVtbnMuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFVuZmlsdGVyZWRSb3dDb3VudCgpJywgbnVsbCwgJzEuMi4wJywgYXJndW1lbnRzLCAnTm8gbG9uZ2VyIHN1cHBvcnRlZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFRoZSB0b3AgbGVmdCBhcmVhIGhhcyBiZWVuIGNsaWNrZWQgb25cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IG1vdXNlIC0gVGhlIGV2ZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgdG9wTGVmdENsaWNrZWQ6IGZ1bmN0aW9uKG1vdXNlKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IudG9wTGVmdENsaWNrZWQodGhpcywgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEEgZml4ZWQgcm93IGhhcyBiZWVuIGNsaWNrZWQuXG4gICAgICogQGRlc2MgRGVsZWdhdGVzIHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBldmVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIHJvd0hlYWRlckNsaWNrZWQ6IGZ1bmN0aW9uKG1vdXNlKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iucm93SGVhZGVyQ2xpY2tlZCh0aGlzLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgQSBmaXhlZCBjb2x1bW4gaGFzIGJlZW4gY2xpY2tlZC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQ2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5jb2x1bW5IZWFkZXJDbGlja2VkKHRoaXMsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBBbiBlZGl0IGV2ZW50IGhhcyBvY2N1cnJlZC4gQWN0aXZhdGUgdGhlIGVkaXRvciBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LmdyaWRDZWxsLnggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC5ncmlkQ2VsbC55IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXZlbnQucHJpbWl0aXZlRXZlbnQudHlwZV1cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfENlbGxFZGl0b3J9IFRoZSBlZGl0b3Igb2JqZWN0IG9yIGB1bmRlZmluZWRgIGlmIG5vIGVkaXRvciBvciBlZGl0b3IgYWxyZWFkeSBvcGVuLlxuICAgICAqL1xuICAgIG9uRWRpdG9yQWN0aXZhdGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRBdChldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBjZWxsIGVkaXRvci5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBjZWxsIGVkaXRvciBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbEV2ZW50IC0gVGhlIGdyaWQgY2VsbCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENlbGxFZGl0b3JBdChldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHN1bW1hcnkgVG9nZ2xlIEhpRFBJIHN1cHBvcnQuXG4gICAgICogQGRlc2MgSGlEUEkgc3VwcG9ydCBpcyBub3cgKm9uKiBieSBkZWZhdWx0LlxuICAgICAqID4gVGhlcmUgdXNlZCB0byBiZSBhIGJ1ZyBpbiBDaHJvbWUgdGhhdCBjYXVzZWQgc2V2ZXJlIHNsb3cgZG93biBvbiBiaXQgYmxpdCBvZiBsYXJnZSBpbWFnZXMsIHNvIHRoaXMgSGlEUEkgbmVlZGVkIHRvIGJlIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIHRvZ2dsZUhpRFBJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy51c2VIaURQSSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2hpZHBpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGlkcGknLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgSGlEUEkgcmF0aW8uXG4gICAgICovXG4gICAgZ2V0SGlEUEk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gJiYgdGhpcy5wcm9wZXJ0aWVzLnVzZUhpRFBJKSB7XG4gICAgICAgICAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSBjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gKHJlY2VudGx5IHJlbmRlcmVkKSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZFdpZHRoOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRSZW5kZXJlZFdpZHRoKGNvbEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiAocmVjZW50bHkgcmVuZGVyZWQpIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4LlxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRSZW5kZXJlZEhlaWdodChyb3dJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgVXBkYXRlIHRoZSBjdXJzb3IgdW5kZXIgdGhlIGhvdmVyIGNlbGwuXG4gICAgICovXG4gICAgdXBkYXRlQ3Vyc29yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuYmVoYXZpb3IuZ2V0Q3Vyc29yQXQoLTEsIC0xKTtcbiAgICAgICAgdmFyIGhvdmVyQ2VsbCA9IHRoaXMuaG92ZXJDZWxsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBob3ZlckNlbGwgJiZcbiAgICAgICAgICAgIGhvdmVyQ2VsbC54ID4gLTEgJiZcbiAgICAgICAgICAgIGhvdmVyQ2VsbC55ID4gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGhvdmVyQ2VsbC54ICsgdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgICAgIGN1cnNvciA9IHRoaXMuYmVoYXZpb3IuZ2V0Q3Vyc29yQXQoeCwgaG92ZXJDZWxsLnkgKyB0aGlzLmdldFZTY3JvbGxWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlQ3Vyc29yKGN1cnNvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgUmVwYWludCB0aGUgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAcGFyYW0ge3h9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7eX0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIHJlcGFpbnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVwYWludENlbGwoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSB1c2VyIGlzIGN1cnJlbnRseSBkcmFnZ2luZyBhIGNvbHVtbiB0byByZW9yZGVyIGl0LlxuICAgICAqL1xuICAgIGlzRHJhZ2dpbmdDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU2Nyb2xsIHVwIG9uZSBmdWxsIHBhZ2UuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBwYWdlVXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93TnVtID0gdGhpcy5yZW5kZXJlci5nZXRQYWdlVXBSb3coKTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUocm93TnVtKTtcbiAgICAgICAgcmV0dXJuIHJvd051bTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTY3JvbGwgZG93biBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93TnVtID0gdGhpcy5yZW5kZXJlci5nZXRQYWdlRG93blJvdygpO1xuICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShyb3dOdW0pO1xuICAgICAgICByZXR1cm4gcm93TnVtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIE5vdCB5ZXQgaW1wbGVtZW50ZWQuXG4gICAgICovXG4gICAgcGFnZUxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyAncGFnZSBsZWZ0IG5vdCB5ZXQgaW1wbGVtZW50ZWQnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIE5vdCB5ZXQgaW1wbGVtZW50ZWQuXG4gICAgICovXG4gICAgcGFnZVJpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgJ3BhZ2UgcmlnaHQgbm90IHlldCBpbXBsZW1lbnRlZCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQHJldHVybnMge29iamVjdFtdfSBPYmplY3RzIHdpdGggdGhlIHZhbHVlcyB0aGF0IHdlcmUganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhc3N1bWVzIG9uZSByb3cgb2YgaGVhZGVyc1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmJlaGF2aW9yLFxuICAgICAgICAgICAgY29sQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCkubGVuZ3RoLFxuICAgICAgICAgICAgcm93Q291bnQgPSB0aGlzLnJlbmRlcmVyLnZpc2libGVSb3dzLmxlbmd0aCxcbiAgICAgICAgICAgIGhlYWRlcnMgPSBuZXcgQXJyYXkoY29sQ291bnQpLFxuICAgICAgICAgICAgcmVzdWx0cyA9IG5ldyBBcnJheShyb3dDb3VudCksXG4gICAgICAgICAgICByb3c7XG5cbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlciwgYykge1xuICAgICAgICAgICAgaGVhZGVyc1tjXSA9IGJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihjKS5oZWFkZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbihyZXN1bHQsIHIpIHtcbiAgICAgICAgICAgIHJvdyA9IHJlc3VsdHNbcl0gPSB7XG4gICAgICAgICAgICAgICAgaGllcmFyY2h5OiBiZWhhdmlvci5nZXRGaXhlZENvbHVtblZhbHVlKDAsIHIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBjKSB7XG4gICAgICAgICAgICAgICAgcm93W2ZpZWxkXSA9IGJlaGF2aW9yLmdldFZhbHVlKGMsIHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBdXRvc2l6ZSBhIGNvbHVtbiBmb3IgYmVzdCBmaXQuXG4gICAgICogQHBhcmFtIHtDb2x1bW58bnVtYmVyfSBjb2x1bW5PckluZGV4IC0gVGhlIGNvbHVtbiBvciBhY3RpdmUgY29sdW1uIGluZGV4LlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgYXV0b3NpemVDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbk9ySW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbk9ySW5kZXggPj0gLTIgPyB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihjb2x1bW5PckluZGV4KSA6IGNvbHVtbk9ySW5kZXg7XG4gICAgICAgIGNvbHVtbi5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgRW5hYmxlL2Rpc2FibGUgaWYgdGhpcyBjb21wb25lbnQgY2FuIHJlY2VpdmUgdGhlIGZvY3VzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gLSBjYW5SZWNlaXZlRm9jdXNcbiAgICAgKi9cbiAgICBzZXRGb2N1c2FibGU6IGZ1bmN0aW9uKGNhblJlY2VpdmVGb2N1cykge1xuICAgICAgICB0aGlzLmNhbnZhcy5zZXRGb2N1c2FibGUoY2FuUmVjZWl2ZUZvY3VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdGhhdCB3ZXJlIGp1c3QgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uc0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyB0aGF0IHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFZpc2libGVSb3dzQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlUm93c0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgVXBkYXRlIHRoZSBzaXplIG9mIGEgZ3JpZCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICB1cGRhdGVTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2hlY2tzaXplKCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTdG9wIHRoZSBnbG9iYWwgcmVwYWludGluZyBmbGFnIHRocmVhZC5cbiAgICAgKi9cbiAgICBzdG9wUGFpbnRUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdG9wUGFpbnRUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTdG9wIHRoZSBnbG9iYWwgcmVzaXplIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHN0b3BSZXNpemVUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdG9wUmVzaXplVGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgUmVzdGFydCB0aGUgZ2xvYmFsIHJlc2l6ZSBjaGVjayBmbGFnIHRocmVhZC5cbiAgICAgKi9cbiAgICByZXN0YXJ0UmVzaXplVGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzdGFydFJlc2l6ZVRocmVhZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFJlc3RhcnQgdGhlIGdsb2JhbCByZXBhaW50aW5nIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHJlc3RhcnRQYWludFRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc3RhcnRQYWludFRocmVhZCgpO1xuICAgIH0sXG5cbiAgICBzd2FwQ29sdW1uczogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgLy9UdXJucyBvdXQgdGhpcyBpcyBjYWxsZWQgZHVyaW5nIGRyYWdnZWQgJ2kuZScgd2hlbiB0aGUgZmxvYXRlciBjb2x1bW4gaXMgcmVzaHVmZmxlZFxuICAgICAgICAvL2J5IHRoZSBjdXJyZW50bHkgZHJhZ2dlZCBjb2x1bW4uIFRoZSBjb2x1bW4gcG9zaXRpb25zIGFyZSBjb25zdGFudGx5IHJlc2h1ZmZsZWRcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zd2FwQ29sdW1ucyhzb3VyY2UsIHRhcmdldCk7XG4gICAgfSxcblxuICAgIGVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb24oKTtcbiAgICB9LFxuXG4gICAgZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNNYXhXaWR0aCgpO1xuICAgIH0sXG5cbiAgICBpc01vdXNlRG93bkluSGVhZGVyQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IHRoaXMuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHJldHVybiBtb3VzZURvd24ueCA8IDAgfHwgbW91c2VEb3duLnkgPCBoZWFkZXJSb3dDb3VudDtcbiAgICB9LFxuXG4gICAgX2dldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdfZ2V0Qm91bmRzT2ZDZWxsKCknLCAnZ2V0Qm91bmRzT2ZDZWxsKCknLCAnMS4yLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2luZGV4fSB4IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW5kZXh9IHggLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwcm9wZXJ0aWVzIGZvciBhIHNwZWNpZmljIGNvbHVtbi5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHNldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKHgsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRDb2x1bW5Qcm9wZXJ0aWVzKHgsIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNlbGwgcHJvcGVydGllcyBvZiBnaXZlbiBjb2x1bW4gb3Igb2YgYWxsIGNvbHVtbnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4XSAtIE9taXQgZm9yIGFsbCBjb2x1bW5zLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBjbGVhckFsbENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2xlYXJBbGxDZWxsUHJvcGVydGllcyh4KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZXNldEFsbENlbGxQcm9wZXJ0aWVzQ2FjaGVzKCk7XG4gICAgfSxcblxuICAgIGlzU2hvd1Jvd051bWJlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdpc1Nob3dSb3dOdW1iZXJzKCknLCAncHJvcGVydGllcy5zaG93Um93TnVtYmVycycsICd2MS4yLjEwJyk7XG4gICAgfSxcbiAgICBpc0VkaXRhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnaXNFZGl0YWJsZSgpJywgJ3Byb3BlcnRpZXMuZWRpdGFibGUnLCAndjEuMi4xMCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJSb3dJbmRleHxzZWN0aW9uUG9pbnR9IHJuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBpc0dyaWRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmJlYWh2aW9yLkNlbGxFdmVudCgwLCB5KS5pc0RhdGFSb3c7XG4gICAgfSxcblxuICAgIGlzU2hvd0hlYWRlclJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2lzU2hvd0hlYWRlclJvdygpJywgJ3Byb3BlcnRpZXMuc2hvd0hlYWRlclJvdycsICd2MS4yLjEwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBvZiBhbGwgc3ViZ3JpZHMgcHJlY2VkaW5nIHRoZSBkYXRhIHN1YmdyaWQuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIGlzU2hvd0ZpbHRlclJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2lzU2hvd0ZpbHRlclJvdygpJywgJ3Byb3BlcnRpZXMuc2hvd0ZpbHRlclJvdycsICd2MS4yLjEwJyk7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgIH0sXG4gICAgaXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkgJiYgeCA9PT0gMDtcbiAgICB9LFxuICAgIGNoZWNrU2Nyb2xsYmFyVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHZhciBob3ZlckNsYXNzT3ZlciA9IHRoaXMucHJvcGVydGllcy5zY3JvbGxiYXJIb3Zlck92ZXI7XG4gICAgICAgIC8vIHZhciBob3ZlckNsYXNzT2ZmID0gdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhckhvdmVyT2ZmO1xuXG4gICAgICAgIC8vIGlmIChob3ZlckNsYXNzT2ZmID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NMaXN0LnJlbW92ZShob3ZlckNsYXNzT3Zlcik7XG4gICAgICAgIC8vICAgICB0aGlzLnNiVlNjcm9sbGVyLmNsYXNzTGlzdC5yZW1vdmUoaG92ZXJDbGFzc09mZik7XG4gICAgICAgIC8vICAgICB0aGlzLnNiSFNjcm9sbGVyLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyB9XG4gICAgfSxcbiAgICBpc1Jvd051bWJlckF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdpc1Jvd051bWJlckF1dG9zaXppbmcoKScsICdwcm9wZXJ0aWVzLnJvd051bWJlckF1dG9zaXppbmcnLCAndjEuMi4xMCcpO1xuICAgIH0sXG4gICAgbG9va3VwRmVhdHVyZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmxvb2t1cEZlYXR1cmUoa2V5KTtcbiAgICB9LFxuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRSb3coeSk7XG4gICAgfSxcblxuICAgIGlzQ29sdW1uQXV0b3NpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2lzQ29sdW1uQXV0b3NpemluZygpJywgJ2NvbHVtbkF1dG9zaXppbmcnLCAndjEuMi4yJywgYXJndW1lbnRzLCAnTm90ZSBob3dldmVyIHRoYXQgYXMgb2YgdjEuMi4yIGNvbHVtbkF1dG9zaXppbmcgZ3JpZCBwcm9wZXJ0eSBubyBsb25nZXIgaGFzIHRoZSBnbG9iYWwgbWVhbmluZyBpdCBoYWQgcHJldmlvdXNseSBhbmQgc2hvdWxkIG5vIGxvbmdlciBiZSByZWZlcnJlZCB0byBkaXJlY3RseS4gUmVmZXIgdG8gZWFjaCBjb2x1bW5cXCdzIGBjb2x1bW5BdXRvc2l6aW5nYCBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuICAgIH0sXG5cbiAgICBuZXdQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgbmV3UmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGdpdmVuIGRhdGEgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm5zIHtudWxsfHVuZGVmaW5lZHwqfSBUaGUgZGF0YSBjb250cm9sbGVyIG9yOlxuICAgICAqICogYG51bGxgIG1lYW5zIHVua25vd24gZGF0YSBjb250cm9sbGVyLlxuICAgICAqICogYHVuZGVmaW5lZGAgbWVhbnMgdGhlIGRhdGEgc291cmNlIGhhbmRsZXMgdGhpcyBkYXRhIGNvbnRyb2xsZXIgYnV0IHRoZSBkYXRhIGNvbnRyb2xsZXIgaXMgdW5kZWZpbmVkLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgZ2V0Q29udHJvbGxlcjogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGdpdmVuIGRhdGEgY29udHJvbGxlcihzKS5cbiAgICAgKiBAZGVzYyBUaGUgZGF0YSBtb2RlbCBuZWVkcyB0byBiZSBhYmxlIHRvIGFjY2VwdCB0aGUgc3BlY2lmaWVkIGRhdGEgY29udHJvbGxlciB0eXBlKHMpLiBJZiBpdCBmYWlscyB0byBhY2NlcHQgdGhlIHNwZWNpZmllZCBkYXRhIGNvbnRyb2xsZXIocyksIGFuIGVycm9yIGNvbmRpdGlvbiBpcyByYWlzZWQuXG4gICAgICpcbiAgICAgKiAoVG8gaWdub3JlIHRoZSBlcnJvciwgcGxhY2UgdGhlIGNhbGwgaW4gYSBgdHJ5Li4uY2F0Y2hgLiBGcm9tIHRoZXJlIHlvdSBjb3VsZCBjYWxsIHtAbGluayBCYXNlI25vdGlmeXxub3RpZnl9IHRvIHJlcG9ydCBpdCBhcyBhIHdhcm5pbmcgb3IgYW4gYWxlcnQgaW5zdGVhZC4pXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIGRhdGEgY29udHJvbGxlcihzKSB0cmlnZ2VycyBhIHNoYXBlIGNoYW5nZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU9ySGFzaE9mVHlwZXMgLSBPbmUgb2Y6XG4gICAgICogKiAqKm9iamVjdCoqIC0gSGFzaCBvZiBtdWx0aXBsZSBkYXRhIGNvbnRyb2xsZXJzLCBieSB0eXBlLlxuICAgICAqICogKipzdHJpbmcqKiAtIFR5cGUgb2YgdGhlIHNpbmdsZSBkYXRhIGNvbnRyb2xsZXIgZ2l2ZW4gaW4gYGNvbnRyb2xsZXJgLlxuICAgICAqIEBwYXJhbSB7ZGF0YUNvbnRyb2xJbnRlcmZhY2V9IFtjb250cm9sbGVyXSAtIE9ubHkgcmVxdWlyZWQgd2hlbiAnaGFzaCcgaXMgYSBzdHJpbmc7IG9taXQgd2hlbiBgaGFzaGAgaXMgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gSGFzaCBvZiBhbGwgcmVzdWx0cywgYnkgdHlwZS4gRWFjaCBtZW1iZXIgd2lsbCBiZTpcbiAgICAgKiAqIFRoZSBnaXZlbiBkYXRhIGNvbnRyb2xsZXIgZm9yIHRoYXQgdHlwZSB3aGVuIGRlZmluZWQuXG4gICAgICogKiBBIG5ldyBcIm51bGxcIiBkYXRhIGNvbnRyb2xsZXIsIGdlbmVyYXRlZCBieSB0aGUgZGF0YSBtb2RlbCB3aGVuIHRoZSBnaXZlbiBkYXRhIGNvbnRyb2xsZXIgZm9yIHRoYXQgdHlwZSB3YXMgYHVuZGVmaW5lZGAuXG4gICAgICogKiBgdW5kZWZpbmVkYCAtIFRoZSBkYXRhIGNvbnRyb2xsZXIgd2FzIHVua25vd24gdG8gdGhlIGRhdGEgbW9kZWwuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBzZXRDb250cm9sbGVyOiBmdW5jdGlvbih0eXBlT3JIYXNoT2ZUeXBlcywgY29udHJvbGxlcikge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuYmVoYXZpb3Iuc2V0Q29udHJvbGxlcih0eXBlT3JIYXNoT2ZUeXBlcywgY29udHJvbGxlciksXG4gICAgICAgICAgICByZWplY3Rpb25zID0gT2JqZWN0LmtleXMocmVzdWx0cykuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdHNbbmFtZV07XG4gICAgICAgICAgICB9KS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmIChyZWplY3Rpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCBkYXRhIGNvbnRyb2xsZXIocyk6ICcgKyByZWplY3Rpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcblxuICAgIHByb3A6IGZ1bmN0aW9uKHR5cGUsIGNvbHVtbkluZGV4LCBrZXlPckhhc2gsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLnByb3AuYXBwbHkodGhpcy5iZWhhdmlvciwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZ2V0IGNoYXJNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmNoYXJNYXA7XG4gICAgfVxufSk7XG5cbnZhciBWQVIgPSAnLnZhci4nO1xuZnVuY3Rpb24gaGFzVmFyKGRlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBkZXNjcmlwdG9yLmdldCAmJiBkZXNjcmlwdG9yLmdldC50b1N0cmluZygpLmluZGV4T2YoVkFSKSA+PSAwIHx8XG4gICAgICAgIGRlc2NyaXB0b3Iuc2V0ICYmIGRlc2NyaXB0b3Iuc2V0LnRvU3RyaW5nKCkuaW5kZXhPZihWQVIpID49IDBcbiAgICApO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIHZhcmlhYmxlIGJhY2tlciBmb3IgdXNlIGJ5IHRoZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGluIHtAbGluayBkeW5hbWljUHJvcGVydGllc30uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBtZW1iZXJPZiBIeXBlcmdyaWR+XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBWYXIoKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZHluYW1pY1Byb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoaGFzVmFyKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZHluYW1pY1Byb3BlcnRpZXMsIG5hbWUpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGZpbmRPckNyZWF0ZUNvbnRhaW5lcihib3VuZGluZ1JlY3QpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2h5cGVyZ3JpZCcpLFxuICAgICAgICB1c2VkID0gZGl2ICYmICFkaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNldFN0eWxlcyhkaXYsIGJvdW5kaW5nUmVjdCwgUkVDVF9TVFlMRVMpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpdjtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVzKGVsLCBzdHlsZSwga2V5cykge1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICB2YXIgZWxTdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZWxTdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoZWFkZXJGb3JtYXR0ZXIodmFsdWUsIGNvbmZpZykge1xuICAgIHZhciBjb2xJbmRleCA9IGNvbmZpZy5kYXRhQ2VsbC54LFxuICAgICAgICBzb3J0U3RyaW5nID0gdGhpcy5iZWhhdmlvci5kYXRhTW9kZWwuZ2V0U29ydEltYWdlRm9yQ29sdW1uKGNvbEluZGV4KTtcblxuICAgIGlmIChzb3J0U3RyaW5nKSB7XG4gICAgICAgIHZhciBncm91cHMgPSB2YWx1ZS5sYXN0SW5kZXhPZih0aGlzLmJlaGF2aW9yLmdyb3VwSGVhZGVyRGVsaW1pdGVyKSArIDE7XG5cbiAgICAgICAgLy8gaWYgZ3JvdXBlZCBoZWFkZXIsIHByZXBlbmQgZ3JvdXAgaGVhZGVycyB0byBzb3J0IGRpcmVjdGlvbiBpbmRpY2F0b3JcbiAgICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICAgICAgc29ydFN0cmluZyA9IHZhbHVlLnN1YnN0cigwLCBncm91cHMpICsgc29ydFN0cmluZztcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKGdyb3Vwcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmVwZW5kIHNvcnQgZGlyZWN0aW9uIGluZGljYXRvciB0byBjb2x1bW4gaGVhZGVyXG4gICAgICAgIHZhbHVlID0gc29ydFN0cmluZyArIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAbmFtZSBwbHVnaW5zXG4gKiBAbWVtYmVyT2YgSHlwZXJncmlkXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHN1bW1hcnkgSGFzaCBvZiByZWZlcmVuY2VzIHRvIHNoYXJlZCBwbHVnLWlucy5cbiAqIEBkZXNjIERpY3Rpb25hcnkgb2Ygc2hhcmVkIChwcmUtaW5zdGFsbGVkKSBwbHVnLWlucy4gVXNlZCBpbnRlcm5hbGx5LCBwcmltYXJpbHkgdG8gYXZvaWQgcmVpbnN0YWxsYXRpb25zLiBTZWUgZXhhbXBsZXMgZm9yIGhvdyB0byByZWZlcmVuY2UgKGFsYmVpdCB0aGVyZSBpcyBub3JtYWxseSBubyBuZWVkIHRvIHJlZmVyZW5jZSBwbHVnaW5zIGRpcmVjdGx5KS5cbiAqXG4gKiBGb3IgdGhlIGRpY3Rpb25hcnkgb2YgX2luc3RhbmNlXyBwbHVnaW5zLCBzZWUge0BsaW5rIEh5cGVyZ3JpZCNwbHVnaW5zfHBsdWdpbnN9IChkZWZpbmVkIGluIHRoZSB7QGxpbmsgSHlwZXJncmlkI2ludGlhbGl6ZXxIeXBlcmdyaWQgY29uc3RydWN0b3J9KS5cbiAqXG4gKiBUbyBmb3JjZSByZWluc3RhbGxhdGlvbiBvZiBhIHNoYXJlZCBwbHVnaW4gZGVsZXRlIGl0IGZpcnN0OlxuICogYGBgamF2YXNjcmlwdFxuICogZGVsZXRlIEh5cGVyZ3JpZC5wbHVnaW5zLm15U2hhcmVkUGx1Z2luO1xuICogYGBgXG4gKiBUbyBmb3JjZSByZWluc3RhbGxhdGlvbiBvZiBhbGwgc2hhcmVkIHBsdWdpbnM6XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBIeXBlcmdyaWQucGx1Z2lucyA9IHt9O1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogdmFyIGFsbFNoYXJlZFBsdWdpbnMgPSBIeXBlcmdyaWQucGx1Z2lucztcbiAqIHZhciBteVNoYXJlZFBsdWdpbiA9IEh5cGVyZ3JpZC5wbHVnaW5zLm15U2hhcmVkUGx1Z2luO1xuICovXG5IeXBlcmdyaWQucGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIEBuYW1lIGxvY2FsaXphdGlvblxuICogQG1lbWJlck9mIEh5cGVyZ3JpZFxuICogQHR5cGUge29iamVjdH1cbiAqIEBzdW1tYXJ5IFNoYXJlZCBsb2NhbGl6YXRpb24gZGVmYXVsdHMgZm9yIGFsbCBncmlkIGluc3RhbmNlcy5cbiAqIEBkZXNjIFRoZXNlIHByb3BlcnR5IHZhbHVlcyBhcmUgb3ZlcnJpZGRlbiBieSB0aG9zZSBzdXBwbGllZCBpbiB0aGUgYEh5cGVyZ3JpZGAgY29uc3RydWN0b3IncyBgb3B0aW9ucy5sb2NhbGl6YXRpb25gLlxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IFtsb2NhbGVdIC0gVGhlIGRlZmF1bHQgbG9jYWxlIHRvIHVzZSB3aGVuIGFuIGV4cGxpY2l0IGBsb2NhbGVgIGlzIG9taXR0ZWQgZnJvbSBsb2NhbGl6ZXIgY29uc3RydWN0b3IgY2FsbHMuIFBhc3NlZCB0byBJbnRsLk51bWJlckZvcm1hdGAgYW5kIGBJbnRsLkRhdGVGb3JtYXRgLiBTZWUge0AgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCNMb2NhbGVfaWRlbnRpZmljYXRpb25fYW5kX25lZ290aWF0aW9ufExvY2FsZSBpZGVudGlmaWNhdGlvbiBhbmQgbmVnb3RpYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLiBPbWl0dGluZyB3aWxsIHVzZSB0aGUgcnVudGltZSdzIGxvY2FsIGxhbmd1YWdlIGFuZCByZWdpb24uXG4gKiBAcHJvcGVydHkge29iamVjdH0gW251bWJlck9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuTnVtYmVyRm9ybWF0YCBmb3IgY3JlYXRpbmcgdGhlIGJhc2ljIFwibnVtYmVyXCIgbG9jYWxpemVyLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtkYXRlT3B0aW9uc10gLSBPcHRpb25zIHBhc3NlZCB0byBgSW50bC5EYXRlRm9ybWF0YCBmb3IgY3JlYXRpbmcgdGhlIGJhc2ljIFwiZGF0ZVwiIGxvY2FsaXplci5cbiAqL1xuSHlwZXJncmlkLmxvY2FsaXphdGlvbiA9IHtcbiAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgbnVtYmVyT3B0aW9uczogeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDAgfVxufTtcblxuXG5IeXBlcmdyaWQucHJvdG90eXBlLnNldENvbnRyb2xsZXIub25lcnJvciA9ICd3YXJuJztcblxuSHlwZXJncmlkLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL2xpYi9ldmVudHMnKSk7XG5IeXBlcmdyaWQucHJvdG90eXBlLm1peEluKHJlcXVpcmUoJy4vbGliL3NlbGVjdGlvbicpKTtcblxuSHlwZXJncmlkLmRlZmF1bHRzID0gSHlwZXJncmlkLnByb3BlcnRpZXMgPSBkZWZhdWx0cztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEh5cGVyZ3JpZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKS5Qb2ludDtcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi9CYXNlJyk7XG52YXIgQ29sdW1uID0gcmVxdWlyZSgnLi9Db2x1bW4nKTtcbnZhciBjZWxsRXZlbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi8uLi9saWIvY2VsbEV2ZW50RmFjdG9yeScpO1xudmFyIG5vRXhwb3J0UHJvcGVydGllcyA9IFtcbiAgICAnY29sdW1uSGVhZGVyJyxcbiAgICAnY29sdW1uSGVhZGVyQ29sdW1uU2VsZWN0aW9uJyxcbiAgICAnZmlsdGVyUHJvcGVydGllcycsXG4gICAgJ3Jvd0hlYWRlcicsXG4gICAgJ3Jvd0hlYWRlclJvd1NlbGVjdGlvbicsXG4gICAgJ3Jvd051bWJlcnNQcm9wZXJ0aWVzJyxcbiAgICAndHJlZUNvbHVtblByb3BlcnRpZXMnLFxuICAgICd0cmVlQ29sdW1uUHJvcGVydGllc0NvbHVtblNlbGVjdGlvbicsXG5dO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFic3RyYWN0XG4gKiBAZGVzYyBBIHNvcnQgb2YgXCJtb2RlbCsrLlwiIEl0IGNvbnRhaW5zIGFsbCBjb2RlL2RhdGEgdGhhdCdzIG5lY2Vzc2FyeSBmb3IgZWFzaWx5IGltcGxlbWVudGluZyBhIHZpcnR1YWwgZGF0YSBzb3VyY2UgYW5kIGl0cyBtYW5pcHVsYXRpb24vYW5hbHl0aWNzLlxuICpcbiAqL1xudmFyIEJlaGF2aW9yID0gQmFzZS5leHRlbmQoJ0JlaGF2aW9yJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgdGhpcyBpcyB0aGUgY2FsbGJhY2sgZm9yIHRoZSBwbHVnaW4gcGF0dGVybiBvZiBuZXN0ZWQgdGFnc1xuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF8oU2VlIHtAbGluayBiZWhhdmlvcnMuSlNPTiNzZXREYXRhfSBmb3IgYWRkaXRpb25hbCBvcHRpb25zLilfXG4gICAgICogQHBhcmFtIHtEYXRhTW9kZWxzW119IFtvcHRpb25zLnN1YmdyaWRzXVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SHlwZXJncmlkfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZlYXR1cmVDaGFpbihncmlkKTtcblxuICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc2V0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGZlYXR1cmUgY2hhaW4gLSB0aGlzIGlzIHRoZSBbY2hhaW4gb2YgcmVzcG9uc2liaWxpdHldKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/Q2hhaW5PZlJlc3BvbnNpYmlsaXR5UGF0dGVybikgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBpbml0aWFsaXplRmVhdHVyZUNoYWluOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgSGFzaCBvZiBmZWF0dXJlIGNsYXNzIG5hbWVzLlxuICAgICAgICAgKiBAZGVzYyBCdWlsdCBoZXJlIGJ1dCBvdGhlcndpc2Ugbm90IGluIHVzZS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mZWF0dXJlTWFwID0ge307XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKEZlYXR1cmVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdmFyIG5ld0ZlYXR1cmUgPSBuZXcgRmVhdHVyZUNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgc2VsZi5mZWF0dXJlTWFwW25ld0ZlYXR1cmUuJCRDTEFTU19OQU1FXSA9IG5ld0ZlYXR1cmU7XG4gICAgICAgICAgICBpZiAoc2VsZi5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDaGFpbi5zZXROZXh0KG5ld0ZlYXR1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAc3VtbWFyeSBDb250cm9sbGVyIGNoYWluIG9mIGNvbW1hbmQuXG4gICAgICAgICAgICAgICAgICogQGRlc2MgRWFjaCBmZWF0dXJlIGlzIGxpbmtlZCB0byB0aGUgbmV4dCBmZWF0dXJlLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDaGFpbiA9IG5ld0ZlYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmluaXRpYWxpemVPbihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmZWF0dXJlczogW10sIC8vIG92ZXJyaWRlIGluIGltcGxlbWVudGluZyBjbGFzcyB1bmxlc3Mgbm8gZmVhdHVyZXNcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMucGlwZWxpbmVdIC0gQ29uc3VtZWQgYnkge0BsaW5rIGRhdGFNb2RlbHMuSlNPTiNyZXNldH0uXG4gICAgICpcbiAgICAgKiBJZiBvbWl0dGVkLCBwcmV2aW91c2x5IGVzdGFibGlzaGVkIHBpcGVsaW5lIGlzIHJldXNlZC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuY29udHJvbGxlcnNdIC0gQ29uc3VtZWQgYnkge0BsaW5rIGRhdGFNb2RlbHMuSlNPTiNyZXNldH0uXG4gICAgICpcbiAgICAgKiBJZiBvbWl0dGVkLCBwcmV2aW91c2x5IGVzdGFibGlzaGVkIGNvbnRyb2xsZXJzIGxpc3QgaXMgcmV1c2VkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5kYXRhTW9kZWwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwucmVzZXQoe1xuICAgICAgICAgICAgICAgIHBpcGVsaW5lOiBvcHRpb25zLnBpcGVsaW5lLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJzOiBvcHRpb25zLmNvbnRyb2xsZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge2RhdGFNb2RlbEFQSX1cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kYXRhTW9kZWwgPSB0aGlzLmdldE5ld0RhdGFNb2RlbChvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gcmVjcmVhdGUgYENlbGxFdmVudGAgY2xhc3Mgc28gaXQgY2FuIHNldCB1cCBpdHMgaW50ZXJuYWwgYGdyaWRgLCBgYmVoYXZpb3JgLCBhbmQgYGRhdGFNb2RlbGAgY29udmVuaWVuY2UgcHJvcGVydGllc1xuICAgICAgICAgICAgdGhpcy5DZWxsRXZlbnQgPSBjZWxsRXZlbnRGYWN0b3J5KHRoaXMuZ3JpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uWCA9IHRoaXMuc2Nyb2xsUG9zaXRpb25ZID0gMDtcblxuICAgICAgICB0aGlzLmNsZWFyQ29sdW1ucygpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3JkZXJlZCBsaXN0IG9mIHN1YmdyaWRzIHRvIHJlbmRlci5cbiAgICAgICAgICogQHR5cGUge3N1YmdyaWRTcGVjW119XG4gICAgICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1YmdyaWRzID0gb3B0aW9ucy5zdWJncmlkcyB8fCB0aGlzLnN1YmdyaWRzIHx8IHRoaXMuZGVmYXVsdFN1YmdyaWRTcGVjcztcbiAgICB9LFxuXG4gICAgZ2V0IHJlbmRlcmVkQ29sdW1uQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBnZXQgcmVuZGVyZWRSb3dDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yZW5kZXJlci52aXNpYmxlUm93cy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGNsZWFyQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Q29sdW1uW119XG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Q29sdW1uW119XG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucyA9IFtdO1xuXG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMV0gPSB0aGlzLmNvbHVtbnNbLTFdID0gdGhpcy5uZXdDb2x1bW4oeyBpbmRleDogLTEgfSk7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMl0gPSB0aGlzLmNvbHVtbnNbLTJdID0gdGhpcy5uZXdDb2x1bW4oeyBpbmRleDogLTIgfSk7XG5cbiAgICAgICAgdGhpcy5jb2x1bW5FbnVtID0ge307XG4gICAgfSxcblxuICAgIGdldEFjdGl2ZUNvbHVtbjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zW3hdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgXCJncmlkIGluZGV4XCIgZ2l2ZW4gYSBcImRhdGEgaW5kZXhcIiAob3IgY29sdW1uIG9iamVjdClcbiAgICAgKiBAcGFyYW0ge0NvbHVtbnxudW1iZXJ9IGNvbHVtbk9ySW5kZXhcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfG51bWJlcn0gVGhlIGdyaWQgaW5kZXggb2YgdGhlIGNvbHVtbiBvciB1bmRlZmluZWQgaWYgY29sdW1uIG5vdCBpbiBncmlkLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgZ2V0QWN0aXZlQ29sdW1uSW5kZXg6IGZ1bmN0aW9uKGNvbHVtbk9ySW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY29sdW1uT3JJbmRleCBpbnN0YW5jZW9mIENvbHVtbiA/IGNvbHVtbk9ySW5kZXguaW5kZXggOiBjb2x1bW5PckluZGV4O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uc1tpXS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRWaXNpYmxlQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0VmlzaWJsZUNvbHVtbih4KScsICdnZXRBY3RpdmVDb2x1bW4oeCknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZ2V0VmlzaWJsZUNvbHVtbk5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1uTmFtZSh4KScsICdnZXRBY3RpdmVDb2x1bW4oeCkubmFtZScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRDb2x1bW5JZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldENvbHVtbklkKHgpJywgJ2dldEFjdGl2ZUNvbHVtbih4KS5oZWFkZXInLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZ2V0SGVhZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0SGVhZGVyKHgpJywgJ2dldEFjdGl2ZUNvbHVtbih4KS5oZWFkZXInLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsQ29sdW1uc1t4XTtcbiAgICB9LFxuXG4gICAgbmV3Q29sdW1uOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sdW1uKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBhZGRDb2x1bW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubmV3Q29sdW1uKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgIH0sXG5cbiAgICBjcmVhdGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbENlbGxQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vY29uY3JldGUgaW1wbGVtZW50YXRpb24gaGVyZVxuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oeCk7XG4gICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnByb3BlcnRpZXMuZGVmYXVsdENvbHVtbldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbHVtbi5nZXRXaWR0aCgpO1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29sdW1ufG51bWJlcn0gY29sdW1uT3JJbmRleCAtIFRoZSBjb2x1bW4gb3IgYWN0aXZlIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAcGFyYW0gd2lkdGhcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHNldENvbHVtbldpZHRoOiBmdW5jdGlvbihjb2x1bW5PckluZGV4LCB3aWR0aCkge1xuICAgICAgICB2YXIgY29sdW1uID0gY29sdW1uT3JJbmRleCA+PSAtMiA/IHRoaXMuZ2V0QWN0aXZlQ29sdW1uKGNvbHVtbk9ySW5kZXgpIDogY29sdW1uT3JJbmRleDtcbiAgICAgICAgY29sdW1uLnNldFdpZHRoKHdpZHRoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFByb3ZpZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldENlbGxQcm92aWRlcigpJywgJ2dyaWQuY2VsbFJlbmRlcmVycycsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBjcmVhdGVDZWxsUHJvdmlkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2V0Q2VsbFByb3ZpZGVyKCkgaXMgZGVwcmVjYXRlZCBhcyBvZiB2MS4wLjYuIE5vIHJlcGxhY2VtZW50OyBkbyBub3QgY2FsbC4gUHJldmlvdXNseSBjYWxsZWQgYnkgYEJlaGF2aW9yYCBjb25zdHJ1Y3RvcjsgYG5ldyBDZWxsUmVuZGVyZXJzKClgIGlzIG5vdyBjYWxsZWQgYnkgYEh5cGVyZ3JpZGAgY29uc3RydWN0b3IgaW5zdGVhZC4nLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICovXG4gICAgcmVpbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnJlaW5kZXgoKTtcbiAgICAgICAgdGhpcy5zaGFwZUNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gdG8gZW1wdHkgYW4gb2JqZWN0IG9mIGl0cyBtZW1iZXJzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gZW1wdHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBvcnRQcm9wc11cbiAgICAgKiAqIGB1bmRlZmluZWRgIChvbWl0dGVkKSAtIGRlbGV0ZSAqYWxsKiBwcm9wZXJ0aWVzXG4gICAgICogKiAqKmZhbHN5KiogLSBkZWxldGUgKm9ubHkqIHRoZSBleHBvcnQgcHJvcGVydGllc1xuICAgICAqICogKip0cnV0aHkqKiAtIGRlbGV0ZSBhbGwgcHJvcGVydGllcyAqZXhjZXB0KiB0aGUgZXhwb3J0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBjbGVhck9iamVjdFByb3BlcnRpZXM6IGZ1bmN0aW9uKG9iaiwgZXhwb3J0UHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0UHJvcHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAhZXhwb3J0UHJvcHMgJiYgbm9FeHBvcnRQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydFByb3BzICYmIG5vRXhwb3J0UHJvcGVydGllcy5pbmRleE9mKGtleSkgPCAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBnZXR0ZXIgZm9yIGEgW01lbWVudG9dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TWVtZW50b1BhdHRlcm4pIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0UHJpdmF0ZVN0YXRlKCknLCAnZ3JpZC5wcm9wZXJ0aWVzJywgJzEuMi4wJyk7XG4gICAgfSxcblxuICAgIC8vdGhpcyBpcyBlZmZlY3RpdmVseSBhIGNsb25lLCB3aXRoIGNlcnRhaW4gdGhpbmdzIHJlbW92ZWQuLi4uXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5ncmlkLnByb3BlcnRpZXMpKTtcbiAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY29weS5jb2x1bW5Qcm9wZXJ0aWVzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGNsZWFyIGFsbCB0YWJsZSBzdGF0ZVxuICAgICAqL1xuICAgIGNsZWFyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgIHRoaXMuZ3JpZC5jbGVhclN0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBSZXN0b3JlIHRoaXMgdGFibGUgdG8gYSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKiBTZWUgdGhlIFttZW1lbnRvIHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TWVtZW50b1BhdHRlcm4pLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZW1lbnRvIC0gYW4gZW5jYXBzdWxhdGVkIHJlcHJlc2VudGF0aW9uIG9mIHRhYmxlIHN0YXRlXG4gICAgICovXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uKG1lbWVudG8pIHtcblxuICAgICAgICBpZiAobWVtZW50by5yb3dIZWlnaHRzKSB7XG4gICAgICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ3Jvd0hlaWdodHMnLCAncm93SGVpZ2h0cywgdGhlIGhhc2ggb2Ygcm93IGhlaWdodHMgeW91IHByb3ZpZGVkIHRvIHNldFN0YXRlIG1ldGhvZCwgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhcyBvZiB2MS4yLjAgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCB1c2UgaW5kaXZpZHVhbCBjYWxscyB0byBzZXRSb3dIZWlnaHQoeSwgaGVpZ2h0LCBkYXRhTW9kZWwpIGZvciBlYWNoIHJvdyBoZWlnaHQgeW91IHdpc2ggdG8gc2V0LCB3aGVyZSB5IGlzIGxvY2FsIHplcm8tYmFzZWQgcm93IGluZGV4IHdpdGhpbiBkYXRhTW9kZWwuIFRoZSBkYXRhTW9kZWwgYXJnIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byB0aGlzLmRhdGFNb2RlbDsgc3BlY2lmeSB0byBzZXQgcm93IGhlaWdodHMgaW4gb3RoZXIgZGF0YSBtb2RlbHMsIHN1Y2ggYXMgaGVhZGVyIHJvdywgZmlsdGVyIGNlbGwgcm93LCBpbmRpdmlkdWFsIHN1bW1hcnkgcm93cywgZXRjLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG5cbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5ncmlkLnByb3BlcnRpZXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtZW1lbnRvKSB7XG4gICAgICAgICAgICBpZiAobWVtZW50by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG1lbWVudG9ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0QWxsQ29sdW1uUHJvcGVydGllcyhtZW1lbnRvLmNvbHVtblByb3BlcnRpZXMpO1xuXG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnJlaW5kZXgoKTtcbiAgICB9LFxuXG4gICAgc2V0QWxsQ29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uUHJvcGVydGllcykge1xuICAgICAgICBpZiAoY29sdW1uUHJvcGVydGllcykge1xuICAgICAgICAgICAgY29sdW1uUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnRpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbHVtbihpKS5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldENvbHVtbk9yZGVyOiBmdW5jdGlvbihjb2x1bW5JbmRleGVzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtbkluZGV4ZXMpKXtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSBjb2x1bW5JbmRleGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbihpbmRleCwgaSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uc1tpXSA9IHRoaXMuYWxsQ29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0Q29sdW1uT3JkZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdfc2V0Q29sdW1uT3JkZXIoY29sdW1uSW5kZXhlcyknLCAnc2V0Q29sdW1uT3JkZXIoY29sdW1uSW5kZXhlcyknLCAnMS4yLjEwJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFJlYnVpbGQgdGhlIGNvbHVtbiBvcmRlciBpbmRleGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sdW1uSW5kZXhlcyAtIGxpc3Qgb2YgY29sdW1uIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIC0gd2hldGhlciB0byB0cmlnZ2VyIGNvbHVtbiBjaGFuZ2VkIGV2ZW50XG4gICAgICovXG4gICAgc2V0Q29sdW1uSW5kZXhlczogZnVuY3Rpb24oY29sdW1uSW5kZXhlcywgc2lsZW50KSB7XG4gICAgICAgIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbkluZGV4ZXMgPSBjb2x1bW5JbmRleGVzO1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNPbkNvbHVtbnNDaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG93IGluYWN0aXZlIGNvbHVtbihzKSBvciBtb3ZlIGFjdGl2ZSBjb2x1bW4ocykuXG4gICAgICpcbiAgICAgKiBAZGVzYyBBZGRzIG9uZSBvciBzZXZlcmFsIGNvbHVtbnMgdG8gdGhlIFwiYWN0aXZlXCIgY29sdW1uIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0FjdGl2ZUNvbHVtbkluZGV4ZXM9ZmFsc2VdIC0gV2hpY2ggbGlzdCBgY29sdW1uSW5kZXhlc2AgcmVmZXJzIHRvOlxuICAgICAqICogYHRydWVgIC0gVGhlIGFjdGl2ZSBjb2x1bW4gbGlzdC4gVGhpcyBjYW4gb25seSBtb3ZlIGNvbHVtbnMgYXJvdW5kIHdpdGhpbiB0aGUgYWN0aXZlIGNvbHVtbiBsaXN0OyBpdCBjYW5ub3QgYWRkIGluYWN0aXZlIGNvbHVtbnMgKGJlY2F1c2UgaXQgY2FuIG9ubHkgcmVmZXIgdG8gY29sdW1ucyBpbiB0aGUgYWN0aXZlIGNvbHVtbiBsaXN0KS5cbiAgICAgKiAqIGBmYWxzZWAgLSBUaGUgZnVsbCBjb2x1bW4gbGlzdCAoYXMgcGVyIGNvbHVtbiBzY2hlbWEgYXJyYXkpLiBUaGlzIGluc2VydHMgY29sdW1ucyBmcm9tIHRoZSBcImluYWN0aXZlXCIgY29sdW1uIGxpc3QsIG1vdmluZyBjb2x1bW5zIHRoYXQgYXJlIGFscmVhZHkgYWN0aXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IGNvbHVtbkluZGV4ZXMgLSBDb2x1bW4gaW5kZXgoZXMpIGludG8gbGlzdCBhcyBkZXRlcm1pbmVkIGJ5IGBpc0FjdGl2ZUNvbHVtbkluZGV4ZXNgLiBPbmUgb2Y6XG4gICAgICogKiAqKlNjYWxhciBjb2x1bW4gaW5kZXgqKiAtIEFkZHMgc2luZ2xlIGNvbHVtbiBhdCBpbnNlcnRpb24gcG9pbnQuXG4gICAgICogKiAqKkFycmF5IG9mIGNvbHVtbiBpbmRleGVzKiogLSBBZGRzIG11bHRpcGxlIGNvbnNlY3V0aXZlIGNvbHVtbnMgYXQgaW5zZXJ0aW9uIHBvaW50LlxuICAgICAqXG4gICAgICogX1RoaXMgcmVxdWlyZWQgcGFyYW1ldGVyIGlzIHByb21vdGVkIGxlZnQgb25lIGFyZyBwb3NpdGlvbiB3aGVuIGBpc0FjdGl2ZUNvbHVtbkluZGV4ZXNgIG9taXR0ZWQuX1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZWZlcmVuY2VJbmRleD10aGlzLmNvbHVtbnMubGVuZ3RoXSAtIEluc2VydGlvbiBwb2ludCwgX2kuZS4sXyB0aGUgZWxlbWVudCB0byBpbnNlcnQgYmVmb3JlLiBBIG5lZ2F0aXZlIHZhbHVlcyBza2lwcyB0aGUgcmVpbnNlcnQuIERlZmF1bHQgaXMgdG8gaW5zZXJ0IG5ldyBjb2x1bW5zIGF0IGVuZCBvZiBhY3RpdmUgY29sdW1uIGxpc3QuXG4gICAgICpcbiAgICAgKiBfUHJvbW90ZWQgbGVmdCBvbmUgYXJnIHBvc2l0aW9uIHdoZW4gYGlzQWN0aXZlQ29sdW1uSW5kZXhlc2Agb21pdHRlZC5fXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd0R1cGxpY2F0ZUNvbHVtbnM9ZmFsc2VdIC0gVW5sZXNzIHRydWUsIGFscmVhZHkgdmlzaWJsZSBjb2x1bW5zIGFyZSByZW1vdmVkIGZpcnN0LlxuICAgICAqXG4gICAgICogX1Byb21vdGVkIGxlZnQgb25lIGFyZyBwb3NpdGlvbiB3aGVuIGBpc0FjdGl2ZUNvbHVtbkluZGV4ZXNgIG9taXR0ZWQgKyBvbmUgcG9zaXRpb24gd2hlbiBgcmVmZXJlbmNlSW5kZXhgIG9taXR0ZWQuX1xuICAgICAqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIHNob3dDb2x1bW5zOiBmdW5jdGlvbihpc0FjdGl2ZUNvbHVtbkluZGV4ZXMsIGNvbHVtbkluZGV4ZXMsIHJlZmVyZW5jZUluZGV4LCBhbGxvd0R1cGxpY2F0ZUNvbHVtbnMpIHtcbiAgICAgICAgLy8gUHJvbW90ZSBhcmdzIHdoZW4gaXNBY3RpdmVDb2x1bW5JbmRleGVzIG9taXR0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiBpc0FjdGl2ZUNvbHVtbkluZGV4ZXMgPT09ICdudW1iZXInIHx8IEFycmF5LmlzQXJyYXkoaXNBY3RpdmVDb2x1bW5JbmRleGVzKSkge1xuICAgICAgICAgICAgYWxsb3dEdXBsaWNhdGVDb2x1bW5zID0gcmVmZXJlbmNlSW5kZXg7XG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCA9IGNvbHVtbkluZGV4ZXM7XG4gICAgICAgICAgICBjb2x1bW5JbmRleGVzID0gaXNBY3RpdmVDb2x1bW5JbmRleGVzO1xuICAgICAgICAgICAgaXNBY3RpdmVDb2x1bW5JbmRleGVzID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aXZlQ29sdW1ucyA9IHRoaXMuY29sdW1ucyxcbiAgICAgICAgICAgIHNvdXJjZUNvbHVtbkxpc3QgPSBpc0FjdGl2ZUNvbHVtbkluZGV4ZXMgPyBhY3RpdmVDb2x1bW5zIDogdGhpcy5hbGxDb2x1bW5zO1xuXG4gICAgICAgIC8vIE5lc3Qgc2NhbGFyIGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uSW5kZXhlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ZXMgPSBbY29sdW1uSW5kZXhlc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3Q29sdW1ucyA9IGNvbHVtbkluZGV4ZXNcbiAgICAgICAgICAgIC8vIExvb2sgdXAgY29sdW1ucyB1c2luZyBwcm92aWRlZCBpbmRleGVzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGluZGV4KSB7IHJldHVybiBzb3VyY2VDb2x1bW5MaXN0W2luZGV4XTsgfSlcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgdW5kZWZpbmVkIGNvbHVtbnNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY29sdW1uKSB7IHJldHVybiBjb2x1bW47IH0pO1xuXG4gICAgICAgIC8vIERlZmF1bHQgaW5zZXJ0aW9uIHBvaW50IGlzIGVuZCAoaS5lLiwgYmVmb3JlIChsYXN0KzEpdGggZWxlbWVudClcbiAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VJbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFsbG93RHVwbGljYXRlQ29sdW1ucyA9IHJlZmVyZW5jZUluZGV4OyAvLyBhc3N1bWUgcmVmZXJlbmNlIGluZGV4IHdhcyBvbWl0dGVkIHdoZW4gbm90IGEgbnVtYmVyXG4gICAgICAgICAgICByZWZlcmVuY2VJbmRleCA9IGFjdGl2ZUNvbHVtbnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFscmVhZHkgdmlzaWJsZSBjb2x1bW5zIGFuZCBhZGp1c3QgaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgIGlmICghYWxsb3dEdXBsaWNhdGVDb2x1bW5zKSB7XG4gICAgICAgICAgICBuZXdDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhY3RpdmVDb2x1bW5zLmluZGV4T2YoY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNvbHVtbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlSW5kZXggPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLXJlZmVyZW5jZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBjb2x1bW5zIGF0IHRoZSBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgaWYgKHJlZmVyZW5jZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGFjdGl2ZUNvbHVtbnMuc3BsaWNlLmFwcGx5KGFjdGl2ZUNvbHVtbnMsIFtyZWZlcmVuY2VJbmRleCwgMF0uY29uY2F0KG5ld0NvbHVtbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbkluZGV4ZXMgPSBhY3RpdmVDb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5pbmRleDsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhpZGUgYWN0aXZlIGNvbHVtbihzKS5cbiAgICAgKiBAZGVzYyBSZW1vdmVzIG9uZSBvciBzZXZlcmFsIGNvbHVtbnMgZnJvbSB0aGUgXCJhY3RpdmVcIiBjb2x1bW4gbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0FjdGl2ZUNvbHVtbkluZGV4ZXM9ZmFsc2VdIC0gV2hpY2ggbGlzdCBgY29sdW1uSW5kZXhlc2AgcmVmZXJzIHRvOlxuICAgICAqICogYHRydWVgIC0gVGhlIGFjdGl2ZSBjb2x1bW4gbGlzdC5cbiAgICAgKiAqIGBmYWxzZWAgLSBUaGUgZnVsbCBjb2x1bW4gbGlzdCAoYXMgcGVyIGNvbHVtbiBzY2hlbWEgYXJyYXkpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBjb2x1bW5JbmRleGVzIC0gQ29sdW1uIGluZGV4KGVzKSBpbnRvIGxpc3QgYXMgZGV0ZXJtaW5lZCBieSBgaXNBY3RpdmVDb2x1bW5JbmRleGVzYC4gT25lIG9mOlxuICAgICAqICogKipTY2FsYXIgY29sdW1uIGluZGV4KiogLSBBZGRzIHNpbmdsZSBjb2x1bW4gYXQgaW5zZXJ0aW9uIHBvaW50LlxuICAgICAqICogKipBcnJheSBvZiBjb2x1bW4gaW5kZXhlcyoqIC0gQWRkcyBtdWx0aXBsZSBjb25zZWN1dGl2ZSBjb2x1bW5zIGF0IGluc2VydGlvbiBwb2ludC5cbiAgICAgKlxuICAgICAqIF9UaGlzIHJlcXVpcmVkIHBhcmFtZXRlciBpcyBwcm9tb3RlZCBsZWZ0IG9uZSBhcmcgcG9zaXRpb24gd2hlbiBgaXNBY3RpdmVDb2x1bW5JbmRleGVzYCBvbWl0dGVkLl9cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICovXG4gICAgaGlkZUNvbHVtbnM6IGZ1bmN0aW9uKGlzQWN0aXZlQ29sdW1uSW5kZXhlcywgY29sdW1uSW5kZXhlcykge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7IC8vIENvbnZlcnQgdG8gYXJyYXkgc28gd2UgY2FuIGFkZCBhbiBhcmd1bWVudCAoZWxlbWVudClcbiAgICAgICAgYXJncy5wdXNoKC0xKTsgLy8gUmVtb3ZlIG9ubHk7IGRvIG5vdCByZWluc2VydC5cbiAgICAgICAgdGhpcy5zaG93Q29sdW1ucy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGZldGNoIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYSBwcm9wZXJ0eSBuYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy8gdG9kbzogcmVtb3ZlIHdoZW4gd2UgcmVtb3ZlIHRoZSBkZXByZWNhdGVkIGdyaWQucmVzb2x2ZVByb3BlcnR5XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KGtleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBBIHNwZWNpZmljIGNlbGwgd2FzIGNsaWNrZWQ7IHlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIGFsbCBldmVudCBpbmZvcm1hdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENsaWNrZWQgaW4gYSBkcmlsbC1kb3duIGNvbHVtbi5cbiAgICAgKi9cbiAgICBjZWxsQ2xpY2tlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2NlbGxDbGlja2VkKGNlbGwsIGV2ZW50KScsICdjZWxsQ2xpY2tlZChldmVudCknLCAnMS4yLjAnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5jZWxsQ2xpY2tlZChldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBBIHNwZWNpZmljIGNlbGwgd2FzIGxlIGRvdWJsZS1jbGlja2VkOyB5b3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gcG9pbnQgb2YgY2VsbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIGFsbCBldmVudCBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGNlbGxEb3VibGVDbGlja2VkOiBmdW5jdGlvbihjZWxsLCBldmVudCkge1xuXG4gICAgfSxcblxuICAgIGxvb2t1cEZlYXR1cmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlTWFwW2tleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fG51bWJlcn0geE9yQ2VsbEV2ZW50IC0gR3JpZCBjb2x1bW4gY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gT21pdCBpZiBgeE9yQ2VsbEV2ZW50YCBpcyBhIENlbGxFdmVudC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4geE9yQ2VsbEV2ZW50LnZhbHVlO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5DZWxsRXZlbnQoeE9yQ2VsbEV2ZW50LCB5KS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXRzIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgZGF0YSBzdWJncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkVmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0QWN0aXZlQ29sdW1uKHgpO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5nZXRVbmZpbHRlcmVkVmFsdWUoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGRhdGEgYXQgcG9pbnQgeCwgeSB3aXRoIHZhbHVlXG4gICAgICogQHJldHVybiBUaGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudHxudW1iZXJ9IHhPckNlbGxFdmVudCAtIEdyaWQgY29sdW1uIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5XSAtIEdyaWQgcm93IGNvb3JkaW5hdGUuIE9taXQgaWYgYHhPckNlbGxFdmVudGAgaXMgYSBDZWxsRXZlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHVzZS4gX1doZW4gYHlgIG9taXR0ZWQsIHByb21vdGVkIHRvIDJuZCBhcmcuX1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnN1bWVkLlxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4T3JDZWxsRXZlbnQsIHksIHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAzOiB4T3JDZWxsRXZlbnQgPSBuZXcgdGhpcy5DZWxsRXZlbnQoeE9yQ2VsbEV2ZW50LCB5KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6IHZhbHVlID0geTsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB4T3JDZWxsRXZlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YVZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldERhdGFWYWx1ZSh4LCB5KScsICdkYXRhTW9kZWwuZ2V0VmFsdWUoeCwgeSknLCAnMS4xLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBzZXREYXRhVmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ3NldERhdGFWYWx1ZSh4LCB5LCB2YWx1ZSknLCAnZGF0YU1vZGVsLnNldFZhbHVlKHgsIHksIHZhbHVlKScsICcxLjEuMCcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgY2VsbCdzIG93biBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgKiBAZGVzYyBNYXkgYmUgdW5kZWZpbmVkIGJlY2F1c2UgY2VsbHMgb25seSBoYXZlIHRoZWlyIG93biBwcm9wZXJ0aWVzIG9iamVjdCB3aGVuIGF0IGxlc3Qgb25lIG93biBwcm9wZXJ0eSBoYXMgYmVlbiBzZXQuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfG9iamVjdH0gVGhlIFwib3duXCIgcHJvcGVydGllcyBvZiB0aGUgY2VsbCBhdCB4LHkgaW4gdGhlIGdyaWQuIElmIHRoZSBjZWxsIGRvZXMgbm90IG93biBhIHByb3BlcnRpZXMgb2JqZWN0LCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBnZXRDZWxsT3duUHJvcGVydGllczogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5KSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB4T3JDZWxsRXZlbnQuY29sdW1uIC8vIHhPckNlbGxFdmVudCBpcyBjZWxsRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLmdldENlbGxPd25Qcm9wZXJ0aWVzKHhPckNlbGxFdmVudC5kYXRhQ2VsbC55LCB4T3JDZWxsRXZlbnQudmlzaWJsZVJvdy5zdWJncmlkKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KSAvLyB4T3JDZWxsRXZlbnQgaXMgeFxuICAgICAgICAgICAgICAgICAgICAuZ2V0Q2VsbE93blByb3BlcnRpZXMoeSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBwcm9wZXJ0aWVzIG9iamVjdCBmb3IgY2VsbC5cbiAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBjZWxsJ3Mgb3duIHByb3BlcnRpZXMgb2JqZWN0IGlmIGZvdW5kIGVsc2UgdGhlIGNvbHVtbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIHNlZWtpbmcgYSBzaW5nbGUgc3BlY2lmaWMgcHJvcGVydHksIGNvbnNpZGVyIGNhbGxpbmcge0BsaW5rIEJlaGF2aW9yI2dldENlbGxQcm9wZXJ0eX0gaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudHxudW1iZXJ9IHhPckNlbGxFdmVudCAtIERhdGEgeCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLiBfT21pdCB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIGEgYENlbGxFdmVudGAuX1xuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGNlbGwgYXQgeCx5IGluIHRoZSBncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5KSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB4T3JDZWxsRXZlbnQucHJvcGVydGllczsgLy8geE9yQ2VsbEV2ZW50IGlzIGNlbGxFdmVudFxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbih4T3JDZWxsRXZlbnQpIC8vIHhPckNlbGxFdmVudCBpcyB4XG4gICAgICAgICAgICAgICAgICAgIC5nZXRDZWxsUHJvcGVydGllcyh5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXR1cm4gYSBzcGVjaWZpYyBjZWxsIHByb3BlcnR5LlxuICAgICAqIEBkZXNjIElmIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3QsIGRlZmVycyB0byBjb2x1bW4gcHJvcGVydGllcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS5fIE9taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gTmFtZSBvZiBwcm9wZXJ0eSB0byBnZXQuIF9XaGVuIGB5YCBvbWl0dGVkLCB0aGlzIHBhcmFtIHByb21vdGVkIHRvIDJuZCBhcmcuX1xuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBmb3IgdGhlIGNlbGwgYXQgeCx5IGluIHRoZSBncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydHk6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSwga2V5KSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB4T3JDZWxsRXZlbnQucHJvcGVydGllc1t5XTsgLy8geE9yQ2VsbEV2ZW50IGlzIGNlbGxFdmVudCBhbmQgeSBvbWl0dGVkIHNvIHkgaGVyZSBpcyBhY3R1YWxseSBrZXlcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KSAvLyB4T3JDZWxsRXZlbnQgaXMgeFxuICAgICAgICAgICAgICAgICAgICAuZ2V0Q2VsbFByb3BlcnR5KHksIGtleSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgZGF0YSBhdCBwb2ludCB4LCB5IHdpdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudHxudW1iZXJ9IHhPckNlbGxFdmVudCAtIERhdGEgeCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLiBfT21pdCB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIGEgYENlbGxFdmVudGAuX1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gSGFzaCBvZiBjZWxsIHByb3BlcnRpZXMuIF9XaGVuIGB5YCBvbWl0dGVkLCB0aGlzIHBhcmFtIHByb21vdGVkIHRvIDJuZCBhcmcuX1xuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4T3JDZWxsRXZlbnQsIHksIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgeE9yQ2VsbEV2ZW50LmNvbHVtbiAvLyB4T3JDZWxsRXZlbnQgaXMgY2VsbEV2ZW50XG4gICAgICAgICAgICAgICAgLnNldENlbGxQcm9wZXJ0aWVzKHhPckNlbGxFdmVudC5kYXRhQ2VsbC55LCB5LCB4T3JDZWxsRXZlbnQudmlzaWJsZVJvdy5zdWJncmlkKTsgLy8geSBvbWl0dGVkIHNvIHkgaGVyZSBpcyBhY3R1YWxseSBwcm9wZXJ0aWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldENvbHVtbih4T3JDZWxsRXZlbnQpIC8vIHhPckNlbGxFdmVudCBpcyB4XG4gICAgICAgICAgICAgICAgLnNldENlbGxQcm9wZXJ0aWVzKHksIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGRhdGEgYXQgcG9pbnQgeCwgeSB3aXRoIHZhbHVlXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIEhhc2ggb2YgY2VsbCBwcm9wZXJ0aWVzLiBfV2hlbiBgeWAgb21pdHRlZCwgdGhpcyBwYXJhbSBwcm9tb3RlZCB0byAybmQgYXJnLl9cbiAgICAgKi9cbiAgICBhZGRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHhPckNlbGxFdmVudC5jb2x1bW4gLy8geE9yQ2VsbEV2ZW50IGlzIGNlbGxFdmVudFxuICAgICAgICAgICAgICAgIC5hZGRDZWxsUHJvcGVydGllcyh4T3JDZWxsRXZlbnQuZGF0YUNlbGwueSwgeSwgeE9yQ2VsbEV2ZW50LnZpc2libGVSb3cuc3ViZ3JpZCk7IC8vIHkgb21pdHRlZCBzbyB5IGhlcmUgaXMgYWN0dWFsbHkgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KSAvLyB4T3JDZWxsRXZlbnQgaXMgeFxuICAgICAgICAgICAgICAgIC5hZGRDZWxsUHJvcGVydGllcyh5LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgYSBzcGVjaWZpYyBjZWxsIHByb3BlcnR5LlxuICAgICAqIEBkZXNjIElmIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3QsIGRlZmVycyB0byBjb2x1bW4gcHJvcGVydGllcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBOT1RFOiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgcmVuZGVyZXIncyBjZWxsIGV2ZW50IG9iamVjdHMgY2FjaGUgdGhlaXIgcmVzcGVjdGl2ZSBjZWxsIHByb3BlcnRpZXMgb2JqZWN0cy4gVGhpcyBtZXRob2QgYWNjZXB0cyBhIGBDZWxsRXZlbnRgIG92ZXJsb2FkLiBXaGVuZXZlciBwb3NzaWJsZSwgdXNlIHRoZSBgQ2VsbEV2ZW50YCBmcm9tIHRoZSByZW5kZXJlcidzIGNlbGwgZXZlbnQgcG9vbC4gRG9pbmcgc28gd2lsbCByZXNldCB0aGUgY2VsbCBwcm9wZXJ0aWVzIG9iamVjdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIElmIHlvdSB1c2Ugc29tZSBvdGhlciBgQ2VsbEV2ZW50YCwgdGhlIHJlbmRlcmVyJ3MgYENlbGxFdmVudGAgcHJvcGVydGllcyBjYWNoZSB3aWxsIG5vdCBiZSBhdXRvbWF0aWNhbGx5IHJlc2V0IHVudGlsIHRoZSB3aG9sZSBjZWxsIGV2ZW50IHBvb2wgaXMgcmVzZXQgb24gdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgUmVuZGVyZXIjY29tcHV0ZUNlbGxCb3VuZGFyaWVzfS4gSWYgbmVjZXNzYXJ5LCB5b3UgY2FuIFwibWFudWFsbHlcIiByZXNldCBpdCBieSBjYWxsaW5nIHtAbGluayBSZW5kZXJlciNyZXNldENlbGxQcm9wZXJ0aWVzQ2FjaGV8cmVzZXRDZWxsUHJvcGVydGllc0NhY2hlKHlvdXJDZWxsRXZlbnQpfSB3aGljaCBzZWFyY2hlcyB0aGUgY2VsbCBldmVudCBwb29sIGZvciBvbmUgd2l0aCBtYXRjaGluZyBjb29yZGluYXRlcyBhbmQgcmVzZXRzIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFRoZSByYXcgY29vcmRpbmF0ZXMgb3ZlcmxvYWQgY2FsbHMgdGhlIGByZXNldENlbGxQcm9wZXJ0aWVzQ2FjaGUoeCwgeSlgIG92ZXJsb2FkIGZvciB5b3UuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBgQ2VsbEV2ZW50YCBvciBkYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gTmFtZSBvZiBwcm9wZXJ0eSB0byBnZXQuIF9XaGVuIGB5YCBvbWl0dGVkLCB0aGlzIHBhcmFtIHByb21vdGVkIHRvIDJuZCBhcmcuX1xuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJzYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbD10aGlzLnN1YmdyaWRzLmxvb2t1cC5kYXRhXSAtIEZvciB1c2Ugb25seSB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIF9ub3RfIGEgYENlbGxFdmVudGA6IFByb3ZpZGUgYSBzdWJncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBzZXRDZWxsUHJvcGVydHk6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSwga2V5LCB2YWx1ZSwgZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciBjZWxsT3duUHJvcGVydGllcztcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgLy8geE9yQ2VsbEV2ZW50IGlzIGNlbGxFdmVudCwgeSBpcyBrZXksIGtleSBpcyB2YWx1ZVxuICAgICAgICAgICAgICAgIGNlbGxPd25Qcm9wZXJ0aWVzID0geE9yQ2VsbEV2ZW50LnNldENlbGxQcm9wZXJ0eSh5LCBrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNlbGxPd25Qcm9wZXJ0aWVzID0gdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KSAvLyB4T3JDZWxsRXZlbnQgaXMgeFxuICAgICAgICAgICAgICAgICAgICAuc2V0Q2VsbFByb3BlcnR5KHksIGtleSwgdmFsdWUsIGRhdGFNb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnJlbmRlcmVyLnJlc2V0Q2VsbFByb3BlcnRpZXNDYWNoZSh4T3JDZWxsRXZlbnQsIHksIGRhdGFNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxPd25Qcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRVbmZpbHRlcmVkUm93Q291bnQoKScsIG51bGwsICcxLjIuMCcsIGFyZ3VtZW50cywgJ05vIGxvbmdlciBzdXBwb3J0ZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgXCJmaXhlZCByb3dzLlwiXG4gICAgICogQGRlc2MgVGhlIHRvdGFsIGhlaWdodCBvZiBhbGwgKG5vbi1zY3JvbGxhYmxlKSByb3dzIHByZWNlZGluZyB0aGUgKHNjcm9sbGFibGUpIGRhdGEgc3ViZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgZml4ZWQgcm93cyBhcmVhIG9mIHRoZSBoeXBlcmdyaWQsIHRoZSB0b3RhbCBoZWlnaHQgb2Y6XG4gICAgICogMS4gQWxsIHJvd3Mgb2YgYWxsIHN1YmdyaWRzIHByZWNlZGluZyB0aGUgZGF0YSBzdWJncmlkLlxuICAgICAqIDIuIFRoZSBmaXJzdCBgZml4ZWRSb3dDb3VudGAgcm93cyBvZiB0aGUgZGF0YSBzdWJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhTW9kZWwsIGlzRGF0YSwgciwgUixcbiAgICAgICAgICAgIHN1YmdyaWRzID0gdGhpcy5zdWJncmlkcyxcbiAgICAgICAgICAgIGhlaWdodCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJncmlkcy5sZW5ndGggJiYgIWlzRGF0YTsgKytpKSB7XG4gICAgICAgICAgICBkYXRhTW9kZWwgPSBzdWJncmlkc1tpXTtcbiAgICAgICAgICAgIGlzRGF0YSA9IGRhdGFNb2RlbC5pc0RhdGE7XG4gICAgICAgICAgICBSID0gaXNEYXRhID8gdGhpcy5ncmlkLnByb3BlcnRpZXMuZml4ZWRSb3dDb3VudCA6IGRhdGFNb2RlbC5nZXRSb3dDb3VudCgpO1xuICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IFI7ICsrcikge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSB0aGlzLmdldFJvd0hlaWdodChyLCBkYXRhTW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUgbG9jYWwgdG8gZGF0c01vZGVsLlxuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbZGF0YU1vZGVsPXRoaXMuZGF0YU1vZGVsXVxuICAgICAqL1xuICAgIGdldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgICAgICB2YXIgcm93RGF0YSA9IChkYXRhTW9kZWwgfHwgdGhpcy5kYXRhTW9kZWwpLmdldFJvdyhyb3dJbmRleCk7XG4gICAgICAgIHJldHVybiByb3dEYXRhICYmIHJvd0RhdGEuX19ST1dfSEVJR0hUIHx8IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBUaGUgdmFsdWUgaXMgbGF6aWx5IGluaXRpYWxpemVkIGFuZCBjb21lcyBmcm9tIHRoZSBwcm9wZXJ0aWVzIG1lY2hhbmlzbSBmb3IgJ2BkZWZhdWx0Um93SGVpZ2h0YCcsIHdoaWNoIHNob3VsZCBiZSB+MjBweC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IGhlaWdodCBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFJvd0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldERlZmF1bHRSb3dIZWlnaHQoKScsICdncmlkLnByb3BlcnRpZXMuZGVmYXVsdFJvd0hlaWdodCcsICcxLjIuMCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2Mgc2V0IHRoZSBwaXhlbCBoZWlnaHQgb2YgYSBzcGVjaWZpYyByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlIGxvY2FsIHRvIGRhdHNNb2RlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gcGl4ZWwgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtkYXRhTW9kZWw9dGhpcy5kYXRhTW9kZWxdXG4gICAgICovXG4gICAgc2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dJbmRleCwgaGVpZ2h0LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgdmFyIHJvd0RhdGEgPSAoZGF0YU1vZGVsIHx8IHRoaXMuZGF0YU1vZGVsKS5nZXRSb3cocm93SW5kZXgpO1xuICAgICAgICBpZiAocm93RGF0YSkge1xuICAgICAgICAgICAgcm93RGF0YS5fX1JPV19IRUlHSFQgPSBNYXRoLm1heCg1LCBNYXRoLmNlaWwoaGVpZ2h0KSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZml4ZWQgY29sdW1uIGFyZWEgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbnNXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5ncmlkLnByb3BlcnRpZXMuc2hvd1Jvd051bWJlcnMgPyAtMSA6IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbCArPSB0aGlzLmdldENvbHVtbldpZHRoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFRoaXMgZXhpc3RzIHRvIHN1cHBvcnQgXCJmbG9hdGluZ1wiIGNvbHVtbnMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgd2lkdGggb2YgdGhlIGZpeGVkIGNvbHVtbnMgYXJlYS5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpeGVkQ29sdW1uc1dpZHRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB2ZXJ0aWNhbCBkaW1lbnNpb24gYW5kIG5vdGlmeSBsaXN0ZW5lcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgbmV3IHkgdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsUG9zaXRpb25ZOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsUG9zaXRpb25ZKHkpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIGhvcml6b250YWwgZGltZW5zaW9uIGFuZCBub3RpZnkgbGlzdGVuZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIG5ldyB4IHZhbHVlXG4gICAgICovXG4gICAgX3NldFNjcm9sbFBvc2l0aW9uWDogZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFBvc2l0aW9uWCh4KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBUaGUgZml4ZWQgcm93IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCwgbWFzc2FnZSB0aGUgZGV0YWlscyBhbmQgY2FsbCB0aGUgcmVhbCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBfZml4ZWRSb3dDbGlja2VkOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICB2YXIgeCA9IHRoaXMudHJhbnNsYXRlQ29sdW1uSW5kZXgodGhpcy5nZXRTY3JvbGxQb3NpdGlvblgoKSArIG1vdXNlLmdyaWRDZWxsLnggLSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSk7XG4gICAgICAgIHZhciB0cmFuc2xhdGVkUG9pbnQgPSBuZXcgUG9pbnQoeCwgbW91c2UuZ3JpZENlbGwueSk7XG4gICAgICAgIG1vdXNlLmdyaWRDZWxsID0gdHJhbnNsYXRlZFBvaW50O1xuICAgICAgICB0aGlzLmZpeGVkUm93Q2xpY2tlZChncmlkLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBUaGUgZml4ZWQgY29sdW1uIGFyZWEgaGFzIGJlZW4gY2xpY2tlZCwgbWFzc2FnZSB0aGUgZGV0YWlscyBhbmQgY2FsbCB0aGUgcmVhbCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBfZml4ZWRDb2x1bW5DbGlja2VkOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICB2YXIgdHJhbnNsYXRlZFBvaW50ID0gbmV3IFBvaW50KG1vdXNlLmdyaWRDZWxsLngsIHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb25ZKCkgKyBtb3VzZS5ncmlkQ2VsbC55IC0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCkpO1xuICAgICAgICBtb3VzZS5ncmlkQ2VsbCA9IHRyYW5zbGF0ZWRQb2ludDtcbiAgICAgICAgdGhpcy5maXhlZENvbHVtbkNsaWNrZWQoZ3JpZCwgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgc2V0dGluZyB0aGUgY3Vyc29yIHVwIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzZXRDdXJzb3I6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgZ3JpZC51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uc2V0Q3Vyc29yKGdyaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgbW92ZSB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIHRhcCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbkNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB0YXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Db250ZXh0TWVudTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVDb250ZXh0TWVudShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgd2hlZWwgbW92ZWQgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25XaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZVdoZWVsTW92ZWQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIHVwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBkcmFnIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcga2V5IGRvd24gdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25LZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGtleSB1cCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbktleVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUtleVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBkb3VibGUgY2xpY2sgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Eb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIGRvd24gdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZXhpdCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZUV4aXQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VFeGl0KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBJJ3ZlIGJlZW4gbm90aWZpZWQgdGhhdCB0aGUgYmVoYXZpb3IgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgY2hhbmdlZDogZnVuY3Rpb24oKSB7IHRoaXMuZ3JpZC5iZWhhdmlvckNoYW5nZWQoKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgc2hhcGVDaGFuZ2VkOiBmdW5jdGlvbigpIHsgdGhpcy5ncmlkLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGdyaWQgZGF0YSBoYXZlIGNoYW5nZWQuIFlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIHN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7IHRoaXMuZ3JpZC5iZWhhdmlvclN0YXRlQ2hhbmdlZCgpOyB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiByZS1vcmRlciBjb2x1bW5zLlxuICAgICAqL1xuICAgIGlzQ29sdW1uUmVvcmRlcmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnByb3BlcnRpZXMuY29sdW1uc1Jlb3JkZXJhYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2luZGV4fSB4IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5wcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2luZGV4fSB4IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIHNldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKHgsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGNvbHVtbi4nO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKGNvbHVtbi5wcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2VsbCBwcm9wZXJ0aWVzIG9mIGdpdmVuIGNvbHVtbiBvciBvZiBhbGwgY29sdW1ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3hdIC0gT21pdCBmb3IgYWxsIGNvbHVtbnMuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIGNsZWFyQWxsQ2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5jbGVhckFsbENlbGxQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdWJncmlkcykge1xuICAgICAgICAgICAgdGhpcy5zdWJncmlkcy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFNb2RlbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhTW9kZWwuZ2V0Um93Q291bnQoKTsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGF0YU1vZGVsLmdldFJvdyhpKS5fX01FVEE7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IHRlc3QgaWYgb3B0aW1pemVyIHdhbnRzIGZvbGxvd2luZyBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGFSb3cgPSBkYXRhTW9kZWwuZ2V0Um93KGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZGF0YVJvdy5fX01FVEEgIT09IHVuZGVmaW5lZCkgeyBkYXRhUm93Ll9fTUVUQSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gQWxsIHRoZSBjdXJyZW50bHkgaGlkZGVuIGNvbHVtbiBoZWFkZXIgbGFiZWxzLlxuICAgICAqL1xuICAgIGdldEhpZGRlbkNvbHVtbkRlc2NyaXB0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdyaWQucHJvcGVydGllcztcbiAgICAgICAgdmFyIGluZGV4ZXMgPSB0YWJsZVN0YXRlLmNvbHVtbkluZGV4ZXM7XG4gICAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRBY3RpdmVDb2x1bW5Db3VudCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbmRleGVzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0QWN0aXZlQ29sdW1uKGkpO1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogY29sdW1uLmhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbHVtbi5uYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnByb3BlcnRpZXMuZml4ZWRDb2x1bW5Db3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIHNldCB0aGUgbnVtYmVyIG9mIGZpeGVkIGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIHRoZSBpbnRlZ2VyIGNvdW50IG9mIGhvdyBtYW55IGNvbHVtbnMgdG8gYmUgZml4ZWRcbiAgICAgKi9cbiAgICBzZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmZpeGVkQ29sdW1uQ291bnQgPSBuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgbnVtYmVyIG9mIFwiZml4ZWQgcm93cy5cIlxuICAgICAqIEBkZXNjIFRoZSBudW1iZXIgb2YgKG5vbi1zY3JvbGxhYmxlKSByb3dzIHByZWNlZGluZyB0aGUgKHNjcm9sbGFibGUpIGRhdGEgc3ViZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3VtIG9mOlxuICAgICAqIDEuIEFsbCByb3dzIG9mIGFsbCBzdWJncmlkcyBwcmVjZWRpbmcgdGhlIGRhdGEgc3ViZ3JpZC5cbiAgICAgKiAyLiBUaGUgZmlyc3QgYGZpeGVkUm93Q291bnRgIHJvd3Mgb2YgdGhlIGRhdGEgc3ViZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpICtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmZpeGVkUm93Q291bnRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFNldCB0aGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MsIHdoaWNoIGluY2x1ZGVzICh0b3AgdG8gYm90dG9tIG9yZGVyKTpcbiAgICAgKiAxLiBUaGUgaGVhZGVyIHJvd3NcbiAgICAgKiAgICAxLiBUaGUgaGVhZGVyIGxhYmVscyByb3cgKG9wdGlvbmFsKVxuICAgICAqICAgIDIuIFRoZSBmaWx0ZXIgcm93IChvcHRpb25hbClcbiAgICAgKiAgICAzLiBUaGUgdG9wIHRvdGFsIHJvd3MgKDAgb3IgbW9yZSlcbiAgICAgKiAyLiBUaGUgbm9uLXNjcm9sbGluZyByb3dzIChleHRlcm5hbGx5IGNhbGxlZCBcInRoZSBmaXhlZCByb3dzXCIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTdW0gb2YgdGhlIGFib3ZlIG9yIDAgaWYgbm9uZSBvZiB0aGUgYWJvdmUgYXJlIGluIHVzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MuXG4gICAgICovXG4gICAgc2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLmdyaWQucHJvcGVydGllcy5maXhlZFJvd0NvdW50ID0gbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIGEgZG5kIGNvbHVtbiBoYXMganVzdCBiZWVuIGRyb3BwZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWRcbiAgICAgKi9cbiAgICBlbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge251bGx9IHRoZSBjdXJzb3IgYXQgYSBzcGVjaWZpYyB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldEN1cnNvckF0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgX3Zpc2libGVfIGNvbHVtbnMuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucy5sZW5ndGg7XG4gICAgfSxcbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldENvbHVtbkNvdW50KCknLCAnZ2V0QWN0aXZlQ29sdW1uQ291bnQoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbHVtbiBhbGlnbm1lbnQgb2YgZ2l2ZW4gZ3JpZCBjb2x1bW4uXG4gICAgICogQGRlc2MgT25lIG9mOlxuICAgICAqICogYCdsZWZ0J2BcbiAgICAgKiAqIGAnY2VudGVyJ2BcbiAgICAgKiAqIGAncmlnaHQnYFxuICAgICAqXG4gICAgICogQ2FzY2FkZXMgdG8gZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgUXVpZXRseSBzZXQgdGhlIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIG5ldyBwb3NpdGlvbiBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgc2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uWCA9IHg7XG4gICAgfSxcblxuICAgIGdldFNjcm9sbFBvc2l0aW9uWDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFBvc2l0aW9uWDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIFF1aWV0bHkgc2V0IHRoZSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgbmV3IHBvc2l0aW9uIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25ZID0geTtcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb25ZOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUG9zaXRpb25ZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7Y2VsbEVkaXRvcn0gVGhlIGNlbGwgZWRpdG9yIGZvciB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGVkaXRQb2ludCAtIFRoZSBncmlkIGNlbGwgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZ2V0Q2VsbEVkaXRvckF0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuaXNEYXRhQ29sdW1uICYmIChcbiAgICAgICAgICAgIGV2ZW50LmlzRmlsdGVyQ2VsbFxuICAgICAgICAgICAgICAgID8gdGhpcy5ncmlkLmNlbGxFZGl0b3JzLmNyZWF0ZSgnZmlsdGVyYm94JywgZXZlbnQpXG4gICAgICAgICAgICAgICAgOiBldmVudC5jb2x1bW4uZ2V0Q2VsbEVkaXRvckF0KGV2ZW50KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHdlIHNob3VsZCBoaWdobGlnaHQgb24gaG92ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ29sdW1uSG92ZXJlZCAtIHRoZSBjb2x1bW4gaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUm93SG92ZXJlZCAtIHRoZSByb3cgaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKi9cbiAgICBoaWdobGlnaHRDZWxsT25Ib3ZlcjogZnVuY3Rpb24oaXNDb2x1bW5Ib3ZlcmVkLCBpc1Jvd0hvdmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sdW1uSG92ZXJlZCAmJiBpc1Jvd0hvdmVyZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbFByb3BlcnRpZXNQcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGZpeGVkIHJvdyBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxGaXhlZFJvd1ByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgZml4ZWQgY29sdW1uIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbEZpeGVkQ29sdW1uUHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSB0b3AgbGVmdCBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxUb3BMZWZ0UHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQGRlc2Mgc3dhcCBzcmMgYW5kIHRhciBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyYyAtIGNvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXIgLSBjb2x1bW4gaW5kZXhcbiAgICAgKi9cbiAgICBzd2FwQ29sdW1uczogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgIHZhciB0bXAgPSBjb2x1bW5zW3NvdXJjZV07XG4gICAgICAgIGNvbHVtbnNbc291cmNlXSA9IGNvbHVtbnNbdGFyZ2V0XTtcbiAgICAgICAgY29sdW1uc1t0YXJnZXRdID0gdG1wO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uRWRnZTogZnVuY3Rpb24oYywgcmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENvbHVtbkVkZ2UoYywgcmVuZGVyZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgb2JqZWN0IGF0IHkgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRSb3coeSk7XG4gICAgfSxcblxuICAgIGNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludDogZnVuY3Rpb24odW5zY3JvbGxlZCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy5nZXRBY3RpdmVDb2x1bW4odW5zY3JvbGxlZC54KS5pbmRleCxcbiAgICAgICAgICAgIHVuc2Nyb2xsZWQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBoYXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbk1hdHJpeEZ1bmN0aW9uOiBmdW5jdGlvbihzZWxlY3RlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGF1dG9zaXplQWxsQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgY2hlY2tDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBmb3JjZSA9IGZvcmNlID09PSB0cnVlO1xuICAgICAgICB2YXIgYXV0b1NpemVkID0gdGhpcy5hdXRvU2l6ZVJvd051bWJlckNvbHVtbigpIHx8XG4gICAgICAgICAgICB0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpICYmIHRoaXMuYWxsQ29sdW1uc1stMl0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZvcmNlKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICBhdXRvU2l6ZWQgPSBjb2x1bW4uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZvcmNlKSB8fCBhdXRvU2l6ZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXV0b1NpemVkO1xuICAgIH0sXG5cbiAgICBhdXRvU2l6ZVJvd051bWJlckNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQucHJvcGVydGllcy5zaG93Um93TnVtYmVycyAmJiB0aGlzLmdyaWQucHJvcGVydGllcy5yb3dOdW1iZXJBdXRvc2l6aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGxDb2x1bW5zWy0xXS5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBnaXZlbiBkYXRhIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfCp9IFRoZSBkYXRhIGNvbnRyb2xsZXI7IG9yIGB1bmRlZmluZWRgIGlmIGRhdGEgY29udHJvbGxlciB1bmtub3duIHRvIGRhdGEgbW9kZWwuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIGdldENvbnRyb2xsZXI6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgZ2l2ZW4gZGF0YSBjb250cm9sbGVyKHMpLlxuICAgICAqIEBkZXNjIFRyaWdnZXJzIGEgc2hhcGUgY2hhbmdlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlT3JIYXNoT2ZUeXBlcyAtIE9uZSBvZjpcbiAgICAgKiAqICoqb2JqZWN0KiogLSBIYXNoIG9mIG11bHRpcGxlIGRhdGEgY29udHJvbGxlcnMsIGJ5IHR5cGUuXG4gICAgICogKiAqKnN0cmluZyoqIC0gVHlwZSBvZiB0aGUgc2luZ2xlIGRhdGEgY29udHJvbGxlciBnaXZlbiBpbiBgY29udHJvbGxlcmAuXG4gICAgICogQHBhcmFtIHtkYXRhQ29udHJvbEludGVyZmFjZX0gW2NvbnRyb2xsZXJdIC0gT25seSByZXF1aXJlZCB3aGVuICdoYXNoJyBpcyBhIHN0cmluZzsgb21pdCB3aGVuIGBoYXNoYCBpcyBhbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge29iamVjdH0gLSBIYXNoIG9mIGFsbCByZXN1bHRzLCBieSB0eXBlLiBFYWNoIG1lbWJlciB3aWxsIGJlOlxuICAgICAqICogVGhlIGdpdmVuIGRhdGEgY29udHJvbGxlciBmb3IgdGhhdCB0eXBlIHdoZW4gZGVmaW5lZC5cbiAgICAgKiAqIEEgbmV3IFwibnVsbFwiIGRhdGEgY29udHJvbGxlciwgZ2VuZXJhdGVkIGJ5IHRoZSBkYXRhIG1vZGVsIHdoZW4gdGhlIGdpdmVuIGRhdGEgY29udHJvbGxlciBmb3IgdGhhdCB0eXBlIHdhcyBgdW5kZWZpbmVkYC5cbiAgICAgKiAqIGB1bmRlZmluZWRgIC0gVGhlIGRhdGEgY29udHJvbGxlciB3YXMgdW5rbm93biB0byB0aGUgZGF0YSBtb2RlbC4uXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yI1xuICAgICAqL1xuICAgIHNldENvbnRyb2xsZXI6IGZ1bmN0aW9uKHR5cGVPckhhc2hPZlR5cGVzLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5kYXRhTW9kZWwuc2V0Q29udHJvbGxlcih0eXBlT3JIYXNoT2ZUeXBlcywgY29udHJvbGxlcik7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgcHJvcDogZnVuY3Rpb24odHlwZSwgY29sdW1uSW5kZXgsIGtleU9ySGFzaCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YU1vZGVsLnByb3AuYXBwbHkodGhpcy5kYXRhTW9kZWwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghcmVzdWx0LkdFVFRFUikge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0IGNoYXJNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5jaGFyTWFwO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsQ29sdW1ucztcbiAgICB9LFxuXG4gICAgZ2V0QWN0aXZlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnM7XG4gICAgfSxcblxuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgdmFyIGFsbCA9IHRoaXMuYWxsQ29sdW1ucztcbiAgICAgICAgdmFyIGhpZGRlbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZpc2libGUuaW5kZXhPZihhbGxbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGhpZGRlbi5wdXNoKGFsbFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuaGVhZGVyIDwgYi5oZWFkZXI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0RGF0YSgpO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRJbmRleGVkRGF0YSgpJywgJ2dldEluZGV4ZWREYXRhJywgJzEuMi4wJywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldEluZGV4ZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICB0aGlzLmRhdGFNb2RlbC5nZXRJbmRleGVkRGF0YSgpO1xuICAgIH1cbn0pO1xuXG4vLyBzeW5vbnltc1xuXG4vKipcbiAqIFN5bm9ueW0gb2Yge0BsaW5rIEJlaGF2aW9yI3JlaW5kZXh9LlxuICogQG5hbWUgYXBwbHlBbmFseXRpY3NcbiAqIEBkZXByZWNhdGVkXG4gKiBAbWVtYmVyT2YgQmVoYXZpb3IjXG4gKi9cbkJlaGF2aW9yLnByb3RvdHlwZS5hcHBseUFuYWx5dGljcyA9IEJlaGF2aW9yLnByb3RvdHlwZS5yZWluZGV4O1xuXG5cbi8vIG1peC1pbnNcbkJlaGF2aW9yLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL3N1YmdyaWRzJykpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmVoYXZpb3I7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3ZlcnJpZGVyID0gcmVxdWlyZSgnb3ZlcnJpZGVyJyk7XG5cbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZSgnLi4vbGliL2RlcHJlY2F0ZWQnKTtcbnZhciBIeXBlcmdyaWRFcnJvciA9IHJlcXVpcmUoJy4uL2xpYi9lcnJvcicpO1xudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcy9pbmRleCcpO1xuXG4vKiogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGBDb2x1bW5gIG9iamVjdC5cbiAqIEBzZWUge0BsaW5rIG1vZHVsZTpDZWxsfSBpcyBtaXhlZCBpbnRvIENvbHVtbi5wcm90b3R5cGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBiZWhhdmlvclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG9iamVjdH0gaW5kZXhPck9wdGlvbnMgLSBPbmUgb2Y6XG4gKiAqIElmIGEgcG9zaXRpdmUgbnVtYmVyLCB2YWxpZCBpbmRleCBpbnRvIGBmaWVsZHNgIGFycmF5LlxuICogKiBJZiBhIHN0cmluZywgYSBuYW1lIGluIHRoZSBgZmllbGRzYCBhcnJheS5cbiAqICogSWYgYW4gb2JqZWN0LCBtdXN0IGNvbnRhaW4gZWl0aGVyIGFuIGBpbmRleGAgb3IgYSBgbmFtZWAgcHJvcGVydHkuXG4gKlxuICogUG9zaXRpdmUgdmFsdWVzIG9mIGBpbmRleGAgYXJlIFwicmVhbFwiIGZpZWxkczsgc2VlIGFsc28ge0BsaW5rIENvbHVtbiNzZXRQcm9wZXJ0aWVzfHNldFByb3BlcnRpZXN9IHdoaWNoIGlzIGNhbGxlZCB0byBzZXQgdGhlIHJlbWFpbmluZyBwcm9wZXJ0aWVzIHNwZWNpZmllZCBpbiBgb3B0aW9uc2AuXG4gKlxuICogTmVnYXRpdmUgdmFsdWVzIG9mIGBpbmRleGAgYXJlIHNwZWNpYWwgY2FzZXM6XG4gKiBgaW5kZXhgIHwgTWVhbmluZ1xuICogOi0tLS0tOiB8IC0tLS0tLS0tXG4gKiAgICAtMSAgIHwgUm93IGhlYWRlciBjb2x1bW5cbiAqICAgIC0yICAgfCBUcmVlIChkcmlsbC1kb3duKSBjb2x1bW5cbiAqL1xuZnVuY3Rpb24gQ29sdW1uKGJlaGF2aW9yLCBpbmRleE9yT3B0aW9ucykge1xuICAgIHZhciBpbmRleCwgc2NoZW1hLCBvcHRpb25zO1xuXG4gICAgdGhpcy5iZWhhdmlvciA9IGJlaGF2aW9yO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gYmVoYXZpb3IuZGF0YU1vZGVsO1xuXG4gICAgc2NoZW1hID0gdGhpcy5iZWhhdmlvci5kYXRhTW9kZWwuc2NoZW1hO1xuXG4gICAgc3dpdGNoICh0eXBlb2YgaW5kZXhPck9wdGlvbnMpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXhPck9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGluZGV4ID0gZ2V0SW5kZXhGcm9tTmFtZShpbmRleE9yT3B0aW9ucyk7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbmRleE9yT3B0aW9ucztcbiAgICAgICAgICAgIGluZGV4ID0gb3B0aW9ucy5pbmRleCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmluZGV4XG4gICAgICAgICAgICAgICAgOiBnZXRJbmRleEZyb21OYW1lKG9wdGlvbnMubmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXhGcm9tTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZmluZEluZGV4KGZ1bmN0aW9uKGNvbHVtblNjaGVtYSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtblNjaGVtYS5uYW1lID09PSBuYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyAnQ29sdW1uIG5vdCBmb3VuZCBpbiBkYXRhLic7XG4gICAgfVxuXG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcblxuICAgIHRoaXMucHJvcGVydGllcyA9IG9wdGlvbnM7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAvLyBXaWR0aCBvZiBpY29uICsgMy1waXhlbCBzcGFjZXIgKGNoZWNrZWQgYW5kIHVuY2hlY2tlZCBzaG91bGQgYmUgc2FtZSB3aWR0aClcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5taW5pbXVtQ29sdW1uV2lkdGggPSAoaW1hZ2VzLnVuY2hlY2tlZCAmJiBpbWFnZXMudW5jaGVja2VkLndpZHRoKVxuICAgICAgICAgICAgICAgID8gIGltYWdlcy51bmNoZWNrZWQud2lkdGggKyAzIDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC0yOlxuICAgICAgICAgICAgLy8gVGhpcyBjYXNlIGF2b2lkcyB0aGUgXCJvdXQgb2YgcmFuZ2VcIiBlcnJvci5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdgaW5kZXhgIG91dCBvZiByYW5nZSc7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuXG5Db2x1bW4ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb2x1bW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuICAgICQkQ0xBU1NfTkFNRTogJ0NvbHVtbicsXG4gICAgZGVwcmVjYXRlZDogZGVwcmVjYXRlZCxcblxuICAgIEh5cGVyZ3JpZEVycm9yOiBIeXBlcmdyaWRFcnJvcixcblxuICAgIG1peEluOiBvdmVycmlkZXIubWl4SW4sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnc2V0KG9wdGlvbnMpJywgJ3NldFByb3BlcnRpZXMob3B0aW9ucyknLCAnMS4yLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRleCBvZiB0aGlzIGNvbHVtbiBpbiB0aGUgYGZpZWxkc2AgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaW5kZXgoKSB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE5hbWUgb2YgdGhpcyBjb2x1bW4gZnJvbSB0aGUgYGZpZWxkc2AgYXJyYXkuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGNvbHVtbiBpcyBub3QgaW4gdGhlIHNjaGVtYSAoc3VjaCBhcyBmb3IgaGFuZGxlIGNvbHVtbikuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICB2YXIgY29sdW1uU2NoZW1hID0gdGhpcy5kYXRhTW9kZWwuc2NoZW1hW3RoaXMuX2luZGV4XTtcbiAgICAgICAgcmV0dXJuIGNvbHVtblNjaGVtYSAmJiBjb2x1bW5TY2hlbWEubmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IG9yIHNldCB0aGUgdGV4dCBvZiB0aGUgY29sdW1uJ3MgaGVhZGVyLlxuICAgICAqIEBkZXNjIFRoZSBfaGVhZGVyXyBpcyB0aGUgbGFiZWwgYXQgdGhlIHRvcCBvZiB0aGUgY29sdW1uLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGUgaGVhZGVyIHVwZGF0ZXMgYm90aDpcbiAgICAgKiAqIHRoZSBgZmllbGRzYCAoYWthLCBoZWFkZXIpIGFycmF5IGluIHRoZSB1bmRlcmx5aW5nIGRhdGEgc291cmNlOyBhbmRcbiAgICAgKiAqIHRoZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBzZXQgaGVhZGVyKGhlYWRlclRleHQpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2NoZW1hW3RoaXMuaW5kZXhdLmhlYWRlciA9IGhlYWRlclRleHQ7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnByb3AobnVsbCwgdGhpcy5pbmRleCwgJ2hlYWRlcicsIGhlYWRlclRleHQpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmdyaWQucmVwYWludCgpO1xuICAgIH0sXG4gICAgZ2V0IGhlYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLnNjaGVtYVt0aGlzLmluZGV4XS5oZWFkZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBvciBzZXQgdGhlIGNvbXB1dGVkIGNvbHVtbidzIGNhbGN1bGF0b3IgZnVuY3Rpb24uXG4gICAgICogQGRlc2MgU2V0dGluZyB0aGUgdmFsdWUgaGVyZSB1cGRhdGVzIHRoZSBjYWxjdWxhdG9yIGluIGJvdGg6XG4gICAgICogKiB0aGUgYGNhbGN1bGF0b3JgIGFycmF5IGluIHRoZSB1bmRlcmx5aW5nIGRhdGEgc291cmNlOyBhbmRcbiAgICAgKiAqIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzdWx0cyBvZiB0aGUgbmV3IGNhbGN1bGF0aW9ucyB3aWxsIGFwcGVhciBpbiB0aGUgY29sdW1uIGNlbGxzIG9uIHRoZSBuZXh0IHJlcGFpbnQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBzZXQgY2FsY3VsYXRvcihjYWxjdWxhdG9yKSB7XG4gICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLmRhdGFNb2RlbC5zY2hlbWE7XG4gICAgICAgIGlmIChjYWxjdWxhdG9yICE9PSBzY2hlbWFbdGhpcy5pbmRleF0uY2FsY3VsYXRvcikge1xuICAgICAgICAgICAgaWYgKGNhbGN1bGF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbdGhpcy5pbmRleF0uY2FsY3VsYXRvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hW3RoaXMuaW5kZXhdLmNhbGN1bGF0b3IgPSBjYWxjdWxhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5wcm9wKG51bGwsIHRoaXMuaW5kZXgsICdjYWxjdWxhdG9yJywgY2FsY3VsYXRvcik7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjYWxjdWxhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuc2NoZW1hW3RoaXMuaW5kZXhdLmNhbGN1bGF0b3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBvciBzZXQgdGhlIHR5cGUgb2YgdGhlIGNvbHVtbidzIGhlYWRlci5cbiAgICAgKiBAZGVzYyBTZXR0aW5nIHRoZSB0eXBlIHVwZGF0ZXMgdGhlIGZpbHRlciB3aGljaCB0eXBpY2FsbHkgdXNlcyB0aGlzIGluZm9ybWF0aW9uIGZvciBwcm9wZXIgY29sbGF0aW9uLlxuICAgICAqXG4gICAgICogQHRvZG86IEluc3RlYWQgb2YgdXNpbmcgYHRoaXMuX3R5cGVgLCBwdXQgb24gZGF0YSBzb3VyY2UgbGlrZSB0aGUgb3RoZXIgZXNzZW50aWFsIHByb3BlcnRpZXMuIEluIHRoaXMgY2FzZSwgc29ydGVyIGNvdWxkIHVzZSB0aGUgaW5mbyB0byBjaG9vc2UgYSBjb21wYXJhdG9yIG1vcmUgaW50ZWxsaWdlbnRseSBhbmQgZWZmaWNpZW50bHkuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICAvL1RPRE86IFRoaXMgaXMgY2FsbGluZyByZWluZGV4IGZvciBldmVyeSBjb2x1bW4gZHVyaW5nIGdyaWQgaW5pdC4gTWF5YmUgZGVmZXIgYWxsIHJlaW5kZXggY2FsbHMgdW50aWwgYWZ0ZXIgYW4gZ3JpZCAncmVhZHknIGV2ZW50XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnByb3AobnVsbCwgdGhpcy5pbmRleCwgJ3R5cGUnLCB0eXBlKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5yZWluZGV4KCk7XG4gICAgfSxcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRWYWx1ZTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRVbmZpbHRlcmVkVmFsdWUoeSknLCBudWxsLCAnMS4yLjAnLCBhcmd1bWVudHMsICdObyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRWYWx1ZSh0aGlzLmluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5zZXRWYWx1ZSh0aGlzLmluZGV4LCB5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy53aWR0aCB8fCB0aGlzLmJlaGF2aW9yLmdyaWQucHJvcGVydGllcy5kZWZhdWx0Q29sdW1uV2lkdGg7XG4gICAgfSxcblxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRoaXMucHJvcGVydGllcy5taW5pbXVtQ29sdW1uV2lkdGgsIHdpZHRoKTtcbiAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLnByb3BlcnRpZXMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmNvbHVtbkF1dG9zaXppbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgd2lkdGgsIHByZWZlcnJlZFdpZHRoLCBhdXRvU2l6ZWQ7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemluZykge1xuICAgICAgICAgICAgd2lkdGggPSBwcm9wZXJ0aWVzLndpZHRoO1xuICAgICAgICAgICAgcHJlZmVycmVkV2lkdGggPSBwcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoIHx8IHdpZHRoO1xuICAgICAgICAgICAgZm9yY2UgPSBmb3JjZSB8fCAhcHJvcGVydGllcy5jb2x1bW5BdXRvc2l6ZWQ7XG4gICAgICAgICAgICBpZiAod2lkdGggIT09IHByZWZlcnJlZFdpZHRoIHx8IGZvcmNlICYmIHByZWZlcnJlZFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLndpZHRoID0gZm9yY2UgPyBwcmVmZXJyZWRXaWR0aCA6IE1hdGgubWF4KHdpZHRoLCBwcmVmZXJyZWRXaWR0aCk7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5jb2x1bW5BdXRvc2l6ZWQgPSAhaXNOYU4ocHJvcGVydGllcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgYXV0b1NpemVkID0gcHJvcGVydGllcy53aWR0aCAhPT0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXV0b1NpemVkO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsVHlwZTogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKHkpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHRoaXMuY29tcHV0ZUNvbHVtblR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuXG4gICAgY29tcHV0ZUNvbHVtblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJlaGF2aW9yLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoaGVhZGVyUm93Q291bnQpO1xuICAgICAgICB2YXIgZWFjaFR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgIGlmICghZWFjaFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgIC8vdmFyIGlzTnVtYmVyID0gKCh0eXBlb2YgdmFsdWUpID09PSAnbnVtYmVyJyk7XG4gICAgICAgIGZvciAodmFyIHkgPSBoZWFkZXJSb3dDb3VudDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoeSk7XG4gICAgICAgICAgICBlYWNoVHlwZSA9IHRoaXMudHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIGlmICh0eXBlICE9PSBlYWNoVHlwZSkge1xuICAgICAgICAgICAgLy8gICAgIGlmIChpc051bWJlciAmJiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgdHlwZSA9ICdmbG9hdCc7XG4gICAgICAgICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuICdtaXhlZCc7XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG5cbiAgICB0eXBlT2Y6IGZ1bmN0aW9uKHNvbWV0aGluZykge1xuICAgICAgICBpZiAoc29tZXRoaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlT2YgPSB0eXBlb2Ygc29tZXRoaW5nO1xuICAgICAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc29tZXRoaW5nLmNvbnN0cnVjdG9yLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNvbWV0aGluZykgPT09IHNvbWV0aGluZyA/ICdpbnQnIDogJ2Zsb2F0JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVPZjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgfSxcbiAgICBzZXQgcHJvcGVydGllcyhvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB0aGlzLmNyZWF0ZUNvbHVtblByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0aWVzKG93blByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICBnZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0UHJvcGVydGllcygpJywgJ3Byb3BlcnRpZXMnLCAnMS4yLjAnKTtcbiAgICB9LFxuXG4gICAgLyoqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGJlY2F1c2Ugc29tZSBncmlkIHJlbmRlcmVyIG9wdGltaXphdGlvbnMgcmVxdWlyZSB0aGF0IHRoZSBncmlkIHJlbmRlcmVyIGJlIGluZm9ybWVkIHdoZW4gY29sdW1uIGNvbG9ycyBjaGFuZ2UuIER1ZSB0byBwZXJmb3JtYW5jZSBjb25jZXJucywgdGhleSBjYW5ub3QgdGFrZSB0aGUgdGltZSB0byBmaWd1cmUgaXQgb3V0IGZvciB0aGVtc2VsdmVzLiBBbG9uZyB0aGUgc2FtZSBsaW5lcywgbWFraW5nIHRoZSBwcm9wZXJ0eSBhIGdldHRlci9zZXR0ZXIgKGluIGNvbHVtblByb3BlcnRpZXMuanMpLCB0aG91Z2ggZG9hYmxlLCBtaWdodCBwcmVzZW50IHBlcmZvcm1hbmNlIGNvbmNlcm5zIGFzIHRoaXMgcHJvcGVydHkgaXMgcG9zc2libHkgdGhlIG1vc3QgYWNjZXNzZWQgb2YgYWxsIGNvbHVtbiBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSBjb2xvclxuICAgICAqL1xuICAgIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3IgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmdyaWQucmVuZGVyZXIucmVidW5kbGVHcmlkUmVuZGVyZXJzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVzZXJ2ZT1mYWxzZV1cbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzLCBwcmVzZXJ2ZSkge1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ3NldFByb3BlcnRpZXMnLCAnc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHByb3BlcnRpZXMgKHNldHRlcikgYXMgb2YgdjEuMi4wLiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uKSBUaGlzIGFkdmljZSBvbmx5IHBlcnRhaW5zIHRvIHVzYWdlcyBvZiBzZXRQcm9wZXJ0aWVzIHdoZW4gY2FsbGVkIHdpdGggYSBzaW5nbGUgcGFyYW1ldGVyLiBXaGVuIGNhbGxlZCB3aXRoIGEgdHJ1dGh5IHNlY29uZCBwYXJhbWV0ZXIsIHVzZSB0aGUgbmV3IGFkZFByb3BlcnRpZXMocHJvcGVydGllcykgY2FsbCBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVwcmVjYXRlZCgnc2V0UHJvcGVydGllc1ByZXNlcnZlJywgJ3NldFByb3BlcnRpZXMocHJvcGVydGllcywgcHJlc2VydmUpJywgJ2FkZFByb3BlcnRpZXMocHJvcGVydGllcyknLCAnMS4yLjAnLCBhcmd1bWVudHMsICdUaGlzIHdhcm5pbmcgcGVydGFpbnMgdG8gc2V0UHJvcGVydGllcyBvbmx5IHdoZW4gcHJlc2VydmUgaXMgdHJ1dGh5LiBXaGVuIHByZXNlcnZlIGlzIGZhdWx0eSwgdXNlIHRoZSBuZXcgcHJvcGVydGllcyBzZXR0ZXIuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICB2YXIga2V5LCBkZXNjcmlwdG9yLCBvYmogPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlc2NyaXB0b3IgfHwgZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgbmV3IGNlbGwgZWRpdG9yLlxuICAgICAqIEBkZXNjIFRoZSBjZWxsIGVkaXRvciB0byB1c2UgbXVzdCBiZSByZWdpc3RlcmVkIHdpdGggdGhlIGtleSBpbiB0aGUgY2VsbCdzIGBlZGl0b3JgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIGNlbGwncyBgZm9ybWF0YCBwcm9wZXJ0eSBpcyBtaXhlZCBpbnRvIHRoZSBwcm92aWRlZCBjZWxsRXZlbnQgZm9yIHBvc3NpYmxlIG92ZXJyaWRpbmcgYnkgZGV2ZWxvcGVyJ3Mgb3ZlcnJpZGUgb2Yge0BsaW5rIERhdGFNb2RlbC5wcm90b3R5cGUuZ2V0Q2VsbEVkaXRvckF0fSBiZWZvcmUgYmVpbmcgdXNlZCBieSB7QGxpbmsgQ2VsbEVkaXRvcn0gdG8gcGFyc2UgYW5kIGZvcm1hdCB0aGUgY2VsbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBjZWxsRXZlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gRmFsc3kgdmFsdWUgbWVhbnMgZWl0aGVyIG5vIGRlY2xhcmVkIGNlbGwgZWRpdG9yIF9vcl8gaW5zdGFudGlhdGlvbiBhYm9ydGVkIGJ5IGZhbHN5IHJldHVybiBmcm9tIGBmaXJlUmVxdWVzdENlbGxFZGl0YC5cbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKGNlbGxFdmVudCkge1xuICAgICAgICB2YXIgY29sdW1uSW5kZXggPSB0aGlzLmluZGV4LFxuICAgICAgICAgICAgcm93SW5kZXggPSBjZWxsRXZlbnQuZ3JpZENlbGwueSxcbiAgICAgICAgICAgIGVkaXRvck5hbWUgPSBjZWxsRXZlbnQucHJvcGVydGllcy5lZGl0b3IsXG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShjZWxsRXZlbnQsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYG9wdGlvbnMuZm9ybWF0YCBpcyBhIGNvcHkgb2YgdGhlIGNlbGwncyBgZm9ybWF0YCBwcm9wZXJ0eSB3aGljaCBpczpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gU3ViamVjdCB0byBhZGp1c3RtZW50IGJ5IHRoZSBgZ2V0Q2VsbEVkaXRvckF0YCBvdmVycmlkZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gVGhlbiB1c2VkIGJ5IHRoZSBjZWxsIGVkaXRvciB0byByZWZlcmVuY2UgdGhlIHByZWRlZmluZWQgbG9jYWxpemVyLlxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgLy8gc28gY2VsbCBlZGl0b3Igd2lsbCBjb3B5IGl0IHRvIHNlbGZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNlbGxFdmVudC5wcm9wZXJ0aWVzLmZvcm1hdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2VsbEVkaXRvciA9IHRoaXMuZGF0YU1vZGVsLmdldENlbGxFZGl0b3JBdChjb2x1bW5JbmRleCwgcm93SW5kZXgsIGVkaXRvck5hbWUsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChjZWxsRWRpdG9yICYmICFjZWxsRWRpdG9yLmdyaWQpIHtcbiAgICAgICAgICAgIC8vIGNlbGwgZWRpdG9yIHJldHVybmVkIGJ1dCBub3QgZnVsbHkgaW5zdGFudGlhdGVkIChhYm9ydGVkIGJ5IGZhbHN5IHJldHVybiBmcm9tIGZpcmVSZXF1ZXN0Q2VsbEVkaXQpXG4gICAgICAgICAgICBjZWxsRWRpdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGxFZGl0b3I7XG4gICAgfSxcblxuICAgIGdldEZvcm1hdHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb2NhbGl6ZXJOYW1lID0gdGhpcy5wcm9wZXJ0aWVzLmZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ3JpZC5sb2NhbGl6YXRpb24uZ2V0KGxvY2FsaXplck5hbWUpLmZvcm1hdDtcbiAgICB9XG59O1xuXG5Db2x1bW4ucHJvdG90eXBlLm1peEluKHJlcXVpcmUoJy4vY2VsbFByb3BlcnRpZXMnKSk7XG5Db2x1bW4ucHJvdG90eXBlLm1peEluKHJlcXVpcmUoJy4vY29sdW1uUHJvcGVydGllcycpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCZWhhdmlvciA9IHJlcXVpcmUoJy4vQmVoYXZpb3InKTtcbnZhciBEYXRhTW9kZWxKU09OID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9KU09OJyk7XG52YXIgZmVhdHVyZXMgPSByZXF1aXJlKCcuLi9mZWF0dXJlcycpO1xuXG52YXIgUkVHRVhfQ0FNRUxfQ0FTRSA9IC8oW15fQS1aXSkoW0EtWl0rKS9nOyAvLyBhbGwgaW5zdGFuY2VzIG9mIHhYIG9yIF9YIHdpdGhpbiBhIFwid29yZFwiXG5cbi8qKlxuICogQG5hbWUgYmVoYXZpb3JzLkpTT05cbiAqIEBkZXNjID4gU2FtZSBwYXJhbWV0ZXJzIGFzIHtAbGluayBiZWhhdmlvcnMuQmVoYXZpb3IjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoaXMgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJlaGF2aW9yXG4gKi9cbnZhciBKU09OID0gQmVoYXZpb3IuZXh0ZW5kKCdiZWhhdmlvcnMuSlNPTicsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENvbnN0cnVjdG9yIGxvZ2ljLCBjYWxsZWQgX2FmdGVyX3tAbGluayBCZWhhdmlvciNpbml0aWFsaXplfEJlaGF2aW9yLmluaXRpYWxpemUoKX0uXG4gICAgICogQGRlc2MgVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgdXBvbiBpbnN0YW50aWF0aW9uIG9mIHRoaXMgY2xhc3Mgb3Igb2YgYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBmcm9tIHRoaXMgY2xhc3MuXG4gICAgICogPiBBbGwgYGluaXRpYWxpemUoKWAgbWV0aG9kcyBpbiB0aGUgaW5oZXJpdGFuY2UgY2hhaW4gYXJlIGNhbGxlZCwgaW4gdHVybiwgZWFjaCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IsIGJlZ2lubmluZyB3aXRoIHRoYXQgb2YgdGhlIG1vc3QgXCJzZW5pb3JcIiBjbGFzcyB0aHJvdWdoIHRoYXQgb2YgdGhlIGNsYXNzIG9mIHRoZSBuZXcgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLnBpcGVsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBpcGVsaW5lKG9wdGlvbnMucGlwZWxpbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIGZlYXR1cmVzLkZpbHRlcnMsXG4gICAgICAgIGZlYXR1cmVzLkNlbGxTZWxlY3Rpb24sXG4gICAgICAgIGZlYXR1cmVzLktleVBhZ2luZyxcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uUmVzaXppbmcsXG4gICAgICAgIC8vIGZlYXR1cmVzLlJvd1Jlc2l6aW5nLFxuICAgICAgICBmZWF0dXJlcy5Sb3dTZWxlY3Rpb24sXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtblNlbGVjdGlvbixcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uTW92aW5nLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5Tb3J0aW5nLFxuICAgICAgICBmZWF0dXJlcy5DZWxsQ2xpY2ssXG4gICAgICAgIGZlYXR1cmVzLkNlbGxFZGl0aW5nLFxuICAgICAgICBmZWF0dXJlcy5PbkhvdmVyXG4gICAgXSxcblxuICAgIGNyZWF0ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBCZWhhdmlvci5wcm90b3R5cGUuY3JlYXRlQ29sdW1ucy5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNjaGVtYS5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29sdW1uKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBjb2x1bW5TY2hlbWEuaGVhZGVyLFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0b3I6IGNvbHVtblNjaGVtYS5jYWxjdWxhdG9yXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5jb2x1bW5FbnVtW3RoaXMuY29sdW1uRW51bUtleShjb2x1bW5TY2hlbWEubmFtZSldID0gaW5kZXg7IC8vIHRvZG86IG1vdmUgY29sdW1uRW51bSBjb2RlIGZyb20gY29yZSB0byBkZW1vXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdHlsZSBlbnVtIGtleXMuXG4gICAgICogQGRlc2MgT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gc3R5bGUgeW91ciBrZXlzIHRvIHlvdXIgbGlraW5nLlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAdG9kbyBtb3ZlIGNvbHVtbkVudW0gY29kZSBmcm9tIGNvcmUgdG8gZGVtb1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNvbHVtbkVudW1LZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5LnJlcGxhY2UoUkVHRVhfQ0FNRUxfQ0FTRSwgJyQxXyQyJykudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgZ2V0TmV3RGF0YU1vZGVsOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YU1vZGVsSlNPTih0aGlzLmdyaWQsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgaGVhZGVyIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfG9iamVjdH0gaGVhZGVycyAtIFRoZSBoZWFkZXIgbGFiZWxzLiBPbmUgb2Y6XG4gICAgICogKiBfSWYgYW4gYXJyYXk6XyBNdXN0IGNvbnRhaW4gYWxsIGhlYWRlcnMgaW4gY29sdW1uIG9yZGVyLlxuICAgICAqICogX0lmIGEgaGFzaDpfIE1heSBjb250YWluIGFueSBoZWFkZXJzLCBrZXllZCBieSBmaWVsZCBuYW1lLCBpbiBhbnkgb3JkZXIuXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyBSZXNldCBhbGwgaGVhZGVyc1xuICAgICAgICAgICAgdmFyIGFsbENvbHVtbnMgPSB0aGlzLmFsbENvbHVtbnM7XG4gICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGFsbENvbHVtbnNbaW5kZXhdLmhlYWRlciA9IGhlYWRlcjsgLy8gc2V0dGVyIHVwZGF0ZXMgaGVhZGVyIGluIGJvdGggY29sdW1uIGFuZCBkYXRhIHNvdXJjZSBvYmplY3RzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBqdXN0IHRoZSBoZWFkZXJzIGluIHRoZSBoYXNoXG4gICAgICAgICAgICB0aGlzLmFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyc1tjb2x1bW4ubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLmhlYWRlciA9IGhlYWRlcnNbY29sdW1uLm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBmaWVsZHMgYXJyYXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyAtIFRoZSBmaWVsZCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkTmFtZXMpIHtcbiAgICAgICAgLy93ZXJlIGRlZmluaW5nIHRoZSBjb2x1bW5zIGJhc2VkIG9uIGZpZWxkIG5hbWVzLi4uLlxuICAgICAgICAvL3dlIG11c3QgcmVidWlsZCB0aGUgY29sdW1uIGRlZmluaXRpb25zXG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEZpZWxkcyhmaWVsZE5hbWVzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIGRhdGFNb2RlbHMuSlNPTiNzZXRQaXBlbGluZX1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW0RhdGFTb3VyY2VzXSAtIE5ldyBwaXBlbGluZSBkZXNjcmlwdGlvbi4gXyhTZWUge0BsaW5rIGRhdGFNb2RlbHMuSlNPTiNzZXRQaXBlbGluZX0uKV9cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVGFrZXMgZmlyc3QgYXJndW1lbnQgcG9zaXRpb24gd2hlbiBgRGF0YVNvdXJjZXNgIG9taXR0ZWQuIF8oU2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04jc2V0UGlwZWxpbmV9LilfXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hcHBseT10cnVlXSBBcHBseSBkYXRhIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgbmV3IGRhdGEuXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldFBpcGVsaW5lOiBmdW5jdGlvbihEYXRhU291cmNlcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRQaXBlbGluZS5hcHBseSh0aGlzLmRhdGFNb2RlbCwgYXJndW1lbnRzKTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoRGF0YVNvdXJjZXMpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gRGF0YVNvdXJjZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5hcHBseSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuYXBwbHkpIHtcbiAgICAgICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcCBwaXBlbGluZSBzdGFjay5cbiAgICAgKiBAc2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04jdW5zdGFzaFBpcGVsaW5lfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbd2hpY2hTdGFzaF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gVGFrZXMgZmlyc3QgYXJndW1lbnQgcG9zaXRpb24gd2hlbiBgRGF0YVNvdXJjZXNgIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hcHBseT10cnVlXSBBcHBseSBkYXRhIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgbmV3IGRhdGEuXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHVuc3Rhc2hQaXBlbGluZTogZnVuY3Rpb24oc3Rhc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFzaCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBzdGFzaDtcbiAgICAgICAgICAgIHN0YXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhTW9kZWwudW5zdGFzaFBpcGVsaW5lKHN0YXNoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5hcHBseSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuYXBwbHkpIHtcbiAgICAgICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBkYXRhIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0W119IFtkYXRhUm93cz1vcHRpb25zLmRhdGFdIC0gQXJyYXkgb2YgdW5pZm9ybSBkYXRhIHJvdyBvYmplY3RzIG9yIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUYWtlcyBmaXJzdCBhcmd1bWVudCBwb3NpdGlvbiB3aGVuIGBkYXRhUm93c2Agb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gW29wdGlvbnMuZGF0YV0gLSBBcnJheSBvZiB1bmlmb3JtIGRhdGEgcm93IG9iamVjdHMgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuXG4gICAgICogUGFzc2VkIGFzIDFzdCBwYXJhbSB0byB7QGxpbmsgZGF0YU1vZGVsLkpTT04jc2V0RGF0YX0uIElmIGZhbHN5LCBtZXRob2QgYWJvcnRlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gW29wdGlvbnMuZmllbGRzXSAtIEFycmF5IG9mIGZpZWxkIG5hbWVzIG9yIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lLlxuICAgICAqIFBhc3NlZCBhcyAybmQgcGFyYW0gdG8ge0BsaW5rIGRhdGFNb2RlbC5KU09OI3NldERhdGF9LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0fSBbb3B0aW9ucy5jYWxjdWxhdG9yc10gLSBBcnJheSBvZiBjYWxjdWxhdG9ycyBvciBmdW5jdGlvbiByZXR1cm5pbmcgc2FtZS5cbiAgICAgKiBQYXNzZWQgYXMgM3JkIHBhcmFtIHRvIHtAbGluayBkYXRhTW9kZWwuSlNPTiNzZXREYXRhfS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGx5PXRydWVdIEFwcGx5IGRhdGEgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGRhdGFSb3dzKSB8fCB0eXBlb2YgZGF0YVJvd3MgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGF0YVJvd3M7XG4gICAgICAgICAgICBkYXRhUm93cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVJvd3MgPSB0aGlzLnVud3JhcChkYXRhUm93cyk7XG5cbiAgICAgICAgaWYgKGRhdGFSb3dzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhUm93cykpIHtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBkYXRhIHRvIGJlIGFuIGFycmF5IChvZiBkYXRhIHJvdyBvYmplY3RzKS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgICAgICBzY2hlbWEgPSB0aGlzLnVud3JhcChvcHRpb25zLnNjaGVtYSksIC8vICphbHdheXMqIGRlZmluZSBhIG5ldyBzY2hlbWEgb24gcmVzZXRcbiAgICAgICAgICAgIHNjaGVtYUNoYW5nZWQgPSBzY2hlbWEgfHwgIXRoaXMuc3ViZ3JpZHMubG9va3VwLmRhdGEuc2NoZW1hLmxlbmd0aCwgLy8gc2NoZW1hIHdpbGwgY2hhbmdlIGlmIGEgbmV3IHNjaGVtYSB3YXMgcHJvdmlkZWQgT1IgZGF0YSBtb2RlbCBoYXMgYW4gZW1wdHkgc2NoZW1hIG5vdywgd2hpY2ggdHJpZ2dlcnMgc2NoZW1hIGdlbmVyYXRpb24gb24gc2V0RGF0YSBiZWxvd1xuICAgICAgICAgICAgcmVpbmRleCA9IG9wdGlvbnMuYXBwbHkgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmFwcGx5OyAvLyBkZWZhdWx0cyB0byB0cnVlXG5cbiAgICAgICAgLy8gSW5mb3JtIGludGVyZXN0ZWQgZGF0YSBtb2RlbHMgb2YgZGF0YS5cbiAgICAgICAgdGhpcy5zdWJncmlkcy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGRhdGFNb2RlbC5zZXREYXRhICYmICFkYXRhTW9kZWwuaGFzT3duRGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGFNb2RlbC5zZXREYXRhKGRhdGFSb3dzLCBzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ3JpZC5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICBncmlkLmNlbGxFZGl0b3IuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5hbGxvd0V2ZW50cyh0aGlzLmRhdGFNb2RlbC5nZXRSb3dDb3VudCgpID4gMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlYmluZHMgdGhlIGRhdGEgd2l0aG91dCByZXNoYXBpbmcgaXQuXG4gICAgICogQGRlc2MgU2VlIHtAbGluayBiZWhhdmlvcnMuSlNPTiNzZXREYXRhfHNldERhdGF9J3MgcGFyYW1ldGVyIGRlc2NyaXB0aW9ucy5cbiAgICAgKiBAcGFyYW0gZGF0YVJvd3NcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB1cGRhdGVEYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ3VwZGF0ZURhdGEoZGF0YVJvd3MsIG9wdGlvbnMpJywgJ3NldERhdGEoZGF0YVJvd3MsIG9wdGlvbnMpJywgJ3YxLjIuMTAnLCBhcmd1bWVudHMsXG4gICAgICAgICAgICAnVG8gdXBkYXRlIGRhdGEgd2l0aG91dCBjaGFuZ2luZyBjb2x1bW4gZGVmaW5pdGlvbnMsIGNhbGwgc2V0RGF0YSBfd2l0aG91dCBhIHNjaGVtYS5fJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgdGhlIGZpZWxkcyBhbmQgaGVhZGVycyBmcm9tIHRoZSBzdXBwbGllZCBjb2x1bW4gZGVmaW5pdGlvbnMuXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIG15SnNvbkJlaGF2aW9yLnNldENvbHVtbnMoW1xuICAgICAqICAgICB7IGhlYWRlcjogJ1N0b2NrIE5hbWUnLCBuYW1lOiAnc2hvcnRfZGVzY3JpcHRpb24nIH0sXG4gICAgICogICAgIHsgaGVhZGVyOiAnU3RhdHVzJywgbmFtZTogJ3RyYWRpbmdfcGhhc2UnIH0sXG4gICAgICogICAgIHsgaGVhZGVyOiAnUmVmZXJlbmNlIFByaWNlJywgbmFtZTogJ3JlZmVyZW5jZV9wcmljZScgfVxuICAgICAqIF0pO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbHVtbkRlZmluaXRpb25zIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGZpZWxkcyAndGl0bGUnLCBhbmQgJ2ZpZWxkJ1xuICAgICAqL1xuICAgIHNldENvbHVtbnM6IGZ1bmN0aW9uKGNvbHVtbkRlZmluaXRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBkbyBhbnl0aGluZycpO1xuICAgIH0sXG5cbiAgICAvL05vdCBiZWluZyB1c2VkLiBTaG91bGQgYmUgcmVwdXJwb3NlZD8/XG4gICAgc2V0RGF0YVByb3ZpZGVyOiBmdW5jdGlvbihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RGF0YVByb3ZpZGVyKGRhdGFQcm92aWRlcik7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1ucygpJywgJ2dldEFjdGl2ZUNvbHVtbnMoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTjtcbiIsIi8qIGVzbGludC1lbnYgYnJvIHdzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbHVtbi5qcyBtaXhlcyB0aGlzIG1vZHVsZSBpbnRvIGl0cyBwcm90b3R5cGUuXG4gKiBAbW9kdWxlXG4gKi9cbnZhciBjZWxsID0ge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBwcm9wZXJ0aWVzIG9iamVjdCBmb3IgY2VsbC5cbiAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBjZWxsJ3Mgb3duIHByb3BlcnRpZXMgb2JqZWN0IGlmIGZvdW5kOyBlbHNlIHRoZSBjb2x1bW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgeW91IGFyZSBzZWVraW5nIGEgc2luZ2xlIHNwZWNpZmljIHByb3BlcnR5LCBjb25zaWRlciBjYWxsaW5nIHtAbGluayBDb2x1bW4jZ2V0Q2VsbFByb3BlcnR5fSBpbnN0ZWFkICh3aGljaCBjYWxscyB0aGlzIG1ldGhvZCkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjZWxsIGF0IHgseSBpbiB0aGUgZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uI1xuICAgICAqL1xuICAgIGdldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihyb3dJbmRleCwgZGF0YU1vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGxPd25Qcm9wZXJ0aWVzKHJvd0luZGV4LCBkYXRhTW9kZWwpIHx8IHRoaXMucHJvcGVydGllcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIEhhc2ggb2YgY2VsbCBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW4jXG4gICAgICovXG4gICAgc2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHJvd0luZGV4LCBwcm9wZXJ0aWVzLCBkYXRhTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3Q2VsbFByb3BlcnRpZXNPYmplY3QuY2FsbCh0aGlzLCByb3dJbmRleCwgZGF0YU1vZGVsKSwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBIYXNoIG9mIGNlbGwgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVzZXJ2ZT1mYWxzZV0gLSBGYWxzeSBjcmVhdGVzIG5ldyBvYmplY3Q7IHRydXRoeSBjb3BpZXMgYHByb3BlcnRpZXNgIG1lbWJlcnMgaW50byBleGlzdGluZyBvYmplY3QuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBhZGRDZWxsUHJvcGVydGllczogZnVuY3Rpb24ocm93SW5kZXgsIHByb3BlcnRpZXMsIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihnZXRDZWxsUHJvcGVydGllc09iamVjdC5jYWxsKHRoaXMsIHJvd0luZGV4LCBkYXRhTW9kZWwpLCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBjZWxsJ3Mgb3duIHByb3BlcnRpZXMgb2JqZWN0LlxuICAgICAqIEBkZXNjIER1ZSB0byBtZW1vcnkgY29uc3RyYWludHMsIHdlIGRvbid0IGNyZWF0ZSBhIGNlbGwgb3B0aW9ucyBwcm9wZXJ0aWVzIG9iamVjdCBmb3IgZXZlcnkgY2VsbC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjZWxsIGhhcyBpdHMgb3duIHByb3BlcnRpZXMgb2JqZWN0LCBpdDpcbiAgICAgKiAqIHdhcyBjcmVhdGVkIGJ5IGEgcHJldmlvdXMgY2FsbCB0byBgc2V0Q2VsbFByb3BlcnRpZXNgIG9yIGBzZXRDZWxsUHJvcGVydHlgXG4gICAgICogKiBoYXMgdGhlIGNvbHVtbiBwcm9wZXJ0aWVzIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlXG4gICAgICogKiBpcyByZXR1cm5lZFxuICAgICAqXG4gICAgICogSWYgdGhlIGNlbGwgZG9lcyBub3QgaGF2ZSBpdHMgb3duIHByb3BlcnRpZXMgb2JqZWN0LCB0aGlzIG1ldGhvZCBzaW1wbHkgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIENhbGwgdGhpcyBtZXRob2Qgb25seSB3aGVuIHlvdSBuZWVkIHRvIGtub3cgaWYgdGhlIHRoZSBjZWxsIGhhcyBpdHMgb3duIHByb3BlcnRpZXMgb2JqZWN0OyBvdGhlcndpc2UgY2FsbCB7QGxpbmsgQ29sdW1uI2dldENlbGxQcm9wZXJ0aWVzfGdldENlbGxQcm9wZXJ0aWVzfS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtudWxsfG9iamVjdH0gVGhlIFwib3duXCIgcHJvcGVydGllcyBvZiB0aGUgY2VsbCBhdCB4LHkgaW4gdGhlIGdyaWQuIElmIHRoZSBjZWxsIGRvZXMgbm90IG93biBhIHByb3BlcnRpZXMgb2JqZWN0LCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW4jXG4gICAgICovXG4gICAgZ2V0Q2VsbE93blByb3BlcnRpZXM6IGZ1bmN0aW9uKHJvd0luZGV4LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgdmFyIHJvd0RhdGE7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyB0aGlzLmluZGV4ID49IDAgJiYgLy8gbm8gY2VsbCBwcm9wcyBvbiByb3cgaGFuZGxlIGNlbGxzXG4gICAgICAgICAgICAocm93RGF0YSA9IChkYXRhTW9kZWwgfHwgdGhpcy5kYXRhTW9kZWwpLmdldFJvdyhyb3dJbmRleCkpICYmIC8vIG5vIGNlbGwgcHJvcHMgb24gbm9uLWV4aXN0ZW50IHJvd3NcbiAgICAgICAgICAgIHJvd0RhdGEuX19NRVRBICYmIHJvd0RhdGEuX19NRVRBW3RoaXMubmFtZV0gfHxcbiAgICAgICAgICAgIG51bGwgLy8gbnVsbCBtZWFucyBub3QgcHJldmlvdXNseSBjcmVhdGVkXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGRlbGV0ZUNlbGxPd25Qcm9wZXJ0aWVzOiBmdW5jdGlvbihyb3dJbmRleCwgZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciByb3dEYXRhID0gKGRhdGFNb2RlbCB8fCB0aGlzLmRhdGFNb2RlbCkuZ2V0Um93KHJvd0luZGV4KTtcbiAgICAgICAgaWYgKHJvd0RhdGEuX19NRVRBKSB7XG4gICAgICAgICAgICBkZWxldGUgcm93RGF0YS5fX01FVEFbdGhpcy5uYW1lXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXR1cm4gYSBzcGVjaWZpYyBjZWxsIHByb3BlcnR5LlxuICAgICAqIEBkZXNjIElmIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3QsIGRlZmVycyB0byBjb2x1bW4gcHJvcGVydGllcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgc3BlY2lmaWVkIHByb3BlcnR5IGZvciB0aGUgY2VsbCBhdCB4LHkgaW4gdGhlIGdyaWQuXG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydHk6IGZ1bmN0aW9uKHJvd0luZGV4LCBrZXksIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsUHJvcGVydGllcyhyb3dJbmRleCwgZGF0YU1vZGVsKVtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW4jXG4gICAgICovXG4gICAgc2V0Q2VsbFByb3BlcnR5OiBmdW5jdGlvbihyb3dJbmRleCwga2V5LCB2YWx1ZSwgZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciBjZWxsUHJvcHMgPSBnZXRDZWxsUHJvcGVydGllc09iamVjdC5jYWxsKHRoaXMsIHJvd0luZGV4LCBkYXRhTW9kZWwpO1xuICAgICAgICBjZWxsUHJvcHNba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2VsbFByb3BzO1xuICAgIH0sXG5cbiAgICBkZWxldGVDZWxsUHJvcGVydHk6IGZ1bmN0aW9uKHJvd0luZGV4LCBrZXksIGRhdGFNb2RlbCkge1xuICAgICAgICB2YXIgY2VsbFByb3BzID0gdGhpcy5nZXRDZWxsT3duUHJvcGVydGllcyhyb3dJbmRleCwgZGF0YU1vZGVsKTtcbiAgICAgICAgaWYgKGNlbGxQcm9wcykge1xuICAgICAgICAgICAgZGVsZXRlIGNlbGxQcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFyQWxsQ2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5uYW1lO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnN1YmdyaWRzLmZvckVhY2goZnVuY3Rpb24oZGF0YU1vZGVsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGF0YU1vZGVsLmdldFJvd0NvdW50KCk7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93RGF0YSA9IGRhdGFNb2RlbC5nZXRSb3coaSksXG4gICAgICAgICAgICAgICAgICAgIG1ldGEgPSByb3dEYXRhLl9fTUVUQTtcbiAgICAgICAgICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobWV0YSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm93RGF0YS5fX01FVEE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHRoaXMge0NvbHVtbn1cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VsbFByb3BlcnRpZXNPYmplY3Qocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgIHJldHVybiB0aGlzLmdldENlbGxPd25Qcm9wZXJ0aWVzKHJvd0luZGV4LCBkYXRhTW9kZWwpIHx8IG5ld0NlbGxQcm9wZXJ0aWVzT2JqZWN0LmNhbGwodGhpcywgcm93SW5kZXgsIGRhdGFNb2RlbCk7XG59XG5cbi8qKlxuICogQHRvZG86IEZvciB2OCBvcHRpbWl6YXRpb24sIGNvbnNpZGVyIHNldHRpbmcgdGhlIG5ldyBgX19NRVRBYCBvYmplY3QgdG8gYSBcInJlZ3VsYXJseSBzaGFwZWQgb2JqZWN0XCIgKGkuZS4sIHdpdGggYWxsIHRoZSBjb2x1bW5zKSBpbnN0ZWFkIG9mIHNpbXBseSB0byBge31gLiBDb25zaWRlcmF0aW9ucyBpbmNsdWRlIGhvdyBtYW55IG9mIHRoZXNlIG9iamVjdHMgYXJlIHRoZXJlLCBob3cgb2Z0ZW4gYXJlIHRoZXkgcmVmZXJlbmNlZCwgZXRjLlxuICogQHRvZG86IFdlIG5lZWQgYSBmdW5jdGlvbiB0byByZXNldCB0aGUgcHJvdG90eXBlcyBvZiBwcmUtZXhpc3RpbmcgX19NRVRBIG1lbWJlcnMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBjb2x1bW4gcHJvcGVydGllcyBvYmplY3RzLlxuICogQHRoaXMge0NvbHVtbn1cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV3Q2VsbFByb3BlcnRpZXNPYmplY3Qocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgIHZhciByb3dEYXRhID0gKGRhdGFNb2RlbCB8fCB0aGlzLmRhdGFNb2RlbCkuZ2V0Um93KHJvd0luZGV4KSxcbiAgICAgICAgbWV0YURhdGEgPSByb3dEYXRhLl9fTUVUQSA9IHJvd0RhdGEuX19NRVRBIHx8IHt9O1xuICAgIHJldHVybiAobWV0YURhdGFbdGhpcy5uYW1lXSA9IE9iamVjdC5jcmVhdGUodGhpcy5faW5kZXggPj0gMCA/IHRoaXMucHJvcGVydGllcyA6IHRoaXMucHJvcGVydGllcy5yb3dIZWFkZXIpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjZWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9GdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2xpYi90b0Z1bmN0aW9uJyk7XG5cbnZhciBGSUVMRCA9ICdjb2x1bW5Qcm9wZXJ0aWVzLmZpZWxkIGlzIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMS4wIGluIGZhdm9yIG9mIGNvbHVtblByb3BlcnRpZXMubmFtZS4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknLFxuICAgIENPTFVNTl9OQU1FID0gJ2NvbHVtblByb3BlcnRpZXMuY29sdW1uTmFtZSBpcyBkZXByZWNhdGVkIGFzIG9mIHYxLjEuMCBpbiBmYXZvciBvZiBjb2x1bW5Qcm9wZXJ0aWVzLm5hbWUuIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4pJztcblxuLyoqXG4gKiBAdGhpcyB7Q29sdW1ufVxuICogQHJldHVybnMge29iamVjdH1cbiAqIEBtZW1iZXJPZiBDb2x1bW4jXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtblByb3BlcnRpZXMoKSB7XG4gICAgdmFyIGNvbHVtbiA9IHRoaXMsXG4gICAgICAgIHRhYmxlU3RhdGUgPSBjb2x1bW4uYmVoYXZpb3IuZ3JpZC5wcm9wZXJ0aWVzLFxuICAgICAgICBwcm9wZXJ0aWVzO1xuXG4gICAgcHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUodGFibGVTdGF0ZSwge1xuXG4gICAgICAgIGluZGV4OiB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuYW1lOiB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZpZWxkOiB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZJRUxEKSB7IGNvbnNvbGUud2FybihGSUVMRCk7IEZJRUxEID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNvbHVtbk5hbWU6IHsgLy8gcmVhZC1vbmx5IChubyBzZXR0ZXIpXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ09MVU1OX05BTUUpIHsgY29uc29sZS53YXJuKENPTFVNTl9OQU1FKTsgQ09MVU1OX05BTUUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmhlYWRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbHVtbi5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi50eXBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYWxjdWxhdG9yOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmNhbGN1bGF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihjYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLmNhbGN1bGF0b3IgPSB0b0Z1bmN0aW9uKGNhbGN1bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wZXJ0aWVzLCAncm93SGVhZGVyJywge1xuICAgICAgICB2YWx1ZTogT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCBjcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzLnJvd0hlYWRlckRlc2NyaXB0b3JzKVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BlcnRpZXMsICdjb2x1bW5IZWFkZXInLCB7XG4gICAgICAgIHZhbHVlOiBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIGNyZWF0ZUNvbHVtblByb3BlcnRpZXMuY29sdW1uSGVhZGVyRGVzY3JpcHRvcnMpXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcGVydGllcywgJ2ZpbHRlclByb3BlcnRpZXMnLCB7XG4gICAgICAgIHZhbHVlOiBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIGNyZWF0ZUNvbHVtblByb3BlcnRpZXMuZmlsdGVyRGVzY3JpcHRvcnMpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuY3JlYXRlQ29sdW1uUHJvcGVydGllcy5yb3dIZWFkZXJEZXNjcmlwdG9ycyA9IHtcbiAgICBmb250OiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckZvbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucm93SGVhZGVyRm9udCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY3JlYXRlQ29sdW1uUHJvcGVydGllcy5maWx0ZXJEZXNjcmlwdG9ycyA9IHtcbiAgICBmb250OiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckZvbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyRm9udCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoYWxpZ246IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVySGFsaWduO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckhhbGlnbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJlcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJSZW5kZXJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJSZW5kZXJlciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY3JlYXRlQ29sdW1uUHJvcGVydGllcy5jb2x1bW5IZWFkZXJEZXNjcmlwdG9ycyA9IHtcbiAgICBmb250OiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9udCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoYWxpZ246IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVySGFsaWduO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckhhbGlnbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJlcjoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJSZW5kZXJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJSZW5kZXJlciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsZWZ0SWNvbjogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZH0sXG4gICAgY2VudGVySWNvbjogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZH0sXG4gICAgcmlnaHRJY29uOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUNvbHVtblByb3BlcnRpZXMgPSBjcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCZWhhdmlvcjogcmVxdWlyZSgnLi9CZWhhdmlvcicpLFxuICAgIEpTT046IHJlcXVpcmUoJy4vSlNPTicpLFxuICAgIENvbHVtbjogcmVxdWlyZSgnLi9Db2x1bW4nKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRhdGFNb2RlbHMgPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzJyk7XG5cbi8qKiBAdHlwZWRlZiBzdWJncmlkQ29uc3RydWN0b3JSZWZcbiAqIEBzdW1tYXJ5IFR5cGUgZGVmaW5pdGlvbi5cbiAqIEBkZXNjIE9uZSBvZjpcbiAqICogKipgZnVuY3Rpb25gIHR5cGUqKiAtIEFzc3VtZWQgdG8gYWxyZWFkeSBiZSBhIGRhdGEgbW9kZWwgY29uc3RydWN0b3IuXG4gKiAqICoqYHN0cmluZ2AgdHlwZSoqIC0gVGhlIG5hbWUgb2YgYSBkYXRhIG1vZGVsIFwiY2xhc3NcIiAoY29uc3RydWN0b3IpIHJlZ2lzdGVyZWQgaW4gdGhlIHtAbGluayBzcmMvZGF0YU1vZGVsc30gbmFtZXNwYWNlLiBVc2VkIHRvIGxvb2sgdXAgdGhlIGNvbnN0cnVjdG9yIGluIHRoZSBuYW1lc3BhY2UuXG4gKi9cblxuLyoqIEB0eXBlZGVmIHN1YmdyaWRTcGVjXG4gKiBAc3VtbWFyeSBUeXBlIGRlZmluaXRpb24uXG4gKiBAZGVzYyBPbmUgb2Y6XG4gKiAqICoqYG9iamVjdGAgdHlwZSoqIF8oZXhjZXB0IHdoZW4gYW4gYXJyYXkpXyAtIEFzc3VtZWQgdG8gYmUgYSByZWZlcmVuY2UgdG8gYW4gYWxyZWFkeS1pbnN0YW50aWF0ZWQgZGF0YSBtb2RlbC4gVXNlZCBhcyBpcy5cbiAqICogKipgJ2RhdGEnYCBzcGVjaWFsIHZhbHVlKiogLSBTZXQgdG8gdGhlIGRhdGEgc3ViZ3JpZCAoX2kuZS4sXyB0aGUgYmVoYXZpb3IncyBhbHJlYWR5LWluc3RhbnRpYXRlZCBkYXRhIG1vZGVsKS5cbiAqICogKip7QGxpbmsgc3ViZ3JpZENvbnN0cnVjdG9yUmVmfSoqIF8oc2VlKV8gLSBUaGUgY29uc3RydWN0b3IgcmVmIGlzIHJlc29sdmVkIGFuZCBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCArIGEgcmVmZXJlbmNlIHRvIHRoZSBncmlkIGFzIHRoZSBzb2xlIHBhcmFtZXRlci5cbiAqICogKipgQXJyYXlgIG9iamVjdCoqIOKAlCBBY2NvbW1vZGF0ZXMgZGF0YSBtb2RlbCBjb25zdHJ1Y3RvciBhcmd1bWVudHMuIFRoZSBjb25zdHJ1Y3RvciByZWYgaXMgcmVzb2x2ZWQgYW5kIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkICsgYSByZWZlcmVuY2UgdG8gdGhlIGdyaWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciArIHRoZSByZW1haW5pbmcgZWxlbWVudHMgYXMgYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiAoSWYgeW91IGRvbid0IGhhdmUgcmVtYWluaW5nIGVsZW1lbnRzLCBkb24ndCBnaXZlIGFuIGFycmF5IGhlcmU7IGp1c3QgcHJvdmlkZSBhIHNpbXBsZSBgc3ViZ3JpZENvbnN0cnVjdG9yUmVmYCBpbnN0ZWFkLikgVGhlIGFycmF5IHNob3VsZCBoYXZlIHR3byBvciBtb3JlIGVsZW1lbnRzOlxuICogICAqIFRoZSBmaXJzdCBlbGVtZW50IGlzIGEge0BsaW5rIHN1YmdyaWRDb25zdHJ1Y3RvclJlZn0uXG4gKiAgICogUmVtYWluaW5nIGVsZW1lbnRzIGFyZSB1c2VkIGFzIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byB0aGUgY29uc3RydWN0b3IuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGF0YU1vZGVsczoge1xuICAgICAgICBIZWFkZXJTdWJncmlkOiBkYXRhTW9kZWxzLkhlYWRlclN1YmdyaWRcbiAgICB9LFxuXG4gICAgZGVmYXVsdFN1YmdyaWRTcGVjczogW1xuICAgICAgICAnSGVhZGVyU3ViZ3JpZCcsXG4gICAgICAgICdkYXRhJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgcmVwcmVzZW50cyBhIHN1YmdyaWQgdG8gYmUgcmVuZGVyZWQgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKlxuICAgICAqIFRoZSBsaXN0IHNob3VsZCBhbHdheXMgaW5jbHVkZSBhdCBsZWFzdCBvbmUgXCJkYXRhXCIgc3ViZ3JpZCwgdHlwaWNhbGx5IHtAbGluayBCZWhhdmlvciNkYXRhTW9kZWx8ZGF0YU1vZGVsfS5cbiAgICAgKiBJdCBtYXkgYWxzbyBpbmNsdWRlIHplcm8gb3IgbW9yZSBvdGhlciB0eXBlcyBvZiBzdWJncmlkcyBzdWNoIGFzIGhlYWRlciwgZmlsdGVyLCBhbmQgc3VtbWFyeSBzdWJncmlkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgb2JqZWN0IGFsc28gc3BvcnRzIGEgZGljdGlvbmFyeSBvZiBzdWJncmlkcyBpbiBgbG9va3VwYCBwcm9wZXJ0eSB3aGVyZSBlYWNoIGRpY3Rpb25hcnkga2V5IGlzIG9uZSBvZjpcbiAgICAgKiAqICoqYHN1YmdyaWQubmFtZWAqKiAoZm9yIHRob3NlIHRoYXQgaGF2ZSBhIGRlZmluZWQgbmFtZSwgd2hpY2ggaXMgcHJlc3VtZWQgdG8gYmUgdW5pcXVlKVxuICAgICAqICogKipgc3ViZ3JpZC50eXBlYCoqIChub3QgdW5pcXVlLCBzbyBpZiB5b3UgcGxhbiBvbiBoYXZpbmcgbXVsdGlwbGUsIG5hbWUgdGhlbSEpXG4gICAgICogKiAqKmAnZGF0YSdgKiogZm9yIHRoZSAob25lIGFuZCBvbmx5KSBkYXRhIHN1YmdyaWQgd2hlbiB1bm5hbWVkIChub3RlIHRoYXQgZGF0YSBzdWJncmlkcyBoYXZlIG5vIGB0eXBlYClcbiAgICAgKlxuICAgICAqIFRoZSBzZXR0ZXI6XG4gICAgICogKiBcIkVubGl2ZW5zXCIgYW55IGNvbnN0cnVjdG9ycyAoc2VlIHtAbGluayBCZWhhdmlvcn5jcmVhdGVTdWJncmlkfGNyZWF0ZVN1YmdyaWR9IGZvciBkZXRhaWxzKS5cbiAgICAgKiAqIFJlY29uc3RydWN0cyB0aGUgZGljdGlvbmFyeS5cbiAgICAgKiAqIENhbGxzIHtAbGluayBCZWhhdmlvciNzaGFwZUNoYW5nZWR8c2hhcGVDaGFuZ2VkKCl9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdWJncmlkU3BlY1tdfSBzdWJncmlkU3BlY3NcbiAgICAgKlxuICAgICAqIEB0eXBlIHtkYXRhTW9kZWxBUElbXX1cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBzZXQgc3ViZ3JpZHMoc3ViZ3JpZFNwZWNzKSB7XG4gICAgICAgIHZhciBzdWJncmlkcyA9IHRoaXMuX3N1YmdyaWRzID0gW107XG5cbiAgICAgICAgc3ViZ3JpZHMubG9va3VwID0ge307XG5cbiAgICAgICAgc3ViZ3JpZFNwZWNzLmZvckVhY2goZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBzdWJncmlkcy5wdXNoKHRoaXMuY3JlYXRlU3ViZ3JpZChzcGVjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2hhcGVDaGFuZ2VkKCk7XG4gICAgfSxcbiAgICBnZXQgc3ViZ3JpZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJncmlkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTWFwcyBhIGBzdWJncmlkU3BlY2AgdG8gYSBkYXRhIG1vZGVsLlxuICAgICAqIEBkZXNjIFRoZSBzcGVjIG1heSBkZXNjcmliZSBlaXRoZXIgYW4gZXhpc3RpbmcgZGF0YSBtb2RlbCwgb3IgYSBjb25zdHJ1Y3RvciBmb3IgYSBuZXcgZGF0YSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge3N1YmdyaWRTcGVjfSBzcGVjXG4gICAgICogQHJldHVybnMge2RhdGFNb2RlbEFQSX0gQSBkYXRhIG1vZGVsLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvciNcbiAgICAgKi9cbiAgICBjcmVhdGVTdWJncmlkOiBmdW5jdGlvbihzcGVjLCBhcmdzKSB7XG4gICAgICAgIHZhciBzdWJncmlkLCBDb25zdHJ1Y3RvciwgdmFyaWFibGVBcmdBcnJheTtcblxuICAgICAgICBpZiAoc3BlYyA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICBzdWJncmlkID0gdGhpcy5kYXRhTW9kZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoc3BlYyBpbnN0YW5jZW9mIEFycmF5ICYmIHNwZWMubGVuZ3RoKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGRlcmVmU3ViZ3JpZFJlZi5jYWxsKHRoaXMsIHNwZWNbMF0pO1xuICAgICAgICAgICAgdmFyaWFibGVBcmdBcnJheSA9IHNwZWMuc2xpY2UoMSk7XG4gICAgICAgICAgICBzdWJncmlkID0gdGhpcy5jcmVhdGVBcHBseShDb25zdHJ1Y3RvciwgdmFyaWFibGVBcmdBcnJheSwgdGhpcy5ncmlkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHN1YmdyaWQgPSBzcGVjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSBkZXJlZlN1YmdyaWRSZWYuY2FsbCh0aGlzLCBzcGVjKTtcbiAgICAgICAgICAgIHZhcmlhYmxlQXJnQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgc3ViZ3JpZCA9IHRoaXMuY3JlYXRlQXBwbHkoQ29uc3RydWN0b3IsIHZhcmlhYmxlQXJnQXJyYXksIHRoaXMuZ3JpZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1bmRlZmluZWQgdHlwZSBpcyBkYXRhXG4gICAgICAgIHN1YmdyaWQudHlwZSA9IHN1YmdyaWQudHlwZSB8fCAnZGF0YSc7XG5cbiAgICAgICAgLy8gbWFrZSBkaWN0aW9uYXJ5IGxvb2t1cCBlbnRyeVxuICAgICAgICB2YXIga2V5ID0gc3ViZ3JpZC5uYW1lIHx8IHN1YmdyaWQudHlwZTtcbiAgICAgICAgdGhpcy5fc3ViZ3JpZHMubG9va3VwW2tleV0gPSB0aGlzLl9zdWJncmlkcy5sb29rdXBba2V5XSB8fCBzdWJncmlkOyAvLyBvbmx5IHNhdmUgZmlyc3Qgd2l0aCB0aGlzIGtleVxuXG4gICAgICAgIC8vIG1ha2UgaXNUeXBlIGJvb2xlYW5cbiAgICAgICAgc3ViZ3JpZFsnaXMnICsgc3ViZ3JpZC50eXBlWzBdLnRvVXBwZXJDYXNlKCkgKyBzdWJncmlkLnR5cGUuc3Vic3RyKDEpXSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHN1YmdyaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldHMgdGhlIG51bWJlciBvZiBcImhlYWRlciByb3dzXCIuXG4gICAgICogQGRlc2MgRGVmaW5lZCBhcyB0aGUgc3VtIG9mIGFsbCByb3dzIG9mIGFsbCBzdWJncmlkcyBiZWZvcmUgdGhlIChmaXJzdCkgZGF0YSBzdWJncmlkLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuXG4gICAgICAgIHRoaXMuc3ViZ3JpZHMuZmluZChmdW5jdGlvbihzdWJncmlkKSB7XG4gICAgICAgICAgICBpZiAoc3ViZ3JpZC5pc0RhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc3RvcFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IHN1YmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5IFJlc29sdmVzIGEgc3ViZ3JpZCBjb25zdHJ1Y3RvciByZWZlcmVuY2UuXG4gKiBAZGVzYyBUaGUgcmVmIGlzIHJlc29sdmVkIHRvIGEgZGF0YSBtb2RlbCBjb25zdHJ1Y3Rvci5cbiAqIEB0aGlzIHtCZWhhdmlvcn1cbiAqIEBwYXJhbSB7c3ViZ3JpZENvbnN0cnVjdG9yUmVmfSByZWZcbiAqIEByZXR1cm5zIHtEYXRhTW9kZWx9IEEgZGF0YSBtb2RlbCBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJPZiBCZWhhdmlvcn5cbiAqL1xuZnVuY3Rpb24gZGVyZWZTdWJncmlkUmVmKHJlZikge1xuICAgIHZhciBDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHR5cGVvZiByZWYpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gdGhpcy5kYXRhTW9kZWxzW3JlZl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSByZWY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyB0aGlzLkh5cGVyZ3JpZEVycm9yKCdFeHBlY3RlZCBzdWJncmlkIHJlZiB0byBiZSByZWdpc3RlcmVkIG5hbWUgb3IgY29uc3RydWN0b3IsIGJ1dCBmb3VuZCAnICsgdHlwZW9mIHJlZiArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtdXN0YWNoZSA9IHJlcXVpcmUoJ211c3RhY2hlJyk7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vQmFzZScpO1xudmFyIGVmZmVjdHMgPSByZXF1aXJlKCcuLi9saWIvRE9NL2VmZmVjdHMnKTtcbnZhciBMb2NhbGl6YXRpb24gPSByZXF1aXJlKCcuLi9saWIvTG9jYWxpemF0aW9uJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDZWxsRWRpdG9yID0gQmFzZS5leHRlbmQoJ0NlbGxFZGl0b3InLCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBvcHRpb25zIC0gUHJvcGVydGllcyBsaXN0ZWQgYmVsb3cgKyBhcmJpdHJhcnkgbXVzdGFjaGUgXCJ2YXJpYWJsZXNcIiBmb3IgbWVyZ2luZyBpbnRvIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IG9wdGlvbnMuZWRpdFBvaW50IC0gRGVwcmVjYXRlZDsgdXNlIGBvcHRpb25zLmdyaWRDZWxsYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9ybWF0XSAtIE5hbWUgb2YgYSBsb2NhbGl6ZXIgd2l0aCB3aGljaCB0byBvdmVycmlkZSBwcm90b3R5cGUncyBgbG9jYWxpemVyYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIE1peCBpbiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBtdXN0YWNoZSB1c2UsIHR5cGljYWxseSBgY29sdW1uYCBhbmQgYGZvcm1hdGAuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV2ZW50ID0gb3B0aW9ucztcblxuICAgICAgICB2YXIgdmFsdWUgPSBncmlkLmJlaGF2aW9yLmdldFZhbHVlKHRoaXMuZXZlbnQpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTsgLy9pdCdzIGEgbmVzdGVkIG9iamVjdFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG15IGluc3RhbmNlIG9mIGh5cGVyZ3JpZFxuICAgICAgICAgKiBAdHlwZSB7SHlwZXJncmlkfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubG9jYWxlID0gZ3JpZC5sb2NhbGl6YXRpb24ubG9jYWxlOyAvLyBmb3IgdGVtcGxhdGUncyBgbGFuZ2AgYXR0cmlidXRlXG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgbmF0aXZlIGxvY2FsaXplciB3aXRoIGxvY2FsaXplciBuYW1lZCBpbiBmb3JtYXQgaWYgZGVmaW5lZCAoZnJvbSBpbnN0YW50aWF0aW9uIG9wdGlvbnMpXG4gICAgICAgIGlmIChvcHRpb25zLmZvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGl6ZXIgPSB0aGlzLmdyaWQubG9jYWxpemF0aW9uLmdldChvcHRpb25zLmZvcm1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IG11c3RhY2hlLnJlbmRlcih0aGlzLnRlbXBsYXRlLCB0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBvYmplY3QncyBpbnB1dCBjb250cm9sLCBvbmUgb2Y6XG4gICAgICAgICAqICogKmlucHV0IGVsZW1lbnQqIC0gYW4gYEhUTUxFbGVtZW50YCB0aGF0IGhhcyBhIGB2YWx1ZWAgYXR0cmlidXRlLCBzdWNoIGFzIGBIVE1MSW5wdXRFbGVtZW50YCwgYEhUTUxCdXR0b25FbGVtZW50YCwgZXRjLlxuICAgICAgICAgKiAqICpjb250YWluZXIgZWxlbWVudCogLSBhbiBgSFRNTEVsZW1lbnRgIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgaW5wdXQgZWxlbWVudHMsIG9ubHkgb25lIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBlZGl0b3IgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBhY2Nlc3MgdG8gdGhlIGlucHV0IGNvbnRyb2wgaXRzZWxmICh3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyBgdGhpcy5lbGApLCBzZWUgYHRoaXMuaW5wdXRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZWw7XG5cbiAgICAgICAgdGhpcy5lcnJvcnMgPSAwO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMua2V5dXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IFRBQiBmcm9tIGxlYXZpbmcgaW5wdXQgY29udHJvbFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudChzZWxmLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlQcmVzc0V2ZW50KHNlbGYsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLm9ubW91c2Vkb3duKGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gSWYgeW91IG92ZXJyaWRlIHRoaXMgbWV0aG9kLCBiZSBzdXJlIHRvIGNhbGwgaXQgYXMgYSBmaW5hbCBzdGVwIChvciBjYWxsIHN0b3BQcm9wYWdhdGlvbiB5b3Vyc2VsZikuXG4gICAgb25tb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBDYXRjaCBtb3VzZWRvd24gaGVyZSBiZWZvcmUgaXQgZ2V0cyB0byB0aGUgZG9jdW1lbnQgbGlzdGVuZXIgZGVmaW5lZCBpbiBIeXBlcmdyaWQoKS5cbiAgICB9LFxuXG4gICAgbG9jYWxpemVyOiBMb2NhbGl6YXRpb24ucHJvdG90eXBlLm51bGwsXG5cbiAgICBzcGVjaWFsS2V5dXBzOiB7XG4gICAgICAgIC8vMHgwODogJ2NsZWFyU3RvcEVkaXRpbmcnLCAvLyBiYWNrc3BhY2VcbiAgICAgICAgMHgwOTogJ3N0b3BFZGl0aW5nJywgLy8gdGFiXG4gICAgICAgIDB4MGQ6ICdzdG9wRWRpdGluZycsIC8vIHJldHVybi9lbnRlclxuICAgICAgICAweDFiOiAnY2FuY2VsRWRpdGluZycgLy8gZXNjYXBlXG4gICAgfSxcblxuICAgIGtleXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICAgICAgY2VsbFByb3BzID0gdGhpcy5ldmVudC5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgZmVlZGJhY2tDb3VudCA9IGNlbGxQcm9wcy5mZWVkYmFja0NvdW50LFxuICAgICAgICAgICAga2V5Q2hhciA9IGdyaWQuY2FudmFzLmdldEtleUNoYXIoZSksXG4gICAgICAgICAgICBzcGVjaWFsS2V5dXAsXG4gICAgICAgICAgICBzdG9wcGVkO1xuXG4gICAgICAgIC8vIFNURVAgMTogQ2FsbCB0aGUgc3BlY2lhbCBrZXkgaGFuZGxlciBhcyBuZWVkZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHNwZWNpYWxLZXl1cCA9IHRoaXMuc3BlY2lhbEtleXVwc1tlLmtleUNvZGVdKSAmJlxuICAgICAgICAgICAgKHN0b3BwZWQgPSB0aGlzW3NwZWNpYWxLZXl1cF0oZmVlZGJhY2tDb3VudCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDI6IElmIHRoaXMgaXMgYSBwb3NzaWJsZSBcIm5hdiBrZXlcIiBjb25zdW1hYmxlIGJ5IENlbGxTZWxlY3Rpb24jaGFuZGxlS2V5RG93biwgdHJ5IHRvIHN0b3AgZWRpdGluZyBhbmQgc2VuZCBpdCBhbG9uZ1xuICAgICAgICBpZiAoY2VsbFByb3BzLm1hcHBlZE5hdktleShrZXlDaGFyLCBlLmN0cmxLZXkpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXNwZWNpYWxLZXl1cCAmJlxuICAgICAgICAgICAgICAgIC8vIFdlIGRpZG4ndCB0cnkgdG8gc3RvcCBlZGl0aW5nIGFib3ZlIHNvIHRyeSB0byBzdG9wIGl0IG5vd1xuICAgICAgICAgICAgICAgIChzdG9wcGVkID0gdGhpcy5zdG9wRWRpdGluZyhmZWVkYmFja0NvdW50KSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIEVkaXRpbmcgc3VjY2Vzc2Z1bGx5IHN0b3BwZWRcbiAgICAgICAgICAgICAgICAvLyAtPiBzZW5kIHRoZSBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluXG4gICAgICAgICAgICAgICAgdmFyIGZpbkV2ZW50ID0gZ3JpZC5jYW52YXMubmV3RXZlbnQoZSwgJ2Zpbi1lZGl0b3Ita2V5ZG93bicsIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0OiBlLmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgICAgICAgICBjaGFyOiBrZXlDaGFyLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmNoYXJDb2RlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogZS5tZXRhS2V5LFxuICAgICAgICAgICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogZS5rZXksXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQuZGVsZWdhdGVLZXlEb3duKGZpbkV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5maXJlU3ludGhldGljRWRpdG9yS2V5VXBFdmVudCh0aGlzLCBlKTtcblxuICAgICAgICByZXR1cm4gc3RvcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdHJ1ZSwgY2hlY2sgdGhhdCB0aGUgZWRpdG9yIGlzIGluIHRoZSByaWdodCBsb2NhdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBhIGNhbGxiYWNrIGZyb20gdGhlIGZpbi1oeXBlcmdyaWQuICAgSXQgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcGFpbnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkXG4gICAgICovXG4gICAgc2Nyb2xsVmFsdWVDaGFuZ2VkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIG1vdmUgdGhlIGVkaXRvciB0byB0aGUgY3VycmVudCBlZGl0b3IgcG9pbnRcbiAgICAgKi9cbiAgICBtb3ZlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRCb3VuZHModGhpcy5ldmVudC5ib3VuZHMpO1xuICAgIH0sXG5cbiAgICBiZWdpbkVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkLmZpcmVSZXF1ZXN0Q2VsbEVkaXQodGhpcy5ldmVudCwgdGhpcy5pbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVnaW5FZGl0QXQ6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2JlZ2luRWRpdEF0KHBvaW50KScsICdiZWdpbkVkaXRpbmcoKScsICcxLjAuNicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBQdXQgdGhlIHZhbHVlIGludG8gb3VyIGVkaXRvci5cbiAgICAgKiBAZGVzYyBGb3JtYXRzIHRoZSB2YWx1ZSBhbmQgZGlzcGxheXMgaXQuXG4gICAgICogVGhlIGxvY2FsaXplcidzIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2UjZm9ybWF0fGZvcm1hdH0gbWV0aG9kIHdpbGwgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91ciBlZGl0b3IgaGFzIGFkZGl0aW9uYWwgb3IgYWx0ZXJuYXRpdmUgR1VJIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIC0gVGhlIHJhdyB1bmZvcm1hdHRlZCB2YWx1ZSBmcm9tIHRoZSBkYXRhIHNvdXJjZSB0aGF0IHdlIHdhbnQgdG8gZWRpdC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IHRoaXMubG9jYWxpemVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRpc3BsYXkgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIHNob3dFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGlkZSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgaGlkZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFN0b3BzIGVkaXRpbmcuXG4gICAgICogQGRlc2MgQmVmb3JlIHNhdmluZywgdmFsaWRhdGVzIHRoZSBlZGl0ZWQgdmFsdWUgaW4gdHdvIHBoYXNlcyBhcyBmb2xsb3dzOlxuICAgICAqIDEuIENhbGwgYHZhbGlkYXRlRWRpdG9yVmFsdWVgLiAoQ2FsbHMgdGhlIGxvY2FsaXplcidzIGBpbnZhbGlkKClgIGZ1bmN0aW9uLCBpZiBhdmFpbGFibGUuKVxuICAgICAqIDIuIENhdGNoIGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSB7QGxpbmsgQ2VsbEVkaXRvciNnZXRFZGl0b3JWYWx1ZXxnZXRFZGl0b3JWYWx1ZX0gbWV0aG9kLlxuICAgICAqXG4gICAgICogKipJZiB0aGUgZWRpdGVkIHZhbHVlIHBhc3NlcyBib3RoIHBoYXNlcyBvZiB0aGUgdmFsaWRhdGlvbjoqKlxuICAgICAqIFNhdmVzIHRoZSBlZGl0ZWQgdmFsdWUgYnkgY2FsbGluZyB0aGUge0BsaW5rIENlbGxFZGl0b3Ijc2F2ZUVkaXRvclZhbHVlfHNhdmVFZGl0b3JWYWx1ZX0gbWV0aG9kLlxuICAgICAqXG4gICAgICogKipPbiB2YWxpZGF0aW9uIGZhaWx1cmU6KipcbiAgICAgKiAxLiBJZiBgZmVlZGJhY2tgIHdhcyBvbWl0dGVkLCBjYW5jZWxzIGVkaXRpbmcsIGRpc2NhcmRpbmcgdGhlIGVkaXRlZCB2YWx1ZS5cbiAgICAgKiAyLiBJZiBgZmVlZGJhY2tgIHdhcyBwcm92aWRlZCwgZ2l2ZXMgdGhlIHVzZXIgc29tZSBmZWVkYmFjayAoc2VlIGBmZWVkYmFja2AsIGJlbG93KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZmVlZGJhY2tdIFdoYXQgdG8gZG8gb24gdmFsaWRhdGlvbiBmYWlsdXJlLiBPbmUgb2Y6XG4gICAgICogKiAqKmB1bmRlZmluZWRgKiogLSBEbyBub3Qgc2hvdyB0aGUgZXJyb3IgZWZmZWN0IG9yIHRoZSBlbmQgZWZmZWN0LiBKdXN0IGRpc2NhcmQgdGhlIHZhbHVlIGFuZCBjbG9zZSB0aGUgZWRpdG9yIChhcyBpZiBgRVNDYCBoYWQgYmVlbiB0eXBlZCkuXG4gICAgICogKiAqKmAwYCoqIC0gSnVzdCBzaG93cyB0aGUgZXJyb3IgZWZmZWN0IChzZWUgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0fGVycm9yRWZmZWN0fSBwcm9wZXJ0eSkuXG4gICAgICogKiAqKmAxYCoqIC0gU2hvd3MgdGhlIGVycm9yIGZlZWRiYWNrIGVmZmVjdCBmb2xsb3dlZCBieSB0aGUgZGV0YWlsZWQgZXhwbGFuYXRpb24uXG4gICAgICogKiBgMmAgb3IgbW9yZTpcbiAgICAgKiAgIDEuIFNob3dzIHRoZSBlcnJvciBmZWVkYmFjayBlZmZlY3RcbiAgICAgKiAgIDIuIE9uIGV2ZXJ5IGBmZWVkYmFja2AgdHJpZXMsIHNob3dzIHRoZSBkZXRhaWxlZCBleHBsYW5hdGlvbi5cbiAgICAgKiAqIElmIGB1bmRlZmluZWRgIChvbWl0dGVkKSwgc2ltcGx5IGNhbmNlbHMgZWRpdGluZyB3aXRob3V0IHNhdmluZyBlZGl0ZWQgdmFsdWUuXG4gICAgICogKiBJZiAwLCBzaG93cyB0aGUgZXJyb3IgZmVlZGJhY2sgZWZmZWN0IChzZWUgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0fGVycm9yRWZmZWN0fSBwcm9wZXJ0eSkuXG4gICAgICogKiBJZiA+IDAsIHNob3dzIHRoZSBlcnJvciBmZWVkYmFjayBlZmZlY3QgX2FuZF8gY2FsbHMgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0RW5kfGVycm9yRWZmZWN0RW5kfSBtZXRob2QpIGV2ZXJ5IGBmZWVkYmFja2AgY2FsbChzKSB0byBgc3RvcEVkaXRpbmdgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnV0aHkgbWVhbnMgc3VjY2Vzc2Z1bCBzdG9wLiBGYWxzeSBtZWFucyBzeW50YXggZXJyb3IgcHJldmVudGVkIHN0b3AuIE5vdGUgdGhhdCBlZGl0aW5nIGlzIGNhbmNlbGVkIHdoZW4gbm8gZmVlZGJhY2sgcmVxdWVzdGVkIGFuZCBzdWNjZXNzZnVsIHN0b3AgaW5jbHVkZXMgKHN1Y2Nlc3NmdWwpIGNhbmNlbC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzdG9wRWRpdGluZzogZnVuY3Rpb24oZmVlZGJhY2spIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ3xFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGVFZGl0b3JWYWx1ZSgpO1xuXG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRFZGl0b3JWYWx1ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVycm9yICYmIHRoaXMuZ3JpZC5maXJlU3ludGhldGljRWRpdG9yRGF0YUNoYW5nZUV2ZW50KHRoaXMsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlRWRpdG9yVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5jZWxsRWRpdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmVlZGJhY2sgPj0gMCkgeyAvLyBmYWxzZSB3aGVuIGBmZWVkYmFja2AgdW5kZWZpbmVkXG4gICAgICAgICAgICB0aGlzLmVycm9yRWZmZWN0QmVnaW4oKyt0aGlzLmVycm9ycyAlIGZlZWRiYWNrID09PSAwICYmIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gaW52YWxpZCBidXQgbm8gZmVlZGJhY2tcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFlcnJvcjtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IENhbmNlbHMgZWRpdGluZy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gU3VjY2Vzc2Z1bC4gKENhbmNlbCBpcyBhbHdheXMgc3VjY2Vzc2Z1bC4pXG4gICAgICovXG4gICAgY2FuY2VsRWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0RWRpdG9yVmFsdWUodGhpcy5pbml0aWFsVmFsdWUpO1xuICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZWZmZWN0IGZ1bmN0aW9uIGluZGljYXRlZCBpbiB0aGUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5mZWVkYmFja0VmZmVjdHxmZWVkYmFja0VmZmVjdH0gcHJvcGVydHksIHdoaWNoIHRyaWdnZXJzIGEgc2VyaWVzIG9mIENTUyB0cmFuc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfEVycm9yfSBbZXJyb3JdIC0gSWYgZGVmaW5lZCwgY2FsbCB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3RFbmR8ZXJyb3JFZmZlY3RFbmR9IG1ldGhvZCBhdCB0aGUgZW5kIG9mIHRoZSBsYXN0IGVmZmVjdCB0cmFuc2l0aW9uIHdpdGggdGhpcyBlcnJvci5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlcnJvckVmZmVjdEJlZ2luOiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB2YXIgc3BlYyA9IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmZlZWRiYWNrRWZmZWN0LCAvLyBzcGVjIG1heSBlIGEgc3RyaW5nIG9yIGFuIG9iamVjdCB3aXRoIG5hbWUgYW5kIG9wdGlvbnMgcHJvcHNcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzcGVjLm9wdGlvbnMpLCAvLyBpZiBzcGVjIGlzIGEgc3RyaW5nLCBzcGVjLm9wdGlvbnMgd2lsbCBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdHNbc3BlYy5uYW1lIHx8IHNwZWNdOyAvLyBpZiBzcGVjIGlzIGEgc3RyaW5nLCBzcGVjLm5hbWUgd2lsbCBiZSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgPSB0aGlzLmVycm9yRWZmZWN0RW5kLmJpbmQodGhpcywgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVmZmVjdCkge1xuICAgICAgICAgICAgZWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBleHBlY3RzIHRvIGJlIHBhc3NlZCBhbiBlcnJvci4gVGhlcmUgaXMgbm8gcG9pbnQgaW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGlmIHRoZXJlIGlzIG5vIGVycm9yLiBOZXZlcnRoZWxlc3MsIGlmIGNhbGxlZCB3aXRoIGEgZmFsc3kgYGVycm9yYCwgcmV0dXJucyB3aXRob3V0IGRvaW5nIGFueXRoaW5nLlxuICAgICAqIEB0aGlzIHtDZWxsRWRpdG9yfVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd8RXJyb3J9IFtlcnJvcl1cbiAgICAgKi9cbiAgICBlcnJvckVmZmVjdEVuZDogZnVuY3Rpb24oZXJyb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgbXNnID1cbiAgICAgICAgICAgICAgICAnSW52YWxpZCB2YWx1ZS4gVG8gcmVzb2x2ZSwgZG8gb25lIG9mIHRoZSBmb2xsb3dpbmc6XFxuXFxuJyArXG4gICAgICAgICAgICAgICAgJyAgICogQ29ycmVjdCB0aGUgZXJyb3IgYW5kIHRyeSBhZ2Fpbi5cXG4nICtcbiAgICAgICAgICAgICAgICAnICAgICAgICAgLSBvciAtXFxuJyArXG4gICAgICAgICAgICAgICAgJyAgICogQ2FuY2VsIGVkaXRpbmcgYnkgcHJlc3NpbmcgdGhlIFwiZXNjXCIgKGVzY2FwZSkga2V5Lic7XG5cbiAgICAgICAgICAgIGVycm9yID0gZXJyb3IubWVzc2FnZSB8fCBlcnJvcjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbGl6ZXIuZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yID8gZXJyb3IgKyAnXFxuJyArIHRoaXMubG9jYWxpemVyLmV4cGVjdGF0aW9uIDogdGhpcy5sb2NhbGl6ZXIuZXhwZWN0YXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICgvW1xcblxccl0vLnRlc3QoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ1xcbicgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5yZXBsYWNlKC9bXFxuXFxyXSsvZywgJ1xcblxcbiAgICogJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1zZyArPSAnXFxuXFxuQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yOiAnICsgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IC8vIGFsbG93IGFuaW1hdGlvbiB0byBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIGFsZXJ0KG1zZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHNhdmUgdGhlIG5ldyB2YWx1ZSBpbnRvIHRoZSBiZWhhdmlvciAobW9kZWwpXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IERhdGEgY2hhbmdlZCBhbmQgcHJlLWNlbGwtZWRpdCBldmVudCB3YXMgbm90IGNhbmNlbGVkLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNhdmVFZGl0b3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNhdmUgPSAoXG4gICAgICAgICAgICAhKHZhbHVlICYmIHZhbHVlID09PSB0aGlzLmluaXRpYWxWYWx1ZSkgJiYgLy8gZGF0YSBjaGFuZ2VkXG4gICAgICAgICAgICB0aGlzLmdyaWQuZmlyZUJlZm9yZUNlbGxFZGl0KHRoaXMuZXZlbnQuZ3JpZENlbGwsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSwgdGhpcykgLy8gcHJvY2VlZFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzYXZlKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3Iuc2V0VmFsdWUodGhpcy5ldmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZpcmVBZnRlckNlbGxFZGl0KHRoaXMuZXZlbnQuZ3JpZENlbGwsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2F2ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRXh0cmFjdCB0aGUgZWRpdGVkIHZhbHVlIGZyb20gdGhlIGVkaXRvci5cbiAgICAgKiBAZGVzYyBEZS1mb3JtYXQgdGhlIGVkaXRlZCBzdHJpbmcgYmFjayBpbnRvIGEgcHJpbWl0aXZlIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhlIGxvY2FsaXplcidzIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2UjcGFyc2V8cGFyc2V9IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgdGV4dCBib3ggY29udGVudHMuXG4gICAgICpcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VyIGVkaXRvciBoYXMgYWRkaXRpb25hbCBvciBhbHRlcm5hdGl2ZSBHVUkgZWxlbWVudHMuIFRoZSBHVUkgZWxlbWVudHMgd2lsbCBpbmZsdWVuY2UgdGhlIHByaW1pdGl2ZSB2YWx1ZSwgZWl0aGVyIGJ5IGFsdGVyaW5nIHRoZSBlZGl0ZWQgc3RyaW5nIGJlZm9yZSBpdCBpcyBwYXJzZWQsIG9yIGJ5IHRyYW5zZm9ybWluZyB0aGUgcGFyc2VkIHZhbHVlIGJlZm9yZSByZXR1cm5pbmcgaXQuXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGN1cnJlbnQgZWRpdG9yJ3MgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXplci5wYXJzZSh0aGlzLmlucHV0LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgbm8gdmFsaWRhdG9yIG9uIHRoZSBsb2NhbGl6ZXIsIHJldHVybnMgZmFsc3kgKG5vdCBpbnZhbGlkOyBwb3NzaWJseSB2YWxpZCkuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58c3RyaW5nfSBUcnV0aHkgdmFsdWUgbWVhbnMgaW52YWxpZC4gSWYgYSBzdHJpbmcsIHRoaXMgd2lsbCBiZSBhbiBlcnJvciBtZXNzYWdlLiBJZiBub3QgYSBzdHJpbmcsIGl0IG1lcmVseSBpbmRpY2F0ZXMgYSBnZW5lcmljIGludmFsaWQgcmVzdWx0LlxuICAgICAqL1xuICAgIHZhbGlkYXRlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZXIuaW52YWxpZCAmJiB0aGlzLmxvY2FsaXplci5pbnZhbGlkKHRoaXMuaW5wdXQudmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXF1ZXN0IGZvY3VzIGZvciBteSBpbnB1dCBjb250cm9sLlxuICAgICAqIEBkZXNjIFNlZSBHUklELTk1IFwiU2Nyb2xsYmFyIG1vdmVzIGlud2FyZFwiIGZvciBpc3N1ZSBhbmQgd29yay1hcm91bmQgZXhwbGFuYXRpb24uXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgICAgIGxlZnRXYXMgPSBlbC5zdHlsZS5sZWZ0LFxuICAgICAgICAgICAgdG9wV2FzID0gZWwuc3R5bGUudG9wO1xuXG4gICAgICAgIGVsLnN0eWxlLmxlZnQgPSBlbC5zdHlsZS50b3AgPSAwOyAvLyB3b3JrLWFyb3VuZDogbW92ZSB0byB1cHBlciBsZWZ0XG5cbiAgICAgICAgdmFyIHggPSB3aW5kb3cuc2Nyb2xsWCwgeSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcblxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gbGVmdFdhcztcbiAgICAgICAgZWwuc3R5bGUudG9wID0gdG9wV2FzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZWxlY3QgZXZlcnl0aGluZ1xuICAgICAqL1xuICAgIHNlbGVjdEFsbDogbnVsbFBhdHRlcm4sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIGJvdW5kcyBvZiBteSBpbnB1dCBjb250cm9sXG4gICAgICogQHBhcmFtIHtyZWN0YW5nbGV9IHJlY3RhbmdsZSAtIHRoZSBib3VuZHMgdG8gbW92ZSB0b1xuICAgICAqL1xuICAgIHNldEJvdW5kczogZnVuY3Rpb24oY2VsbEJvdW5kcykge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuXG4gICAgICAgIHN0eWxlLmxlZnQgPSBweChjZWxsQm91bmRzLngpO1xuICAgICAgICBzdHlsZS50b3AgPSBweChjZWxsQm91bmRzLnkpO1xuICAgICAgICBzdHlsZS53aWR0aCA9IHB4KGNlbGxCb3VuZHMud2lkdGgpO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBweChjZWxsQm91bmRzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGNoZWNrIHRoYXQgdGhlIGVkaXRvciBpcyBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbiwgYW5kIGlzIHNob3dpbmcvaGlkZGVuIGFwcHJvcHJpYXRlbHlcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjaGVja0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudC5pc0NlbGxWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFZGl0b3JWYWx1ZSh0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRha2VGb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRhY2hFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyaWQuZGl2LmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZTogJydcblxufSk7XG5cbmZ1bmN0aW9uIG51bGxQYXR0ZXJuKCkge31cbmZ1bmN0aW9uIHB4KG4pIHsgcmV0dXJuIG4gKyAncHgnOyB9XG5cblxuQ2VsbEVkaXRvci5hYnN0cmFjdCA9IHRydWU7IC8vIGRvbid0IGluc3RhbnRpYXRlIGRpcmVjdGx5XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG4vKipcbiAqIEFzIG9mIHNwcmluZyAyMDE2OlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lIGFuZCBGaXJlZm94OyB1bmltcGxlbWVudGVkIGluIFNhZmFyaS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgQ29sb3IgPSBDZWxsRWRpdG9yLmV4dGVuZCgnQ29sb3InLCB7XG5cbiAgICB0ZW1wbGF0ZTogJzxpbnB1dCB0eXBlPVwiY29sb3JcIiBsYW5nPVwie3tsb2NhbGV9fVwiIHN0eWxlPVwie3tzdHlsZX19XCI+J1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcbiIsIi8vIENvbWJvQm94LmpzIC0gQSBjb21iby1ib3ggaXMgYSBjb21iaW5hdGlvbiBvZiBhIHRleHQtYm94IGFuZCBhIGRyb3AtZG93bi5cbi8vIFVzZXIgbWF5IHR5cGUgaW50byBpdCBhbmQvb3Igc2VsZWN0IGFuIGl0ZW0gZnJvbSB0aGUgZHJvcC1kb3duIChieSBjbGlja2luZyBvbiB0aGUgdHJpYW5nbGUgYXQgdGhlIHJpZ2h0KS5cbi8vIFRoZSBkcm9wLWRvd24gaGFzIHNlY3Rpb25zIHdoaWNoIGFyZSB0b2dnbGVkIGZyb20gYSBjb250cm9sIGFyZWEgYmV0d2VlbiB0aGUgdGV4dC1ib3ggYW5kIHRoZSBkcm9wLWRvd24uXG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUZXh0ZmllbGQgPSByZXF1aXJlKCcuL1RleHRmaWVsZCcpO1xudmFyIHByb3RvdHlwZSA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpLnByb3RvdHlwZTtcbnZhciBRdWV1ZWxlc3MgPSByZXF1aXJlKCcuLi9saWIvRE9NL3F1ZXVlbGVzcycpO1xudmFyIGVsZm9yID0gcmVxdWlyZSgnLi4vbGliL0RPTS9lbGZvcicpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBUT0dHTEVfTU9ERV9QUkVGSVggPSAndG9nZ2xlLW1vZGUtJztcblxudmFyIHN0YXRlVG9BY3Rpb25NYXAgPSB7XG4gICAgaGlkZGVuOiBzbGlkZURvd24sXG4gICAgdmlzaWJsZTogc2xpZGVVcFxufTtcblxuLyoqXG4gKiBBIGNvbWJvIGJveCBpcyBhIHRleHQgYm94IHRoYXQgYWxzbyBoYXMgYSBkcm9wLWRvd24gY29udGFpbmluZyBvcHRpb25zLiBUaGUgZHJvcC1kb3duIGNvbnNpc3RzIG9mIGFuIGFjdHVhbCBkcm9wLWRvd24gbGlzdCAoYSBgPHNlbGVjdD5gIGxpc3QpIHBsdXMgYSBfY29udHJvbCBhcmVhXyBhYm92ZSBpdCBjb250YWluaW5nIHRvZ2dsZXMuIFRoZSB0b2dnbGVzIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHZhcmlvdXMgXCJtb2RlIGxpc3RzLlwiXG4gKlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lLCBTYWZhcmksIEZpcmVmb3gsIGFuZCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgVGV4dGZpZWxkXG4gKi9cbnZhciBDb21ib0JveCA9IFRleHRmaWVsZC5leHRlbmQoJ0NvbWJvQm94Jywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgICAgdGhpcy5pbnB1dCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuZHJvcHBlciA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZWwucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgIHRoaXMuY29udHJvbHMgPSB0aGlzLm9wdGlvbnMucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24gPSB0aGlzLm9wdGlvbnMucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb250cm9sbGFibGUgPSB0aGlzLm1vZGVzLmxlbmd0aCA+IDE7XG5cbiAgICAgICAgLy8gc2V0IHVwIGEgdHJhbnNpdGlvbiBlbmQgY29udHJvbGxlclxuICAgICAgICB0aGlzLm9wdGlvbnNUcmFuc2l0aW9uID0gbmV3IFF1ZXVlbGVzcyh0aGlzLm9wdGlvbnMsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMubWVudU1vZGVzU291cmNlID0gdGhpcy5jb2x1bW4ubWVudU1vZGVzIHx8IHsgZGlzdGluY3RWYWx1ZXM6IHRydWUgfTtcblxuICAgICAgICAvLyB3aXJlLXVwc1xuICAgICAgICB0aGlzLmRyb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy50b2dnbGVEcm9wRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24oZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9KTtcbiAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmluc2VydFRleHQuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlOiBbXG4nPGRpdiBjbGFzcz1cImh5cGVyZ3JpZC1jb21ib2JveFwiIHRpdGxlPVwiXCI+JyxcbicgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbGFuZz1cInt7bG9jYWxlfX1cIiBzdHlsZT1cInt7c3R5bGV9fVwiPicsXG4nICAgIDxzcGFuIHRpdGxlPVwiQ2xpY2sgZm9yIG9wdGlvbnNcIj48L3NwYW4+JyxcbicgICAgPGRpdj4nLFxuJyAgICAgICAgPGRpdj48L2Rpdj4nLFxuJyAgICAgICAgPHNlbGVjdCBzaXplPVwiMTVcIiBsYW5nPVwie3tsb2NhbGV9fVwiPjwvc2VsZWN0PicsXG4nICAgIDwvZGl2PicsXG4nPC9kaXY+J1xuICAgIF0uam9pbignXFxuJyksXG5cbiAgICBtb2RlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnZGlzdGluY3RWYWx1ZXMnLFxuICAgICAgICAgICAgYXBwZW5kT3B0aW9uczogZnVuY3Rpb24ob3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RpbmN0IGNvbHVtbiB2YWx1ZXMgYW5kIHNvcnQgdGhlbVxuICAgICAgICAgICAgICAgIHZhciBkaXN0aW5jdCA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBkID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSB0aGlzLmNvbHVtbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLmNvbHVtbi5nZXRGb3JtYXR0ZXIoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5iZWhhdmlvci5nZXREYXRhKCkuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBmb3JtYXR0ZXIoZGF0YVJvd1tjb2x1bW5OYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RpbmN0W3ZhbF0gPSAoZGlzdGluY3RbdmFsXSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGlzdGluY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wdGdyb3VwLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmZpcnN0RWxlbWVudENoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGQuc29ydCgpLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBuZXcgT3B0aW9uKHZhbCArICcgKCcgKyBkaXN0aW5jdFt2YWxdICsgJyknLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSxcblxuICAgIHNob3dFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZXQgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIG1vZGUgdG9nZ2xlc1xuICAgICAgICBpZiAoIXRoaXMuYnVpbHQpIHtcbiAgICAgICAgICAgIHZhciBtZW51TW9kZXNTb3VyY2UgPSB0aGlzLm1lbnVNb2Rlc1NvdXJjZSxcbiAgICAgICAgICAgICAgICBtZW51TW9kZXMgPSB0aGlzLm1lbnVNb2RlcyA9IHt9O1xuXG4gICAgICAgICAgICAvLyBidWlsZCB0aGUgcHJveHlcbiAgICAgICAgICAgIHRoaXMubW9kZXMuZm9yRWFjaChmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGVOYW1lID0gbW9kZS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlTmFtZSBpbiBtZW51TW9kZXNTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudU1vZGVzW21vZGVOYW1lXSA9IG1lbnVNb2Rlc1NvdXJjZVttb2RlTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHdpcmUtdXBzXG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25Nb2RlSWNvbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1vZGVzLmZvckVhY2goZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHRvZ2dsZVxuICAgICAgICAgICAgICAgIHZhciB0b2dnbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZS5jbGFzc05hbWUgPSBUT0dHTEVfTU9ERV9QUkVGSVggKyBtb2RlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZS50aXRsZSA9ICdUb2dnbGUgJyArIChtb2RlLmxhYmVsIHx8IG1vZGUubmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUudG9vbHRpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlLnRpdGxlICs9ICdcXG4nICsgbW9kZS50b29sdGlwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZS50ZXh0Q29udGVudCA9IG1vZGUuc3ltYm9sO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMuYXBwZW5kQ2hpbGQodG9nZ2xlKTtcblxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbmQgbGFiZWwgYSBuZXcgb3B0Z3JvdXBcbiAgICAgICAgICAgICAgICBpZiAobW9kZS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0Z3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRncm91cCcpO1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5sYWJlbCA9IG1vZGUubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmNsYXNzTmFtZSA9ICdzdWJtZW51LScgKyBtb2RlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFkZChvcHRncm91cCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0TW9kZUljb25BbmRPcHRncm91cC5jYWxsKHRoaXMsIHRvZ2dsZSwgbW9kZS5uYW1lLCBtZW51TW9kZXNbbW9kZS5uYW1lXSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5idWlsdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90b3R5cGUuc2hvd0VkaXRvci5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBoaWRlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB3aGVyZSB5b3Ugd291bGQgcGVyc2lzdCB0aGlzLm1lbnVNb2Rlc1xuICAgICAgICBwcm90b3R5cGUuaGlkZUVkaXRvci5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVEcm9wRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zVHJhbnNpdGlvbi50cmFuc2l0aW9uaW5nKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRyb3Bkb3duKS52aXNpYmlsaXR5O1xuICAgICAgICAgICAgc3RhdGVUb0FjdGlvbk1hcFtzdGF0ZV0uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbnNlcnRUZXh0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIGlucHV0IHRleHQgd2l0aCB0aGUgZHJvcC1kb3duIHRleHRcbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gdGhpcy5kcm9wZG93bi52YWx1ZTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSgwLCB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gY2xvc2UgdGhlIGRyb3AtZG93blxuICAgICAgICB0aGlzLnRvZ2dsZURyb3BEb3duKCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIG9uTW9kZUljb25DbGljayhlKSB7XG4gICAgdmFyIGN0cmwgPSBlLnRhcmdldDtcblxuICAgIGlmIChjdHJsLnRhZ05hbWUgPT09ICdTUEFOJykge1xuICAgICAgICAvLyBleHRyYSBjdCB0aGUgbW9kZSBuYW1lIGZyb20gdGhlIHRvZ2dsZSBjb250cm9sJ3MgY2xhc3MgbmFtZVxuICAgICAgICB2YXIgbW9kZUNsYXNzTmFtZSA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoY3RybC5jbGFzc0xpc3QsIGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWUuaW5kZXhPZihUT0dHTEVfTU9ERV9QUkVGSVgpID09PSAwO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtb2RlTmFtZSA9IG1vZGVDbGFzc05hbWUuc3Vic3RyKFRPR0dMRV9NT0RFX1BSRUZJWC5sZW5ndGgpO1xuXG4gICAgICAgIC8vIHRvZ2dsZSBtb2RlIGluIHRoZSBmaWx0ZXJcbiAgICAgICAgdmFyIG1vZGVTdGF0ZSA9IHRoaXMubWVudU1vZGVzW21vZGVOYW1lXSBePSAxO1xuXG4gICAgICAgIHNldE1vZGVJY29uQW5kT3B0Z3JvdXAuY2FsbCh0aGlzLCBjdHJsLCBtb2RlTmFtZSwgbW9kZVN0YXRlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldE1vZGVJY29uQW5kT3B0Z3JvdXAoY3RybCwgbmFtZSwgc3RhdGUpIHtcbiAgICB2YXIgc3R5bGUsIG9wdGdyb3VwLCBzdW0sIGRpc3BsYXksXG4gICAgICAgIGRyb3Bkb3duID0gdGhpcy5kcm9wZG93bixcbiAgICAgICAgbW9kZSA9IHRoaXMubW9kZXMuZmluZChmdW5jdGlvbihtb2RlKSB7IHJldHVybiBtb2RlLm5hbWUgPT09IG5hbWU7IH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuICAgICAgICBzZWxlY3RvciA9IG1vZGUuc2VsZWN0b3I7XG5cbiAgICAvLyBzZXQgaWNvbiBzdGF0ZSAoY29sb3IpXG4gICAgY3RybC5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnLCAhIXN0YXRlKTtcblxuICAgIC8vIGVtcHR5IHRoZSBvcHRncm91cCBpZiBoaWRpbmc7IHJlYnVpbGQgaXQgaWYgc2hvd2luZ1xuICAgIGlmIChzdGF0ZSkgeyAvLyByZWJ1aWxkIGl0XG4gICAgICAgIC8vIHNob3cgcHJvZ3Jlc3MgY3Vyc29yIGZvciAoYXQgbGVhc3QpIDEvMyBzZWNvbmRcbiAgICAgICAgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSAncHJvZ3Jlc3MnO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzdHlsZS5jdXJzb3IgPSBudWxsOyB9LCAzMzMpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgb3B0Z3JvdXAgPSBkcm9wZG93bi5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIHN1bSA9IG1vZGUuYXBwZW5kT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGdyb3VwKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHN1bVxuICAgICAgICAgICAgb3B0Z3JvdXAubGFiZWwgPSBvcHRncm91cC5sYWJlbC5yZXBsYWNlKC8gXFwoXFxkK1xcKSQvLCAnJyk7IC8vIHJlbW92ZSBvbGQgc3VtXG4gICAgICAgICAgICBvcHRncm91cC5sYWJlbCArPSAnICgnICsgc3VtICsgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VtID0gbW9kZS5hcHBlbmRPcHRpb25zLmNhbGwodGhpcywgZHJvcGRvd24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xsYWJsZSkge1xuICAgICAgICAgICAgICAgIGN0cmwudGV4dENvbnRlbnQgPSBzdW0gKyAnIHZhbHVlcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwbGF5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIC8vIGhpZGUvc2hvdyB0aGUgZ3JvdXBcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHNlbGVjdG9yID0gJ29wdGlvbixvcHRncm91cDpub3QoW2NsYXNzXSknO1xuICAgICAgICB2YXIgbXVzdEJlQ2hpbGRyZW4gPSB0cnVlOyAvLyB3b3JrLWFyb3VuZCBmb3IgJzpzY29wZT5vcHRpb24sLi4uJyBub3QgYXZhaWwgaW4gSUUxMVxuICAgIH1cbiAgICBlbGZvci5lYWNoKHNlbGVjdG9yLCBpdGVyYXRlZSwgZHJvcGRvd24pO1xuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZWwpIHtcbiAgICAgICAgaWYgKCFtdXN0QmVDaGlsZHJlbiB8fCBlbC5wYXJlbnRFbGVtZW50ID09PSBkcm9wZG93bikge1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBSZXNldCB0aGUgd2lkdGggb2YgdGhpcy5vcHRpb25zIHRvIHRoZSBuYXR1cmFsIHdpZHRoIG9mIHRoaXMuZHJvcGRvd24uIFRvIGRvIHRoaXMsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsYXR0ZXIncyBcIndpZHRoOiAxMDAlXCIgZnJvbSB0aGUgQ1NTIGFuZCB0aGVuIHNldCBhbiBleHBsaWNpdCB0aGlzLm9wdGlvbnMuc3R5bGUud2lkdGggYmFzZWQgb24gdGhlIGNvbXB1dGVkIHdpZHRoIG9mIHRoaXMuZHJvcGRvd24uIFRoaXMgaXMgY29tcGxpY2F0ZWQgYnkgdGhlIGZhY3QgdGhhdCBpdCBjYW5ub3QgYmUgZG9uZSBiZWZvcmUgaXQgaXMgaW4gdGhlIERPTS5cbn1cblxuZnVuY3Rpb24gc2xpZGVEb3duKCkge1xuICAgIC8vIHByZXNlcnZlIHRoZSB0ZXh0IGJveCdzIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24sIHdoaWNoIGlzIGFib3V0IHRvIGJlIGxvc3RcbiAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5pbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuaW5wdXQuc2VsZWN0aW9uRW5kO1xuXG4gICAgLy8gY2xlYW4gdXAgdGhlIHNlbGVjdCBsaXN0IGZyb20gbGFzdCB1c2FnZVxuICAgIHRoaXMuZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBiZSBraW5kIChyZW1vdmUgcHJldmlvdXMgc2VsZWN0aW9uKVxuICAgIHRoaXMuZHJvcGRvd24uc3R5bGUuc2Nyb2xsVG9wID0gMDsgLy8gcmV3aW5kXG5cbiAgICAvLyBzaG93IHRoZSBkcm9wLWRvd24gc2xpZGUgZG93biBlZmZlY3RcbiAgICB0aGlzLm9wdGlvbnMuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB2YXIgZHJvcERvd25Ub3BNYXJnaW4gPSBnZXRGbG9hdCh0aGlzLmRyb3Bkb3duLCAnbWFyZ2luVG9wJyksXG4gICAgICAgIGRyb3BEb3duUm93cyA9IHRoaXMuZHJvcGRvd24uc2l6ZSxcbiAgICAgICAgb3B0aW9uSGVpZ2h0ID0gTWF0aC5jZWlsKCh0aGlzLmRyb3Bkb3duLmxlbmd0aCAmJiBnZXRGbG9hdCh0aGlzLmRyb3Bkb3duWzBdLCAnaGVpZ2h0JykgfHwgMTMuMTg3NSkgKiAyKSAvIDIgKyAxO1xuICAgIHRoaXMub3B0aW9ucy5zdHlsZS5oZWlnaHQgPSBkcm9wRG93blRvcE1hcmdpbiArIG9wdGlvbkhlaWdodCAqIGRyb3BEb3duUm93cyArICdweCc7IC8vIHN0YXJ0cyB0aGUgc2xpZGUgZG93biBlZmZlY3RcblxuICAgIC8vIHdoaWxlIGluIGRyb3AtZG93biwgbGlzdGVuIGZvciBjbGlja3MgaW4gdGV4dCBib3ggd2hpY2ggbWVhbnMgYWJwcnRcbiAgICB0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuc2xpZGVVcEJvdW5kID0gc2xpZGVVcC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdhaXQgZm9yIHRyYW5zaXRpb24gdG8gZW5kXG4gICAgdGhpcy5vcHRpb25zVHJhbnNpdGlvbi5iZWdpbigpO1xufVxuXG5mdW5jdGlvbiBzbGlkZVVwKCkge1xuICAgIC8vIHN0b3AgbGlzdGVuaW5nIHRvIGlucHV0IGNsaWNrc1xuICAgIHRoaXMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5zbGlkZVVwQm91bmQpO1xuXG4gICAgLy8gc3RhcnQgdGhlIHNsaWRlIHVwIGVmZmVjdFxuICAgIHRoaXMub3B0aW9ucy5zdHlsZS5oZWlnaHQgPSAwO1xuXG4gICAgLy8gc2NoZWR1bGUgdGhlIGhpZGUgdG8gb2NjdXIgYWZ0ZXIgdGhlIHNsaWRlIHVwIGVmZmVjdFxuICAgIHRoaXMub3B0aW9uc1RyYW5zaXRpb24uYmVnaW4oZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZsb2F0KGVsLCBzdHlsZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKVtzdHlsZV0pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tYm9Cb3g7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG52YXIgaXNDaHJvbWl1bSA9IHdpbmRvdy5jaHJvbWUsXG4gICAgd2luTmF2ID0gd2luZG93Lm5hdmlnYXRvcixcbiAgICB2ZW5kb3JOYW1lID0gd2luTmF2LnZlbmRvcixcbiAgICBpc09wZXJhID0gd2luTmF2LnVzZXJBZ2VudC5pbmRleE9mKCdPUFInKSA+IC0xLFxuICAgIGlzSUVlZGdlID0gd2luTmF2LnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPiAtMSxcbiAgICBpc0lPU0Nocm9tZSA9IHdpbk5hdi51c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyksXG4gICAgaXNDaHJvbWUgPSAhaXNJT1NDaHJvbWUgJiZcbiAgICAgICAgaXNDaHJvbWl1bSAhPT0gbnVsbCAmJlxuICAgICAgICBpc0Nocm9taXVtICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdmVuZG9yTmFtZSA9PT0gJ0dvb2dsZSBJbmMuJyAmJlxuICAgICAgICBpc09wZXJhID09IGZhbHNlICYmIGlzSUVlZGdlID09IGZhbHNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXG4vKipcbiAqIEFzIG9mIHNwcmluZyAyMDE2OlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lIGV4Y2VwdCBubyBsb2NhbGl6YXRpb24gKGRheSwgbW9udGggbmFtZXM7IGRhdGUgZm9ybWF0KS5cbiAqIFVuaW1wbGVtZW50ZWQgaW4gU2FmYXJpLCBGaXJlZm94LCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIFRoaXMgaXMgYSBcInNubWFydFwiIGNvbnRyb2wuIEl0IGRldGVjdHMgQ2hyb21lOlxuICogKiBJZiBDaHJvbWUsIHVzZXMgY2hyb21lRGF0ZSBvdmVycmlkZXMgZm9ybWF0IHRvIHRoYXQgcmVxdWlyZWQgYnkgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgeXl5eS1tbS1kZC4gKE5vdGUgdGhhdCB0aGlzIGlzIG5vdCB0aGUgZm9ybWF0IGRpc3BsYXllZCBpbiB0aGUgY29udHJvbCwgd2hpY2ggaXMgYWx3YXlzIG1tL2RkL3l5eXkuKVxuICogKiBPdGhlcndpc2UgdXNlcyBsb2NhbGl6ZWQgZGF0ZSBmb3JtYXQgX2J1dF8gZmFsbHMgYmFjayB0byBhIHJlZ3VsYXIgdGV4dCBib3guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxFZGl0b3JcbiAqL1xudmFyIERhdGUgPSBDZWxsRWRpdG9yLmV4dGVuZCgnRGF0ZScsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICB2YXIgbG9jYWxpemVyTmFtZSxcbiAgICAgICAgICAgIHVzZXNEYXRlSW5wdXRDb250cm9sID0gaXNDaHJvbWU7XG5cbiAgICAgICAgaWYgKHVzZXNEYXRlSW5wdXRDb250cm9sKSB7XG4gICAgICAgICAgICBsb2NhbGl6ZXJOYW1lID0gJ2Nocm9tZURhdGUnO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9ICc8aW5wdXQgdHlwZT1cImRhdGVcIj4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxpemVyTmFtZSA9ICdkYXRlJztcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbGFuZz1cInt7bG9jYWxlfX1cIj4nO1xuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Q2hhclBsdXNPbmUgPSB0aGlzLmdldEVkaXRvclZhbHVlKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgbGFzdENoYXJQbHVzT25lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvY2FsaXplciA9IGdyaWQubG9jYWxpemF0aW9uLmdldChsb2NhbGl6ZXJOYW1lKTtcbiAgICB9XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGU7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9wTWVudSA9IHJlcXVpcmUoJ3BvcC1tZW51Jyk7XG5cbnZhciBDb21ib0JveCA9IHJlcXVpcmUoJy4vQ29tYm9Cb3gnKTtcbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJyk7XG5cblxuLyoqXG4gKiBUaGUgc2VsZWN0IGxpc3QgY29uc2lzdHMgb2YgdGhlIGZvbGxvd2luZyBzZXRzIG9mIGRyb3AtZG93biBpdGVtczpcbiAqICogYG9wZXJhdG9yc2AgKGljb24gKiZsdDsqKSBUaGUgcGFydGljdWxhciBzZWxlY3Rpb24gb2Ygb3BlcmF0b3JzIGZvciB0aGlzIGNvbHVtbi4gQ29tZXMgZnJvbSB0aGUgZmlsdGVyIHRyZWUuXG4gKiAqIGBkaXN0aW5jdFZhbHVlc2AgKGljb24gKiMqKSBMaXN0IG9mIGRpc3RpbmN0IGNvbHVtbiB2YWx1ZXMuIENhbGN1bGF0ZWQgZnJvbSBpbnNwZWN0aW9uIG9mIGNvbHVtbiB2YWx1ZXMgb24gX2FuZF8gb24gaWNvbiBjbGljay5cbiAqICogYGNvbHVtbk5hbWVzYCAoaWNvbiAqVCopIExpc3Qgb3RoZXIgY29sdW1uIG5hbWVzLiBDYWxjdWxhdGVkIGZyb20gaW5zcGVjdGlvbiBvZiBjb2x1bW4gdmFsdWVzIG9uIF9hbmRfIG9uIGljb24gY2xpY2suXG4gKlxuICogVGhlIGNvbnRyb2wgYXJlYSByZWZsZWN0cyB0aGUgYHRoaXMubW9kZXNgIGFycmF5IChhYm92ZSkuIEl0IGlzIG1vZGVsZWQgYnkgYSAnbWVudU1vZGVzYCBvYmplY3QsIGEgaGFzaCB3aXRoIGJvb2xlYW4gcHJvcGVydGllcyByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIGVhY2ggb2YgdGhlIHNldHMgb2YgbWVudSBpdGVtcyBvdXRsaW5lZCBhYm92ZS4gTWlzc2luZyBwcm9wZXJ0aWVzIGFyZSBmYWxzeSBieSBpbXBsaWNhdGlvbi4gVGhlIHN0YXRlIHNlbWFudGljcyBhcmU6XG4gKiAgICogYDFgIG9yIGB0cnVlYCBtZWFucyBhZGRzIENTUyBjbGFzcyBgYWN0aXZlYCB0byBpY29uIF9hbmRfIHNob3dzIHNldCdzIGl0ZW1zIGluIGRyb3AtZG93bi5cbiAqICAgKiBgMGAgb3IgYGZhbHNlYCBtZWFucyByZW1vdmVzIChDU1MgY2xhc3MgYGFjdGl2ZWAgZnJvbSBpY29uIF9hbmRfIGhpZGVzIHNldCdzIGl0ZW1zIGluIGRyb3AtZG93bi5cbiAqXG4gKiAqUGVyc2lzdGluZyBjaGFuZ2VzOiogVGhlIG9ubHkgY2hhbmdlIHRoaXMgVUkgc3VwcG9ydHMgKGJlc2lkZXMgdGhlIGZpbHRlciB0ZXh0IGl0c2VsZikgaXMgdGhlIG1lbnUgbW9kZSBzdGF0ZXMsIHdoaWNoIGFyZSBleHBlY3RlZCB0byBiZSBcInN0aWNreS5cIiBUaGF0IGlzLCB0aGV5IGFyZSBcInBlcnNpc3RlZFwiICh3cml0dGVuIGJhY2spIHRvIHRoZSBmaWx0ZXIuIEhvd2V2ZXIsIHRoZXJlIGlzIGEgcHJvYmxlbTogV2hlbiB0aGUgY29sdW1uIGZpbHRlciBpcyBibGFuayBpdCBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IHlldCBpbiB0aGUgZmlsdGVyLCBzbyB0aGVyZSBpcyBub3doZXJlIHRvIHNhdmUgaXQuIFRoZSBzb2x1dGlvbiBpcyB0byByZWFkIHRoZSBgbWVudU1vZGVzYCBoYXNoIF9mcm9tXyB0aGUgZmlsdGVyIHRyZWUgYnV0IGRvbid0IG1vZGlmeSBpdCB1bnRpbCBlbmQgb2YgZWRpdGluZy4gUmVhZGluZyBpdCBmcm9tIHRoZSBmaWx0ZXIgdHJlZSBwaWNrcyB1cCBwcmV2aW91cyBzZXR0aW5nIGlmIHRoZXJlIHdhcyBhbiBleHRhbnQgY29sdW1uIGZpbHRlciBvciB0aGUgZGVmYXVsdCBpZiB0aGVyZSB3YXMgbm90LiBCdXQgdGhlbiwgcmF0aGVyIHRoYW4gbW9kaWZ5aW5nIHRoaXMgc3RydWN0dXJlIChiZWNhdXNlIGl0IG1pZ2h0IGJlIHRoZSBkZWZhdWx0IGFuZCB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSB0aGF0KSwgd2UgaGFuZyBhIHByb3h5IGNvcHkgb2ZmIHRoZSBiZWhhdmlvcidzIGNvbHVtbiBvYmplY3QgZm9yIHRoaXMgY29sdW1uLiBUaGlzIHdpbGwgcGVyc2lzdCBpdCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBhcHAgc2Vzc2lvbi4gQXQgZW5kIG9mIGVkaXRpbmcsIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGlzIG5vdyBhIGNvbHVtbiBmaWx0ZXIgKHRleHQgaXMgbm90IGJsYW5rKSwgd2UgY29weSBpdCB0byB0aGUgY29sdW1uIGZpbHRlcidzIHN1YnRyZWUgbm9kZSBpbiB0aGUgZmlsdGVyIHRyZWUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb21ib0JveFxuICovXG52YXIgRmlsdGVyQm94ID0gQ29tYm9Cb3guZXh0ZW5kKCdGaWx0ZXJCb3gnLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBsb29rIGluIHRoZSBmaWx0ZXIsIHVuZGVyIGNvbHVtbiBmaWx0ZXJzLCBmb3IgYSBjb2x1bW4gZmlsdGVyIGZvciB0aGlzIGNvbHVtblxuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZ3JpZC5iZWhhdmlvci5maWx0ZXIsXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJzID0gcm9vdCAmJiByb290LmNvbHVtbkZpbHRlcnM7XG5cbiAgICAgICAgaWYgKCFjb2x1bW5GaWx0ZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyAnQ29sdW1uIGZpbHRlcnMgbm90IGF2YWlsYWJsZS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbHVtbk5hbWUgPSB0aGlzLmNvbHVtbi5uYW1lLFxuICAgICAgICAgICAgY29sdW1uRmlsdGVyU3VidHJlZSA9IHJvb3QuZ2V0Q29sdW1uRmlsdGVyKGNvbHVtbk5hbWUpIHx8IHt9LFxuICAgICAgICAgICAgY29sdW1uU2NoZW1hID0gcm9vdC5zY2hlbWEubG9va3VwKGNvbHVtbk5hbWUpIHx8IHt9O1xuXG5cbiAgICAgICAgLy8gZ2V0IHRoZSBvcGVyYXRvciBsaXN0IGZyb20gdGhlIG5vZGUsIHNjaGVtYSwgdHlwZU9wTWFwLCBvciByb290OlxuICAgICAgICAvLyAoVGhpcyBtaW1pY3MgdGhlIGNvZGUgaW4gRmlsdGVyTGVhZi5qcydzIGBnZXRPcE1lbnVgIGZ1bmN0aW9uIGJlY2F1c2UgdGhlIG5vZGUgbWF5IG5vdCBleGlzdCB5ZXQuKVxuICAgICAgICB0aGlzLm9wTWVudSA9XG5cbiAgICAgICAgICAgIC8vIHB1bGwgb3BlcmF0b3IgbGlzdCBmcm9tIGNvbHVtbiBzY2hlbWEgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBjb2x1bW5TY2hlbWEub3BNZW51IHx8XG5cbiAgICAgICAgICAgIC8vIG9wZXJhdG9yIGxpc3QgZm9yIHRoZSBjb2x1bW4ncyB0eXBlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgcm9vdC50eXBlT3BNYXAgJiYgcm9vdC50eXBlT3BNYXBbY29sdW1uU2NoZW1hLnR5cGUgfHwgY29sdW1uRmlsdGVyU3VidHJlZS50eXBlXSB8fFxuXG4gICAgICAgICAgICAvLyBkZWZhdWx0IG9wZXJhdG9yIGxpc3QgKHdoaWNoIGl0c2VsZiBkZWZhdWx0cyB0byBgQ29uZGl0aW9uYWxzLmRlZmF1bHRPcE1lbnVgKVxuICAgICAgICAgICAgcm9vdC5vcE1lbnU7XG5cblxuICAgICAgICAvLyBnZXQgdGhlIGNvbHVtbiBmaWx0ZXIncyBgbWVudU1vZGVzYCBvYmplY3QgLS0gY29udGFpbnMgdGhlIHN0YXRlcyBvZiB0aGUgZHJvcC1kb3duIG9wdGlvbiBpY29uczpcbiAgICAgICAgdGhpcy5tZW51TW9kZXNTb3VyY2UgPVxuXG4gICAgICAgICAgICAvLyBmaXJzdCB0cnkgcHJveHkgZnJvbSBsYXN0IHRpbWUgKGJlY2F1c2UgZWRpdGluZyBtYXkgaGF2ZSBlbmRlZCB3aXRob3V0IGEgY29sdW1uIGZpbHRlciB0byBwdXQgaW4gdGhlIGZpbHRlciB0cmVlKVxuICAgICAgICAgICAgdGhpcy5jb2x1bW4ubWVudU1vZGVzIHx8XG5cbiAgICAgICAgICAgIC8vIEVMU0UgdHJ5IGNvbHVtbiBmaWx0ZXIncyBgbWVudU1vZGVzYCBXSEVOIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29sdW1uRmlsdGVyU3VidHJlZS5tZW51TW9kZXMgfHxcblxuICAgICAgICAgICAgLy8gdHJ5IHVzZSBjb2x1bW4gc2NoZW1hJ3MgYG1lbnVNb2Rlc2Agd2hlbiBkZWZpbmVkXG4gICAgICAgICAgICBjb2x1bW5TY2hlbWEubWVudU1vZGVzIHx8XG5cbiAgICAgICAgICAgIC8vIEVMU0UgdHJ5IHRoZSBmaWx0ZXIgZGVmYXVsdCAod2hpY2ggaXRzZWxmIGRlZmF1bHRzIHRvIG9wZXJhdG9ycyBPTiwgb3RoZXJzIE9GRjsgc2VlIGRlZmluaXRpb24gYXQgdG9wIG9mIERlZmF1bHRGaWx0ZXIuanMpXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJzLm1lbnVNb2RlcztcblxuICAgIH0sXG5cbiAgICBhYm9ydEVkaXRpbmc6IENlbGxFZGl0b3IucHJvdG90eXBlLmNhbmNlbEVkaXRpbmcsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZXJlJ3Mgb25seSBvbmUgbW9kZSBkZWZpbmVkIGhlcmUsIHRoZSBjb250cm9sIGFyZWEgcG9ydGlvbiBvZiB0aGUgVUkgaXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG1vZGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdvcGVyYXRvcnMnLFxuICAgICAgICAgICAgc3ltYm9sOiAnPCcsXG4gICAgICAgICAgICBhcHBlbmRPcHRpb25zOiBmdW5jdGlvbihkcm9wZG93bikge1xuICAgICAgICAgICAgICAgIGlmICghZHJvcGRvd24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhcmlvdXMgIG9wZXJhdG9yIG9wdGlvbnMgYW5kL29yIG9wdGdyb3VwcyB2YXJ5IHBlciBjb2x1bW4gYmFzZWQgb24gYG9wTWVudWAuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcE1lbnVHcm91cHMgPSB0aGlzLmdyaWQuYmVoYXZpb3IuZmlsdGVyLm9wTWVudUdyb3VwcztcbiAgICAgICAgICAgICAgICAgICAgcG9wTWVudS5idWlsZChkcm9wZG93biwgdGhpcy5vcE1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBmdW5jdGlvbihncm91cE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BNZW51R3JvdXBzW2dyb3VwTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxpc3Qgb2YgY29uanVuY3Rpb25zIGlzIGFuIGV4dHJhIGFuZCBpcyBmb3IgYWxsIGNvbHVtbnMuIEFsbCBvcGVyYXRvciBvcHRncm91cHMgYXJlIGNsYXNzbGVzcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAubGFiZWwgPSAnQ29uanVuY3Rpb25zJztcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQobmV3IE9wdGlvbignYW5kJywgJyBhbmQgJykpO1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5hcHBlbmRDaGlsZChuZXcgT3B0aW9uKCdvcicsICcgb3IgJykpO1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5hcHBlbmRDaGlsZChuZXcgT3B0aW9uKCdub3InLCAnIG5vciAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnY29sdW1uTmFtZXMnLFxuICAgICAgICAgICAgbGFiZWw6ICdDb2x1bW4gTmFtZXMnLFxuICAgICAgICAgICAgc2VsZWN0b3I6ICdvcHRncm91cC5zdWJtZW51LWNvbHVtbk5hbWVzJyxcbiAgICAgICAgICAgIHRvb2x0aXA6ICcoSG9sZCBkb3duIGFsdC9vcHRpb24ga2V5IHdoaWxlIGNsaWNraW5nIHRvIGluY2x1ZGUgaGlkZGVuIGNvbHVtbiBuYW1lcy4pJyxcbiAgICAgICAgICAgIHN5bWJvbDogJ0EnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2VmZicsXG4gICAgICAgICAgICBhcHBlbmRPcHRpb25zOiBmdW5jdGlvbihvcHRncm91cCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gd2luZG93LmV2ZW50LmFsdEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0Q29sdW1ucygpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZ3JpZC5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLmV2ZW50LmdyaWRDZWxsLng7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAob3B0Z3JvdXAuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuZmlyc3RFbGVtZW50Q2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGNvbHVtbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG5ldyBPcHRpb24obmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24udGl0bGUgPSAnWycgKyBuYW1lICsgJ11cXHJcIicgKyBjb2x1bW4uaGVhZGVyICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdkaXN0aW5jdFZhbHVlcycsXG4gICAgICAgICAgICBsYWJlbDogJ0Rpc3RpbmN0IFZhbHVlcycsXG4gICAgICAgICAgICBzZWxlY3RvcjogJ29wdGdyb3VwLnN1Ym1lbnUtZGlzdGluY3RWYWx1ZXMnLFxuICAgICAgICAgICAgc3ltYm9sOiAnIycsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmVmJyxcbiAgICAgICAgICAgIGFwcGVuZE9wdGlvbnM6IENvbWJvQm94LnByb3RvdHlwZS5tb2Rlc1swXS5hcHBlbmRPcHRpb25zXG4gICAgICAgIH1cbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogV3JpdGUgdGhlIGBtZW51TW9kZXNgIHByb3h5IHRvIHRoZSBmaWx0ZXIgdHJlZSdzIGNvbHVtbiBmaWx0ZXIgc3VidHJlZSBub2RlLlxuICAgICAqIFdlIGxvb2sgdXAgdGhlIG5vZGUgYWdhaW4gaGVyZSBiZWNhdXNlIGl0IG1pZ2h0IGJlIG5ldzsgb3IgbWF5IGhhdmUgYmVlbiBkZWxldGVkICYgcmVjcmVhdGVkIGR1cmluZyBlZGl0aW5nLlxuICAgICAqL1xuICAgIGhpZGVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBsb29rIGluIHRoZSBmaWx0ZXIsIHVuZGVyIGNvbHVtbiBmaWx0ZXJzLCBmb3IgYSBjb2x1bW4gZmlsdGVyIGZvciB0aGlzIGNvbHVtblxuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5ncmlkLmJlaGF2aW9yLmZpbHRlcixcbiAgICAgICAgICAgIGNvbHVtbk5hbWUgPSB0aGlzLmNvbHVtbi5uYW1lLFxuICAgICAgICAgICAgY29sdW1uRmlsdGVyU3VidHJlZSA9IGZpbHRlci5nZXRDb2x1bW5GaWx0ZXIoY29sdW1uTmFtZSk7XG5cbiAgICAgICAgaWYgKGNvbHVtbkZpbHRlclN1YnRyZWUpIHtcbiAgICAgICAgICAgIC8vIHdyaXRlIGJhY2sgdG8gZmlsdGVyLXRyZWUgbm9kZSBmb3IgcGVyc2lzdGluZyB3aXRoIGdldFN0YXRlXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJTdWJ0cmVlLm1lbnVNb2RlcyA9IHRoaXMubWVudU1vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2x1bW4ubWVudU1vZGVzID0gdGhpcy5tZW51TW9kZXM7XG5cbiAgICAgICAgQ29tYm9Cb3gucHJvdG90eXBlLmhpZGVFZGl0b3IuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAga2V5dXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFDZWxsRWRpdG9yLnByb3RvdHlwZS5rZXl1cC5jYWxsKHRoaXMsIGV2ZW50KSAmJlxuICAgICAgICAgICAgdGhpcy5ncmlkLnByb3BlcnRpZXMuZmlsdGVyaW5nTW9kZSA9PT0gJ2ltbWVkaWF0ZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZUVkaXRvclZhbHVlKHRoaXMuZ2V0RWRpdG9yVmFsdWUoKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc3ludGF4IGVycm9ycyBpbiBpbW1lZGlhdGUgbW9kZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kLFxuICAgICAgICAgICAgZHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duLFxuICAgICAgICAgICAgb3BlcmF0b3IgPSBkcm9wZG93bi52YWx1ZSxcbiAgICAgICAgICAgIG9wdGlvbiA9IGRyb3Bkb3duLm9wdGlvbnNbZHJvcGRvd24uc2VsZWN0ZWRJbmRleF0sXG4gICAgICAgICAgICBvcHRncm91cCA9IG9wdGlvbi5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgaXNPcGVyYXRvciA9ICEob3B0Z3JvdXAudGFnTmFtZSA9PT0gJ09QVEdST1VQJyAmJiBvcHRncm91cC5jbGFzc05hbWUpO1xuXG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcblxuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCAmJiBpc09wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gdGhpcy5ncmlkLmJlaGF2aW9yLmZpbHRlci5wYXJzZXJDUUwsXG4gICAgICAgICAgICAgICAgY3FsID0gdGhpcy5pbnB1dC52YWx1ZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBhcnNlci5nZXRPcGVyYXRvclBvc2l0aW9uKGNxbCwgdGhpcy5zZWxlY3Rpb25TdGFydCwgb3BlcmF0b3IpO1xuXG4gICAgICAgICAgICBzdGFydCA9IHBvc2l0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgZW5kID0gcG9zaXRpb24uZW5kO1xuXG4gICAgICAgICAgICAvLyBwcmVwZW5kIHNwYWNlIHRvIG9wZXJhdG9yIGFzIG5lZWRlZFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0YXJ0ID4gMCAmJiAvLyBub3QgYXQgdmVyeSBiZWdpbm5pbmc/IGFuZC4uLlxuICAgICAgICAgICAgICAgICEvXFxzLy50ZXN0KGNxbFtzdGFydCAtIDFdKSAvLyBubyB3aGl0ZSBzcGFjZSBiZWZvcmUgb3BlcmF0b3I/XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA9ICcgJyArIG9wZXJhdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhcHBlbmQgc3BhY2UgdG8gb3BlcmF0b3IgYXMgbmVlZGVkXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZW5kID09PSBjcWwubGVuZ3RoIHx8IC8vIGF0IHZlcnkgZW5kPyBvci4uLlxuICAgICAgICAgICAgICAgICEvXFxzLy50ZXN0KGNxbFtlbmRdKSAvLyBubyB3aGl0ZSBzcGFjZSBhZnRlciBvcGVyYXRvcj9cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yICs9ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluc2VydCB0aGUgZHJvcC1kb3duIHRleHQgYXQgdGhlIGluc2VydGlvbiBwb2ludCBvciBvdmVyIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgIHRoaXMuaW5wdXQuc2V0UmFuZ2VUZXh0KG9wZXJhdG9yLCBzdGFydCwgZW5kLCAnZW5kJyk7XG5cbiAgICAgICAgLy8gY2xvc2UgdGhlIGRyb3AtZG93blxuICAgICAgICB0aGlzLnRvZ2dsZURyb3BEb3duKCk7XG4gICAgfSxcblxuICAgIHNhdmVFZGl0b3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgQ2VsbEVkaXRvci5wcm90b3R5cGUuc2F2ZUVkaXRvclZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IucmVpbmRleCgpO1xuICAgIH0sXG5cbiAgICBzdG9wRWRpdGluZzogZnVuY3Rpb24oZmVlZGJhY2tDb3VudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQ2VsbEVkaXRvci5wcm90b3R5cGUuc3RvcEVkaXRpbmcuY2FsbCh0aGlzLCBmZWVkYmFja0NvdW50KTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyQm94O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGV4dGZpZWxkID0gcmVxdWlyZSgnLi9UZXh0ZmllbGQnKTtcblxuLyoqXG4gKiBGdW5jdGlvbnMgd2VsbCBpbiBDaHJvbWUsIFNhZmFyaSwgRmlyZWZveCwgYW5kIEludGVybmV0IEV4cGxvcmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBUZXh0ZmllbGRcbiAqL1xudmFyIE51bWJlciA9IFRleHRmaWVsZC5leHRlbmQoJ051bWJlcicsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6ZXIgPSBncmlkLmxvY2FsaXphdGlvbi5nZXQoJ251bWJlcicpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgU2xpZGVyID0gQ2VsbEVkaXRvci5leHRlbmQoJ1NsaWRlcicsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJyYW5nZVwiIGxhbmc9XCJ7e2xvY2FsZX19XCIgc3R5bGU9XCJ7e3N0eWxlfX1cIj4nXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuL0NlbGxFZGl0b3InKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxFZGl0b3JcbiAqL1xudmFyIFNwaW5uZXIgPSBDZWxsRWRpdG9yLmV4dGVuZCgnU3Bpbm5lcicsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJudW1iZXJcIiBsYW5nPVwie3tsb2NhbGV9fVwiIHN0eWxlPVwie3tzdHlsZX19XCI+J1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGlubmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xudmFyIExvY2FsaXphdGlvbiA9IHJlcXVpcmUoJy4uL2xpYi9Mb2NhbGl6YXRpb24nKTtcblxuXG4vKipcbiAqIEFzIG9mIHNwcmluZyAyMDE2OlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lLCBTYWZhcmksIEZpcmVmb3gsIGFuZCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgVGV4dGZpZWxkID0gQ2VsbEVkaXRvci5leHRlbmQoJ1RleHRmaWVsZCcsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbGFuZz1cInt7bG9jYWxlfX1cIiBjbGFzcz1cImh5cGVyZ3JpZC10ZXh0ZmllbGRcIiBzdHlsZT1cInt7c3R5bGV9fVwiPicsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5zdHlsZS50ZXh0QWxpZ24gPSB0aGlzLmV2ZW50LnByb3BlcnRpZXMuaGFsaWduO1xuICAgIH0sXG5cbiAgICBsb2NhbGl6ZXI6IExvY2FsaXphdGlvbi5wcm90b3R5cGUuc3RyaW5nLFxuXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSgwLCB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dGZpZWxkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICogQHBhcmFtIHtib29sZWFufSBbcHJpdmF0ZVJlZ2lzdHJ5PWZhbHNlXSAtIFRoaXMgaW5zdGFuY2Ugd2lsbCB1c2UgYSBwcml2YXRlIHJlZ2lzdHJ5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENlbGxFZGl0b3JzKGdyaWQsIHByaXZhdGVSZWdpc3RyeSkge1xuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICBpZiAocHJpdmF0ZVJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuZWRpdG9ycyA9IHt9O1xuICAgIH1cblxuICAgIC8vIHByZXJlZ2lzdGVyIHRoZSBzdGFuZGFyZCBjZWxsIGVkaXRvcnNcbiAgICBpZiAocHJpdmF0ZVJlZ2lzdHJ5IHx8ICF0aGlzLmdldCgnY2VsbGVkaXRvcicpKSB7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9Db21ib0JveCcpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9Db2xvcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9EYXRlJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0ZpbHRlckJveCcpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9OdW1iZXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU2xpZGVyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1NwaW5uZXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vVGV4dGZpZWxkJykpO1xuICAgIH1cbn1cblxuQ2VsbEVkaXRvcnMucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDZWxsRWRpdG9ycy5wcm90b3R5cGUuY29uc3RydWN0b3IsIC8vIHByZXNlcnZlIGNvbnN0cnVjdG9yXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIGNlbGwgZWRpdG9yIGNvbnN0cnVjdG9yLlxuICAgICAqIEBkZXNjIEFkZHMgYSBjdXN0b20gY2VsbCBlZGl0b3IgY29uc3RydWN0b3IgdG8gdGhlIGBlZGl0b3JzYCBoYXNoIHVzaW5nIHRoZSBwcm92aWRlZCBuYW1lIChvciB0aGUgY2xhc3MgbmFtZSksIGNvbnZlcnRlZCB0byBhbGwgbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqID4gQWxsIG5hdGl2ZSBjZWxsIGVkaXRvcnMgYXJlIFwicHJlcmVnaXN0ZXJlZFwiIGluIGBlZGl0b3JzYC4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gQ2FzZS1pbnNlbnNpdGl2ZSBlZGl0b3Iga2V5LiBJZiBub3QgZ2l2ZW4sIGBZb3VyQ2VsbEVkaXRvci5wcm90b3R5cGUuJCRDTEFTU19OQU1FYCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtZb3VyQ2VsbEVkaXRvci5wcm90b3R5cGUuY29uc3RydWN0b3J9IENvbnN0cnVjdG9yIC0gQSBjb25zdHJ1Y3RvciwgdHlwaWNhbGx5IGV4dGVuZGVkIGZyb20gYENlbGxFZGl0b3JgIChvciBhIGRlc2NlbmRhbnQgdGhlcmVmcm9tKS5cbiAgICAgKlxuICAgICAqID4gTm90ZTogYCQkQ0xBU1NfTkFNRWAgY2FuIGJlIGVhc2lseSBzZXQgdXAgYnkgcHJvdmlkaW5nIGEgc3RyaW5nIGFzIHRoZSAob3B0aW9uYWwpIGZpcnN0IHBhcmFtZXRlciAoYGFsaWFzYCkgaW4geW91ciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXh0ZW5kLW1lfENlbGxFZGl0b3IuZXh0ZW5kfSBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NlbGxFZGl0b3J9IEEgbmV3bHkgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIHtAbGluayBDZWxsRWRpdG9yfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9ycyNcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IENvbnN0cnVjdG9yLnByb3RvdHlwZS4kJENMQVNTX05BTUU7XG4gICAgICAgIG5hbWUgPSBuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5lZGl0b3JzW25hbWVdID0gQ29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYSBzeW5vbnltIGZvciBhbiBleGlzdGluZyBjZWxsIGVkaXRvciBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3lub255bU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhpc3RpbmdOYW1lXG4gICAgICogQHJldHVybnMge0NlbGxFZGl0b3J9IFRoZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY29uc3RydWN0b3IgdGhpcyBuZXcgc3lub255bSBwb2ludHMgdG8uXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3JzI1xuICAgICAqL1xuICAgIGFkZFN5bm9ueW06IGZ1bmN0aW9uKHN5bm9ueW1OYW1lLCBleGlzdGluZ05hbWUpIHtcbiAgICAgICAgdmFyIGNlbGxFZGl0b3IgPSB0aGlzLmdldChleGlzdGluZ05hbWUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuZWRpdG9yc1tzeW5vbnltTmFtZV0gPSBjZWxsRWRpdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGEgcmVnaXN0ZXJlZCBlZGl0b3IuXG4gICAgICogQHJldHVybnMge0NlbGxFZGl0b3J9IEEgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIHtAbGluayBDZWxsRWRpdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvcnMjXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvcnNbbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBMb29rdXAgcmVnaXN0ZXJlZCBjZWxsIGVkaXRvciBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIHRoZXJlb2YuXG4gICAgICogQGRlc2MgTm90ZTogTXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgSHlwZXJncmlkIG9iamVjdCBhcyBjb250ZXh0IVxuICAgICAqIEByZXR1cm5zIHtDZWxsRWRpdG9yfSBOZXcgaW5zdGFuY2Ugb2YgdGhlIG5hbWVkIGNlbGwgZWRpdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBhIHJlZ2lzdGVyZWQgZWRpdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gLSBQcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgaW5zdGFudGlhdGVkIGVkaXRvciBwcmltYXJpbHkgZm9yIG11c3RhY2hlJ3MgdXNlLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9ycyNcbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNlbGxFZGl0b3IsXG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0KG5hbWUpO1xuXG4gICAgICAgIGlmIChDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKENvbnN0cnVjdG9yLmFic3RyYWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0F0dGVtcHQgdG8gaW5zdGFudGlhdGUgYW4gXCJhYnN0cmFjdFwiIGNlbGwgZWRpdG9yIGNsYXNzLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsRWRpdG9yID0gbmV3IENvbnN0cnVjdG9yKHRoaXMuZ3JpZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNlbGwgZWRpdG9yIHJlZ2lzdHJ5IGNvbnRhaW5pbmcgYWxsIHRoZSBcInByZXJlZ2lzdGVyZWRcIiBjZWxsIGVkaXRvciBjb25zdHJ1Y3RvcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvcnMjXG4gICAgICovXG4gICAgZWRpdG9yczoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbEVkaXRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBCdXR0b24gPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdCdXR0b24nLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgZGVmYXVsdCBjZWxsIHJlbmRlcmluZyBmdW5jdGlvbiBmb3IgYSBidXR0b24gY2VsbC5cbiAgICAgKiBAaW1wbGVtZW50cyBwYWludEZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIEJ1dHRvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgdmFsID0gY29uZmlnLnZhbHVlLFxuICAgICAgICAgICAgYyA9IGNvbmZpZy5kYXRhQ2VsbC54LFxuICAgICAgICAgICAgciA9IGNvbmZpZy5ncmlkQ2VsbC55LFxuICAgICAgICAgICAgYm91bmRzID0gY29uZmlnLmJvdW5kcyxcbiAgICAgICAgICAgIHggPSBib3VuZHMueCArIDEsXG4gICAgICAgICAgICB5ID0gYm91bmRzLnkgKyAxLFxuICAgICAgICAgICAgd2lkdGggPSBib3VuZHMud2lkdGggLSAxIC0gY29uZmlnLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSAxIC0gY29uZmlnLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIHJhZGl1cyA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgICBhcmNHcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuXG4gICAgICAgIGlmIChjb25maWcubW91c2VEb3duKSB7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNCNUNCRUQnKTtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzRkNzRlYScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjZmZmZmZmJyk7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyNhYWFhYWEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRyYXcgdGhlIGJhY2tncm91bmRcbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgZ2MuZmlsbFJlY3QoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIGRyYXcgdGhlIGNhcHN1bGVcbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gYXJjR3JhZGllbnQ7XG4gICAgICAgIGdjLmNhY2hlLnN0cm9rZVN0eWxlID0gJyMwMDAwMDAnO1xuICAgICAgICB0aGlzLnJvdW5kUmVjdChnYywgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBhcmNHcmFkaWVudCwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIG94ID0gKHdpZHRoIC0gZ2MuZ2V0VGV4dFdpZHRoKHZhbCkpIC8gMjtcbiAgICAgICAgdmFyIG95ID0gKGhlaWdodCAtIGdjLmdldFRleHRIZWlnaHQoZ2MuY2FjaGUuZm9udCkuZGVzY2VudCkgLyAyO1xuXG4gICAgICAgIC8vIGRyYXcgdGhlIHRleHRcbiAgICAgICAgZ2MuY2FjaGUudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9ICcjMzMzMzMzJztcbiAgICAgICAgZ2MuY2FjaGUuZm9udCA9IGhlaWdodCAtIDIgKyAncHggc2Fucy1zZXJpZic7XG4gICAgICAgIGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGdjLmZpbGxUZXh0KHZhbCwgeCArIG94LCB5ICsgb3kpO1xuXG4gICAgICAgIC8vaWRlbnRpZnkgdGhhdCB3ZSBhcmUgYSBidXR0b25cbiAgICAgICAgY29uZmlnLmJ1dHRvbkNlbGxzW2MgKyAnLCcgKyByXSA9IHRydWU7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnV0dG9uO1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi9CYXNlJyk7XG5cbi8qKiBAdHlwZWRlZiBwYWludEZ1bmN0aW9uXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAdGhpcyB7Q2VsbEVkaXRvcn1cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgY2xpcHBpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcueCAtIHRoZSBcInRyYW5zbGF0ZWRcIiBpbmRleCBpbnRvIHRoZSBgYmVoYXZpb3IuYWxsQ29sdW1uc2AgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcubm9ybWFsaXplZFkgLSB0aGUgdmVydGljYWwgZ3JpZCBjb29yZGluYXRlIG5vcm1hbGl6ZWQgdG8gZmlyc3QgZGF0YSByb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcudW50cmFuc2xhdGVkWCAtIHRoZSBob3Jpem9udGFsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIGZpcnN0IGRhdGEgY29sdW1uXG4gKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnkgLSB0aGUgdmVydGljYWwgZ3JpZCBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gdG9wIGhlYWRlciByb3dcbiAqL1xuXG4vKiogQGNvbnN0cnVjdG9yXG4gKiBAZGVzYyBJbnN0YW5jZXMgb2YgYENlbGxSZW5kZXJlcmAgYXJlIHVzZWQgdG8gcmVuZGVyIHRoZSAyRCBncmFwaGljcyBjb250ZXh0IHdpdGhpbiB0aGUgYm91bmQgb2YgYSBjZWxsLiBFeHRlbmQgdGhpcyBiYXNlIGNsYXNzIHRvIGltcGxlbWVudCB5b3VyIG93biBjZWxsIHJlbmRlcmVyXG4gKlxuICpcbiAqIFNlZSBhbHNvIHtAdHV0b3JpYWwgY2VsbC1yZW5kZXJlcn0uXG4gKi9cbnZhciBDZWxsUmVuZGVyZXIgPSBCYXNlLmV4dGVuZCgnQ2VsbFJlbmRlcmVyJywge1xuICAgIC8qKlxuICAgICAqIEBkZXNjIEFuIGVtcHR5IGltcGxlbWVudGF0aW9uIG9mIGEgY2VsbCByZW5kZXJlciwgc2VlIFt0aGUgbnVsbCBvYmplY3QgcGF0dGVybl0oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9OdWxsT2JqZWN0KS5cbiAgICAgKiBAaW1wbGVtZW50cyBwYWludEZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge30sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiByb3VuZGluZyBhIGNlbGwuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBncmlkIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBncmlkIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZpbGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3Ryb2tlXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByb3VuZFJlY3Q6IGZ1bmN0aW9uKGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGZpbGwsIHN0cm9rZSkge1xuXG4gICAgICAgIGlmICghc3Ryb2tlKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFkaXVzKSB7XG4gICAgICAgICAgICByYWRpdXMgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgICAgIGdjLmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgICAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICAgICAgZ2MubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgICAgIGdjLmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICAgICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfVxufSk7XG5cbkNlbGxSZW5kZXJlci5hYnN0cmFjdCA9IHRydWU7IC8vIGRvbid0IGluc3RhbnRpYXRlIGRpcmVjdGx5XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbFJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgRXJyb3JDZWxsID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnRXJyb3JDZWxsJywge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgV3JpdGVzIGVycm9yIG1lc3NhZ2UgaW50byBjZWxsLlxuICAgICAqXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGdjLnNhdmUoKTtcbiAgICAgKiBnYy5iZWdpblBhdGgoKTtcbiAgICAgKiBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAqIGdjLmNsaXAoKTtcbiAgICAgKiBiZWhhdmlvci5nZXRDZWxsUHJvdmlkZXIoKS5yZW5kZXJDZWxsRXJyb3IoZ2MsIG1lc3NhZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAqIGdjLnJlc3RvcmUoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBjbGVhciB0aGUgY2VsbCBieSBzZXR0aW5nIGBnYy5maWxsU3R5bGVgIGFuZCBjYWxsaW5nIGBnYy5maWxsKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGNsaXBwaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQG1lbWJlck9mIEVycm9yQ2VsbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZywgbWVzc2FnZSkge1xuICAgICAgICAvL3ZhciBpbWFnZXMgPSByZXF1aXJlKCcuLi8uLi9pbWFnZXMvaW5kZXgnKTtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgLy8gd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNlbGxcbiAgICAgICAgLy8gKHRoaXMgbWFrZXMgdXNlIG9mIHRoZSByZWN0IHBhdGggZGVmaW5lZCBieSB0aGUgY2FsbGVyKVxuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSAnI0ZGRDUwMCc7XG4gICAgICAgIGdjLmZpbGwoKTtcblxuICAgICAgICAvLyByZW5kZXIgbWVzc2FnZSB0ZXh0XG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9ICcjQTAwJztcbiAgICAgICAgZ2MuY2FjaGUudGV4dEFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgZ2MuY2FjaGUudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGdjLmNhY2hlLmZvbnQgPSAnYm9sZCA2cHQgXCJhcmlhbCBuYXJyb3dcIiwgdmVyZGFuYSwgZ2VuZXZhJztcbiAgICAgICAgZ2MuZmlsbFRleHQobWVzc2FnZSwgeCArIDQsIHkgKyBoZWlnaHQgLyAyICsgMC41KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBFcnJvckNlbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBMYXN0U2VsZWN0aW9uID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnTGFzdFNlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgcmVuZGVyaW5nIG9mIHRoZSBsYXN0IFNlbGVjdGlvbiBNb2RlbFxuICAgICAqIEBpbXBsZW1lbnRzIHBhaW50RnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgTGFzdFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgdmlzT3ZlcmxheSA9IGdjLmFscGhhKGNvbmZpZy5zZWxlY3Rpb25SZWdpb25PdmVybGF5Q29sb3IpID4gMCxcbiAgICAgICAgICAgIHZpc091dGxpbmUgPSBnYy5hbHBoYShjb25maWcuc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yKSA+IDA7XG5cbiAgICAgICAgaWYgKHZpc092ZXJsYXkgfHwgdmlzT3V0bGluZSkge1xuICAgICAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAodmlzT3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGNvbmZpZy5zZWxlY3Rpb25SZWdpb25PdmVybGF5Q29sb3I7XG4gICAgICAgICAgICAgICAgZ2MuZmlsbCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlzT3V0bGluZSkge1xuICAgICAgICAgICAgICAgIGdjLmNhY2hlLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSBjb25maWcuc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yO1xuICAgICAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhc3RTZWxlY3Rpb247XG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcbnZhciBpbWFnZXMgPSByZXF1aXJlKCcuLi8uLi9pbWFnZXMvaW5kZXgnKTtcblxudmFyIFdISVRFU1BBQ0UgPSAvXFxzXFxzKy9nO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTaW1wbGVDZWxsID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnU2ltcGxlQ2VsbCcsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBkZWZhdWx0IGNlbGwgcmVuZGVyaW5nIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgYSB2YW5pbGxhIGNlbGwuXG4gICAgICogQGRlc2MgR3JlYXQgY2FyZSBoYXMgYmVlbiB0YWtlbiBpbiBjcmFmdGluZyB0aGlzIGZ1bmN0aW9uIGFzIGl0IG5lZWRzIHRvIHBlcmZvcm0gZXh0cmVtZWx5IGZhc3QuIFJlYWRzIG9uIHRoZSBnYyBvYmplY3QgYXJlIGV4cGVuc2l2ZSBidXQgbm90IHF1aXRlIGFzIGV4cGVuc2l2ZSBhcyB3cml0ZXMgdG8gaXQuIFdlIGRvIG91ciBiZXN0IHRvIGF2b2lkIHdyaXRlcywgdGhlbiBhdm9pZCByZWFkcy4gQ2xpcHBpbmcgYm91bmRzIGFyZSBub3Qgc2V0IGhlcmUgYXMgdGhpcyBpcyBhbHNvIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24uIEluc3RlYWQsIHdlIHRydW5jYXRlIG92ZXJmbG93aW5nIHRleHQgYW5kIGNvbnRlbnQgYnkgZmlsbGluZyBhIHJlY3RhbmdsZSB3aXRoIGJhY2tncm91bmQgY29sb3IgY29sdW1uIGJ5IGNvbHVtbiBpbnN0ZWFkIG9mIGNlbGwgYnkgY2VsbC4gIFRoaXMgY29sdW1uIGJ5IGNvbHVtbiBmaWxsIGhhcHBlbnMgaGlnaGVyIHVwIG9uIHRoZSBzdGFjayBpbiBhIGNhbGxpbmcgZnVuY3Rpb24gZnJvbSBmaW4taHlwZXJncmlkLXJlbmRlcmVyLiAgVGFrZSBub3RlIHdlIGRvIG5vdCBkbyBjZWxsIGJ5IGNlbGwgYm9yZGVyIHJlbmRlcmluZyBhcyB0aGF0IGlzIGV4cGVuc2l2ZS4gIEluc3RlYWQgd2UgcmVuZGVyIG1hbnkgZmV3ZXIgZ3JpZGxpbmVzIGFmdGVyIGFsbCBjZWxscyBhcmUgcmVuZGVyZWQuXG4gICAgICogQGltcGxlbWVudHMgcGFpbnRGdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGVDZWxsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB2YWwgPSBjb25maWcudmFsdWUsXG4gICAgICAgICAgICBib3VuZHMgPSBjb25maWcuYm91bmRzLFxuICAgICAgICAgICAgeCA9IGJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgaWNvblBhZGRpbmcgPSBjb25maWcuaWNvblBhZGRpbmcsXG4gICAgICAgICAgICBwYXJ0aWFsUmVuZGVyID0gY29uZmlnLnByZWZpbGxDb2xvciA9PT0gdW5kZWZpbmVkLCAvLyBzaWduaWZpZXMgYWJvcnQgYmVmb3JlIHJlbmRlcmluZyBpZiBzYW1lXG4gICAgICAgICAgICBzbmFwc2hvdCA9IGNvbmZpZy5zbmFwc2hvdCxcbiAgICAgICAgICAgIHNhbWUgPSBzbmFwc2hvdCAmJiBwYXJ0aWFsUmVuZGVyLFxuICAgICAgICAgICAgdmFsV2lkdGggPSAwLFxuICAgICAgICAgICAgdGV4dENvbG9yLCB0ZXh0Rm9udCxcbiAgICAgICAgICAgIGl4b2Zmc2V0LCBpeW9mZnNldCxcbiAgICAgICAgICAgIGxlZnRJY29uLCByaWdodEljb24sIGNlbnRlckljb24sXG4gICAgICAgICAgICBsZWZ0UGFkZGluZywgcmlnaHRQYWRkaW5nLFxuICAgICAgICAgICAgaG92ZXIsIGhvdmVyQ29sb3IsIHNlbGVjdENvbG9yLCBmb3VuZGF0aW9uQ29sb3IsIGluaGVyaXRzQmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYywgY29sb3JzO1xuXG4gICAgICAgIC8vIHNldHRpbmcgZ2MgcHJvcGVydGllcyBhcmUgZXhwZW5zaXZlLCBsZXQncyBub3QgZG8gaXQgbmVlZGxlc3NseVxuXG4gICAgICAgIGlmICh2YWwgJiYgdmFsLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgbGVmdEljb24gPSB2YWxbMF07XG4gICAgICAgICAgICByaWdodEljb24gPSB2YWxbMl07XG4gICAgICAgICAgICB2YWwgPSBjb25maWcuZXhlYyh2YWxbMV0pO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwubmF0dXJhbFdpZHRoICE9PSB1bmRlZmluZWQpIHsgLy8gbXVzdCBiZSBhbiBpbWFnZSAobXVjaCBmYXN0ZXIgdGhhbiBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY2VudGVySWNvbiA9IHZhbDtcbiAgICAgICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pc0ZpbHRlclJvdykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5maWx0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRJY29uID0gaW1hZ2VzW2NvbmZpZy5pc0hhbmRsZUNvbHVtbiB8fCAhdmFsLmxlbmd0aCA/ICdmaWx0ZXItb2ZmJyA6ICdmaWx0ZXItb24nXTtcbiAgICAgICAgICAgICAgICBjb25maWcucmVuZGVyRmFsc3kgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghY29uZmlnLmlzSGFuZGxlQ29sdW1uKSB7XG4gICAgICAgICAgICBsZWZ0SWNvbiA9IGltYWdlc1tjb25maWcubGVmdEljb25dO1xuICAgICAgICAgICAgY2VudGVySWNvbiA9IGltYWdlc1tjb25maWcuY2VudGVySWNvbl07XG4gICAgICAgICAgICByaWdodEljb24gPSBpbWFnZXNbY29uZmlnLnJpZ2h0SWNvbl07XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmlzRGF0YVJvdykge1xuICAgICAgICAgICAgbGVmdEljb24gPSBpbWFnZXNbY29uZmlnLmxlZnRJY29uICE9IHVuZGVmaW5lZCA/IGNvbmZpZy5sZWZ0SWNvbiA6IGNvbmZpZy5pc1Jvd1NlbGVjdGVkID8gJ2NoZWNrZWQnIDogJ3VuY2hlY2tlZCddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pc0hlYWRlclJvdykge1xuICAgICAgICAgICAgbGVmdEljb24gPSBpbWFnZXNbY29uZmlnLmxlZnRJY29uICE9IHVuZGVmaW5lZCA/IGNvbmZpZy5sZWZ0SWNvbiA6IGNvbmZpZy5hbGxSb3dzU2VsZWN0ZWQgPyAnY2hlY2tlZCcgOiAndW5jaGVja2VkJ107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByb3cgaGFuZGxlcyBmb3IgXCJzdW1tYXJ5XCIgb3Igb3RoZXIgc3ViZ3JpZHMnIHJvd3M6IGVtcHR5XG4gICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHZmID09IDAgaXMgZmFzdGVzdCBlcXVpdmFsZW50IG9mIHZmID09PSAwIHx8IHZmID09PSBmYWxzZSB3aGljaCBleGNsdWRlcyBOYU4sIG51bGwsIHVuZGVmaW5lZFxuICAgICAgICB2YXIgcmVuZGVyVmFsdWUgPSB2YWwgfHwgY29uZmlnLnJlbmRlckZhbHN5ICYmIHZhbCA9PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXG4gICAgICAgIGlmIChyZW5kZXJWYWx1ZSkge1xuICAgICAgICAgICAgdmFsID0gY29uZmlnLmZvcm1hdFZhbHVlKHZhbCwgY29uZmlnKTtcblxuICAgICAgICAgICAgdGV4dEZvbnQgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA6IGNvbmZpZy5mb250O1xuXG4gICAgICAgICAgICB0ZXh0Q29sb3IgPSBnYy5jYWNoZS5zdHJva2VTdHlsZSA9IGNvbmZpZy5pc1NlbGVjdGVkXG4gICAgICAgICAgICAgICAgPyBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yXG4gICAgICAgICAgICAgICAgOiBjb25maWcuY29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHNhbWUgPSBzYW1lICYmXG4gICAgICAgICAgICB2YWwgPT09IHNuYXBzaG90LnZhbHVlICYmXG4gICAgICAgICAgICB0ZXh0Rm9udCA9PT0gc25hcHNob3QudGV4dEZvbnQgJiZcbiAgICAgICAgICAgIHRleHRDb2xvciA9PT0gc25hcHNob3QudGV4dENvbG9yO1xuXG4gICAgICAgIC8vIGZpbGwgYmFja2dyb3VuZCBvbmx5IGlmIG91ciBiZ0NvbG9yIGlzIHBvcHVsYXRlZCBvciB3ZSBhcmUgYSBzZWxlY3RlZCBjZWxsXG4gICAgICAgIGNvbG9ycyA9IFtdO1xuICAgICAgICBjID0gMDtcbiAgICAgICAgaWYgKGNvbmZpZy5pc0NlbGxIb3ZlcmVkICYmIGNvbmZpZy5ob3ZlckNlbGxIaWdobGlnaHQuZW5hYmxlZCkge1xuICAgICAgICAgICAgaG92ZXJDb2xvciA9IGNvbmZpZy5ob3ZlckNlbGxIaWdobGlnaHQuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pc1Jvd0hvdmVyZWQgJiYgKGhvdmVyID0gY29uZmlnLmhvdmVyUm93SGlnaGxpZ2h0KS5lbmFibGVkKSB7XG4gICAgICAgICAgICBob3ZlckNvbG9yID0gY29uZmlnLmlzRGF0YUNvbHVtbiB8fCAhaG92ZXIuaGVhZGVyIHx8IGhvdmVyLmhlYWRlci5iYWNrZ3JvdW5kQ29sb3IgPT09IHVuZGVmaW5lZCA/IGhvdmVyLmJhY2tncm91bmRDb2xvciA6IGhvdmVyLmhlYWRlci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmlzQ29sdW1uSG92ZXJlZCAmJiAoaG92ZXIgPSBjb25maWcuaG92ZXJDb2x1bW5IaWdobGlnaHQpLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhvdmVyQ29sb3IgPSBjb25maWcuaXNEYXRhUm93IHx8ICFob3Zlci5oZWFkZXIgfHwgaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvciA9PT0gdW5kZWZpbmVkID8gaG92ZXIuYmFja2dyb3VuZENvbG9yIDogaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2MuYWxwaGEoaG92ZXJDb2xvcikgPCAxKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnYy5hbHBoYShzZWxlY3RDb2xvcikgPCAxKSB7XG4gICAgICAgICAgICAgICAgaW5oZXJpdHNCYWNrZ3JvdW5kQ29sb3IgPSAoY29uZmlnLmJhY2tncm91bmRDb2xvciA9PT0gY29uZmlnLnByZWZpbGxDb2xvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmhlcml0c0JhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZGF0aW9uQ29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChjb25maWcuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2FtZSA9IHNhbWUgJiYgIGZvdW5kYXRpb25Db2xvciA9PT0gc25hcHNob3QuZm91bmRhdGlvbkNvbG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuYmFja2dyb3VuZENvbG9yID09PSBzbmFwc2hvdC5jb2xvcnNbYysrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzLnB1c2goc2VsZWN0Q29sb3IpO1xuICAgICAgICAgICAgICAgIHNhbWUgPSBzYW1lICYmIHNlbGVjdENvbG9yID09PSBzbmFwc2hvdC5jb2xvcnNbYysrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaG92ZXJDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2xvcnMucHVzaChob3ZlckNvbG9yKTtcbiAgICAgICAgICAgIHNhbWUgPSBzYW1lICYmIGhvdmVyQ29sb3IgPT09IHNuYXBzaG90LmNvbG9yc1tjKytdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9kbyBjaGVjayBpZiBpY29ucyBoYXZlIGNoYW5nZWRcbiAgICAgICAgaWYgKHNhbWUgJiYgYyA9PT0gc25hcHNob3QuY29sb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGEgc25hcHNob3QgdG8gc2F2ZSBpbiBjZWxsRXZlbnQgZm9yIGZ1dHVyZSBjb21wYXJpc29ucyBieSBwYXJ0aWFsIHJlbmRlcmVyXG4gICAgICAgIGNvbmZpZy5zbmFwc2hvdCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRleHRDb2xvcixcbiAgICAgICAgICAgIHRleHRGb250OiB0ZXh0Rm9udCxcbiAgICAgICAgICAgIGZvdW5kYXRpb25Db2xvcjogZm91bmRhdGlvbkNvbG9yLFxuICAgICAgICAgICAgY29sb3JzOiBjb2xvcnNcbiAgICAgICAgfTtcblxuICAgICAgICBsYXllckNvbG9ycyhnYywgY29sb3JzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3VuZGF0aW9uQ29sb3IpO1xuXG4gICAgICAgIC8vIE1lYXN1cmUgbGVmdCBhbmQgcmlnaHQgaWNvbnMsIG5lZWRlZCBmb3IgcmVuZGVyaW5nIGFuZCBmb3IgcmV0dXJuIHZhbHVlIChtaW4gd2lkdGgpXG4gICAgICAgIGxlZnRQYWRkaW5nID0gbGVmdEljb24gPyBpY29uUGFkZGluZyArIGxlZnRJY29uLndpZHRoICsgaWNvblBhZGRpbmcgOiBjb25maWcuY2VsbFBhZGRpbmc7XG4gICAgICAgIHJpZ2h0UGFkZGluZyA9IHJpZ2h0SWNvbiA/IGljb25QYWRkaW5nICsgcmlnaHRJY29uLndpZHRoICsgaWNvblBhZGRpbmcgOiBjb25maWcuY2VsbFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlclZhbHVlKSB7XG4gICAgICAgICAgICAvLyBkcmF3IHRleHRcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZvbnQgPSB0ZXh0Rm9udDtcbiAgICAgICAgICAgIHZhbFdpZHRoID0gY29uZmlnLmlzSGVhZGVyUm93ICYmIGNvbmZpZy5oZWFkZXJUZXh0V3JhcHBpbmdcbiAgICAgICAgICAgICAgICA/IHJlbmRlck11bHRpTGluZVRleHQoZ2MsIGNvbmZpZywgdmFsLCBsZWZ0UGFkZGluZywgcmlnaHRQYWRkaW5nKVxuICAgICAgICAgICAgICAgIDogcmVuZGVyU2luZ2xlTGluZVRleHQoZ2MsIGNvbmZpZywgdmFsLCBsZWZ0UGFkZGluZywgcmlnaHRQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmIChjZW50ZXJJY29uKSB7XG4gICAgICAgICAgICAvLyBNZWFzdXJlICYgZHJhdyBjZW50ZXIgaWNvblxuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSBjZW50ZXJJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGl4b2Zmc2V0ID0gTWF0aC5yb3VuZCgod2lkdGggLSBjZW50ZXJJY29uLndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgZ2MuZHJhd0ltYWdlKGNlbnRlckljb24sIHggKyB3aWR0aCAtIGl4b2Zmc2V0IC0gY2VudGVySWNvbi53aWR0aCwgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgICAgIHZhbFdpZHRoID0gaWNvblBhZGRpbmcgKyBjZW50ZXJJY29uLndpZHRoICsgaWNvblBhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdEljb24pIHtcbiAgICAgICAgICAgIC8vIERyYXcgbGVmdCBpY29uXG4gICAgICAgICAgICBpeW9mZnNldCA9IE1hdGgucm91bmQoKGhlaWdodCAtIGxlZnRJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShsZWZ0SWNvbiwgeCArIGljb25QYWRkaW5nLCB5ICsgaXlvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJpZ2h0SWNvbikge1xuICAgICAgICAgICAgLy8gUmVwYWludCBiYWNrZ3JvdW5kIGJlZm9yZSBwYWludGluZyByaWdodCBpY29uLCBiZWNhdXNlIHRleHQgbWF5IGhhdmUgZmxvd2VkIHVuZGVyIHdoZXJlIGl0IHdpbGwgYmUuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgd29yay1hcm91bmQgdG8gY2xpcHBpbmcgd2hpY2ggaXMgdG9vIGV4cGVuc2l2ZSB0byBwZXJmb3JtIGhlcmUuXG4gICAgICAgICAgICB2YXIgcmlnaHRYID0geCArIHdpZHRoIC0gKHJpZ2h0SWNvbi53aWR0aCArIGljb25QYWRkaW5nKTtcbiAgICAgICAgICAgIGlmIChpbmhlcml0c0JhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgIGZvdW5kYXRpb25Db2xvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29sb3JzLnVuc2hpZnQoY29uZmlnLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllckNvbG9ycyhnYywgY29sb3JzLCByaWdodFgsIHksIHJpZ2h0UGFkZGluZywgaGVpZ2h0LCBmb3VuZGF0aW9uQ29sb3IpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHJpZ2h0IGljb25cbiAgICAgICAgICAgIGl5b2Zmc2V0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0IC0gcmlnaHRJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShyaWdodEljb24sIHJpZ2h0WCwgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuY2VsbEJvcmRlclRoaWNrbmVzcykge1xuICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZ2MuY2FjaGUubGluZVdpZHRoID0gY29uZmlnLmNlbGxCb3JkZXJUaGlja25lc3M7XG4gICAgICAgICAgICBnYy5jYWNoZS5zdHJva2VTdHlsZSA9IGNvbmZpZy5jZWxsQm9yZGVyU3R5bGU7XG4gICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLm1pbldpZHRoID0gbGVmdFBhZGRpbmcgKyB2YWxXaWR0aCArIHJpZ2h0UGFkZGluZztcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAc3VtbWFyeSBSZW5kZXJzIHNpbmdsZSBsaW5lIHRleHQuXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGNsaXBwaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gKiBAcGFyYW0geyp9IHZhbCAtIFRoZSB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgY2VsbC5cbiAqIEBtZW1iZXJPZiBTaW1wbGVDZWxsLnByb3RvdHlwZVxuICovXG5mdW5jdGlvbiByZW5kZXJNdWx0aUxpbmVUZXh0KGdjLCBjb25maWcsIHZhbCwgbGVmdFBhZGRpbmcsIHJpZ2h0UGFkZGluZykge1xuICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0LFxuICAgICAgICBjbGVhblZhbCA9ICh2YWwgKyAnJykudHJpbSgpLnJlcGxhY2UoV0hJVEVTUEFDRSwgJyAnKSwgLy8gdHJpbSBhbmQgc3F1ZWV6ZSB3aGl0ZXNwYWNlXG4gICAgICAgIGxpbmVzID0gZmluZExpbmVzKGdjLCBjb25maWcsIGNsZWFuVmFsLnNwbGl0KCcgJyksIHdpZHRoKTtcblxuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclNpbmdsZUxpbmVUZXh0KGdjLCBjb25maWcsIGNsZWFuVmFsLCBsZWZ0UGFkZGluZywgcmlnaHRQYWRkaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgaGFsaWduT2Zmc2V0ID0gbGVmdFBhZGRpbmcsXG4gICAgICAgIHZhbGlnbk9mZnNldCA9IGNvbmZpZy52b2Zmc2V0LFxuICAgICAgICBoYWxpZ24gPSBjb25maWcuaGFsaWduLFxuICAgICAgICB0ZXh0SGVpZ2h0ID0gZ2MuZ2V0VGV4dEhlaWdodChjb25maWcuZm9udCkuaGVpZ2h0O1xuXG4gICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gd2lkdGggLSByaWdodFBhZGRpbmc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBoTWluID0gMCwgdk1pbiA9IE1hdGguY2VpbCh0ZXh0SGVpZ2h0IC8gMik7XG5cbiAgICB2YWxpZ25PZmZzZXQgKz0gTWF0aC5jZWlsKChoZWlnaHQgLSAobGluZXMubGVuZ3RoIC0gMSkgKiB0ZXh0SGVpZ2h0KSAvIDIpO1xuXG4gICAgaGFsaWduT2Zmc2V0ID0gTWF0aC5tYXgoaE1pbiwgaGFsaWduT2Zmc2V0KTtcbiAgICB2YWxpZ25PZmZzZXQgPSBNYXRoLm1heCh2TWluLCB2YWxpZ25PZmZzZXQpO1xuXG4gICAgZ2MuY2FjaGUuc2F2ZSgpOyAvLyBkZWZpbmUgYSBjbGlwcGluZyByZWdpb24gZm9yIGNlbGxcbiAgICBnYy5iZWdpblBhdGgoKTtcbiAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGdjLmNsaXAoKTtcblxuICAgIGdjLmNhY2hlLnRleHRBbGlnbiA9IGhhbGlnbjtcbiAgICBnYy5jYWNoZS50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ2MuZmlsbFRleHQobGluZXNbaV0sIHggKyBoYWxpZ25PZmZzZXQsIHkgKyB2YWxpZ25PZmZzZXQgKyAoaSAqIHRleHRIZWlnaHQpKTtcbiAgICB9XG5cbiAgICBnYy5jYWNoZS5yZXN0b3JlKCk7IC8vIGRpc2NhcmQgY2xpcHBpbmcgcmVnaW9uXG5cbiAgICByZXR1cm4gd2lkdGg7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgUmVuZGVycyBzaW5nbGUgbGluZSB0ZXh0LlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIHsqfSB2YWwgLSBUaGUgdGV4dCB0byByZW5kZXIgaW4gdGhlIGNlbGwuXG4gKiBAbWVtYmVyT2YgU2ltcGxlQ2VsbC5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2luZ2xlTGluZVRleHQoZ2MsIGNvbmZpZywgdmFsLCBsZWZ0UGFkZGluZywgcmlnaHRQYWRkaW5nKSB7XG4gICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgaGFsaWduT2Zmc2V0ID0gbGVmdFBhZGRpbmcsXG4gICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgIG1pbldpZHRoLFxuICAgICAgICBtZXRyaWNzO1xuXG4gICAgaWYgKGNvbmZpZy5jb2x1bW5BdXRvc2l6aW5nKSB7XG4gICAgICAgIG1ldHJpY3MgPSBnYy5nZXRUZXh0V2lkdGhUcnVuY2F0ZWQodmFsLCB3aWR0aCAtIGxlZnRQYWRkaW5nLCBjb25maWcudHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzKTtcbiAgICAgICAgbWluV2lkdGggPSBtZXRyaWNzLndpZHRoO1xuICAgICAgICB2YWwgPSBtZXRyaWNzLnN0cmluZyB8fCB2YWw7XG4gICAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gd2lkdGggLSByaWdodFBhZGRpbmcgLSBtZXRyaWNzLndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAod2lkdGggLSBtZXRyaWNzLndpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBtZXRyaWNzID0gZ2MuZ2V0VGV4dFdpZHRoVHJ1bmNhdGVkKHZhbCwgd2lkdGggLSBsZWZ0UGFkZGluZywgY29uZmlnLnRydW5jYXRlVGV4dFdpdGhFbGxpcHNpcywgdHJ1ZSk7XG4gICAgICAgIG1pbldpZHRoID0gMDtcbiAgICAgICAgaWYgKG1ldHJpY3Muc3RyaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbCA9IG1ldHJpY3Muc3RyaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gcmlnaHRQYWRkaW5nIC0gbWV0cmljcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gKHdpZHRoIC0gbWV0cmljcy53aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgeCArPSBNYXRoLm1heChsZWZ0UGFkZGluZywgaGFsaWduT2Zmc2V0KTtcbiAgICAgICAgeSArPSBjb25maWcuYm91bmRzLmhlaWdodCAvIDI7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pc1VzZXJEYXRhQXJlYSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5saW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5pc0NlbGxIb3ZlcmVkIHx8ICFjb25maWcubGlua09uSG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5saW5rQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdjLmNhY2hlLnN0cm9rZVN0eWxlID0gY29uZmlnLmxpbmtDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lKGNvbmZpZywgZ2MsIHZhbCwgeCwgeSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5saW5rQ29sb3IgJiYgKGNvbmZpZy5pc0NlbGxIb3ZlcmVkIHx8ICFjb25maWcubGlua0NvbG9yT25Ib3ZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmxpbmtDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuc3RyaWtlVGhyb3VnaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHN0cmlrZVRocm91Z2goY29uZmlnLCBnYywgdmFsLCB4LCB5LCAxKTtcbiAgICAgICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmNhY2hlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgZ2MuY2FjaGUudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGdjLmZpbGxUZXh0KHZhbCwgeCwgeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbldpZHRoO1xufVxuXG5mdW5jdGlvbiBmaW5kTGluZXMoZ2MsIGNvbmZpZywgd29yZHMsIHdpZHRoKSB7XG5cbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG5cbiAgICAvLyBzdGFydGluZyB3aXRoIGp1c3QgdGhlIGZpcnN0IHdvcmQuLi5cbiAgICB2YXIgc3RpbGxGaXRzLCBsaW5lID0gW3dvcmRzLnNoaWZ0KCldO1xuICAgIHdoaWxlIChcbiAgICAgICAgLy8gc28gbG9uZSBhcyBsaW5lIHN0aWxsIGZpdHMgd2l0aGluIGN1cnJlbnQgY29sdW1uLi4uXG4gICAgKHN0aWxsRml0cyA9IGdjLmdldFRleHRXaWR0aChsaW5lLmpvaW4oJyAnKSkgPCB3aWR0aClcbiAgICAvLyAuLi5BTkQgdGhlcmUgYXJlIG1vcmUgd29yZHMgYXZhaWxhYmxlLi4uXG4gICAgJiYgd29yZHMubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAvLyAuLi5hZGQgYW5vdGhlciB3b3JkIHRvIGVuZCBvZiBsaW5lIGFuZCByZXRlc3RcbiAgICAgICAgbGluZS5wdXNoKHdvcmRzLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICAgIXN0aWxsRml0cyAvLyBpZiBsaW5lIGlzIG5vdyB0b28gbG9uZy4uLlxuICAgICAgICAmJiBsaW5lLmxlbmd0aCA+IDEgLy8gLi4uQU5EIGlzIG11bHRpcGxlIHdvcmRzLi4uXG4gICAgKSB7XG4gICAgICAgIHdvcmRzLnVuc2hpZnQobGluZS5wb3AoKSk7IC8vIC4uLmJhY2sgb2ZmIGJ5IChpLmUuLCByZW1vdmUpIG9uZSB3b3JkXG4gICAgfVxuXG4gICAgbGluZSA9IFtsaW5lLmpvaW4oJyAnKV07XG5cbiAgICBpZiAod29yZHMubGVuZ3RoKSB7IC8vIGlmIHRoZXJlJ3MgYW55dGhpbmcgbGVmdC4uLlxuICAgICAgICBsaW5lID0gbGluZS5jb25jYXQoZmluZExpbmVzKGdjLCBjb25maWcsIHdvcmRzLCB3aWR0aCkpOyAvLyAuLi5icmVhayBpdCB1cCBhcyB3ZWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmU7XG59XG5cbmZ1bmN0aW9uIHN0cmlrZVRocm91Z2goY29uZmlnLCBnYywgdGV4dCwgeCwgeSwgdGhpY2tuZXNzKSB7XG4gICAgdmFyIHRleHRXaWR0aCA9IGdjLmdldFRleHRXaWR0aCh0ZXh0KTtcblxuICAgIHN3aXRjaCAoZ2MuY2FjaGUudGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICB4IC09IHRleHRXaWR0aCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeCAtPSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB5ID0gTWF0aC5yb3VuZCh5ICsgMC41KSAtIDAuNTtcblxuICAgIGdjLmNhY2hlLmxpbmVXaWR0aCA9IHRoaWNrbmVzcztcbiAgICBnYy5tb3ZlVG8oeCAtIDEsIHkpO1xuICAgIGdjLmxpbmVUbyh4ICsgdGV4dFdpZHRoICsgMSwgeSk7XG59XG5cbmZ1bmN0aW9uIHVuZGVybGluZShjb25maWcsIGdjLCB0ZXh0LCB4LCB5LCB0aGlja25lc3MpIHtcbiAgICB2YXIgdGV4dEhlaWdodCA9IGdjLmdldFRleHRIZWlnaHQoY29uZmlnLmZvbnQpLmhlaWdodCxcbiAgICAgICAgdGV4dFdpZHRoID0gZ2MuZ2V0VGV4dFdpZHRoKHRleHQpO1xuXG4gICAgc3dpdGNoIChnYy5jYWNoZS50ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHggLT0gdGV4dFdpZHRoIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB4IC09IHRleHRXaWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHkgPSBNYXRoLnJvdW5kKHkgKyB0ZXh0SGVpZ2h0IC8gMikgLSAwLjU7XG5cbiAgICAvL2djLmJlZ2luUGF0aCgpO1xuICAgIGdjLmNhY2hlLmxpbmVXaWR0aCA9IHRoaWNrbmVzcztcbiAgICBnYy5tb3ZlVG8oeCwgeSk7XG4gICAgZ2MubGluZVRvKHggKyB0ZXh0V2lkdGgsIHkpO1xufVxuXG5mdW5jdGlvbiBsYXllckNvbG9ycyhnYywgY29sb3JzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3VuZGF0aW9uQ29sb3IpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm91bmRhdGlvbkNvbG9yICYmICFpKSB7XG4gICAgICAgICAgICBnYy5jbGVhckZpbGwoeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3JzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGNvbG9yc1tpXTtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUNlbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTbGlkZXIgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTbGlkZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBFbWVyc29uJ3MgcGFpbnQgZnVuY3Rpb24gZm9yIGEgc2xpZGVyIGJ1dHRvbi4gY3VycmVudGx5IHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIGl0XG4gICAgICogQGltcGxlbWVudHMgcGFpbnRGdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBTbGlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIGdjLmNhY2hlLnN0cm9rZVN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGhlaWdodCAvIDI7XG4gICAgICAgIHZhciBvZmZzZXQgPSB3aWR0aCAqIHZhbDtcbiAgICAgICAgdmFyIGJnQ29sb3IgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiAnIzMzMzMzMyc7XG4gICAgICAgIHZhciBidG5HcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBidG5HcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYmdDb2xvcik7XG4gICAgICAgIGJ0bkdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzY2NjY2NicpO1xuICAgICAgICB2YXIgYXJjR3JhZGllbnQgPSBnYy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjYWFhYWFhJyk7XG4gICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzc3Nzc3NycpO1xuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBidG5HcmFkaWVudDtcbiAgICAgICAgdGhpcy5yb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYnRuR3JhZGllbnQpO1xuICAgICAgICBpZiAodmFsIDwgMS4wKSB7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9ICcjZWVlZWVlJztcbiAgICAgICAgfVxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MuYXJjKHggKyBNYXRoLm1heChvZmZzZXQgLSByYWRpdXMsIHJhZGl1cyksIHkgKyByYWRpdXMsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICBjb25maWcubWluV2lkdGggPSAxMDA7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgU3BhcmtCYXIgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTcGFya0JhcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgc3BhcmtsaW5lLCBiZWNhdXNlIGl0J3MgYSBiYXJjaGFydCB3ZSd2ZSBjaGFuZ2VkIHRoZSBuYW1lIDspLlxuICAgICAqIEBpbXBsZW1lbnRzIHBhaW50RnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgU3BhcmtCYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB2YWwgPSBjb25maWcudmFsdWU7XG4gICAgICAgIGlmICghdmFsIHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsLmxlbmd0aDtcbiAgICAgICAgdmFyIGVXaWR0aCA9IHdpZHRoIC8gY291bnQ7XG4gICAgICAgIHZhciBmZ0NvbG9yID0gY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yIDogY29uZmlnLmNvbG9yO1xuICAgICAgICBpZiAoY29uZmlnLmJhY2tncm91bmRDb2xvciB8fCBjb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmlzU2VsZWN0ZWQgPyAnYmx1ZScgOiBjb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJoZWlnaHQgPSB2YWxbaV0gLyAxMTAgKiBoZWlnaHQ7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCwgZVdpZHRoICogMC42NjY2LCBiYXJoZWlnaHQpO1xuICAgICAgICAgICAgeCArPSBlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IGNvdW50ICogMTA7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhcmtCYXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTcGFya0xpbmUgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTcGFya0xpbmUnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHNwYXJrbGluZS4gIHNlZSBbRWR3YXJkIFR1ZnRlIHNwYXJrbGluZV0oaHR0cDovL3d3dy5lZHdhcmR0dWZ0ZS5jb20vYmJvYXJkL3EtYW5kLWEtZmV0Y2gtbXNnP21zZ19pZD0wMDAxT1IpXG4gICAgICogQGltcGxlbWVudHMgcGFpbnRGdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBTcGFya0xpbmUucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB2YWwgPSBjb25maWcudmFsdWU7XG4gICAgICAgIGlmICghdmFsIHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsLmxlbmd0aDtcbiAgICAgICAgdmFyIGVXaWR0aCA9IHdpZHRoIC8gY291bnQ7XG5cbiAgICAgICAgdmFyIGZnQ29sb3IgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiBjb25maWcuY29sb3I7XG4gICAgICAgIGlmIChjb25maWcuYmFja2dyb3VuZENvbG9yIHx8IGNvbmZpZy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiBjb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2FjaGUuc3Ryb2tlU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyaGVpZ2h0ID0gdmFsW2ldIC8gMTEwICogaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGJhcmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdjLmxpbmVUbyh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCk7XG4gICAgICAgICAgICBnYy5hcmMoeCArIDUsIHkgKyBoZWlnaHQgLSBiYXJoZWlnaHQsIDEsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICB4ICs9IGVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcubWluV2lkdGggPSBjb3VudCAqIDEwO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhcmtMaW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgVHJlZUNlbGwgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdUcmVlQ2VsbCcsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgdHJlZSBjZWxsIHJlbmRlcmVyIGZvciB1c2UgbWFpbmx5IHdpdGggdGhlIHF0cmVlLlxuICAgICAqIEBpbXBsZW1lbnRzIHBhaW50RnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgVHJlZUNlbGwucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZS5kYXRhO1xuICAgICAgICB2YXIgaW5kZW50ID0gY29uZmlnLnZhbHVlLmluZGVudDtcbiAgICAgICAgdmFyIGljb24gPSBjb25maWcudmFsdWUuaWNvbjtcblxuICAgICAgICAvL2ZpbGwgYmFja2dyb3VuZCBvbmx5IGlmIG91ciBiZ0NvbG9yIGlzIHBvcHVsYXRlZCBvciB3ZSBhcmUgYSBzZWxlY3RlZCBjZWxsXG4gICAgICAgIGlmIChjb25maWcuYmFja2dyb3VuZENvbG9yIHx8IGNvbmZpZy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiBjb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZ25PZmZzZXQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuYmFja2dyb3VuZENvbG9yIDogY29uZmlnLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgZ2MuZmlsbFRleHQoaWNvbiArIHZhbCwgeCArIGluZGVudCwgeSArIHZhbGlnbk9mZnNldCk7XG5cbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IGdjLmdldFRleHRXaWR0aChpY29uICsgdmFsKTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0geCArIGluZGVudCArIHRleHRXaWR0aCArIDEwO1xuICAgICAgICBjb25maWcubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlQ2VsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3NkZXNjIEFQSSBvZiBjZWxsIHJlbmRlcmVyIG9iamVjdCBjb25zdHJ1Y3RvcnMsIHBsdXMgc29tZSBhY2Nlc3MgbWV0aG9kcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByaXZhdGVSZWdpc3RyeT1mYWxzZV0gLSBUaGlzIGluc3RhbmNlIHdpbGwgdXNlIGEgcHJpdmF0ZSByZWdpc3RyeS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDZWxsUmVuZGVyZXJzKHByaXZhdGVSZWdpc3RyeSkge1xuICAgIGlmIChwcml2YXRlUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5zaW5nbGV0b25zID0ge307XG4gICAgfVxuXG4gICAgLy8gcHJlcmVnaXN0ZXIgdGhlIHN0YW5kYXJkIGNlbGwgcmVuZGVyZXJzXG4gICAgaWYgKHByaXZhdGVSZWdpc3RyeSB8fCAhdGhpcy5nZXQoJ2VtcHR5Y2VsbCcpKSB7XG4gICAgICAgIHRoaXMuYWRkKCdFbXB0eUNlbGwnLCByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9CdXR0b24nKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU2ltcGxlQ2VsbCcpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TbGlkZXJDZWxsJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1NwYXJrQmFyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0xhc3RTZWxlY3Rpb24nKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU3BhcmtMaW5lJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0Vycm9yQ2VsbCcpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9UcmVlQ2VsbCcpKTtcbiAgICB9XG59XG5cbkNlbGxSZW5kZXJlcnMucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDZWxsUmVuZGVyZXJzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgLy8gcHJlc2VydmUgY29uc3RydWN0b3JcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIGFuZCBpbnN0YW50aWF0ZSBhIGNlbGwgcmVuZGVyZXIgc2luZ2xldG9uLlxuICAgICAqIEBkZXNjIEFkZHMgYSBjdXN0b20gY2VsbCByZW5kZXJlciB0byB0aGUgYHNpbmdsZXRvbnNgIGhhc2ggdXNpbmcgdGhlIHByb3ZpZGVkIG5hbWUgKG9yIHRoZSBjbGFzcyBuYW1lKSwgY29udmVydGVkIHRvIGFsbCBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogPiBBbGwgbmF0aXZlIGNlbGwgcmVuZGVyZXJzIGFyZSBcInByZXJlZ2lzdGVyZWRcIiBpbiBgc2luZ2xldG9uc2AuIEFkZCBtb3JlIGJ5IGNhbGxpbmcgYGFkZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gQ2FzZS1pbnNlbnNpdGl2ZSByZW5kZXJlciBrZXkuIElmIG5vdCBnaXZlbiwgYFlvdXJDZWxsUmVuZGVyZXIucHJvdG90eXBlLiQkQ0xBU1NfTkFNRWAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2VsbFJlbmRlcmVyfSBDb25zdHJ1Y3RvciAtIEEgY29uc3RydWN0b3IsIHR5cGljYWxseSBleHRlbmRlZCBmcm9tIGBDZWxsUmVuZGVyZXJgIChvciBhIGRlc2NlbmRhbnQgdGhlcmVmcm9tKS5cbiAgICAgKlxuICAgICAqID4gTm90ZTogYCQkQ0xBU1NfTkFNRWAgY2FuIGJlIGVhc2lseSBzZXQgdXAgYnkgcHJvdmlkaW5nIGEgc3RyaW5nIGFzIHRoZSAob3B0aW9uYWwpIGZpcnN0IHBhcmFtZXRlciAoYGFsaWFzYCkgaW4geW91ciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZXh0ZW5kLW1lfENlbGxFZGl0b3IuZXh0ZW5kfSBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NlbGxSZW5kZXJlcnN9IEEgbmV3bHkgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIHtAbGluayBDZWxsUmVuZGVyZXJzfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsUmVuZGVyZXJzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24obmFtZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgQ29uc3RydWN0b3IucHJvdG90eXBlLiQkQ0xBU1NfTkFNRTtcbiAgICAgICAgbmFtZSA9IG5hbWUgJiYgbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gKHRoaXMuc2luZ2xldG9uc1tuYW1lXSA9IG5ldyBDb25zdHJ1Y3Rvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIGEgc3lub255bSBmb3IgYW4gZXhpc3RpbmcgY2VsbCByZW5kZXJlciBzaW5nbGV0b24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bm9ueW1OYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4aXN0aW5nTmFtZVxuICAgICAqIEByZXR1cm5zIHtDZWxsUmVuZGVyZXJzfSBUaGUgcHJldmlvdXNseSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yIHRoaXMgbmV3IHN5bm9ueW0gcG9pbnRzIHRvLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsUmVuZGVyZXJzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFkZFN5bm9ueW06IGZ1bmN0aW9uKHN5bm9ueW1OYW1lLCBleGlzdGluZ05hbWUpIHtcbiAgICAgICAgdmFyIGNlbGxSZW5kZXJlciA9IHRoaXMuZ2V0KGV4aXN0aW5nTmFtZSk7XG4gICAgICAgIHJldHVybiAodGhpcy5zaW5nbGV0b25zW3N5bm9ueW1OYW1lXSA9IGNlbGxSZW5kZXJlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgcmVnaXN0ZXJlZCBjZWxsIHJlbmRlcmVyIHNpbmdsZXRvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtDZWxsUmVuZGVyZXJzfSBBIHJlZ2lzdGVyZWQgY29uc3RydWN0b3IgZXh0ZW5kZWQgZnJvbSB7QGxpbmsgQ2VsbFJlbmRlcmVyc30uXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNpbmdsZXRvbnNbbmFtZV07IC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBkbyBub3QgY29udmVydCB0byBsb3dlciBjYXNlXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNpbmdsZXRvbnNbbmFtZS50b0xvd2VyQ2FzZSgpXTsgLy8gbmFtZSBtYXkgZGlmZmVyIGluIGNhc2Ugb25seVxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2luZ2xldG9uc1tuYW1lXSA9IHJlc3VsdDsgLy8gcmVnaXN0ZXIgZm91bmQgbmFtZSBhcyBhIHN5bm9ueW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VsbCBlZGl0b3IgcmVnaXN0cnkgY29udGFpbmluZyBhbGwgdGhlIFwicHJlcmVnaXN0ZXJlZFwiIGNlbGwgcmVuZGVyZXIgc2luZ2xldG9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsUmVuZGVyZXJzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNpbmdsZXRvbnM6IHt9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbFJlbmRlcmVycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi9CYXNlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhTW9kZWwgPSBCYXNlLmV4dGVuZCgnRGF0YU1vZGVsJywge1xuICAgIGdyaWQ6IG51bGwsXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgIH0sXG5cbiAgICBjaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdjaGFuZ2VkKCknLCAnZ3JpZC5iZWhhdmlvci5jaGFuZ2VkKCknLCAnMS4xLjAnKTtcbiAgICB9LFxuXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0UHJpdmF0ZVN0YXRlKCknLCAnZ3JpZC5wcm9wZXJ0aWVzJywgJzEuMi4wJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVjbGFyZWRSZW5kZXJlck5hbWUgLSBUaGUgcHJvcG9zZWQgY2VsbCByZW5kZXJlciBuYW1lIChmb3JtIHRoZSByZW5kZXIgcHJvcGVydGllcykuXG4gICAgICogQHJldHVybnMge0NlbGxSZW5kZXJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRGF0YU1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENlbGw6IGZ1bmN0aW9uKGNvbmZpZywgZGVjbGFyZWRSZW5kZXJlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5jZWxsUmVuZGVyZXJzLmdldChkZWNsYXJlZFJlbmRlcmVyTmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluc3RhbnRpYXRlIGEgbmV3IGNlbGwgZWRpdG9yLlxuICAgICAqIEBkZXNjIFRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvOlxuICAgICAqICogSW5zdGFudGlhdGUgYW5kIHJldHVybiBhbiBhcmJpdHJhcnkgY2VsbCBlZGl0b3IuIFRoZSBnZW5lcmljIGltcGxlbWVudGF0aW9uIGhlcmUgc2ltcGx5IHJldHVybnMgdGhlIGRlY2xhcmVkIGNlbGwgZWRpdG9yLiBUaGlzIGlzIGB1bmRlZmluZWRgIHdoZW4gdGhlcmUgd2FzIG5vIHN1Y2ggZGVjbGFyYXRpb24sIG9yIGlmIHRoZSBuYW1lZCBjZWxsIGVkaXRvciB3YXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICogKiBSZXR1cm4gYHVuZGVmaW5lZGAgZm9yIG5vIGNlbGwgZWRpdG9yIGF0IGFsbC4gVGhlIGNlbGwgd2lsbCBub3QgYmUgZWRpdGFibGUuXG4gICAgICogKiBTZXQgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UgYnkgcGFzc2luZyB0aGVtIGluIHRoZSBgb3B0aW9uc2Agb2JqZWN0LiBUaGVzZSBhcmUgYXBwbGllZCB0byB0aGUgbmV3IGNlbGwgZWRpdG9yIG9iamVjdCBhZnRlciBpbnN0YW50aWF0aW9uIGJ1dCBiZWZvcmUgcmVuZGVyaW5nLlxuICAgICAqICogTWFuaXB1bGF0ZSB0aGUgY2VsbCBlZGl0b3Igb2JqZWN0IChpbmNsdWRpbmcgaXRzIERPTSBlbGVtZW50cykgYWZ0ZXIgcmVuZGVyaW5nIGJ1dCBiZWZvcmUgRE9NIGluc2VydGlvbi5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRpbmcgdGhpcyBtZXRob2Qgd2l0aCBhIG51bGwgZnVuY3Rpb24gKHRoYXQgYWx3YXlzIHJldHVybnMgYHVuZGVmaW5lZGApIHdpbGwgaGF2ZSB0aGUgZWZmZWN0IG9mIG1ha2luZyBhbGwgY2VsbHMgdW5lZGl0YWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIEFic29sdXRlIGNvbHVtbiBpbmRleC4gSS5lLiwgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb2x1bW4gaW4gdGhlIGRhdGEgc291cmNlJ3Mgb3JpZ2luYWwgYGZpZWxkc2AgYXJyYXksIGFzIGVjaG9lZCBpbiBgYmVoYXZpb3IuYWxsQ29sdW1uc1tdYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFJvdyBpbmRleCBvZiB0aGUgZGF0YSByb3cgaW4gdGhlIGN1cnJlbnRseSBmaWx0ZXJlZCBhbmQgc29ydGVkIGxpc3Qgb2Ygcm93cywgcmVnYXJkbGVzcyBvZiB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24sIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIGhlYWRlciByb3dzIChhbGwgdGhlIHJvd3MgYWJvdmUgdGhlIGZpcnN0IGRhdGEgcm93IGluY2x1ZGluZyB0aGUgZmlsdGVyIHJvdykuIEkuZS4sIGFmdGVyIHN1YnRyYWN0aW5nIG91dCB0aGUgbnVtYmVyIG9mIGhlYWRlciByb3dzLCB0aGlzIGlzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGF0YSByb3cgaW4gdGhlIGBpbmRleGAgYXJyYXkgb2YgdGhlIGRhdGEgc291cmNlIChpLmUuLCB0aGUgbGFzdCBkYXRhIHNvdXJjZSBwaXBlbGluZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVjbGFyZWRFZGl0b3JOYW1lIC0gVGhlIHByb3Bvc2VkIGNlbGwgZWRpdG9yIG5hbWUgKGZyb20gdGhlIHJlbmRlciBwcm9wZXJ0aWVzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBjZWxsRXZlbnQgLSBBbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoaXMgb2JqZWN0IHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgY2VsbCBlZGl0b3Igb2JqZWN0IGZvciB0d28gcHVycG9zZXM6XG4gICAgICogKiBVc2VkIGluIGNlbGwgZWRpdG9yIGxvZ2ljLlxuICAgICAqICogRm9yIGFjY2VzcyBmcm9tIHRoZSBjZWxsIGVkaXRvcidzIEhUTUwgdGVtcGxhdGUgKHZpYSBtdXN0YWNoZSkuXG4gICAgICpcbiAgICAgKiB7QGxpbmsgQ2VsbEVkaXRvcn0gcmVxdWlyZXMgYm90aCBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAqICogKipgZm9ybWF0YCoqIC0gVGhlIGNlbGwncyBgZm9ybWF0YCByZW5kZXIgcHJvcCAobmFtZSBvZiBsb2NhbGl6ZXIgdG8gdXNlIHRvIGZvcm1hdCB0aGUgZWRpdG9yIHByZWxvYWQgYW5kIHBhcnNlIHRoZSBlZGl0ZWQgdmFsdWUpLiBNYXkgYmUgYHVuZGVmaW5lZGAgKG5vIGZvcm1hdHRpbmcgb3IgcGFyc2luZykuIEFkZGVkIGJ5IGNhbGxpbmcge0BsaW5rIENvbHVtbiNnZXRDZWxsRWRpdG9yQXR8Z2V0Q2VsbEVkaXRvckF0fSBtZXRob2QuIERldmVsb3BlcidzIG92ZXJyaWRlIGlzIGZyZWUgdG8gYWx0ZXIgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKiAqIF9DZWxsRXZlbnQgcHJvcHNfIC0gYGNvbHVtbmAgKHtAbGluayBDb2x1bW59IG9iamVjdCkgaXMgdGhlIG9ubHkgZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiB0aGUgbmF0aXZlIGBDZWxsRXZlbnRgIG9iamVjdC4gUmVhZC1vbmx5LlxuICAgICAqICogX0N1c3RvbSBwcm9wc18gLSBEZXZlbG9wZXIncyBvdmVycmlkZSBvZiB0aGlzIG1ldGhvZCBtYXkgYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcywgZm9yIGJvdGggcHVycG9zZXMgbGlzdGVkIGFib3ZlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBgZWRpdFBvaW50YCBwcm9wZXJ0eSBwcmV2aW91c2x5IGF2YWlsYWJsZSB0byBjZWxsIGVkaXRvcnMgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBvcHRpb25zLmdyaWRDZWxsLiBgZWRpdFBvaW50YCB3aWxsIHN0aWxsIHdvcmsgZm9yIHRoZSB0aW1lIGJlaW5nIGJ1dCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBpbiB0aGUgY29uc29sZSB0byB1c2UgYGNlbGxFdmVudC5ncmlkQ2VsbGAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gQW4gb2JqZWN0IGluc3RhbnRpYXRlZCBmcm9tIHRoZSByZWdpc3RlcmVkIGNlbGwgZWRpdG9yIGNvbnN0cnVjdG9yIG5hbWVkIGluIGBkZWNsYXJlZEVkaXRvck5hbWVgLiBBIGZhbHN5IHJldHVybiBtZWFucyB0aGUgY2VsbCBpcyBub3QgZWRpdGFibGUgYmVjYXVzZSB0aGUgYGRlY2xhcmVkRWRpdG9yTmFtZWAgd2FzIG5vdCByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFNb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCByb3dJbmRleCwgZGVjbGFyZWRFZGl0b3JOYW1lLCBjZWxsRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5jZWxsRWRpdG9ycy5jcmVhdGUoZGVjbGFyZWRFZGl0b3JOYW1lLCBjZWxsRXZlbnQpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU1vZGVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIGRhdGFNb2RlbEFQSVxuICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhlYWRlclN1YmdyaWQoZ3JpZCwgb3B0aW9ucykge1xuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgdGhpcy5iZWhhdmlvciA9IGdyaWQuYmVoYXZpb3I7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZGF0YVJvd09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGFSb3cgPSB7fTsgLy8gZm9yIG1ldGEgZGF0YSAoX19IRUlHSFQpXG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIH1cbn1cblxuSGVhZGVyU3ViZ3JpZC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEhlYWRlclN1YmdyaWQucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgdHlwZTogJ2hlYWRlcicsXG5cbiAgICBmb3JtYXQ6ICdoZWFkZXInLCAvLyBvdmVycmlkZSBjb2x1bW4gZm9ybWF0XG5cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucHJvcGVydGllcy5zaG93SGVhZGVyUm93ID8gMSA6IDA7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldENvbHVtbih4KTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5oZWFkZXIgfHwgY29sdW1uLm5hbWU7IC8vIHVzZSBmaWVsZCBuYW1lIHdoZW4gaGVhZGVyIHVuZGVmaW5lZFxuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHkgPCB0aGlzLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uKHgpLmhlYWRlciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUm93O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhZGVyU3ViZ3JpZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFNb2RlbCA9IHJlcXVpcmUoJy4vRGF0YU1vZGVsJyk7XG52YXIgRGF0YVNvdXJjZU9yaWdpbiA9IHJlcXVpcmUoJy4uL2xpYi9EYXRhU291cmNlT3JpZ2luJyk7XG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBkYXRhU291cmNlUGlwZWxpbmVPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIC0gQSBcIkRhdGFTb3VyY2VPcmlnaW5cIiBzdHlsZSBjb25zdHJ1Y3RvciBuYW1lLlxuICogQHByb3BlcnR5IHsqfSBbb3B0aW9uc10gLSBXaGVuIGRlZmluZWQsIHBhc3NlZCBhcyAybmQgYXJndW1lbnQgdG8gY29uc3RydWN0b3IuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BhcmVudF0gLSBEZWZpbmVzIGEgYnJhbmNoIG9mZiB0aGUgbWFpbiBzZXF1ZW5jZS5cbiAqL1xuXG4vKipcbiAqIEBuYW1lIGRhdGFNb2RlbHMuSlNPTlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTW9kZWxcbiAqL1xudmFyIEpTT04gPSBEYXRhTW9kZWwuZXh0ZW5kKCdkYXRhTW9kZWxzLkpTT04nLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBIYXNoIG9mIGNvbnRyb2xsZXJzLlxuICAgICAgICAgKiBAZGVzYyBLZXllZCBieSBkYXRhIHNvdXJjZSB0eXBlLlxuICAgICAgICAgKiBEYXRhIGNvbnRyb2xsZXIgYXJlIG9ubHkgYWNjZXB0ZWQgYnkgZGF0YSBzb3VyY2VzIHRoYXQgaGF2ZSBhIGRlZmluZWQgYHR5cGVgIHByb3BlcnR5LlxuICAgICAgICAgKiBAc2VlIHtAbGluayBkYXRhQ29udHJvbEludGVyZmFjZX1cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSB7fTtcblxuICAgICAgICB0aGlzLmNoYXJNYXAgPSBuZXcgQ2hhck1hcCh0aGlzKTtcblxuICAgICAgICB0aGlzLnJlc2V0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0byB1c2UgYSBkaWZmZXJlbnQgb3JpZ2luLlxuICAgICAqIEB0eXBlKERhdGFTb3VyY2VCYXNlfVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgRGF0YVNvdXJjZU9yaWdpbjogRGF0YVNvdXJjZU9yaWdpbixcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtkYXRhU291cmNlUGlwZWxpbmVPYmplY3RbXVtdfVxuICAgICAqIEBzdW1tYXJ5IFBpcGVsaW5lIHN0YXNoIHB1c2gtZG93biBsaXN0LlxuICAgICAqIEBkZXNjIFRoZSBwaXBlbGluZSBzdGFzaCBtYXkgYmUgc2hhcmVkIG9yIGluc3RhbmNlZC4gVGhpcyBpcyB0aGUgc2hhcmVkIHN0YXNoLiBBbiBpbnN0YW5jZSBtYXkgb3ZlcnJpZGUgdGhpcyB3aXRoIGFuIGluc3RhbmNlIHN0YXNoIHZhcmlhYmxlIChvZiB0aGUgc2FtZSBuYW1lKS4gU2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04jZ2V0UGlwZWxpbmVTY2hlbWFTdGFzaH0uXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwaXBlbGluZVNjaGVtYVN0YXNoOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMucGlwZWxpbmVdIC0gQ29uc3VtZWQgYnkge0BsaW5rIGRhdGFNb2RlbHMuSlNPTiNzZXRQaXBlbGluZX0uXG4gICAgICogSWYgb21pdHRlZCwgcHJldmlvdXNseSBlc3RhYmxpc2hlZCBwaXBlbGluZSBpcyByZXVzZWQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmNvbnRyb2xsZXJzXSAtIENvbnN1bWVkIGJ5IHtAbGluayBkYXRhTW9kZWxzLkpTT04jc2V0UGlwZWxpbmV9LlxuICAgICAqIElmIG9taXR0ZWQsIHByZXZpb3VzbHkgZXN0YWJsaXNoZWQgY29udHJvbGxlcnMuXG4gICAgICogKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhID0gW107XG5cbiAgICAgICAgZGVsZXRlIHRoaXMucGlwZWxpbmVTY2hlbWFTdGFzaDsgLy8gcmVtb3ZlIGV4aXN0aW5nIFwib3duXCIgdmVyc2lvbiBpZiBhbnlcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBuZXcgdGhpcy5EYXRhU291cmNlT3JpZ2luKFxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLFxuICAgICAgICAgICAgb3B0aW9ucy5zY2hlbWFcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNldFBpcGVsaW5lKHtcbiAgICAgICAgICAgIHBpcGVsaW5lOiBvcHRpb25zLnBpcGVsaW5lLFxuICAgICAgICAgICAgY29udHJvbGxlcnM6IG9wdGlvbnMuY29udHJvbGxlcnNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpY2F0aW9uIGRldmVsb3BlciBzaG91bGQgb3ZlcnJpZGUgdG8gc2V0IHVwIGEgZGVmYXVsdCBwaXBlbGluZS5cbiAgICAgKiBAdHlwZSB7cGlwZWxpbmVTY2hlbWF9XG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkZWZhdWx0UGlwZWxpbmVTY2hlbWE6IFtdLFxuXG4gICAgY2xlYXJTZWxlY3RlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YS5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBvZiB2MS4wLjcsIHJlZmVyZW5jZSB0aGUgYGRhdGFTb3VyY2VgIHByb3BlcnR5IGluc3RlYWQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXREYXRhU291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0RGF0YVNvdXJjZSgpJywgJ2RhdGFTb3VyY2UnLCAnMS4wLjcnKTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5kYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBvZiB2MS4xLjAsIHVzZSBgZ2V0SW5kZXhlZERhdGEoKWAgaW5zdGVhZC5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEZpbHRlcmVkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldEZpbHRlcmVkRGF0YSgpJywgJ2dldEluZGV4ZWREYXRhKCknLCAnMS4yLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBnZXRJbmRleGVkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkcyA9IHRoaXMuZGF0YVNvdXJjZTtcbiAgICAgICAgdmFyIGNvdW50ID0gZHMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY291bnQ7IHkrKykge1xuICAgICAgICAgICAgcmVzdWx0W3ldID0gZHMuZ2V0Um93KHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gRGF0YSBjb2x1bW4gY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5oYXNIaWVyYXJjaHlDb2x1bW4oKSkge1xuICAgICAgICAgICAgaWYgKHggPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RyaWxsRG93bigpKSB7XG4gICAgICAgICAgICB4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtudW5iZXJ9IFJvdyBpbmRleCBpbiByYXcgZGF0YSBhcnJheSBhZnRlciBkZXJlZmVyZW5jaW5nIGFsbCBkYXRhIHNvdXJjZSBpbmRleGluZy5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldERhdGFJbmRleCh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIERhdGEgY29sdW1uIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHIgLSBHcmlkIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCByLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNIaWVyYXJjaHlDb2x1bW4oKSkge1xuICAgICAgICAgICAgaWYgKHggPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RyaWxsRG93bigpKSB7XG4gICAgICAgICAgICB4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldFZhbHVlKHgsIHIsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgQXMgb2YgdjEuMS4wLCB1c2UgYHRoaXMuZ3JpZC5iZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKHgpYCBpbnN0ZWFkLlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBEYXRhIGNvbHVtbiBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgLy9hY2Nlc3MgZGlyZWN0bHkgYmVjYXVzZSB3ZSB3YW50IGl0IG9yZGVyZWRcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q29sdW1uUHJvcGVydGllcyh4KScsICdncmlkLmJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoeCknLCAnMS4yLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2hvd1RyZWUgPSB0aGlzLmdyaWQucHJvcGVydGllcy5zaG93VHJlZUNvbHVtbiA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIG9mZnNldCA9ICh0aGlzLmlzRHJpbGxEb3duKCkgJiYgIXNob3dUcmVlKSA/IC0xIDogMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRDb2x1bW5Db3VudCgpICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U2NoZW1hUHJvcEFyci5jYWxsKHRoaXMsICdoZWFkZXInLCAnZ2V0SGVhZGVycycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlcnNcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkc1xuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRGaWVsZHMoZmllbGRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFNjaGVtYVByb3BBcnIuY2FsbCh0aGlzLCAnbmFtZScsICdnZXRGaWVsZHMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0Q2FsY3VsYXRvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0U2NoZW1hUHJvcEFyci5jYWxsKHRoaXMsICdjYWxjdWxhdG9yJywgJ2dldENhbGN1bGF0b3JzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVpbmRleDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBzZWxlY3RlZERhdGFSb3dzQmFja2luZ1NlbGVjdGVkR3JpZFJvd3MuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLnBpcGVsaW5lLmZvckVhY2goZnVuY3Rpb24oZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZS5hcHBseSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlLmFwcGx5KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93cy5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgb3IgcmVzZXQgZ3JpZCBkYXRhLlxuICAgICAqIFNlZSB7QGxpbmsgRGF0YVNvdXJjZU9yaWdpbiNzZXREYXRhfSBmb3IgZGV0YWlscy5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGFTb3VyY2UsIHNjaGVtYSkge1xuICAgICAgICB0aGlzLnNvdXJjZS5zZXREYXRhKGRhdGFTb3VyY2UsIHNjaGVtYSk7XG4gICAgfSxcblxuICAgIC8qKiBAdHlwZWRlZiB7RGF0YVNvdXJjZUJhc2VbXX0gcGlwZWxpbmVTY2hlbWFcbiAgICAgKiBAc3VtbWFyeSBEZXNjcmliZXMgYSBuZXcgcGlwZWxpbmUuXG4gICAgICogQGRlc2MgQ29uc2lzdHMgb2YgYW4gb3JkZXJlZCBsaXN0IG9mIGRhdGEgc291cmNlIGNvbnN0cnVjdG9ycywgZGVzY2VuZGFudHMgb2YgYERhdGFTb3VyY2VCYXNlYC5cbiAgICAgKiBNYXkgY29udGFpbiBgdW5kZWZpbmVkYCBlbGVtZW50cywgd2hpY2ggYXJlIGlnbm9yZWQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbnN0YW50aWF0ZXMgdGhlIGRhdGEgc291cmNlIHBpcGVsaW5lLlxuICAgICAqIEBkZXNjIEVhY2ggbmV3IHBpcGUgaXMgY3JlYXRlZCBmcm9tIHRoZSBsaXN0IG9mIHN1cHBsaWVkIGNvbnN0cnVjdG9ycywgZWFjaCB0YWtpbmcgYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIGRhdGEgc291cmNlIGluIHRoZSBwaXBlbGluZS5cbiAgICAgKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIGVhY2ggbmV3IHBpcGUgaXMgYWRkZWQgdG8gYHRoaXMuc291cmNlc2AgZGF0YU1vZGVsIHVzaW5nIHRoZSBwaXBlJ3MgZGVyaXZlZCBuYW1lLlxuICAgICAqXG4gICAgICogV2lsbCBjbGVhciBvdXQgYW55IGZpbHRlcmluZyBhbmQgc29ydGluZyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFRoZSBsYXN0IHBpcGUgaXMgYXNzaWduZWQgdGhlIHN5bm9ueW0gYHRoaXMuZGF0YVNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtwaXBlbGluZVNjaGVtYX0gW0RhdGFTb3VyY2VzXSAtIE5ldyBwaXBlbGluZSBkZXNjcmlwdGlvbi4gSWYgbm90IGdpdmVuLCB1c2VzIHRoZSBkZWZhdWx0IHtAbGluayBkYXRhTW9kZWxzLkpTT04jRGF0YVNvdXJjZXN8dGhpcy5kZWZhdWx0UGlwZWxpbmVTY2hlbWF9LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUYWtlcyBmaXJzdCBhcmd1bWVudCBwb3NpdGlvbiB3aGVuIGBEYXRhU291cmNlc2Agb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3Rhc2hdIC0gU2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04jZ2V0UGlwZWxpbmVTY2hlbWFTdGFzaH0uIElmIGdpdmVuLCBzYXZlcyB0aGUgY3VycmVudGx5IGRlZmluZWQgcGlwZWxpbmUgb250byB0aGUgaW5kaWNhdGVkIHN0YXNoIHN0YWNrIGFuZCB0aGVuIHJlc2V0cyBpdCB3aXRoIHRoZSBnaXZlbiBgRGF0YVNvdXJjZXNgLlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0UGlwZWxpbmU6IGZ1bmN0aW9uKERhdGFTb3VyY2VzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShEYXRhU291cmNlcykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBEYXRhU291cmNlcztcbiAgICAgICAgICAgIERhdGFTb3VyY2VzID0gb3B0aW9ucy5waXBlbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChEYXRhU291cmNlcykge1xuICAgICAgICAgICAgRGF0YVNvdXJjZXMgPSBEYXRhU291cmNlcy5zbGljZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuRGF0YVNvdXJjZXMpIHtcbiAgICAgICAgICAgIERhdGFTb3VyY2VzID0gdGhpcy5EYXRhU291cmNlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIERhdGFTb3VyY2VzID0gdGhpcy5kZWZhdWx0UGlwZWxpbmVTY2hlbWEuc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuRGF0YVNvdXJjZXMgPSBEYXRhU291cmNlcztcblxuICAgICAgICB2YXIgcGlwZWxpbmUgPSBbXSxcbiAgICAgICAgICAgIGRhdGFTb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKERhdGFTb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3Rhc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFBpcGVsaW5lU2NoZW1hU3Rhc2gob3B0aW9ucy5zdGFzaCkucHVzaChEYXRhU291cmNlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIERhdGFTb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oRGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChEYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSBuZXcgRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgcGlwZWxpbmUucHVzaChkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBDdXJyZW50bHkgZGVmaW5lZCBwaXBlbGluZS5cbiAgICAgICAgICogQGRlc2MgRWFjaCBpbnN0YW5jZSBoYXMgaXRzIG93biBwaXBlbGluZS5cbiAgICAgICAgICogKFBpcGVsaW5lcyBjYW5ub3QgYmUgc2hhcmVkIGJlY2F1c2UgdGhleSBjb250YWluIGluZGV4ZXMgc3BlY2lmaWMgdG8gdGhlIGRhdGEgaW4gdGhlIGdyaWQuKVxuICAgICAgICAgKiBAbmFtZSBwaXBlbGluZVxuICAgICAgICAgKiBAdHlwZSB7ZGF0YVNvdXJjZVBpcGVsaW5lT2JqZWN0W119XG4gICAgICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBpcGVsaW5lID0gcGlwZWxpbmU7XG5cbiAgICAgICAgdGhpcy5zZXRDb250cm9sbGVyKG9wdGlvbnMuY29udHJvbGxlcnMgfHwgdGhpcy5jb250cm9sbGVycyk7IC8vIHNldCB0aGUgbmV3IG9yIHByZXZpb3VzbHkgc2V0IGRhdGEgY29udHJvbGxlcihzKSBvbiB0aGUgbmV3IHBpcGVsaW5lXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3QgZGF0YSBzb3VyY2UgaW4gdGhlIHBpcGVsaW5lIG9mIHNwZWNpZmllZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybnMge0RhdGFTb3VyY2VCYXNlfVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZmluZERhdGFTb3VyY2VCeVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIGRhdGFTb3VyY2U7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBpcGVsaW5lLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBkYXRhU291cmNlID0gdGhpcy5waXBlbGluZVtpXTtcbiAgICAgICAgICAgIGlmIChkYXRhU291cmNlLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgcGlwZWxpbmUgc3Rhc2ggY3VycmVudGx5IGluIHVzZSAoZWl0aGVyIHNoYXJlZCBvciBpbnN0YW5jZSkuXG4gICAgICogQGRlc2MgSW5zdGFuY2Ugc3Rhc2ggaXMgY3JlYXRlZCBoZXJlIHdoZW4gcmVxdWVzdGVkIGFuZCBpbnN0YW5jZSBkb2Vzbid0IHlldCBoYXZlIGl0cyBcIm93blwiIHZlcnNpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt3aGljaFN0YXNoPSdkZWZhdWx0J10gLSBPbmUgb2Y6XG4gICAgICogKiBgJ3NoYXJlZCdgIC0gVXNlIHNoYXJlZCBzdGFzaC5cbiAgICAgKiAqIGAnb3duJycgb3IgYCdpbnN0YW5jZSdgIC0gVXNlIGluc3RhbmNlIHN0YXNoLCBjcmVhdGluZyBpdCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiAqIGAnZGVmYXVsdCdgIC0gVXNlIGluc3RhbmNlIHN0YXNoIGlmIHByZXZpb3VzbHkgY3JlYXRlZDsgb3RoZXJ3aXNlIHVzZSBzaGFyZWQgc3Rhc2guXG4gICAgICogQHJldHVybnMgVGhlIHBpcGVsaW5lIHN0YXNoIHB1c2gtZG93biBsaXN0LlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0UGlwZWxpbmVTY2hlbWFTdGFzaDogZnVuY3Rpb24od2hpY2hTdGFzaCkge1xuICAgICAgICB2YXIgc3Rhc2g7XG4gICAgICAgIHN3aXRjaCAod2hpY2hTdGFzaCkge1xuXG4gICAgICAgICAgICBjYXNlICdzaGFyZWQnOlxuICAgICAgICAgICAgICAgIHN0YXNoID0gRGF0YU1vZGVsLnByb3RvdHlwZS5zdGFzaDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnb3duJzpcbiAgICAgICAgICAgIGNhc2UgJ2luc3RhbmNlJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ3BpcGVsaW5lU2NoZW1hU3Rhc2gnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpcGVsaW5lU2NoZW1hU3Rhc2ggPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGVzbGludCBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICBzdGFzaCA9IHRoaXMucGlwZWxpbmVTY2hlbWFTdGFzaDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFzaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUG9wcyB0aGUgbGFzdCBzdGFzaGVkIHBpcGVsaW5lIG9mZiB0aGUgc3Rhc2ggc3RhY2ssIG1ha2luZyBpdCB0aGUgY3VycmVudGx5IGRlZmluZWQgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt3aGljaFN0YXNoXSAtIFNlZSB7QGxpbmsgZGF0YU1vZGVscy5KU09OI2dldFBpcGVsaW5lU2NoZW1hU3Rhc2h9LlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgdW5zdGFzaFBpcGVsaW5lOiBmdW5jdGlvbih3aGljaFN0YXNoKSB7XG4gICAgICAgIHZhciBwaXBlbGluZVNjaGVtYVN0YXNoID0gdGhpcy5nZXRQaXBlbGluZVNjaGVtYVN0YXNoKHdoaWNoU3Rhc2gpO1xuICAgICAgICBpZiAocGlwZWxpbmVTY2hlbWFTdGFzaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGlwZWxpbmUocGlwZWxpbmVTY2hlbWFTdGFzaC5wb3AoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25ld0xlbmd0aD0wXVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgdHJ1bmNhdGVQaXBlbGluZTogZnVuY3Rpb24obmV3TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ3RydW5jYXRlUGlwZWxpbmUobmV3TGVuZ3RoKScsICdzZXRQaXBlbGluZSgpJywgJzEuMi4wJywgYXJndW1lbnRzLCAnQnVpbGQgYSBsb2NhbCBwaXBlbGluZSAoYXJyYXkgb2YgZGF0YSBzb3VyY2UgY29uc3RydWN0b3JzKSBhbmQgcGFzcyBpdCB0byBzZXRQaXBlbGluZS4nKTtcbiAgICB9LFxuXG4gICAgaXNEcmlsbERvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBjb2xJbmRleCA9IGV2ZW50ICYmIGV2ZW50LmdyaWRDZWxsICYmIGV2ZW50LmdyaWRDZWxsLng7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuaXNEcmlsbERvd24oY29sSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBwZiB2MS4xLjAsIHVzZSBgdGhpcy5ncmlkLmJlaGF2aW9yLnNldFRvcFRvdGFscygpYCBpbnN0ZWFkLlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgdG9wIHRvdGFsIHJvdyhzKS5cbiAgICAgKiBAcGFyYW0ge2RhdGFSb3dPYmplY3RbXX0gdG90YWxSb3dzIC0gQXJyYXkgb2YgMCBvciBtb3JlIHJvd3MgY29udGFpbmluZyBzdW1tYXJ5IGRhdGEuIE9taXQgdG8gc2V0IHRvIGVtcHR5IGFycmF5LlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0VG9wVG90YWxzOiBmdW5jdGlvbih0b3RhbFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnc2V0VG9wVG90YWxzKHJvd3MpJywgJ2dyaWQuYmVoYXZpb3Iuc2V0VG9wVG90YWxzKHJvd3MpJywgJzEuMS4wJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgQXMgcGYgdjEuMS4wLCB1c2UgYHRoaXMuZ3JpZC5iZWhhdmlvci5nZXRUb3BUb3RhbHMoKWAgaW5zdGVhZC5cbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHRvcCB0b3RhbCByb3cocykuXG4gICAgICogQHJldHVybnMge2RhdGFSb3dPYmplY3RbXX1cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFRvcFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFRvcFRvdGFscyhyb3dzKScsICdncmlkLmJlaGF2aW9yLmdldFRvcFRvdGFscyhyb3dzKScsICcxLjEuMCcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBib3R0b20gdG90YWwgcm93KHMpLlxuICAgICAqIEBwYXJhbSB7ZGF0YVJvd09iamVjdFtdfSB0b3RhbFJvd3MgLSBBcnJheSBvZiAwIG9yIG1vcmUgcm93cyBjb250YWluaW5nIHN1bW1hcnkgZGF0YS4gT21pdCB0byBzZXQgdG8gZW1wdHkgYXJyYXkuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKHRvdGFsUm93cykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdzZXRCb3R0b21Ub3RhbHMocm93cyknLCAnZ3JpZC5iZWhhdmlvci5zZXRCb3R0b21Ub3RhbHMocm93cyknLCAnMS4xLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJvdHRvbSB0b3RhbCByb3cocykuXG4gICAgICogQGRlcHJlY2F0ZWQgQXMgcGYgdjEuMS4wLCB1c2UgYHRoaXMuZ3JpZC5iZWhhdmlvci5nZXRCb3R0b21Ub3RhbHMoKWAgaW5zdGVhZC5cbiAgICAgKiBAcmV0dXJucyB7ZGF0YVJvd09iamVjdFtdfVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Qm90dG9tVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Qm90dG9tVG90YWxzKCknLCAnZ3JpZC5iZWhhdmlvci5nZXRCb3R0b21Ub3RhbHMoKScsICcxLjEuMCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtDb2x1bW5bXX1cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0QWN0aXZlQ29sdW1ucygpJywgJ2dyaWQuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1ucygpJywgJzEuMi4xNCcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQGRlcHJlY2F0ZWQgQXMgb2YgdjEuMC42LCB1c2UgYHRoaXMuZ2V0QWN0aXZlQ29sdW1uc2AgaW5zdGVhZC5cbiAgICAgKiBAcmV0dXJucyB7Q29sdW1uW119XG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1ucygpJywgJ2dldEFjdGl2ZUNvbHVtbnMoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRIaWRkZW5Db2x1bW5zKCknLCAnZ3JpZC5iZWhhdmlvci5nZXRIaWRkZW5Db2x1bW5zKCknLCAnMS4yLjE0JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNob3dUcmVlID0gdGhpcy5ncmlkLnByb3BlcnRpZXMuc2hvd1RyZWVDb2x1bW4gPT09IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRHJpbGxEb3duKCkgJiYgc2hvd1RyZWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHBhcmFtIHJldHVybkFzU3RyaW5nXG4gICAgICogQGRlc2MgUHJvdmlkZXMgdGhlIHVuaWNvZGUgY2hhcmFjdGVyIHVzZWQgdG8gZGVub3RlIHZpc3VhbGx5IGlmIGEgY29sdW1uIGlzIGEgc29ydGVkIHN0YXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U29ydEltYWdlRm9yQ29sdW1uOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICAvL05vdCBpbXBsZW1lbnRlZFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY2VsbFxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENsaWNrZWQgaW4gYSBkcmlsbC1kb3duIGNvbHVtbi5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnY2VsbENsaWNrZWQoY2VsbCwgZXZlbnQpJywgJ2NlbGxDbGlja2VkKGV2ZW50KScsICcxLjIuMCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlUm93KGV2ZW50LmRhdGFDZWxsLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUb2dnbGUgdGhlIGRyaWxsLWRvd24gY29udHJvbCBvZiBhIHRoZSBzcGVjaWZpZWQgcm93LlxuICAgICAqIEBkZXNjIE9wZXJhdGVzIG9ubHkgb24gdGhlIGZvbGxvd2luZyByb3dzOlxuICAgICAqICogRXhwYW5kYWJsZSByb3dzIC0gUm93cyB3aXRoIGEgZHJpbGwtZG93biBjb250cm9sLlxuICAgICAqICogUmV2ZWFsZWQgcm93cyAtIFJvd3Mgbm90IGhpZGRlbiBpbnNpZGUgb2YgY29sbGFwc2VkIGRyaWxsLWRvd25zLlxuICAgICAqIEBwYXJhbSB5IC0gUmV2ZWFsZWQgcm93IG51bWJlci4gKFRoaXMgaXMgbm90IHRoZSByb3cgSUQuKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4cGFuZF0gLSBPbmUgb2Y6XG4gICAgICogKiBgdHJ1ZWAgLSBFeHBhbmQgcm93LlxuICAgICAqICogYGZhbHNlYCAtIENvbGxhcHNlIHJvdy5cbiAgICAgKiAqIGB1bmRlZmluZWRgIChvciBvbWl0dGVkKSAtIFRvZ2dsZSBzdGF0ZSBvZiByb3cuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfSBDaGFuZ2VkLiBTcGVjaWZpY2FsbHksIG9uZSBvZjpcbiAgICAgKiAqIGB1bmRlZmluZWRgIHJvdyBoYWQgbm8gZHJpbGwtZG93biBjb250cm9sXG4gICAgICogKiBgdHJ1ZWAgZHJpbGwtZG93biBjaGFuZ2VkXG4gICAgICogKiBgZmFsc2VgIGRyaWxsLWRvd24gdW5jaGFuZ2VkICh3YXMgYWxyZWFkeSBpbiByZXF1ZXN0ZWQgc3RhdGUpXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0b2dnbGVSb3c6IGZ1bmN0aW9uKHksIGV4cGFuZCkge1xuICAgICAgICAvL1RPRE86IGZpcmUgYSByb3cgdG9nZ2xlIGV2ZW50XG4gICAgICAgIHZhciBjaGFuZ2VkO1xuICAgICAgICBpZiAodGhpcy5pc0RyaWxsRG93bigpKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5kYXRhU291cmNlLmNsaWNrKHksIGV4cGFuZCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVpbmRleCh7cm93Q2xpY2s6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gciAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9IFJldHVybnMgZGF0YSByb3cgb2JqZWN0IG9yIGB1bmRlZmluZWRgIGlmIGEgaGVhZGVyIHJvdy5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvdyhyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBnaXZlbiBkYXRhIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfCp9IFRoZSBkYXRhIGNvbnRyb2xsZXI7IG9yIGB1bmRlZmluZWRgIGlmIGRhdGEgY29udHJvbGxlciB1bmtub3duIHRvIGRhdGEgbW9kZWwuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTiNcbiAgICAgKi9cbiAgICBnZXRDb250cm9sbGVyOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJzW3R5cGVdOyAvLyBhbHRlcm5hdGl2ZWx5OiB0aGlzLmRhdGFTb3VyY2UuZ2V0Q29udHJvbGxlcih0eXBlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGdpdmVuIGRhdGEgY29udHJvbGxlcihzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU9ySGFzaE9mVHlwZXMgLSBPbmUgb2Y6XG4gICAgICogKiAqKm9iamVjdCoqIC0gSGFzaCBvZiBtdWx0aXBsZSBkYXRhIGNvbnRyb2xsZXJzLCBieSB0eXBlLlxuICAgICAqICogKipzdHJpbmcqKiAtIFR5cGUgb2YgdGhlIHNpbmdsZSBkYXRhIGNvbnRyb2xsZXIgZ2l2ZW4gaW4gYGNvbnRyb2xsZXJgLlxuICAgICAqIEBwYXJhbSB7ZGF0YUNvbnRyb2xJbnRlcmZhY2V9IFtjb250cm9sbGVyXSAtIE9ubHkgcmVxdWlyZWQgd2hlbiAnaGFzaCcgaXMgYSBzdHJpbmc7IG9taXQgd2hlbiBgaGFzaGAgaXMgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gSGFzaCBvZiBhbGwgcmVzdWx0cywgYnkgdHlwZS4gRWFjaCBtZW1iZXIgd2lsbCBiZTpcbiAgICAgKiAqIFRoZSBnaXZlbiBkYXRhIGNvbnRyb2xsZXIgZm9yIHRoYXQgdHlwZSB3aGVuIGRlZmluZWQuXG4gICAgICogKiBBIG5ldyBcIm51bGxcIiBkYXRhIGNvbnRyb2xsZXIsIGdlbmVyYXRlZCBieSB0aGUgZGF0YSBtb2RlbCB3aGVuIHRoZSBnaXZlbiBkYXRhIGNvbnRyb2xsZXIgZm9yIHRoYXQgdHlwZSB3YXMgYHVuZGVmaW5lZGAuXG4gICAgICogKiBgdW5kZWZpbmVkYCAtIFRoZSBkYXRhIGNvbnRyb2xsZXIgd2FzIHVua25vd24gdG8gdGhlIGRhdGEgbW9kZWwuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTiNcbiAgICAgKi9cbiAgICBzZXRDb250cm9sbGVyOiBmdW5jdGlvbih0eXBlT3JIYXNoT2ZUeXBlcywgY29udHJvbGxlcikge1xuICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXJzID0gdGhpcy5jb250cm9sbGVycyxcbiAgICAgICAgICAgIHJlc3VsdCwgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgICAgYXRMZWFzdE9uZUFjY2VwdGVkLFxuICAgICAgICAgICAgaGFzaDtcblxuICAgICAgICBpZiAodHlwZW9mIHR5cGVPckhhc2hPZlR5cGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlT3JIYXNoT2ZUeXBlcztcbiAgICAgICAgICAgIGhhc2ggPSB7fTtcbiAgICAgICAgICAgIGhhc2hbdHlwZV0gPSBjb250cm9sbGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzaCA9IHR5cGVPckhhc2hPZlR5cGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoaGFzaCkuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBkYXRhU291cmNlLnNldENvbnRyb2xsZXIodHlwZSwgaGFzaFt0eXBlXSk7XG4gICAgICAgICAgICBhdExlYXN0T25lQWNjZXB0ZWQgPSBhdExlYXN0T25lQWNjZXB0ZWQgfHwgcmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0c1t0eXBlXSA9IHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGluIHRoZSByZXN1bHRzIHRvIHRoZSBhY3RpdmUgbGlzdCBpbmNsdWRpbmcgcmVqZWN0aW9uc1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbnRyb2xsZXJzLCByZXN1bHRzKTtcblxuICAgICAgICAvLyBwcnVuZSByZWplY3Rpb25zIGZyb20gdGhlIGFjdGl2ZSBsaXN0XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbnRyb2xsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICghY29udHJvbGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29udHJvbGxlcnNbdHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhdExlYXN0T25lQWNjZXB0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IERpZ2VzdHMgYChjb2x1bW5JbmRleCwgcHJvcE5hbWUsIHZhbHVlKWAgYW5kIGNhbGxzIHNwZWNpZmllZCBkYXRhIGNvbnRyb2xsZXJzIGBwcm9wZXJ0aWVzKClgIG1ldGhvZC5cbiAgICAgKiBAZGVzYyBEaWdlc3RzIHRoZSB0aHJlZSBwYXJhbWV0ZXJzIGAoY29sdW1uSW5kZXgsIHByb3BOYW1lLCB2YWx1ZSlgIGRldGFpbGVkIGJlbG93LCBjcmVhdGluZyBhIHNpbmdsZSB7QGxpbmsgZGF0YUNvbnRyb2xJbnRlcmZhY2V9IG9iamVjdCB3aXRoIHdoaWNoIGl0IHRoZW4gY2FsbHMgdGhlIGBwcm9wZXJ0aWVzYCBtZXRob2Qgb2YgdGhlIGRhdGEgY29udHJvbGxlciBzcGVjaWZpZWQgYnkgYHR5cGVgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgb3ZlcmxvYWRlZCBpbiB0aGUgalF1ZXJ5IHN0eWxlOiBZb3UgY2FuIGJvdGggc2V0IGEgZGF0YSBjb250cm9sbGVyIHByb3AgKHdoZW4gdmFsdWUgZ2l2ZSkgYW5kIGEgZ2V0IGEgZGF0YSBjb250cm9sbGVyIHByb3AgKHdoZW4gdmFsdWUgb21pdHRlZCk7IG9yIHlvdSBjYW4gZ2l2ZSBhIGhhc2ggaW4gcGxhY2Ugb2YgdGhlIHByb3BlcnR5IG5hbWUgdG8gc2V0IHNldmVyYWwgcHJvcGVydGllcyBhdCBvbmNlLiBXaGljaGV2ZXIgd2F5IHlvdSB1c2UgaXQsIHlvdSBjYW4gaW4gYWRkaXRpb24gc3BlY2lmeSBhIGNvbHVtbiBpbmRleCBmb3IgY29sdW1uLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bGx8c3RyaW5nfSB0eXBlIC0gVGhlIGNvbnRyb2xsZXIgdHlwZSBmcm9tIHdoaWNoIHRvIGdldCBvciB0byB3aGljaCB0byBzZXQgdGhlIGdpdmVuIHByb3BlcnR5IHZhbHVlKHMpLiBgbnVsbGAgaW4gYSBzZXR0ZXIgb3BlcmF0aW9uIGFwcGxpZXMgdGhlIHZhbHVlKHMpIHRvIGFsbCBkYXRhIGNvbnRyb2xsZXJzOyBgbnVsbGAgaGFzIHF1ZXN0aW9uYWJsZSB1c2VmdWxuZXNzIGluIGEgZ2V0dGVyIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sdW1uSW5kZXhdIC0gSWYgZ2l2ZW4sIHRoaXMgaXMgYSBwcm9wZXJ0eSBvbiBhIHNwZWNpZmljIGNvbHVtbi4gSWYgb21pdHRlZCwgdGhpcyBpcyBhIHByb3BlcnR5IG9uIHRoZSB3aG9sZSBkYXRhIGNvbnRyb2xsZXIgcHJvcGVydGllcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHByb3BOYW1lT3JQcm9wSGFzaCAtIF9JZiBgY29sdW1uSW5kZXhgIGlzIG9taXR0ZWQsIHRoaXMgYXJnIHRha2VzIGl0cyBwbGFjZS5fXG4gICAgICpcbiAgICAgKiBPbmUgb2YgdGhlc2UgdHlwZXM6XG4gICAgICogKiAqKnN0cmluZyoqIC0gUHJvcGVydHkgbmFtZS4gVGhlIG5hbWUgb2YgdGhlIGV4cGxpY2l0IHByb3BlcnR5IHRvIGVpdGhlciBnZXQgb3IgKGlmIGB2YWx1ZWAgYWxzbyBnaXZlbikgc2V0IG9uIHRoZSBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgKiAqICoqb2JqZWN0KiogLSBIYXNoIG9mIHByb3BlcnRpZXMgdG8gc2V0IG9uIHRoZSBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbdmFsdWVdIC0gX0lmIGBjb2x1bW5JbmRleGAgaXMgb21pdHRlZCwgdGhpcyBhcmcgdGFrZXMgaXRzIHBsYWNlLl9cbiAgICAgKlxuICAgICAqIE9uZSBvZjpcbiAgICAgKiAqIElmIG9taXR0ZWQgd2hlbiBgcHJvcE5hbWVPclByb3BIYXNoYCBpcyBhIHN0cmluZywgdGhpcyBpcyB0aGUgXCJnZXR0ZXJcIiBhY3Rpb246XG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9wZXJ0aWVzIG9iamVjdCBvZiB0aGUga2V5IGluIGBwcm9wZXJ0eWAuXG4gICAgICogKiBQcm92aWRlZCB3aGVuIGBwcm9wTmFtZU9yUHJvcEhhc2hgIGlzIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBcInNldHRlclwiIGFjdGlvbjpcbiAgICAgKiBDb3B5IHRoaXMgdmFsdWUgdG8gcHJvcGVydGllcyBvYmplY3QgdXNpbmcgdGhlIGtleSBpbiBgcHJvcGVydHlgLlxuICAgICAqICogV2hlbiBgcHJvcE5hbWVPclByb3BIYXNoYCBpcyBhIGhhc2ggYW5kIGB2YWx1ZWAgaXMgZ2l2ZW46IFVuZXhwZWN0ZWQ7IHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtwcm9wT2JqZWN0fVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTiNcbiAgICAgKi9cbiAgICBwcm9wOiBmdW5jdGlvbih0eXBlLCBjb2x1bW5JbmRleCwgcHJvcE5hbWVPclByb3BIYXNoLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0LCBpbnZhbGlkLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9LFxuICAgICAgICAgICAgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgY29udHJvbGxlcnMgPSB0aGlzLmNvbnRyb2xsZXJzLFxuICAgICAgICAgICAgdHlwZXMgPSAodHlwZSAhPT0gbnVsbCkgPyBbdHlwZV0gOiBPYmplY3Qua2V5cyhjb250cm9sbGVycyk7XG5cbiAgICAgICAgY29udHJvbGxlcnMgPSB0eXBlc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0eXBlKSB7IHJldHVybiBjb250cm9sbGVyc1t0eXBlXTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY29udHJvbGxlcikgeyByZXR1cm4gY29udHJvbGxlcjsgfSk7XG5cbiAgICAgICAgaWYgKGNvbnRyb2xsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW5JbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhcmdDb3VudC0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BOYW1lT3JQcm9wSGFzaDtcbiAgICAgICAgICAgICAgICBwcm9wTmFtZU9yUHJvcEhhc2ggPSBjb2x1bW5JbmRleDtcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChhcmdDb3VudCkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyBnZXR0ZXIgcHJvcE5hbWUgbmFtZSBvciBzZXR0ZXIgaGFzaFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BOYW1lT3JQcm9wSGFzaCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwcm9wTmFtZU9yUHJvcEhhc2g7IC8vIHByb3AgaXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLkdFVFRFUiA9IHByb3BOYW1lT3JQcm9wSGFzaDsgLy8gcHJvcCBpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHNldHRlciBmb3IgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wTmFtZU9yUHJvcEhhc2ggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW3Byb3BOYW1lT3JQcm9wSGFzaF0gPSB2YWx1ZTsgLy8gcHJvcCBpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC8vIHRvbyBmZXcgb3IgdG9vIG1hbnkgYXJnc1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW52YWxpZCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIG92ZXJsb2FkLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW5JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uLWVudW1lcmFibGUgcHJvcE5hbWU6XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BlcnRpZXMsICdDT0xVTU4nLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLnNvdXJjZS5zY2hlbWFbY29sdW1uSW5kZXhdLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHByZXBhcmVkIHByb3BPYmplY3QgdG8gZ2V0IG9yIHNldCB0aGUgcHJvcGVydGllcyBvbiB0aGUgY29udHJvbGxlclxuICAgICAgICAgICAgY29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29udHJvbGxlci5wcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBvZiB2MS4xLjAsIHVzZSBgdGhpcy5yZWluZGV4YCBpbnN0ZWFkLlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHlTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2FwcGx5U3RhdGUoKScsICdyZWluZGV4KCknLCAnMS4yLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkVmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0VW5maWx0ZXJlZFZhbHVlKHgsIHkpJywgbnVsbCwgJzEuMi4wJywgYXJndW1lbnRzLCAnTm8gbG9uZ2VyIHN1cHBvcnRlZCcpO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRVbmZpbHRlcmVkVmFsdWUoeCwgeSknLCBudWxsLCAnMS4yLjAnLCBhcmd1bWVudHMsICdObyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEFkZCBhIG5ldyBkYXRhIHJvdyB0byB0aGUgZ3JpZC5cbiAgICAgKiBAZGVzYyBJZiBkYXRhIHNvdXJjZSBwaXBlbGluZSBpbiB1c2UsIHRvIHNlZSB0aGUgbmV3IHJvdyBpbiB0aGUgZ3JpZCwgeW91IG11c3QgZXZlbnR1YWxseSBjYWxsOlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuYmVoYXZpb3IucmVpbmRleCgpO1xuICAgICAqIHRoaXMuZ3JpZC5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3RGF0YVJvd1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBuZXcgcm93IG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFkZFJvdzogZnVuY3Rpb24obmV3RGF0YVJvdykge1xuICAgICAgICB0aGlzLmdldERhdGEoKS5wdXNoKG5ld0RhdGFSb3cpO1xuICAgICAgICByZXR1cm4gbmV3RGF0YVJvdztcbiAgICB9LFxuXG4gICAgZ2V0IHNjaGVtYSgpIHsgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zY2hlbWE7IH0sXG5cbiAgICBzZXQgc2NoZW1hKHNjaGVtYSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0U2NoZW1hKHNjaGVtYSk7XG4gICAgfVxufSk7XG5cbi8vIExPQ0FMIE1FVEhPRFMgLS0gdG8gYmUgY2FsbGVkIHdpdGggYC5jYWxsKHRoaXNgXG5cbi8qKlxuICogQWNjdW11bGF0ZSBhY3R1YWwgZGF0YSByb3cgb2JqZWN0cyBiYWNraW5nIGN1cnJlbnQgZ3JpZCByb3cgc2VsZWN0aW9ucy5cbiAqIFRoaXMgY2FsbCBzaG91bGQgYmUgcGFpcmVkIHdpdGggYSBzdWJzZXF1ZW50IGNhbGwgdG8gYHJlc2VsZWN0R3JpZFJvd3NCYWNrZWRCeVNlbGVjdGVkRGF0YVJvd3NgLlxuICogQHByaXZhdGVcbiAqIEB0aGlzIHtkYXRhTW9kZWxzLkpTT059XG4gKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBzZWxlY3RlZERhdGFSb3dzQmFja2luZ1NlbGVjdGVkR3JpZFJvd3MoKSB7XG4gICAgdmFyIHNlbGVjdGVkRGF0YSA9IHRoaXMuc2VsZWN0ZWREYXRhLFxuICAgICAgICBoYXNSb3dTZWxlY3Rpb25zID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmhhc1Jvd1NlbGVjdGlvbnMoKSxcbiAgICAgICAgbmVlZEluZGV4ZWREYXRhTGlzdCA9IHNlbGVjdGVkRGF0YS5sZW5ndGggfHwgaGFzUm93U2VsZWN0aW9ucztcblxuICAgIGlmIChuZWVkSW5kZXhlZERhdGFMaXN0KSB7XG4gICAgICAgIHZhciBpbmRleGVkRGF0YSA9IHRoaXMuZ2V0SW5kZXhlZERhdGEoKTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDE6IFJlbW92ZSBhbnkgZmlsdGVyZWQgZGF0YSByb3dzIGZyb20gdGhlIHJlY2VudGx5IHNlbGVjdGVkIGxpc3QuXG4gICAgc2VsZWN0ZWREYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YVJvdywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ZWREYXRhLmluZGV4T2YoZGF0YVJvdykgPj0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGVkRGF0YVtpbmRleF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNURVAgMjogQWNjdW11bGF0ZSB0aGUgZGF0YSByb3dzIGJhY2tpbmcgYW55IGN1cnJlbnRseSBzZWxlY3RlZCBncmlkIHJvd3MgaW4gYHRoaXMuc2VsZWN0ZWREYXRhYC5cbiAgICBpZiAoaGFzUm93U2VsZWN0aW9ucykgeyAvLyBhbnkgY3VycmVudCBncmlkIHJvdyBzZWxlY3Rpb25zP1xuICAgICAgICB0aGlzLmdyaWQuZ2V0U2VsZWN0ZWRSb3dzKCkuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZFJvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGluZGV4ZWREYXRhW3NlbGVjdGVkUm93SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkRGF0YS5pbmRleE9mKGRhdGFSb3cpIDwgMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0YS5wdXNoKGRhdGFSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogUmUtZXN0YWJsaXNoIGdyaWQgcm93IHNlbGVjdGlvbnMgYmFzZWQgb24gYWN0dWFsIGRhdGEgcm93IG9iamVjdHMgYWNjdW11bGF0ZWQgYnkgYHNlbGVjdGVkRGF0YVJvd3NCYWNraW5nU2VsZWN0ZWRHcmlkUm93c2Agd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCBmaXJzdC5cbiAqIEBwcml2YXRlXG4gKiBAdGhpcyB7ZGF0YU1vZGVscy5KU09OfVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93cygpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZERhdGEubGVuZ3RoKSB7IC8vIGFueSBkYXRhIHJvdyBvYmplY3RzIGFkZGVkIGZyb20gcHJldmlvdXMgZ3JpZCByb3cgc2VsZWN0aW9ucz9cbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldEluZGV4ZWREYXRhKCk7XG5cbiAgICAgICAgc2VsZWN0aW9uTW9kZWwuY2xlYXJSb3dTZWxlY3Rpb24oKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFSb3cpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGZpbHRlcmVkRGF0YS5pbmRleE9mKGRhdGFSb3cpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5zZWxlY3RSb3cob2Zmc2V0ICsgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZVxuICogQHRoaXMgRGF0YVNvdXJjZU9yaWdpbiNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT05+XG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtYVByb3BBcnIocHJvcE5hbWUsIGRlcHJlY2F0ZWRNZXRob2ROYW1lKSB7XG4gICAgdGhpcy5kZXByZWNhdGVkKGRlcHJlY2F0ZWRNZXRob2ROYW1lLCBkZXByZWNhdGVkTWV0aG9kTmFtZSArICcoKSBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHYxLjIuMCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIENvbnN0cnVjdHMgbGlrZSAnICsgZGVwcmVjYXRlZE1ldGhvZE5hbWUgKyAnKClbaV0gc2hvdWxkIGJlIGNoYW5nZWQgdG8gc2NoZW1hW2ldLiAoVGhpcyBkZXByZWNhdGVkIG1ldGhvZCBub3cgcmV0dXJucyBhIG5ldyBhcnJheSBkZXJpdmVkIGZyb20gc2NoZW1hLiknKTtcbiAgICByZXR1cm4gdGhpcy5zY2hlbWEubWFwKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSkge1xuICAgICAgICByZXR1cm4gY29sdW1uU2NoZW1hW3Byb3BOYW1lXTtcbiAgICB9LCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gQ2hhck1hcChkYXRhTW9kZWwpIHtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IGRhdGFNb2RlbDtcbn1cbkNoYXJNYXAucHJvdG90eXBlID0ge1xuICAgIG1peEluOiByZXF1aXJlKCdvdmVycmlkZXInKS5taXhJbixcblxuICAgIGdldCBPUEVOKCkgeyByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZGF0YVNvdXJjZS5kcmlsbERvd25DaGFyTWFwLk9QRU47IH0sXG4gICAgc2V0IE9QRU4ocykgeyB0aGlzLmRhdGFNb2RlbC5kYXRhU291cmNlLmRyaWxsRG93bkNoYXJNYXAuT1BFTiA9IHM7IH0sXG5cbiAgICBnZXQgQ0xPU0UoKSB7IHJldHVybiB0aGlzLmRhdGFNb2RlbC5kYXRhU291cmNlLmRyaWxsRG93bkNoYXJNYXAuQ0xPU0U7IH0sXG4gICAgc2V0IENMT1NFKHMpIHsgdGhpcy5kYXRhTW9kZWwuZGF0YVNvdXJjZS5kcmlsbERvd25DaGFyTWFwLkNMT1NFID0gczsgfSxcbn07XG5cbi8qKlxuICogU3lub255bSBvZiB7QGxpbmsgSlNPTi5wcm90b3R5cGUucmVpbmRleH0uXG4gKiBAbmFtZSBhcHBseUFuYWx5dGljc1xuICogQGRlcHJlY2F0ZWRcbiAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gKi9cbkpTT04ucHJvdG90eXBlLmFwcGx5QW5hbHl0aWNzID0gSlNPTi5wcm90b3R5cGUucmVpbmRleDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRlbmQtbmF0aXZlXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRhdGFNb2RlbHMgPSB7XG4gICAgRGF0YU1vZGVsOiByZXF1aXJlKCcuL0RhdGFNb2RlbCcpLFxuICAgIEpTT046IHJlcXVpcmUoJy4vSlNPTicpLFxuICAgIEhlYWRlclN1YmdyaWQ6IHJlcXVpcmUoJy4vSGVhZGVyU3ViZ3JpZCcpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdGFNb2RlbHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBncmFwaGljcyA9IHJlcXVpcmUoJy4vbGliL2dyYXBoaWNzJyk7XG5cbnZhciB3YXJuZWQgPSB7fTtcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBsaXN0cyB0aGUgcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgb24gYSB7QGxpbmsgSHlwZXJncmlkfSBhbG9uZyB3aXRoIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICogRWRpdCB0aGlzIGZpbGUgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICogQG1vZHVsZSBkZWZhdWx0c1xuICovXG5cbnZhciBkZWZhdWx0cyA9IHtcblxuICAgIG1peEluOiByZXF1aXJlKCdvdmVycmlkZXInKS5taXhJbixcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IG1lc3NhZ2UgdG8gZGlzcGxheSBpbiBmcm9udCBvZiB0aGUgY2FudmFzIHdoZW4gdGhlcmUgYXJlIG5vIGdyaWQgcm93cy5cbiAgICAgKiBGb3JtYXQgaXMgSFRNTC5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIG5vRGF0YU1lc3NhZ2U6ICcnLFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9udCBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmb250OiAnMTNweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBGb250IGNvbG9yIGZvciBkYXRhIGNlbGxzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYigyNDEsIDI0MSwgMjQxKScsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIGZvciBzZWxlY3RlZCBjZWxsKHMpLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ6ICdib2xkIDEzcHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBjb2xvciBmb3Igc2VsZWN0ZWQgY2VsbChzKS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigwLCAwLCAxMjgpJyxcbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIGZvciBzZWxlY3RlZCBjZWxsKHMpLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgxNDcsIDE4NSwgMjU1LCAwLjYyNSknLFxuXG5cbiAgICAvKioqKioqKioqKiBTRUNUSU9OOiBDT0xVTU4gSEVBREVSIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLy8gSU1QT1JUQU5UIENBVkVBVDogVGhlIGNvZGUgaXMgaW5jb25zaXN0ZW50IHJlZ2FyZGluZyB0aGUgdGVybWlub2xvZ3kuIElzIHRoZSBcImNvbHVtbiBoZWFkZXJcIiBzZWN0aW9uIF90aGUgcm93XyBvZiBjZWxscyBhdCB0aGUgdG9wICh0aGF0IGFjdCBhcyBoZWFkZXJzIGZvciBlYWNoIGNvbHVtbikgb3IgaXMgaXQgX3RoZSBjb2x1bW5fIG9mIGNlbGxzICh0aGF0IGFjdCBhcyBoZWFkZXJzIGZvciBlYWNoIHJvdyk/IE9oIG15LlxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc3R5bGUgZm9yIHNlbGVjdGVkIGNvbHVtbnMnIGhlYWRlcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDogJ2JvbGQgMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yOiAncmdiKDIyMywgMjI3LCAyMzIpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoODAsIDgwLCA4MCknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYmEoMjU1LCAyMjAsIDk3LCAwLjQ1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckhhbGlnbjogJ2NlbnRlcicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlclJlbmRlcmVyOiAnU2ltcGxlQ2VsbCcsXG5cblxuICAgIC8qKioqKioqKioqIFNFQ1RJT046IFJPVyBIRUFERVIgQ09MT1JTICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dIZWFkZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93SGVhZGVyQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd0hlYWRlckJhY2tncm91bmRDb2xvcjogJ3JnYigyMjMsIDIyNywgMjMyKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDgwLCA4MCwgODApJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc3R5bGUgZm9yIHNlbGVjdGVkIHJvd3MnIGhlYWRlcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDogJ2JvbGQgMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93SGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgyNTUsIDIyMCwgOTcsIDAuNDUpJyxcblxuXG4gICAgLyoqKioqKioqKiogU0VDVElPTjogRklMVEVSIFJPVyBDT0xPUlMgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpbHRlckZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaWx0ZXJDb2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZmlsdGVyQmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpbHRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMjIwLCA5NyknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaWx0ZXJIYWxpZ246ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaWx0ZXJSZW5kZXJlcjogJ1NpbXBsZUNlbGwnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjI6ICdyZ2IoMjAxLCAyMDEsIDIwMSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICB2b2Zmc2V0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzY3JvbGxiYXJIb3Zlck92ZXI6ICd2aXNpYmxlJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2Nyb2xsYmFySG92ZXJPZmY6ICdoaWRkZW4nLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2Nyb2xsaW5nRW5hYmxlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgdlNjcm9sbGJhckNsYXNzUHJlZml4OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgaFNjcm9sbGJhckNsYXNzUHJlZml4OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgaGFsaWduOiAnY2VudGVyJyxcblxuICAgIC8qKlxuICAgICAqIFBhZGRpbmcgdG8gbGVmdCBhbmQgcmlnaHQgb2YgY2VsbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFJpZ2h0IHBhZGRpbmcgbWF5IG5vdCBiZSB2aXNpYmxlIGlmIGNvbHVtbiBpcyBub3Qgc2l6ZWQgd2lkZSBlbm91Z2guXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbyB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmljb25QYWRkaW5nfGljb25QYWRkaW5nfS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGNlbGxQYWRkaW5nOiA1LFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyB0byBsZWZ0IGFuZCByaWdodCBvZiBjZWxsIGljb25zLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGVzIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMuY2VsbFBhZGRpbmd8Y2VsbFBhZGRpbmd9OlxuICAgICAqICogTGVmdCBpY29uICsgYGljb25QYWRkaW5nYCBvdmVycmlkZXMgbGVmdCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmNlbGxQZGRpbmdnfGNlbGxQZGRpbmdnfS5cbiAgICAgKiAqIFJpZ2h0IGljb24gKyBgaWNvblBhZGRpbmdgIG92ZXJyaWRlcyByaWdodCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmNlbGxQZGRpbmdnfGNlbGxQZGRpbmdnfS5cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubGVmdEljb258bGVmdEljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmNlbnRlckljb258Y2VudGVySWNvbn1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMucmlnaHRJY29ufHJpZ2h0SWNvbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGljb25QYWRkaW5nOiAzLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTmFtZSBvZiBpbWFnZSB0byBhcHBlYXIgYXQgcmlnaHQgb2YgY2VsbC5cbiAgICAgKiBNdXN0IGJlIGEga2V5IGZyb20ge0BsaW5rIG1vZHVsZTppbWFnZXN8aW1hZ2VzfS5cbiAgICAgKiBAZGVzYyBVc2VkIGJ5IHtAbGluayBTaW1wbGVDZWxsfSBjZWxsIHJlbmRlcmVyLlxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5jZW50ZXJJY29ufGNlbnRlckljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLnJpZ2h0SWNvbnxyaWdodEljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmljb25QYWRkaW5nfGljb25QYWRkaW5nfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGVmdEljb246IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE5hbWUgb2YgaW1hZ2UgdG8gYXBwZWFyIGF0IHJpZ2h0IG9mIGNlbGwuXG4gICAgICogTXVzdCBiZSBhIGtleSBmcm9tIHtAbGluayBtb2R1bGU6aW1hZ2VzfGltYWdlc30uXG4gICAgICogQGRlc2MgVXNlZCBieSB7QGxpbmsgU2ltcGxlQ2VsbH0gY2VsbCByZW5kZXJlci5cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubGVmdEljb258bGVmdEljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLnJpZ2h0SWNvbnxyaWdodEljb259XG4gICAgICogQHNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmljb25QYWRkaW5nfGljb25QYWRkaW5nfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY2VudGVySWNvbjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTmFtZSBvZiBpbWFnZSB0byBhcHBlYXIgYXQgcmlnaHQgb2YgY2VsbC5cbiAgICAgKiBNdXN0IGJlIGEga2V5IGZyb20ge0BsaW5rIG1vZHVsZTppbWFnZXN8aW1hZ2VzfS5cbiAgICAgKiBAZGVzYyBVc2VkIGJ5IHtAbGluayBTaW1wbGVDZWxsfSBjZWxsIHJlbmRlcmVyLlxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5sZWZ0SWNvbnxsZWZ0SWNvbn1cbiAgICAgKiBAc2VlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMuY2VudGVySWNvbnxjZW50ZXJJY29ufVxuICAgICAqIEBzZWUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5pY29uUGFkZGluZ3xpY29uUGFkZGluZ31cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJpZ2h0SWNvbjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCB0byByZW5kZXIgYDBgIGFuZCBgZmFsc2VgLiBPdGhlcndpc2UgdGhlc2UgdmFsdWUgYXBwZWFyIGFzIGJsYW5rIGNlbGxzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJlbmRlckZhbHN5OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGdyaWRMaW5lc0g6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBncmlkTGluZXNWOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRHJhdyBob3Jpem9udGFsIGdyaWQgbGluZSBiZWZvcmUgZmlyc3QgcmVuZGVyZWQgY29sdW1uLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGdyaWRCb3JkZXJMZWZ0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIERyYXcgaG9yaXpvbnRhbCBncmlkIGxpbmUgYWZ0ZXIgbGFzdCByZW5kZXJlZCBjb2x1bW4uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZ3JpZEJvcmRlclJpZ2h0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIERyYXcgaG9yaXpvbnRhbCBncmlkIGxpbmUgYWJvdmUgZmlyc3QgcmVuZGVyZWQgcm93LlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGdyaWRCb3JkZXJUb3A6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogRHJhdyBob3Jpem9udGFsIGdyaWQgbGluZSBiZWxvdyBsYXN0IHJlbmRlcmVkIHJvdy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBncmlkQm9yZGVyQm90dG9tOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGxpbmVDb2xvcjogJ3JnYigxOTksIDE5OSwgMTk5KScsXG5cbiAgICAvKipcbiAgICAgKiBDYXZlYXQ6IGBsaW5lV2lkdGhgIHNob3VsZCBiZSBhbiBpbnRlZ2VyICh3aG9sZSBwaXhlbClcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGxpbmVXaWR0aDogMSxcblxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBkZWZhdWx0Um93SGVpZ2h0OiAxNSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZGVmYXVsdENvbHVtbldpZHRoOiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIG1pbmltdW1Db2x1bW5XaWR0aDogNSxcblxuICAgIC8vZm9yIGltbWVkaWF0ZSBwYWludGluZywgc2V0IHRoZXNlIHZhbHVlcyB0byAwLCB0cnVlIHJlc3BlY3RpdmVseVxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByZXBhaW50SW50ZXJ2YWxSYXRlOiA2MCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJlcGFpbnRJbW1lZGlhdGVseTogZmFsc2UsXG5cbiAgICAvL2VuYWJsZSBvciBkaXNhYmxlIGRvdWJsZSBidWZmZXJpbmdcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHVzZUJpdEJsaXQ6IGZhbHNlLFxuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICB1c2VIaURQSTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1hcHBpbmdzIGZvciBjZWxsIG5hdmlnYXRpb24ga2V5cy5cbiAgICAgKiBAZGVzYyBDZWxsIG5hdmlnYXRpb24gaXMgaGFuZGxlZCBpbiB0aGUge0BsaW5rIENlbGxTZWxlY3Rpb259IFwiZmVhdHVyZVwiLiBUaGlzIHByb3BlcnR5IGdpdmVzIHlvdSBjb250cm9sIG92ZXIgd2hpY2gga2V5cHJlc3NlcyB0aGUgYnVpbHQtaW4gbWVjaGFuaXNtIHdpbGwgcmVzcG9uZCB0by5cbiAgICAgKlxuICAgICAqIChJZiB0aGlzIGJ1aWx0LWluIGNlbGwgc2VsZWN0aW9uIGxvZ2ljIGlzIGluc3VmZmljaWVudCBmb3IgeW91ciBuZWVkcywgeW91IGNhbiBhbHNvIGxpc3RlbiBmb3IgdGhlIHZhcmlvdXMgXCJmaW4ta2V5XCIgZXZlbnRzIGFuZCBjYXJyeSBvdXQgbW9yZSBjb21wbGV4IG9wZXJhdGlvbnMgaW4geW91ciBsaXN0ZW5lcnMuKVxuICAgICAqXG4gICAgICogVGhlIGtleXByZXNzIG5hbWVzIHVzZWQgaGVyZSBhcmUgZGVmaW5lZCBpbiBDYW52YXMuanMuIE5vdGUgdGhhdCBhbGwga2V5cHJlc3NlcyBhY3R1YWxseSBoYXZlIHR3byBuYW1lcywgYSBub3JtYWwgbmFtZSBhbmQgYSBzaGlmdGVkIG5hbWUuIFRoZSBsYXR0ZXIgbmFtZSBpcyB1c2VkIHdoZW4gZWl0aGVyICoqc2hpZnQqKiBpcyBkZXByZXNzZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYnVpbHQtaW4gbmF2IGtleXByZXNzZXMgYXJlIGFzIGZvbGxvd3M6XG4gICAgICogKiAqKmBVUGAqKiBfKHVwLWFycm93IGtleSlfIC0gUmVwbGFjZSBhbGwgc2VsZWN0aW9ucyB3aXRoIGEgc2luZ2xlIGNlbGwsIG9uZSByb3cgdXAgZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb24uXG4gICAgICogKiAqKmBET1dOYCoqIF8oZG93bi1hcnJvdyBrZXkpXyAtIFJlcGxhY2UgYWxsIHNlbGVjdGlvbnMgd2l0aCBhIHNpbmdsZSBjZWxsLCBvbmUgcm93IGRvd24gZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb24uXG4gICAgICogKiAqKmBMRUZUYCoqIF8obGVmdC1hcnJvdyBrZXkpXyAtIFJlcGxhY2UgYWxsIHNlbGVjdGlvbnMgd2l0aCBhIHNpbmdsZSBjZWxsLCBvbmUgY29sdW1uIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IHNlbGVjdGlvbi5cbiAgICAgKiAqICoqYFJJR0hUYCoqIF8ocmlnaHQtYXJyb3cga2V5KV8gLSBSZXBsYWNlIGFsbCBzZWxlY3Rpb25zIHdpdGggYSBzaW5nbGUgY2VsbCwgb25lIGNvbHVtbiB0byB0aGUgcmlnaHQgb2YgdGhlIGxhc3Qgc2VsZWN0aW9uLlxuICAgICAqICogKipgVVBTSElGVGAqKiBfKHNoaWZ0ICsgdXAtYXJyb3cpXyAtIEV4dGVuZCB0aGUgbGFzdCBzZWxlY3Rpb24gdXAgb25lIHJvdy5cbiAgICAgKiAqICoqYERPV05TSElGVGAqKiBfKHNoaWZ0ICsgZG93bi1hcnJvdylfIC0gRXh0ZW5kIHRoZSBsYXN0IHNlbGVjdGlvbiBkb3duIG9uZSByb3cuXG4gICAgICogKiAqKmBMRUZUU0hJRlRgKiogXyhzaGlmdCArIGxlZnQtYXJyb3cpXyAtIEV4dGVuZCB0aGUgbGFzdCBzZWxlY3Rpb24gbGVmdCBvbmUgY29sdW1uLlxuICAgICAqICogKipgUklHSFRTSElGVGAqKiBfKHNoaWZ0ICsgcmlnaHQtYXJyb3cpXyAtIEV4dGVuZCB0aGUgbGFzdCBzZWxlY3Rpb24gcmlnaHQgb25lIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIFRvIGFsdGVyIHRoZXNlIG9yIGFkZCBvdGhlciBtYXBwaW5ncyBzZWUgdGhlIGV4YW1wbGVzIGJlbG93LlxuICAgICAqXG4gICAgICogQSBub3RlIHJlZ2FyZGluZyB0aGUgb3RoZXIgbWV0YSBrZXlzICgqKnRybCoqLCAqKm9wdGlvbioqLCBhbmQgKipjb21tYW5kKiopOiBBbHRob3VnaCB0aGVzZSBtZXRhIGtleXMgY2FuIGJlIGRldGVjdGVkLCB0aGV5IGRvIG5vdCBtb2RpZnkgdGhlIGtleSBuYW1lcyBhcyAqKnNoaWZ0KiogZG9lcy4gVGhpcyBpcyBiZWNhdXNlIHRoZXkgYXJlIG1vcmUgZm9yIHN5c3RlbSB1c2UgYW5kIGdlbmVyYWxseSAod2l0aCB0aGUgcG9zc2libHkgZXhjZXB0aW9uIGZvICoqY3RybCoqKSBzaG91bGQgbm90IGJlIGRlcGVuZGVkIHVwb24sIGFzIHN5c3RlbSBmdW5jdGlvbnMgd2lsbCB0YWtlIHByaW9yaXR5IGFuZCB5b3VyIGFwcCB3aWxsIG5ldmVyIHNlZSB0aGVzZSBrZXkgcHJlc3Nlcy5cbiAgICAgKlxuICAgICAqIEEgc3BlY2lhbCBhY2NvbW1vZGF0aW9uIGhhcyBiZWVuIG1hZGUgdG8gdGhlIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMuZWRpdE9uS2V5ZG93bnxlZGl0T25LZXlkb3dufSBwcm9wZXJ0eTpcbiAgICAgKiAqIElmIGBlZGl0T25LZXlkb3duYCB0cnV0aHkgQU5EIG1hcHBlZCBjaGFyYWN0ZXIgaXMgYW4gYWN0dWFsIChub24td2hpdGUtc3BhY2UpIGNoYXJhY3RlciAoYXMgb3Bwb3NlZCB0byBzYXkgKip0YWIqKiBvciAqKnJldHVybioqKSwgdGhlbiBuYXZpZ2F0aW9uIHJlcXVpcmVzICoqY3RybCoqIGtleSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIG5hdiBhbmQgZGF0YS5cbiAgICAgKiAqIElmIGBlZGl0T25LZXlkb3duYCBmYWxzeSwgdGhlICoqY3RybCoqIGtleSBpcyBpZ25vcmVkLlxuICAgICAqXG4gICAgICogU28gaW4gdGhlIGxhc3QgZXhhbXBsZSwgaWYgYGVkaXRPbktleWRvd25gIGlzIE9OLCB0aGVuIGBhYCAod2l0aG91dCAqKmN0cmwqKikgd291bGQgc3RhcnQgZWRpdGluZyB0aGUgY2VsbCBhbmQgKipjdHJsKiogKyBgYWAgd291bGQgbW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjb2x1bW4gdG8gdGhlIGxlZnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFRvIHZvaWQgdGhlIGFib3ZlIGJ1aWxkLWluczpcbiAgICAgKiBuYXZLZXlNYXA6IHtcbiAgICAgKiAgICAgVVA6IHVuZGVmaW5lZCxcbiAgICAgKiAgICAgVVBTSElGVDogdW5kZWZpbmVkLFxuICAgICAqICAgICBET1dOOiB1bmRlZmluZWQsXG4gICAgICogICAgIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVG8gbWFwIGFsdGVybmF0aXZlIG5hdiBrZXlwcmVzc2VzIHRvIFJFVFVSTiBhbmQgVEFCIChkZWZhdWx0IG1hcHBpbmcpOlxuICAgICAqIG5hdktleU1hcDoge1xuICAgICAqICAgICBSRVRVUk46ICdET1dOJyxcbiAgICAgKiAgICAgUkVUVVJOU0hJRlQ6ICdVUCcsXG4gICAgICogICAgIFRBQjogJ1JJR0hUJyxcbiAgICAgKiAgICAgVEFCU0hJRlQ6ICdMRUZUJ1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVG8gbWFwIGFsdGVybmF0aXZlIG5hdiBrZXlwcmVzc2VzIHRvIGEvdy9kL3MgYW5kIGV4dGVuZCBzZWxlY3QgdG8gQS9XL0QvUzpcbiAgICAgKiBuYXZLZXlNYXA6IHtcbiAgICAgKiAgICAgYTogJ0xFRlQnLCBBOiAnTEVGVFNISUZUJyxcbiAgICAgKiAgICAgdzogJ1VQJywgVzogJ1VQU0hJRlQnLFxuICAgICAqICAgICBzOiAnRE9XTicsIFM6ICdET1dOU0hJRlQnLFxuICAgICAqICAgICBkOiAnUklHSFQnLCBEOiAnUklHSFRTSElGVCdcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtvYmplY3R8dW5kZWZpbmVkfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBuYXZLZXlNYXA6IHtcbiAgICAgICAgUkVUVVJOOiAnRE9XTicsXG4gICAgICAgIFJFVFVSTlNISUZUOiAnVVAnLFxuICAgICAgICBUQUI6ICdSSUdIVCcsXG4gICAgICAgIFRBQlNISUZUOiAnTEVGVCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbnkgdmFsdWUgb2YgYGtleUNoYXJgIHRoYXQgcGFzc2VzIHRoZSBmb2xsb3dpbmcgbG9naWMgdGVzdDpcbiAgICAgKiAxLiBJZiBhIG5vbi1wcmludGFibGUsIHdoaXRlLXNwYWNlIGNoYXJhY3RlciwgdGhlbiBuYXYga2V5LlxuICAgICAqIDIuIElmIG5vdCAoaS5lLiwgYSBub3JtYWwgY2hhcmFjdGVyKSwgY2FuIHN0aWxsIGJlIGEgbmF2IGtleSBpZiBub3QgZWRpdGluZyBvbiBrZXkgZG93bi5cbiAgICAgKiAzLiBJZiBub3QsIGNhbiBzdGlsbCBiZSBhIG5hdiBrZXkgaWYgQ1RSTCBrZXkgaXMgZG93bi5cbiAgICAgKlxuICAgICAqIE5vdGU6IENhbGxlcnMgYXJlIHR5cGNpYWxseSBvbmx5IGludGVyZXN0ZWQgaW4gdGhlIGZvbGxvd2luZyB2YWx1ZXMgb2YgYGtleUNoYXJgIGFuZCB3aWxsIGlnbm9yZSBhbGwgb3RoZXJzOlxuICAgICAqICogYCdMRUZUJ2AgYW5kIGAnTEVGVFNISUZUJ2BcbiAgICAgKiAqIGAnUklHSFQnYCBhbmQgYCdSSUdIVFNISUZUJ2BcbiAgICAgKiAqIGAnVVAnYCBhbmQgYCdVUFNISUZUJ2BcbiAgICAgKiAqIGAnRE9XTidgIGFuZCBgJ0RPV05TSElGVCdgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5Q2hhciAtIEEgdmFsdWUgZnJvbSBDYW52YXMncyBgY2hhck1hcGAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY3RybEtleT1mYWxzZV0gLSBUaGUgQ1RSTCBrZXkgd2FzIGRvd24uXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxzdHJpbmd9IGB1bmRlZmluZWRgIG1lYW5zIG5vdCBhIG5hdiBrZXk7IG90aGVyd2lzZSByZXR1cm5zIGBrZXlDaGFyYC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbmF2S2V5OiBmdW5jdGlvbihrZXlDaGFyLCBjdHJsS2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChrZXlDaGFyLmxlbmd0aCA+IDEgfHwgIXRoaXMuZWRpdE9uS2V5ZG93biB8fCBjdHJsS2V5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBrZXlDaGFyOyAvLyByZXR1cm4gdGhlIG1hcHBlZCB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb25seSB2YWx1ZXMgb2YgYGtleUNoYXJgIHRoYXQsIHdoZW4gcnVuIHRocm91Z2gge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5uYXZLZXlNYXB8bmF2S2V5TWFwfSwgcGFzcyB0aGUge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5uYXZLZXl8bmF2S2V5fSBsb2dpYyB0ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleUNoYXIgLSBBIHZhbHVlIGZyb20gQ2FudmFzJ3MgYGNoYXJNYXBgLCB0byBiZSByZW1hcHBlZCB0aHJvdWdoIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubmF2S2V5TWFwfG5hdktleU1hcH0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY3RybEtleT1mYWxzZV0gLSBUaGUgQ1RSTCBrZXkgd2FzIGRvd24uXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxzdHJpbmd9IGB1bmRlZmluZWRgIG1lYW5zIG5vdCBhIG5hdiBrZXk7IG90aGVyd2lzZSByZXR1cm5zIGBrZXlDaGFyYC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbWFwcGVkTmF2S2V5OiBmdW5jdGlvbihrZXlDaGFyLCBjdHJsS2V5KSB7XG4gICAgICAgIGtleUNoYXIgPSB0aGlzLm5hdktleU1hcFtrZXlDaGFyXTtcbiAgICAgICAgcmV0dXJuIGtleUNoYXIgJiYgdGhpcy5uYXZLZXkoa2V5Q2hhcik7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBWYWxpZGF0aW9uIGZhaWx1cmUgZmVlZGJhY2suXG4gICAgICogQGRlc2MgVmFsaWRhdGlvbiBvY2N1cnMgb24ge0BsaW5rIENlbGxFZGl0b3Ijc3RvcEVkaXRpbmd9LCBub3JtYWxseSBjYWxsZWQgb24gY29tbWl0IChgVEFCYCwgYEVOVEVSYCwgb3IgYW55IG90aGVyIGtleXMgbGlzdGVkIGluIGBuYXZLZXlNYXBgKS5cbiAgICAgKlxuICAgICAqIE9uIHN1Y2Nlc3NmdWwgdmFsaWRhdGlvbiwgdGhlIHZhbHVlIGlzIHNhdmVkIGJhY2sgdG8gdGhlIGRhdGEgc291cmNlIGFuZCB0aGUgZWRpdG9yIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIE9uIHZhbGlkYXRpb24gZmFpbHVyZSwgZmVlZGJhY2sgaXMgc2hvd24gdG8gdGhlIHVzZXIgaW4gdGhlIGZvcm0gb2YgYW4gXCJlcnJvciBlZmZlY3RcIiBwb3NzaWJseSBmb2xsb3dlZCBieSBhbiBcImVuZCBlZmZlY3RcIiBjb250YWluaW5nIGEgZGV0YWlsZWQgZXhwbGFuYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgZXJyb3IgZWZmZWN0IHRvIHVzZSBpcyBuYW1lZCBpbiBgZmVlZGJhY2tFZmZlY3RcbiAgICAgKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gc2hvdyB0aGUgXCJlcnJvciBlZmZlY3RcIiBvbiB2YWxpZGF0aW9uIGZhaWx1cmUgYmVmb3JlIHNob3dpbmcgdGhlIGRldGFpbGVkIGV4cGxhbmF0aW9uLlxuICAgICAqXG4gICAgICogYGZlZWRiYWNrYCBtYXkgYmUgc2V0IHRvIG9uZSBvZjpcbiAgICAgKiAqICoqYHVuZGVmaW5lZGAqKiAtIERvIG5vdCBzaG93IHRoZSBlcnJvciBlZmZlY3Qgb3IgdGhlIGFsZXJ0LiBKdXN0IGRpc2NhcmQgdGhlIHZhbHVlIGFuZCBjbG9zZSB0aGUgZWRpdG9yIChhcyBpZiBgRVNDYCBoYWQgYmVlbiB0eXBlZCkuXG4gICAgICogKiAqKmAwYCoqIC0gSnVzdCBzaG93cyB0aGUgZXJyb3IgZmVlZGJhY2sgZWZmZWN0IChzZWUgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0fGVycm9yRWZmZWN0fSBwcm9wZXJ0eSkuXG4gICAgICogKiAqKmAxYCoqIC0gU2hvd3MgdGhlIGVycm9yIGZlZWRiYWNrIGVmZmVjdCBmb2xsb3dlZCBieSB0aGUgZGV0YWlsZWQgZXhwbGFuYXRpb24uXG4gICAgICogKiBgMmAgb3IgbW9yZTpcbiAgICAgKiAgIDEuIFNob3dzIHRoZSBlcnJvciBmZWVkYmFjayBlZmZlY3RcbiAgICAgKiAgIDIuIE9uIGV2ZXJ5IGBmZWVkYmFja2AgdHJpZXMsIHNob3dzIHRoZSBkZXRhaWxlZCBleHBsYW5hdGlvbi5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmZWVkYmFja0NvdW50OiAzLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7e25hbWU6c3RyaW5nLG9wdGlvbnM6b2JqZWN0fXxzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZlZWRiYWNrRWZmZWN0OiAnc2hha2VyJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJlYWRPbmx5OiBmYWxzZSxcblxuICAgIC8vIGluaGVyaXRlZCBieSBjZWxsIHJlbmRlcmVyc1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyByZWZlcmVuY2VkIGhlcmUgc28gaXQgd2lsbCBiZSBhdmFpbGFibGUgdG8gdGhlIHJlbmRlcmVyIGFuZCBjZWxsIHJlbmRlcmVycy5cbiAgICAgKiBAZGVmYXVsdCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmdldFRleHRXaWR0aHxnZXRUZXh0V2lkdGh9XG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKGdjLCBzdHJpbmcpIHtcbiAgICAgICAgaWYgKCF3YXJuZWQuZ2V0VGV4dFdpZHRoKSB7XG4gICAgICAgICAgICB3YXJuZWQuZ2V0VGV4dFdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignZ2V0VGV4dFdpZHRoKGdjLCBzdHJpbmcpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgb24gdGhlIHByb3BlcnRpZXMgKG9yIGNvbmZpZykgb2JqZWN0IGFzIG9mIHYxLjIuNCBpbiBmYXZvciBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dCAoYWthIGdjKSBvYmplY3QgYW5kIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBwcm9wZXJ0aWVzIG9iamVjdCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBQbGVhc2UgY2hhbmdlIHlvdXIgY2FsbGluZyBjb250ZXh0IHRvIGdjLmdldFRleHRXaWR0aChzdHJpbmcpLCBleGNsdWRpbmcgdGhlIGZpcnN0IHBhcmFtZXRlciAoZ2MpIGZyb20geW91ciBjYWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaGljcy5nZXRUZXh0V2lkdGguYXBwbHkoZ2MsIHN0cmluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgcmVmZXJlbmNlZCBoZXJlIHNvIGl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIHRoZSByZW5kZXJlciBhbmQgY2VsbCByZW5kZXJlcnMuXG4gICAgICogQGRlZmF1bHQge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5nZXRUZXh0SGVpZ2h0fGdldFRleHRIZWlnaHR9XG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBnZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbihmb250KSB7XG4gICAgICAgIGlmICghd2FybmVkLmdldFRleHRIZWlnaHQpIHtcbiAgICAgICAgICAgIHdhcm5lZC5nZXRUZXh0SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignZ2V0VGV4dEhlaWdodChmb250KSBoYXMgYmVlbiBkZXByZWNhdGVkIG9uIHRoZSBwcm9wZXJ0aWVzIChvciBjb25maWcpIG9iamVjdCBhcyBvZiB2MS4yLjQgaW4gZmF2b3Igb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQgKGFrYSBnYykgb2JqZWN0IGFuZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgcHJvcGVydGllcyBvYmplY3QgaW4gYSBmdXR1cmUgcmVsZWFzZS4gUGxlYXNlIGNoYW5nZSB5b3VyIGNhbGxpbmcgY29udGV4dCB0byBnYy5nZXRUZXh0SGVpZ2h0KGZvbnQpLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFwaGljcy5nZXRUZXh0SGVpZ2h0KGZvbnQpO1xuICAgIH0sXG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgaWYgKCF3YXJuZWQueCkge1xuICAgICAgICAgICAgd2FybmVkLnggPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdjb25maWcueCBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHYxLjIuMTAgaW4gZmF2b3Igb2YgY29uZmlnLmRhdGFDZWxsLnguIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNlbGwueDtcbiAgICB9LFxuXG4gICAgZ2V0IHVudHJhbnNsYXRlZFgoKSB7XG4gICAgICAgIGlmICghd2FybmVkLnVudHJhbnNsYXRlZFgpIHtcbiAgICAgICAgICAgIHdhcm5lZC51bnRyYW5zbGF0ZWRYID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignY29uZmlnLnVudHJhbnNsYXRlZFggaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjEwIGluIGZhdm9yIG9mIGNvbmZpZy5ncmlkQ2VsbC54LiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRDZWxsLng7XG4gICAgfSxcblxuICAgIGdldCB5KCkge1xuICAgICAgICBpZiAoIXdhcm5lZC55KSB7XG4gICAgICAgICAgICB3YXJuZWQueSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NvbmZpZy55IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMi4xMCBpbiBmYXZvciBvZiBjb25maWcuZ3JpZENlbGwueS4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ncmlkQ2VsbC55O1xuICAgIH0sXG5cbiAgICBnZXQgbm9ybWFsaXplZFkoKSB7XG4gICAgICAgIGlmICghd2FybmVkLm5vcm1hbGl6ZWRZKSB7XG4gICAgICAgICAgICB3YXJuZWQubm9ybWFsaXplZFkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdjb25maWcubm9ybWFsaXplZFkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjEwIGluIGZhdm9yIG9mIGNvbmZpZy5kYXRhQ2VsbC55LiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFDZWxsLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgcmVmZXJlbmNlZCBoZXJlIHNvIGl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIHRoZSBjZWxsIHJlbmRlcmVycy5cbiAgICAgKiBAZGVmYXVsdCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmV4ZWN8ZXhlY31cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGV4ZWM6IGV4ZWMsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpeGVkQ29sdW1uQ291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGZpeGVkUm93Q291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzaG93Um93TnVtYmVyczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHNob3dUcmVlQ29sdW1uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2hvd0hlYWRlclJvdzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHNob3dGaWx0ZXJSb3c6IGZhbHNlLFxuXG5cbiAgICAvKiogQ2xpY2tpbmcgaW4gYSBjZWxsIFwic2VsZWN0c1wiIGl0OyBpdCBpcyBhZGRlZCB0byB0aGUgc2VsZWN0IHJlZ2lvbiBhbmQgcmVwYWludGVkIHdpdGggXCJjZWxsIHNlbGVjdGlvblwiIGNvbG9ycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjZWxsU2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgY29sdW1uIGhlYWRlciAodG9wIHJvdykgXCJzZWxlY3RzXCIgdGhlIGNvbHVtbjsgdGhlIGVudGlyZSBjb2x1bW4gaXMgYWRkZWQgdG8gdGhlIHNlbGVjdCByZWdpb24gYW5kIHJlcGFpbnRlZCB3aXRoIFwiY29sdW1uIHNlbGVjdGlvblwiIGNvbG9ycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5TZWxlY3Rpb246IHRydWUsXG5cbiAgICAvKiogQ2xpY2tpbmcgaW4gYSByb3cgaGVhZGVyIChsZWZ0bW9zdCBjb2x1bW4pIFwic2VsZWN0c1wiIHRoZSByb3c7IHRoZSBlbnRpcmUgcm93IGlzIGFkZGVkIHRvIHRoZSBzZWxlY3QgcmVnaW9uIGFuZCByZXBhaW50ZWQgd2l0aCBcInJvdyBzZWxlY3Rpb25cIiBjb2xvcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93U2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2luZ2xlUm93U2VsZWN0aW9uTW9kZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZpbGwgY29sb3IgZm9yIGxhc3Qgc2VsZWN0aW9uIG92ZXJsYXkuXG4gICAgICogQGRlc2MgVGhlIGNvbG9yIHNob3VsZCBiZSB0cmFuc2x1Y2VudCAob3IgdHJhbnNwYXJlbnQpLiBOb3RlIHRoYXQgXCJQYXJ0aWFsXCIgZ3JpZCByZW5kZXJlcnMgKHN1Y2ggYXMgdGhlIHtAbGluayBwYWludENlbGxzQXNOZWVkZWR9IHJlbmRlcmVyKSBkbyBub3QgZHJhdyBvdmVybGF5IGJlY2F1c2UgaXQganVzdCBnZXRzIGRhcmtlciBhbmQgZGFya2VyIGZvciBub24tdXBkYXRlZCBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc2VsZWN0aW9uUmVnaW9uT3ZlcmxheUNvbG9yOiAndHJhbnNwYXJlbnQnLCAvLyAncmdiYSgwLCAwLCA0OCwgMC4yKScsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTdHJva2UgY29sb3IgZm9yIGxhc3Qgc2VsZWN0aW9uIG92ZXJsYXkuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25SZWdpb25PdXRsaW5lQ29sb3I6ICdyZ2IoNjksIDY5LCA2OSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgY29sdW1uQXV0b3NpemluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJvd051bWJlckF1dG9zaXppbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBoZWFkZXJUZXh0V3JhcHBpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcm93UmVzaXplOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGVkaXRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZmlsdGVyYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCBvbmx5IGJ5IEZpbHRlckJveCBjZWxsIGVkaXRvci5cbiAgICAgKiBPbmUgb2Y6XG4gICAgICogKiAqKmAnb25Db21taXQnYCoqIC0gQ29sdW1uIGZpbHRlciBzdGF0ZSBub3Qgc2V0IHVudGlsIGtleXVwID09PSBgXFxyYCAocmV0dXJuL2VudGVyIGtleSlcbiAgICAgKiAqICoqYCdpbW1lZGlhdGUnYCoqIC0gQ29sdW1uIGZpbHRlciBzdGF0ZSBzZXQgb24gZWFjaCBrZXkgcHJlc3NcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBmaWx0ZXJpbmdNb2RlOiAnb25Db21taXQnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZWRpdE9uRG91YmxlQ2xpY2s6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGRvdWJsZUNsaWNrRGVsYXk6IDMyNSxcblxuICAgIC8qKlxuICAgICAqIEdyaWQtbGV2ZWwgcHJvcGVydHkuXG4gICAgICogV2hlbiB1c2VyIHByZXNzZXMgYSBcInByaW50YWJsZVwiIGtleWJvYXJkIGNoYXJhY3RlciBfb3JfIEJBQ0tTUEFDRSBfb3JfIERFTEVURTpcbiAgICAgKiAxLiBBY3RpdmF0ZSBjZWxsIGVkaXRvciBvbiBjdXJyZW50IGNlbGwgKGkuZS4sIG9yaWdpbiBvZiBtb3N0IHJlY2VudCBzZWxlY3Rpb24pLlxuICAgICAqIDIuIElmIGNlbGwgZWRpdG9yIGlzIGEgdGV4dCBlZGl0b3I6XG4gICAgICogICAgMS4gUmVwbGFjZSBjdXJyZW50IHZhbHVlIHdpdGggdGhlIGNoYXJhY3RlciB0aGUgdXNlciB0eXBlZDsgb3JcbiAgICAgKiAgICAyLiBDbGVhciBpdCBvbiBCQUNLU1BBQ0UsIERFTEVURSwgb3Igb3RoZXIgaW52YWxpZCBjaGFyYWN0ZXIgKF9lLmcuXyB3aGVuIHVzZXIgdHlwZXMgYSBsZXR0ZXIgYnV0IHRoZSBjZWxsIGVkaXRvciBvbmx5IGFjY2VwdHMgZGlnaXRzKS5cbiAgICAgKlxuICAgICAqID4gSW4gaW52b2tlZCwgdXNlciBoYXMgdGhlIG9wdGlvbiB0byBiYWNrIG91dCBieSBwcmVzc2luZyB0aGUgRVNDQVBFIGtleS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGVkaXRPbktleWRvd246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBPcGVuIGNlbGwgZWRpdG9yIHdoZW4gY2VsbCBzZWxlY3RlZCB2aWEga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICAgKiBAZGVzYyBLZXlib2FyZCBuYXZpZ2F0aW9uIGFsd2F5cyBpbmNsdWRlczpcbiAgICAgKiAxLiBUaGUgZm91ciBhcnJvdyBrZXlzIC0tIGJ1dCBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIHRleHQgY2VsbCBlZGl0b3Igb3BlblxuICAgICAqIDIuIEFkZGl0aW9uYWwga2V5cyBtYXBwZWQgdG8gdGhlIGZvdXIgZGlyZWN0cyBpbiB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLm5hdktleU1hcH1cbiAgICAgKlxuICAgICAqIEdlbmVyYWxseSBzZXQgYXQgdGhlIGdyaWQgbGV2ZWwuIElmIHNldCBhdCB0aGUgY29sdW1uIChvciBjZWxsKSBsZXZlbCwgbm90ZSB0aGF0IHRoZSBwcm9wZXJ0eSBwZXJ0YWlucyB0byB0aGUgY2VsbCBuYXZpZ2F0ZWQgX3RvLF8gbm90IHRoZSBjZWxsIG5hdmlnYXRlZCBfYXdheSBmcm9tLl9cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBlZGl0T25OZXh0Q2VsbDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXRhaW4gcm93IHNlbGVjdGlvbnMuXG4gICAgICogQGRlc2MgV2hlbiBmYWxzeSwgcm93IHNlbGVjdGlvbnMgYXJlIGNsZWFyZWQgd2hlbiBzZWxlY3RpbmcgY2VsbHM7IHdoZW4gdHJ1dGh5LCByb3cgc2VsZWN0aW9ucyBhcmUga2VwdCBhcyBpcyB3aGVuIHNlbGVjdGluZyBjZWxscy5cbiAgICAgKiBAdG9kbyBEZXByZWNhdGUgaW4gZmF2b3Igb2Ygc29tZXRoaW5nIHNpbXBsZXIgbGlrZSBga2VlcFJvd1NlbGVjdGlvbnNgLiAoVGhlIGN1cnJlbnQgbmFtZSBpcyBtaXNsZWFkaW5nIGFuZCBoYXMgY2F1c2VkIHNvbWUgY29uZnVzaW9uIGFtb25nIGJvdGggZGV2ZWxvcGVycyBhbmQgdXNlcnMuIEF0IHRoZSB2ZXJ5IGxlYXN0IGl0IHNob3VsZCBoYXZlIGJlZW4gY2FsbGVkIGBjaGVja2JveE9ubHlSb3dEZXNlbGVjdGlvbnNgLilcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNlbGVjdCBjZWxsJ3MgZW50aXJlIHJvdy5cbiAgICAgKiBAZGVzYyBXaGVuIHRydXRoeSwgc2VsZWN0aW5nIGEgY2VsbCB3aWxsIGFsc28gc2VsZWN0IHRoZSBlbnRpcmUgcm93IGl0IGlzIGluLCBzdWJqZWN0IHRvIG5vdGUgIzEgYmVsb3cuXG4gICAgICpcbiAgICAgKiBOb3RlczpcbiAgICAgKiAxLiBJbmVmZmVjdHVhbCB1bmxlc3MgYGNoZWNrYm94T25seVJvd1NlbGVjdGlvbnNgIGlzIHNldCB0byBgZmFsc2VgLlxuICAgICAqIDIuIFRvIGFsbG93IGF1dG8tc2VsZWN0aW9uIG9mIF9tdWx0aXBsZSByb3dzLF8gc2V0IGBzaW5nbGVSb3dTZWxlY3Rpb25Nb2RlYCB0byBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgYXV0b1NlbGVjdFJvd3M6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2VsZWN0IGNlbGwncyBlbnRpcmUgY29sdW1uLlxuICAgICAqIEBkZXNjIFdoZW4gdHJ1dGh5LCBzZWxlY3RpbmcgYSBjZWxsIHdpbGwgYWxzbyBzZWxlY3QgdGhlIGVudGlyZSBjb2x1bW4gaXQgaXMgaW4uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgYXV0b1NlbGVjdENvbHVtbnM6IGZhbHNlLFxuXG4gICAgLyoqIEBzdW1tYXJ5IE5hbWUgb2YgYSBmb3JtYXR0ZXIgZm9yIGNlbGwgdGV4dC5cbiAgICAgKiBAZGVzYyBUaGUgZGVmYXVsdCAoYHVuZGVmaW5lZGApIGZhbGxzIGJhY2sgdG8gYGNvbHVtbi50eXBlYC5cbiAgICAgKiBUaGUgdmFsdWUgYG51bGxgIGRvZXMgbm8gZm9ybWF0dGluZy5cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAdHlwZSB7dW5kZWZpbmVkfG51bGx8c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKiBAdHV0b3JpYWwgbG9jYWxpemF0aW9uXG4gICAgICovXG4gICAgZm9ybWF0OiB1bmRlZmluZWQsXG5cbiAgICAvKiogQHN1bW1hcnkgTmFtZSBvZiBhIGNlbGwgZWRpdG9yIGZyb20gdGhlIHtAbGluayBtb2R1bGU6Y2VsbEVkaXRvcnN8Y2VsbEVkaXRvcnMgQVBJfS4uXG4gICAgICogQGRlc2MgTm90IGVkaXRhYmxlIGlmIG5hbWVkIGVkaXRvciBpcyBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAdHlwZSB7dW5kZWZpbmVkfG51bGx8c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKiBAdHV0b3JpYWwgY2VsbC1lZGl0b3JzXG4gICAgICovXG4gICAgZWRpdG9yOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIGNlbGwgcmVuZGVyZXIgZnJvbSB0aGUge0BsaW5rIG1vZHVsZTpjZWxsUmVuZGVyZXJzfGNlbGxSZW5kZXJlcnMgQVBJfS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHJlbmRlcmVyOiAnU2ltcGxlQ2VsbCcsXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIGdyaWQgcmVuZGVyZXIuXG4gICAgICogUmVuZGVyZXIgbXVzdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICAgKiBAc2VlIHtAbGluayBSZW5kZXJlciNyZWdpc3RlckdyaWRSZW5kZXJlcn0uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZXI6ICdieS1jb2x1bW5zLWFuZC1yb3dzJyxcblxuICAgIC8qKioqKioqKioqIEhPVkVSIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLyoqIEB0eXBlZGVmIGhvdmVyQ29sb3JzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZW5hYmxlPWZhbHNlXSAtIGBmYWxzZWAgbWVhbnMgbm90IGhpbGl0ZSBvbiBob3ZlclxuICAgICAqIEBwcm9wZXJ0eSB7Y3NzQ29sb3J9IGJhY2tncm91bmRDb2xvciAtIGNlbGwsIHJvdywgb3IgY29sdW1uIGJhY2tncm91bmQgY29sb3IuIEFscGhhIGNoYW5uZWwgd2lsbCBiZSByZXNwZWN0ZWQgYW5kIGlmIGdpdmVuIHdpbGwgYmUgcGFpbnRlZCBvdmVyIHRoZSBjZWxscyBwcmVkZXRlcm1pbmVkIGNvbG9yLlxuICAgICAqIEBwcm9wZXJ0eSB7Y3NzQ29sb3J9IFtoZWFkZXIuYmFja2dyb3VuZENvbG9yPWJhY2tncm91bmRDb2xvcl0gLSBmb3IgY29sdW1ucyBhbmQgcm93cywgdGhpcyBpcyB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgY29sdW1uIG9yIHJvdyBcImhhbmRsZVwiIChoZWFkZXIgcm93cyBvciBjb2x1bW5zLCByZXNwZWN0aXZlbHkpLiAoTm90IHVzZWQgZm9yIGNlbGxzLilcbiAgICAgKi9cblxuICAgIC8qKiBPbiBtb3VzZSBob3Zlciwgd2hldGhlciB0byByZXBhaW50IHRoZSBjZWxsIGJhY2tncm91bmQgYW5kIGhvdy5cbiAgICAgKiBAdHlwZSB7aG92ZXJDb2xvcnN9XG4gICAgICogQGRlZmF1bHQgJ3sgZW5hYmxlZDogdHJ1ZSwgYmFja2dyb3VuZDogcmdiYSgxNjAsIDE2MCwgNDAsIDAuMzApIH0nXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGhvdmVyQ2VsbEhpZ2hsaWdodDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDE2MCwgMTYwLCA0MCwgMC40NSknXG4gICAgfSxcblxuICAgIC8qKiBPbiBtb3VzZSBob3Zlciwgd2hldGhlciB0byByZXBhaW50IHRoZSByb3cgYmFja2dyb3VuZCBhbmQgaG93LlxuICAgICAqIEB0eXBlIHtob3ZlckNvbG9yc31cbiAgICAgKiBAZGVmYXVsdCAneyBlbmFibGVkOiB0cnVlLCBiYWNrZ3JvdW5kOiByZ2JhKDEwMCwgMTAwLCAyNSwgMC4xNSkgfSdcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgaG92ZXJSb3dIaWdobGlnaHQ6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgxMDAsIDEwMCwgMjUsIDAuMzApJ1xuXG4gICAgfSxcblxuICAgIC8qKiBPbiBtb3VzZSBob3Zlciwgd2hldGhlciB0byByZXBhaW50IHRoZSBjb2x1bW4gYmFja2dyb3VuZCBhbmQgaG93LlxuICAgICAqIEB0eXBlIHtob3ZlckNvbG9yc31cbiAgICAgKiBAZGVmYXVsdCAneyBlbmFibGVkOiB0cnVlLCBiYWNrZ3JvdW5kOiByZ2JhKDYwLCA2MCwgMTUsIDAuMTUpIH0nXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGhvdmVyQ29sdW1uSGlnaGxpZ2h0OiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNjAsIDYwLCAxNSwgMC4xNSknXG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBEaXNwbGF5IGNlbGwgdmFsdWUgYXMgYSBsaW5rICh3aXRoIHVuZGVybGluZSkuXG4gICAgICogQGRlc2MgT25lIG9mOlxuICAgICAqICogYGJvb2xlYW5gIC0gTm8gYWN0aW9uIG9jY3VycyBvbiBjbGljazsgeW91IHdvdWxkIG5lZWQgdG8gYXR0YWNoIGEgJ2Zpbi1jbGljaycgbGlzdGVuZXIgdG8gdGhlIGh5cGVyZ3JpZCBvYmplY3QuXG4gICAgICogICAqIGB0cnVlYCAtIERpc3BsYXlzIHRoZSBjZWxsIGFzIGEgbGluay5cbiAgICAgKiAgICogX2ZhbHN5XyAtIERpc3BsYXlzIHRoZSBjZWxsIG5vcm1hbGx5LlxuICAgICAqICogYHN0cmluZ2AgLSAgVGhlIFVSTCBpcyBkZWNvcmF0ZWQgKHNlZSB7fSkgYW5kIHRoZW4gb3BlbmVkIGluIGEgc2VwYXJhdGUgd2luZG93L3RhYi4gU2VlIGFsc28ge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5saW5rVGFyZ2V0fGxpbmtUYXJnZXR9LlxuICAgICAqICAgKiBgJyonYCAtIFVzZSB0aGUgY2VsbCB2YWx1ZSBhcyB0aGUgVVJMLCByZWFkeSBmb3IgZGVjb3JhdGluZyAoc2VlIHtDZWxsQ2xpY2sjb3Blbkxpbmt8b3BlbkxpbmspKS5cbiAgICAgKiAgICogX2ZpZWxkIG5hbWVfIC0gRmV0Y2hlcyB0aGUgc3RyaW5nIGZyb20gdGhlIG5hbWVkIGZpZWxkIGluIHRoZSBzYW1lIHJvdywgYXNzdW1lZCB0byBiZSBhIFVSTCByZWFkeSBmb3IgZGVjb3JhdGluZy4gKE1heSBjb250YWluIG9ubHkgYWxwaGFudW1lcmljcyBhbmQgdW5kZXJzY29yZTsgbm8gc3BhY2VzIG9yIG90aGVyIHB1bmN0dWF0aW9uLilcbiAgICAgKiAgICogX290aGVyd2lzZV8gQXNzdW1lZCB0byBjb250YWlucyBhIFVSTCByZWFkeSBmb3IgZGVjb3JhdGluZy5cbiAgICAgKiAqIGBmdW5jdGlvbmAgLSBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgdG8gZ2V0IHRoZSBVUkwgcmVhZHkgZm9yIGRlY29yYXRpbmcuIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgYSBzaW5nbGUgcGFyYW1ldGVyLCBgY2VsbEV2ZW50YCwgZnJvbSB3aGljaCB5b3UgY2FuIGdldCB0aGUgZmllbGQgYG5hbWVgLCBgZGF0YVJvd2AsIF9ldGMuX1xuICAgICAqICogYEFycmF5YCAtIEFuIGFycmF5IHRvIFwiYXBwbHlcIiB0byB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9vcGVuIHdpbmRvdy5vcGVufSBpbiBpdHMgZW50aXJldHkuIFRoZSBmaXJzdCBlbGVtZW50IGlzIGludGVycHJldGVkIGFzIGFib3ZlIGZvciBgc3RyaW5nYCBvciBgZnVuY3Rpb25gLlxuICAgICAqXG4gICAgICogSW4gdGhlIGNhc2Ugb2YgYHN0cmluZ2Agb3IgYEFycmF5YCwgdGhlIGxpbmsgaXMgZnVydGhlciB1bnBhY2tlZCBieSB7QGxpbmsgbW9kdWxlOkNlbGxDbGljay5vcGVuTGlua3xvcGVuTGlua30gYW5kIHRoZW4gc2VudCB0byBgZ3JpZC53aW5kb3dPcGVuYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZm9sbG93aW5nIGFmZmVjdCB1cHBlci1sZWZ0IGRhdGEgY2VsbDpcbiAgICAgKiBncmlkLmJlaGF2aW9yLnNldENlbGxQcm9wZXJ0eSgwLCAwLCAnaHR0cHM6Ly9ueXRpbWVzLmNvbScpOyAvLyBhYnNvbHV0ZSBhZGRyZXNzIHVzaW5nIHNwZWNpZmljIHByb3RvY29sXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgJy8vbnl0aW1lcy5jb20nKTsgLy8gYWJzb2x1dGUgYWRkcmVzcyB1c2luZyBjdXJyZW50IHByb3RvY29sXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgJy9wYWdlMi5jb20nKTsgLy8gcmVsYXRpdmUgdG8gY3VycmVudCBzaXRlXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgJ215cGFnZS5jb20nKTsgLy8gcmVsYXRpdmUgdG8gY3VycmVudCBwYWdlXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgJ215cGFnZS5jb20/aWQ9JXZhbHVlJyk7IC8vIGNlbGwncyB2YWx1ZSB3aWxsIHJlcGxhY2UgJXZhbHVlXG4gICAgICogZ3JpZC5iZWhhdmlvci5zZXRDZWxsUHJvcGVydHkoMCwgMCwgWycvL3d3dy5uZXd5b3JrZXIuY29tJywgJ255JywgdW5kZWZpbmVkLCB0cnVlXSkgLy8gdGFyZ2V0PSdueScsIHJlcGxhY2U9dHJ1ZVxuICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ3xBcnJheX1cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBsaW5rOiBmYWxzZSxcblxuICAgIC8qKiBAc3VtbWFyeSBUaGUgd2luZG93IChvciB0YWIpIGluIHdoaWNoIHRvIG9wZW4gdGhlIGxpbmsuXG4gICAgICogQGRlc2MgVGhlIGRlZmF1bHQgKCdfYmxhbmsnYCkgd2lsbCBvcGVuIGEgbmV3IHdpbmRvdyBmb3IgZXZlcnkgY2xpY2suXG4gICAgICpcbiAgICAgKiBUbyBoYXZlIHRoZSBmaXJzdCBjbGljayBvcGVuIGEgbmV3IHdpbmRvdyBhbmQgYWxsIHN1YnNlcXVlbnQgY2xpY2tzIHJldXNlIHRoYXQgc2FtZSB3aW5kb3csIHNldCB0aGlzIHRvIGFuIGFyYml0cmFyeSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBPdGhlcndpc2UsIHNwZWNpZmljIGNvbHVtbnMgb3IgY2VsbHMgY2FuIGJlIHNldCB0byBvcGVuIHRoZWlyIGxpbmtzIGluIHRoZWlyIG93biB3aW5kb3cgYnkgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGUgY29sdW1uJ3Mgb3IgY2VsbCdzIGBsaW5rVGFyZ2V0YCBwcm9wZXJ0eS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBsaW5rVGFyZ2V0OiAnX2JsYW5rJyxcblxuICAgIC8qKiBAc3VtbWFyeSBVbmRlcmxpbmUgbGluayBvbiBob3ZlciBvbmx5LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGxpbmtPbkhvdmVyOiBmYWxzZSxcblxuICAgIC8qKiBAc3VtbWFyeSBDb2xvciBmb3IgbGluay5cbiAgICAgKiBAZGVzYyBGYWxzeSBtZWFucyBkZWZlciB0byBmb3JlZ3JvdW5kIGNvbG9yLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGlua0NvbG9yOiAnYmx1ZScsXG5cbiAgICAvKiogQHN1bW1hcnkgQ29sb3IgZm9yIHZpc2l0ZWQgbGluay5cbiAgICAgKiBAZGVzYyBGYWxzeSBtZWFucyBkZWZlciB0byBmb3JlZ3JvdW5kIGNvbG9yLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgbGlua1Zpc2l0ZWRDb2xvcjogJ3B1cnBsZScsXG5cbiAgICAvKiogQHN1bW1hcnkgQ29sb3IgbGluayBvbiBob3ZlciBvbmx5LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIGxpbmtDb2xvck9uSG92ZXI6IGZhbHNlLFxuXG4gICAgLyoqIERpc3BsYXkgY2VsbCBmb250IHdpdGggc3RyaWtlLXRocm91Z2ggbGluZSBkcmF3biBvdmVyIGl0LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHN0cmlrZVRocm91Z2g6IGZhbHNlLFxuXG4gICAgLyoqIElnbm9yZSBzb3J0IGludGVyYWN0aW9uIChkb3VibGUtY2xpY2spLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIHVuc29ydGFibGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgc29ydE9uSGlkZGVuQ29sdW1uczogdHJ1ZSxcblxuICAgIC8qKiBBbGxvdyBtdWx0aXBsZSBjZWxsIHJlZ2lvbiBzZWxlY3Rpb25zLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICAgICAqL1xuICAgIG11bHRpcGxlU2VsZWN0aW9uczogZmFsc2UsXG5cbiAgICAvKiogQHN1bW1hcnkgUmUtcmVuZGVyIGdyaWQgYXQgbWF4aW11bSBzcGVlZC5cbiAgICAgKiBAZGVzYyBJbiB0aGlzIG1vZGU6XG4gICAgICogKiBUaGUgXCJkaXJ0eVwiIGZsYWcsIHNldCBieSBjYWxsaW5nIGBncmlkLnJlcGFpbnQoKWAsIGlzIGlnbm9yZWQuXG4gICAgICogKiBgZ3JpZC5nZXRDYW52YXMoKS5jdXJyZW50RlBTYCBpcyBhIG1lYXN1cmUgb2YgdGhlIG51bWJlciB0aW1lcyB0aGUgZ3JpZCBpcyBiZWluZyByZS1yZW5kZXJlZCBlYWNoIHNlY29uZC5cbiAgICAgKiAqIFRoZSBIeXBlcmdyaWQgcmVuZGVyZXIgZ29iYmxlcyB1cCBDUFUgdGltZSBldmVuIHdoZW4gdGhlIGdyaWQgYXBwZWFycyBpZGxlICh0aGUgdmVyeSBzY2VuYXJpbyBgcmVwYWludCgpYCBpcyBkZXNpZ25lZCB0byBhdm9pZCkuIEZvciB0aGlzIHJlYXNvbiwgd2UgZW1waGF0aWNhbGx5IGFkdmlzZSBhZ2FpbnN0IHNoaXBwaW5nIGFwcGxpY2F0aW9ucyB1c2luZyB0aGlzIG1vZGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgZW5hYmxlQ29udGludW91c1JlcGFpbnQ6IGZhbHNlLFxuXG4gICAgLyoqIEBzdW1tYXJ5IEFsbG93IHVzZXIgdG8gbW92ZSBjb2x1bW5zIC5cbiAgICAgKiBAZGVzYyBDb2x1bW5zIGNhbiBiZSByZW9yZGVyZWQgdGhyb3VnaCBlaXRoZXIgb2YgdHdvIGludGVyZmFjZXM6XG4gICAgICogKiBDb2x1bW4gRHJhZ2dpbmcgZmVhdHVyZVxuICAgICAqICogYmVoYXZpb3IuY29sdW1ucyBBUElcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5zUmVvcmRlcmFibGU6IHRydWUsXG5cbiAgICAvKiogQHN1bW1hcnkgQXBwbHkgY2VsbCBwcm9wZXJ0aWVzIGJlZm9yZSBgZ2V0Q2VsbGAuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgYXBwbHlDZWxsUHJvcGVydGllczogdHJ1ZSxcblxuICAgIC8qKiBAc3VtbWFyeSBSZWFwcGx5IGNlbGwgcHJvcGVydGllcyBhZnRlciBgZ2V0Q2VsbGAuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgcmVhcHBseUNlbGxQcm9wZXJ0aWVzOiBmYWxzZSxcblxuICAgIC8qKiBAc3VtbWFyeSBDb2x1bW4gZ3JhYiB3aXRoaW4gdGhpcyBudW1iZXIgb2YgcGl4ZWxzIGZyb20gdG9wIG9mIGNlbGwuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5HcmFiTWFyZ2luOiA1LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFNldCB1cCBhIGNsaXBwaW5nIHJlZ2lvbiBhcm91bmQgZWFjaCBjb2x1bW4gYmVmb3JlIHBhaW50aW5nIGNlbGxzLlxuICAgICAqIEBkZXNjIE9uZSBvZjpcbiAgICAgKiAqIGB0cnVlYCAtIENsaXAgY29sdW1uLlxuICAgICAqICogYGZhbHNlYCAtIERvIG5vdCBjbGlwIGNvbHVtbi5cbiAgICAgKiAqIGBudWxsYCAtIENsaXAgaWZmIGxhc3QgYWN0aXZlIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIENsaXBwaW5nIHByZXZlbnRzIHRleHQgdGhhdCBvdmVyZmxvd3MgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjZWxsIGZyb20gYmVpbmcgcmVuZGVyZWQuXG4gICAgICogSWYgeW91IGNhbiBndWFyYW50ZWUgdGhhdCBub25lIG9mIHlvdXIgdGV4dCB3aWxsIG92ZXJmbG93LCB0dXJuIGNvbHVtbiBjbGlwcGluZyBvZmZcbiAgICAgKiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLiBJZiBub3QsIHlvdSBtYXkgc3RpbGwgYmUgYWJsZSB0byBnZXQgYXdheSB3aXRob3V0IGNsaXBwaW5nLlxuICAgICAqIElmIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBuZXh0IGNvbHVtbiBpcyBvcGFxdWUsIHlvdSBkb24ndCByZWFsbHkgbmVlZCB0byBjbGlwLFxuICAgICAqIGFsdGhvdWdoIHRleHQgY2FuIGxlYWsgb3V0IHRvIHRoZSByaWdodCBvZiB0aGUgbGFzdCBjb2x1bW4uIENsaXBwaW5nIHRoZSBsYXN0IGNvbHVtblxuICAgICAqIG9ubHkgY2FuIGhlbHAgdGhpcyBidXQgbm90IHNvbHZlIGl0IHNpbmNlIHRoZSBsZWFrZWQgdGV4dCBmcm9tIChzYXkpIHRoZSBjb2x1bW4gYmVmb3JlXG4gICAgICogdGhlIGxhc3QgY29sdW1uIGNvdWxkIHN0cmV0Y2ggYWNyb3NzIHRoZSBlbnRpcmUgbGFzdCBjb2x1bW4gYW5kIGxlYWsgb3V0IGFueXdheS5cbiAgICAgKiBUaGUgc29sdXRpb24gdG8gdGhpcyBpcyB0byBjbGlwIHRoZSByZW5kZXJlZCBzdHJpbmcgc28gYXQgbW9zdCBvbmx5IGEgcGFydGlhbCBjaGFyYWN0ZXJcbiAgICAgKiB3aWxsIG92ZXJmbG93LlxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICBjb2x1bW5DbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVwZWF0aW5nIHBhdHRlcm4gb2YgcHJvcGVydHkgb3ZlcnJpZGVzIGZvciBncmlkIHJvd3MuXG4gICAgICogQGRlc2MgTm90ZXM6XG4gICAgICogKiBcIkdyaWQgcm93XCIgcmVmZXJzIHRvIGRhdGEgcm93cy5cbiAgICAgKiAqIFJvdyBpbmRleCBtb2R1bG8gaXMgYXBwbGllZCB3aGVuIGRlcmVmZXJlbmNpbmcgdGhpcyBhcnJheS4gSW4gb3RoZXIgd29yZHMsIHRoaXMgYXJyYXkgcmVwcmVzZW50cyBhIF9yZXBlYXRpbmcgcGF0dGVybl8gb2YgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBkYXRhIHJvd3MuXG4gICAgICogKiBGb3Igbm8gcm93IHByb3BlcnRpZXMsIHNwZWNpZnkgYSBmYWxzeSB2YWx1ZSBpbiBwbGFjZSBvZiB0aGUgYXJyYXkuXG4gICAgICogKiBEbyBub3Qgc3BlY2lmeSBhbiBlbXB0eSBhcnJheSAod2lsbCB0aHJvdyBhbiBlcnJvcikuXG4gICAgICogKiBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IG1heSBiZSBlaXRoZXI6XG4gICAgICogICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnR5IG92ZXJyaWRlcyB0byBiZSBhcHBsaWVkIHRvIGV2ZXJ5IGNlbGwgb2YgdGhlIHJvdzsgb3JcbiAgICAgKiAgICogQSBmYWxzeSB2YWx1ZSBzaWduaWZ5aW5nIHRoYXQgdGhlcmUgYXJlIG5vIHJvdyBwcm9wZXJ0aWVzIGZvciB0aGlzIHNwZWNpZmljIHJvdy5cbiAgICAgKiAqIENhdmVhdDogUm93IHByb3BlcnRpZXMgdXNlIGBPYmplY3QuYXNzaWduKClgIHRvIGNvcHkgcHJvcGVydGllcyBhbmQgdGhlcmVmb3JlIGFyZSBub3QgYXMgcGVyZm9ybWFudCBhcyBjb2x1bW4gcHJvcGVydGllcyB3aGljaCB1c2UgcHJvdG90eXBlIGNoYWluLlxuICAgICAqICogYE9iamVjdC5hc3NpZ24oKWAgaXMgYSBwb2x5ZmlsbCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgKDw0NSkgYW5kIGluIGFsbCBJbnRlcm5ldCBFeHBsb3JlciAodGhyb3VnaCAxMSkuXG4gICAgICogQHR5cGUge3VuZGVmaW5lZHxvYmplY3RbXX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAgICAgKi9cbiAgICByb3dQcm9wZXJ0aWVzOiB1bmRlZmluZWQsXG5cbiAgICAvKiogQHN1bW1hcnkgSG93IHRvIHRydW5jYXRlIHRleHQuXG4gICAgICogQGRlc2MgQSBcInF1YXRlcm5hcnlcIiB2YWx1ZSwgb25lIG9mOlxuICAgICAqICogYHVuZGVmaW5lZGAgLSBUZXh0IGlzIG5vdCB0cnVuY2F0ZWQuXG4gICAgICogKiBgdHJ1ZWAgKGRlZmF1bHQpIC0gVHJ1bmNhdGUgc3VmZmljaWVudCBjaGFyYWN0ZXJzIHRvIGZpdCBlbGxpcHNpcyBpZiBwb3NzaWJsZS4gTW9zdCBhY2NlcHRhYmxlIG9wdGlvbiB0aGF0IGF2b2lkcyBuZWVkIGZvciBjbGlwcGluZy5cbiAgICAgKiAqIGBmYWxzZWAgLSBUcnVuY2F0ZSAqYmVmb3JlKiBsYXN0IHBhcnRpYWxseSB2aXNpYmxlIGNoYXJhY3Rlci4gVmlzaWJseSBhbm5veWluZzsgc2VtYW50aWNhbGx5IGphcnJpbmcuXG4gICAgICogKiBgbnVsbGAgLSBUcnVuY2F0ZSAqYWZ0ZXIqIHBhcnRpYWxseSB2aXNpYmxlIGNoYXJhY3Rlci4gTGVzcyB2aXNpYmx5IGFubm95aW5nOyBzdGlsbCBzZW1hbnRpY2FsbHkgY29uZnVzaW5nLiBCZXN0IHNvbHV0aW9uIHdoZW4gY29tYmluZWQgd2l0aCBlaXRoZXIgY29sdW1uIGNsaXBwaW5nIG9yIHBhaW50aW5nIG92ZXIgd2l0aCBuZXh0IGNvbHVtbidzIGJhY2tncm91bmQuXG4gICAgICogQHR5cGUge2Jvb2xlYW58bnVsbHx1bmRlZmluZWR9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRlZmF1bHRzXG4gICAgICovXG4gICAgdHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzOiB0cnVlXG59O1xuXG4vKiogQHR5cGVkZWYge3N0cmluZ30gY3NzQ29sb3JcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlXG4gKi9cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfSBjc3NGb250XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKi9cblxuZnVuY3Rpb24gZXhlYyh2Zikge1xuICAgIGlmICh0aGlzLmRhdGFSb3cpIHtcbiAgICAgICAgdmFyIGNhbGN1bGF0b3IgPSAodHlwZW9mIHZmKVswXSA9PT0gJ2YnICYmIHZmIHx8IHRoaXMuY2FsY3VsYXRvcjtcbiAgICAgICAgaWYgKGNhbGN1bGF0b3IpIHtcbiAgICAgICAgICAgIHZmID0gY2FsY3VsYXRvcih0aGlzLmRhdGFSb3csIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogTk9URVxuICpcbiAqIFdoYXQgdGhpcyBmaWxlIGlzOlxuICogKiBUaGlzIGZpbGUgaXMgYnJvd3NlcmlmeSdzIGVudHJ5IHBvaW50LlxuICogKiBUaGlzIGZpbGUgY3JlYXRlcyB0aGUgYHdpbmRvdy5maW4uSHlwZXJncmlkYCBvYmplY3QuXG4gKlxuICogV2hhdCB0aGlzIGZpbGUgaXMgbm90OlxuICogKiBUaGlzIGZpbGUgaXMgbm90IGEgbm9kZSBtb2R1bGU7IGl0IGhhcyBubyByZWZlcmVuY2UgdG8gYG1vZHVsZS5leHBvcnRzYCBvciBgZXhwb3J0c2A7IGl0IGNhbm5vdCBiZSBcInJlcXVpcmVkXCIgYnkgYW55IG90aGVyIGZpbGUuXG4gKiAqIFRoaXMgZmlsZSBpcyBibGFja2xpc3RlZCBpbiAubnBtaWdub3JlIGFuZCBpcyBub3QgcHVibGlzaGVkIHRvIG5wbS5cbiAqXG4gKiBOb3RlOiBUaGUgbnBtIFwibWFpblwiIGVudHJ5IHBvaW50IGlzIHVuZGVmaW5lZCBpbiBwYWNrYWdlLmpzb24gaW1wbHlpbmcgL2luZGV4LmpzLlxuICovXG5cbnZhciBIeXBlcmdyaWQgPSByZXF1aXJlKCcuL0h5cGVyZ3JpZCcpO1xuXG5IeXBlcmdyaWQuYW5hbHl0aWNzID0gcmVxdWlyZSgnaHlwZXItYW5hbHl0aWNzJyk7IC8vIG5wbVxuLy8gSHlwZXJncmlkLmFuYWx5dGljcyA9IHJlcXVpcmUoJy4uLy4uL2h5cGVyLWFuYWx5dGljcycpOyAvLyBkZXZlbG9wZXJcblxuLy8gRXhwb3NlIHNvbWUgbmFtZXNwYWNlcyB0byB1c2VycyBvZiB0aGUgaHlwZXJncmlkLmpzIGZpbGUgdGhyb3VnaCBgZmluLkh5cGVyZ3JpZGA6XG5IeXBlcmdyaWQuaW1hZ2VzID0gcmVxdWlyZSgnLi4vaW1hZ2VzJyk7XG5IeXBlcmdyaWQuYmVoYXZpb3JzID0gcmVxdWlyZSgnLi9iZWhhdmlvcnMnKTtcbkh5cGVyZ3JpZC5kYXRhTW9kZWxzID0gcmVxdWlyZSgnLi9kYXRhTW9kZWxzJyk7XG5IeXBlcmdyaWQuZmVhdHVyZXMgPSByZXF1aXJlKCcuL2ZlYXR1cmVzJyk7XG5IeXBlcmdyaWQucmVjdGFuZ3VsYXIgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpO1xuSHlwZXJncmlkLmxpYiA9IHJlcXVpcmUoJy4vbGliJyk7XG5IeXBlcmdyaWQuc3R5bGVzaGVldCA9IHJlcXVpcmUoJy4vbGliL3N0eWxlc2hlZXQnKTtcbkh5cGVyZ3JpZC5iYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5cbi8vIENyZWF0ZSB0aGUgYGZpbmAgbmFtZXNwYWNlIGFuZCB0aGUgYGZpbi5IeXBlcmdyaWRgIG9iamVjdHM6XG4od2luZG93LmZpbiA9IHdpbmRvdy5maW4gfHwge30pLkh5cGVyZ3JpZCA9IEh5cGVyZ3JpZDtcblxuLy8gTm90ZSB1c2VycyBvZiB0aGUgbnBtIG1vZHVsZSBkbyBub3QgaGF2ZSB0aGlzIG9iamVjdC5cbi8vIFRIZXkgaGF2ZSBhY2Nlc3MgdG8gYW55IG5hbWVzcGFjZSB0aHJvdWdoIGByZXF1aXJlYCwgZm9yIGV4YW1wbGU6XG4vLyB2YXIgYmVoYXZpb3JKU09OID0gcmVxdWlyZSgnZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0pTT04nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENlbGxDbGljayA9IEZlYXR1cmUuZXh0ZW5kKCdDZWxsQ2xpY2snLCB7XG5cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBsaW5rID0gZXZlbnQucHJvcGVydGllcy5saW5rLFxuICAgICAgICAgICAgaXNBY3Rpb25hYmxlTGluayA9IGxpbmsgJiYgdHlwZW9mIGxpbmsgIT09ICdib29sZWFuJzsgLy8gYWN0aW9uYWJsZSB3aXRoIHRydXRoeSBvdGhlciB0aGFuIGB0cnVlYFxuXG4gICAgICAgIHRoaXMuY3Vyc29yID0gaXNBY3Rpb25hYmxlTGluayA/ICdwb2ludGVyJyA6IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBDZWxsQ2xpY2sjXG4gICAgICovXG4gICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBjb25zdW1lZCA9IGV2ZW50LmlzRGF0YUNlbGwgJiYgKFxuICAgICAgICAgICAgdGhpcy5vcGVuTGluayhncmlkLCBldmVudCkgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgZ3JpZC5jZWxsQ2xpY2tlZChldmVudClcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIWNvbnN1bWVkICYmIHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBPcGVuIHRoZSBjZWxsJ3MgVVJMLlxuICAgICAqXG4gICAgICogQGRlc2MgVGhlIFVSTCBpcyBmb3VuZCBpbiB0aGUgY2VsbCdzIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubGlua3xsaW5rfSBwcm9wZXJ0eSwgd2hpY2ggc2VydmVzIHR3byBmdW5jdGlvbnM6XG4gICAgICogMS4gKipSZW5kZXJzIGFzIGEgbGluay4qKiBXaGVuIHRydXRoeSBjYXVzZXMge0BsaW5rIFNpbXBsZUNlbGx9IGNlbGwgcmVuZGVyZXIgdG8gcmVuZGVyIHRoZSBjZWxsIHVuZGVybGluZWQgd2l0aCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmxpbmtDb2xvcnxsaW5rQ29sb3J9LiAoU2VlIGFsc28ge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5saW5rT25Ib3ZlcnxsaW5rT25Ib3Zlcn0gYW5kIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubGlua0NvbG9yT25Ib3ZlcnxsaW5rQ29sb3JPbkhvdmVyfS4pIFRoZXJlZm9yZSwgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGB0cnVlYCB3aWxsIHJlbmRlciBhcyBhIGxpbmssIGFsdGhvdWdoIGNsaWNraW5nIG9uIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3QuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3aXNoIHRvIGhhbmRsZSB0aGUgY2xpY2sgeW91cnNlbGYgYnkgYXR0YWNoaW5nIGEgYCdmaW4tY2xpY2snYCBsaXN0ZW5lciB0byB5b3VyIGh5cGVyZ3JpZC5cbiAgICAgKiAyLiAqKkZldGNoIHRoZSBVUkwuKiogVGhlIHZhbHVlIG9mIHRoZSBsaW5rIHByb3BlcnR5IGlzIGludGVycHJldGVkIGFzIHBlciB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmxpbmt8bGlua30uXG4gICAgICogMy4gKipEZWNvcmF0ZSB0aGUgVVJMLioqIFRoZSBjZWxsIG5hbWUgKF9pLmUuLF8gdGhlIGRhdGEgY29sdW1uIG5hbWUpIGFuZCBjZWxsIHZhbHVlIGFyZSBtZXJnZWQgaW50byB0aGUgVVJMIHdoZXJldmVyIHRoZSByZXNwZWN0aXZlIHN1YnN0cmluZ3MgYCclbmFtZSdgIGFuZCBgJyV2YWx1ZSdgIGFyZSBmb3VuZC4gRm9yIGV4YW1wbGUsIGlmIHRoZSBjb2x1bW4gbmFtZSBpcyBcImFnZVwiIGFuZCB0aGUgY2VsbCB2YWx1ZSBpcyA2IChvciBhIGZ1bmN0aW9uIHJldHVybmluZyAyNSksIGFuZCB0aGUgbGluayBpcyBgJ2h0dHA6Ly93d3cuYWJjLmNvbT8lbmFtZT0ldmFsdWUnYCwgdGhlbiB0aGUgYWN0dWFsIGxpbmsgKGZpcnN0IGFyZ3VtZW50IGdpdmVuIHRvIGBncmlkLndpbmRvd09wZW5gKSB3b3VsZCBiZSBgJ2h0dHA6Ly93d3cuYWJjLmNvbT9hZ2U9MjUnYC5cbiAgICAgKiA0LiAqKk9wZW4gdGhlIFVSTC4qKiBUaGUgbGluayBpcyB0aGVuIG9wZW5lZCBieSB7QGxpbmsgSHlwZXJncmlkI3dpbmRvd09wZW58Z3JpZC53aW5kb3dPcGVufS4gSWYgYGxpbmtgIGlzIGFuIGFycmF5LCBpdCBpcyBcImFwcGxpZWRcIiB0byBgZ3JpZC53aW5kb3dPcGVuYCBpbiBpdHMgZW50aXJldHk7IG90aGVyd2lzZSwgYGdyaWQud2luZG93T3BlbmAgaXMgY2FsbGVkIHdpdGggdGhlIGxpbmsgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLmxpbmtUYXJnZXR8bGlua1RhcmdldH0gYXMgdGhlIHNlY29uZC5cbiAgICAgKiA1LiAqKkRlY29yYXRlIHRoZSBsaW5rLioqIE9uIHN1Y2Nlc3NmdWwgcmV0dXJuIGZyb20gYHdpbmRvd09wZW4oKWAsIHRoZSB0ZXh0IGlzIGNvbG9yZWQgYXMgXCJ2aXNpdGVkXCIgYXMgcGVyIHRoZSBjZWxsJ3Mge0BsaW5rIG1vZHVsZTpkZWZhdWx0cy5saW5rVmlzaXRlZENvbG9yfGxpbmtWaXNpdGVkQ29sb3J9IHByb3BlcnR5IChieSBzZXR0aW5nIHRoZSBjZWxsJ3MgYGxpbmtDb2xvcmAgcHJvcGVydHkgdG8gaXRzIGBsaW5rVmlzaXRlZENvbG9yYCBwcm9wZXJ0eSkuXG5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBjZWxsRXZlbnQgLSBFdmVudCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58d2luZG93fG51bGx8dW5kZWZpbmVkfSBPbmUgb2Y6XG4gICAgICpcbiAgICAgKiB8IFZhbHVlIHwgTWVhbmluZyB8XG4gICAgICogfCA6LS0tLSB8IDotLS0tLS0gfFxuICAgICAqIHwgYHVuZGVmaW5lZGAgfCBubyBsaW5rIHRvIG9wZW4gfFxuICAgICAqIHwgYG51bGxgIHwgYGdyaWQud2luZG93T3BlbmAgZmFpbGVkIHRvIG9wZW4gYSB3aW5kb3cgfFxuICAgICAqIHwgX290aGVyd2lzZV8gfCBBIGB3aW5kb3dgIHJlZmVyZW5jZSByZXR1cm5lZCBieSBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBgZ3JpZC53aW5kb3dPcGVuYC4gfFxuICAgICAqXG4gICAgICogQG1lbWJlck9mIENlbGxDbGljayNcbiAgICAgKi9cbiAgICBvcGVuTGluazogZnVuY3Rpb24oZ3JpZCwgY2VsbEV2ZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQsIHVybCxcbiAgICAgICAgICAgIGRhdGFSb3cgPSBjZWxsRXZlbnQuZGF0YVJvdyxcbiAgICAgICAgICAgIGNvbmZpZyA9IE9iamVjdC5jcmVhdGUoY2VsbEV2ZW50LnByb3BlcnRpZXMsIHsgZGF0YVJvdzogeyB2YWx1ZTogZGF0YVJvdyB9IH0pLFxuICAgICAgICAgICAgdmFsdWUgPSBjb25maWcuZXhlYyhjZWxsRXZlbnQudmFsdWUpLFxuICAgICAgICAgICAgbGlua1Byb3AgPSBjZWxsRXZlbnQucHJvcGVydGllcy5saW5rLFxuICAgICAgICAgICAgaXNBcnJheSA9IGxpbmtQcm9wIGluc3RhbmNlb2YgQXJyYXksXG4gICAgICAgICAgICBsaW5rID0gaXNBcnJheSA/IGxpbmtQcm9wWzBdIDogbGlua1Byb3A7XG5cbiAgICAgICAgLy8gU1RFUCAyOiBGZXRjaCB0aGUgVVJMXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGxpbmspIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9eXFx3KyQvLnRlc3QobGluaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gZGF0YVJvd1tsaW5rXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICB1cmwgPSBsaW5rKGNlbGxFdmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAvLyBTVEVQIDM6IERlY29yYXRlIHRoZSBVUkxcbiAgICAgICAgICAgIHVybCA9IHVybC50b1N0cmluZygpLnJlcGxhY2UoLyVuYW1lL2csIGNvbmZpZy5uYW1lKS5yZXBsYWNlKC8ldmFsdWUvZywgdmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBTVEVQIDQ6IE9wZW4gdGhlIFVSTFxuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsaW5rUHJvcCA9IGxpbmtQcm9wLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgbGlua1Byb3BbMF0gPSB1cmw7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZ3JpZC53aW5kb3dPcGVuLmFwcGx5KGdyaWQsIGxpbmtQcm9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZ3JpZC53aW5kb3dPcGVuKHVybCwgY2VsbEV2ZW50LnByb3BlcnRpZXMubGlua1RhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDU6IERlY29yYXRlIHRoZSBsaW5rIGFzIFwidmlzaXRlZFwiXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGNlbGxFdmVudC5zZXRDZWxsUHJvcGVydHkoJ2xpbmtDb2xvcicsIGdyaWQucHJvcGVydGllcy5saW5rVmlzaXRlZENvbG9yKTtcbiAgICAgICAgICAgIGdyaWQucmVuZGVyZXIucmVzZXRDZWxsUHJvcGVydGllc0NhY2hlKGNlbGxFdmVudCk7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsQ2xpY2s7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4uL2NlbGxFZGl0b3JzL0NlbGxFZGl0b3InKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENlbGxFZGl0aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NlbGxFZGl0aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5wcm9wZXJ0aWVzLmVkaXRPbkRvdWJsZUNsaWNrICYmXG4gICAgICAgICAgICBldmVudC5pc0RhdGFDZWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ3JpZC5vbkVkaXRvckFjdGl2YXRlKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFncmlkLnByb3BlcnRpZXMuZWRpdE9uRG91YmxlQ2xpY2sgJiZcbiAgICAgICAgICAgIGV2ZW50LmlzRGF0YUNlbGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIEtleVBhZ2luZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgY2hhciwgaXNWaXNpYmxlQ2hhciwgaXNEZWxldGVDaGFyLCBlZGl0b3IsIGNlbGxFdmVudDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoY2VsbEV2ZW50ID0gZ3JpZC5nZXRHcmlkQ2VsbEZyb21MYXN0U2VsZWN0aW9uKCkpICYmXG4gICAgICAgICAgICBjZWxsRXZlbnQucHJvcGVydGllcy5lZGl0T25LZXlkb3duICYmXG4gICAgICAgICAgICAhZ3JpZC5jZWxsRWRpdG9yICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgKGNoYXIgPSBldmVudC5kZXRhaWwuY2hhcikgPT09ICdGMicgfHxcbiAgICAgICAgICAgICAgICAoaXNWaXNpYmxlQ2hhciA9IGNoYXIubGVuZ3RoID09PSAxICYmICEoZXZlbnQuZGV0YWlsLm1ldGEgfHwgZXZlbnQuZGV0YWlsLmN0cmwpKSB8fFxuICAgICAgICAgICAgICAgIChpc0RlbGV0ZUNoYXIgPSBjaGFyID09PSAnREVMRVRFJyB8fCBjaGFyID09PSAnQkFDS1NQQUNFJylcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBlZGl0b3IgPSBncmlkLm9uRWRpdG9yQWN0aXZhdGUoY2VsbEV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGVkaXRvciBpbnN0YW5jZW9mIENlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaW5wdXQudmFsdWUgPSBjaGFyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWxldGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JWYWx1ZSgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LmRldGFpbC5wcmltaXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENlbGxTZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbFNlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBkeCA9IGV2ZW50LmdyaWRDZWxsLngsXG4gICAgICAgICAgICBkeSA9IGV2ZW50LmRhdGFDZWxsLnksXG4gICAgICAgICAgICBpc1NlbGVjdGFibGUgPSBncmlkLmJlaGF2aW9yLmdldENlbGxQcm9wZXJ0eShldmVudC5kYXRhQ2VsbC54LCBldmVudC5ncmlkQ2VsbC55LCAnY2VsbFNlbGVjdGlvbicpO1xuXG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgZXZlbnQuaXNEYXRhQ2VsbCAmJiAhZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaykge1xuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludChkeCwgZHkpLFxuICAgICAgICAgICAgICAgIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIGtleXMgPSBwcmltRXZlbnQuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBrZXlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nICYmIGdyaWQucHJvcGVydGllcy5jZWxsU2VsZWN0aW9uICYmICFldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmFnID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBncmlkLm5ld1BvaW50KGV2ZW50LmdyaWRDZWxsLngsIGV2ZW50LmRhdGFDZWxsLnkpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0RyYWdTY3JvbGwoZ3JpZCwgdGhpcy5jdXJyZW50RHJhZyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgdGhpcy5sYXN0RHJhZ0NlbGwsIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZGV0YWlsID0gZXZlbnQuZGV0YWlsLFxuICAgICAgICAgICAgY2VsbEV2ZW50ID0gZ3JpZC5nZXRHcmlkQ2VsbEZyb21MYXN0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBuYXZLZXkgPSBjZWxsRXZlbnQgJiYgKFxuICAgICAgICAgICAgICAgIGNlbGxFdmVudC5wcm9wZXJ0aWVzLm1hcHBlZE5hdktleShkZXRhaWwuY2hhciwgZGV0YWlsLmN0cmwpIHx8XG4gICAgICAgICAgICAgICAgY2VsbEV2ZW50LnByb3BlcnRpZXMubmF2S2V5KGRldGFpbC5jaGFyLCBkZXRhaWwuY3RybClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpc1snaGFuZGxlJyArIG5hdktleV07XG5cbiAgICAgICAgLy8gU1RFUCAxOiBNb3ZlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBncmlkLCBkZXRhaWwpO1xuXG4gICAgICAgICAgICAvLyBTVEVQIDI6IE9wZW4gdGhlIGNlbGwgZWRpdG9yIGF0IHRoZSBuZXcgcG9zaXRpb24gaWYgaXQgaGFzIGBlZGl0T25OZXh0Q2VsbGAgYW5kIGlzIGBlZGl0YWJsZWBcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IGdyaWQuZ2V0R3JpZENlbGxGcm9tTGFzdFNlbGVjdGlvbigpOyAvLyBuZXcgY2VsbFxuICAgICAgICAgICAgaWYgKGNlbGxFdmVudC5wcm9wZXJ0aWVzLmVkaXRPbk5leHRDZWxsKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5lZGl0QXQoY2VsbEV2ZW50KTsgLy8gc3VjY2VlZHMgb25seSBpZiBgZWRpdGFibGVgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNURVAgMzogSWYgZWRpdG9yIG5vdCBvcGVuZWQgb24gbmV3IGNlbGwsIHRha2UgZm9jdXNcbiAgICAgICAgICAgIGlmICghZ3JpZC5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC50YWtlRm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgYSBtb3VzZWRyYWcgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5tYXgoMCwgZ3JpZENlbGwueCksXG4gICAgICAgICAgICB5ID0gTWF0aC5tYXgoMCwgZ3JpZENlbGwueSksXG4gICAgICAgICAgICBwcmV2aW91c0RyYWdFeHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKSxcbiAgICAgICAgICAgIG1vdXNlRG93biA9IGdyaWQuZ2V0TW91c2VEb3duKCksXG4gICAgICAgICAgICBuZXdYID0geCAtIG1vdXNlRG93bi54LFxuICAgICAgICAgICAgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcblxuICAgICAgICBpZiAocHJldmlvdXNEcmFnRXh0ZW50LnggPT09IG5ld1ggJiYgcHJldmlvdXNEcmFnRXh0ZW50LnkgPT09IG5ld1kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3QobW91c2VEb3duLngsIG1vdXNlRG93bi55LCBuZXdYLCBuZXdZKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGNoZWNrcyB3aGlsZSB3ZXJlIGRyYWdnaW5nIGlmIHdlIGdvIG91dHNpZGUgdGhlIHZpc2libGUgYm91bmRzLCBpZiBzbywga2ljayBvZmYgdGhlIGV4dGVybmFsIGF1dG9zY3JvbGwgY2hlY2sgZnVuY3Rpb24gKGFib3ZlKVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0RyYWdTY3JvbGw6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIGlmICghZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgaW5zaWRlID0gYi5jb250YWlucyhtb3VzZSk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIG91dHNpZGUgb2YgdGhlIGdyaWQgdmlzaWJsZSBib3VuZHMsIHdlIHNyY3JvbGwgYWNjb3JkaW5nbHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNjcm9sbERyYWc6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnU3RhcnRlZEluSGVhZGVyQXJlYSA9IGdyaWQuaXNNb3VzZURvd25JbkhlYWRlckFyZWEoKSxcbiAgICAgICAgICAgIGxhc3REcmFnQ2VsbCA9IHRoaXMubGFzdERyYWdDZWxsLFxuICAgICAgICAgICAgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpLFxuXG4gICAgICAgICAgICB4T2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIHlPZmZzZXQgPSAwLFxuXG4gICAgICAgICAgICBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpLFxuXG4gICAgICAgICAgICBkcmFnRW5kSW5GaXhlZEFyZWFYID0gbGFzdERyYWdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMsXG4gICAgICAgICAgICBkcmFnRW5kSW5GaXhlZEFyZWFZID0gbGFzdERyYWdDZWxsLnkgPCBudW1GaXhlZFJvd3M7XG5cbiAgICAgICAgaWYgKCFkcmFnU3RhcnRlZEluSGVhZGVyQXJlYSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA8IGIub3JpZ2luLngpIHtcbiAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55IDwgYi5vcmlnaW4ueSkge1xuICAgICAgICAgICAgICAgIHlPZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy54ID4gYi5vcmlnaW4ueCArIGIuZXh0ZW50LngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPiBiLm9yaWdpbi55ICsgYi5leHRlbnQueSkge1xuICAgICAgICAgICAgeU9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRYID0geE9mZnNldDtcbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WSA9IHlPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVgpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVkpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGxhc3REcmFnQ2VsbC5wbHVzWFkoZHJhZ0NlbGxPZmZzZXRYLCBkcmFnQ2VsbE9mZnNldFkpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgbGFzdERyYWdDZWxsLCBbXSk7IC8vIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2Nyb2xsRHJhZy5iaW5kKHRoaXMsIGdyaWQpLCAyNSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGV4dGVuZCBhIHNlbGVjdGlvbiBvciBjcmVhdGUgb25lIGlmIHRoZXJlIGlzbnQgeWV0XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JpZENlbGwgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID49IDAsXG4gICAgICAgICAgICBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+PSAwLFxuICAgICAgICAgICAgbW91c2VQb2ludCA9IGdyaWQuZ2V0TW91c2VEb3duKCksXG4gICAgICAgICAgICB4ID0gZ3JpZENlbGwueCwgLy8gLSBudW1GaXhlZENvbHVtbnMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgeSA9IGdyaWRDZWxsLnk7IC8vIC0gbnVtRml4ZWRSb3dzICsgc2Nyb2xsVG9wO1xuXG4gICAgICAgIC8vd2VyZSBvdXRzaWRlIG9mIHRoZSBncmlkIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3dlIGhhdmUgcmVwZWF0ZWQgYSBjbGljayBpbiB0aGUgc2FtZSBzcG90IGRlc2xlY3QgdGhlIHZhbHVlIGZyb20gbGFzdCB0aW1lXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhhc0NUUkwgJiZcbiAgICAgICAgICAgIHggPT09IG1vdXNlUG9pbnQueCAmJlxuICAgICAgICAgICAgeSA9PT0gbW91c2VQb2ludC55XG4gICAgICAgICkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQucG9wTW91c2VEb3duKCk7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzQ1RSTCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnNlbGVjdChtb3VzZVBvaW50LngsIG1vdXNlUG9pbnQueSwgeCAtIG1vdXNlUG9pbnQueCwgeSAtIG1vdXNlUG9pbnQueSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCh4IC0gbW91c2VQb2ludC54LCB5IC0gbW91c2VQb2ludC55KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLnNlbGVjdCh4LCB5LCAwLCAwKTtcbiAgICAgICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDAsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgLTEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURPV046IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8va2VlcCB0aGUgYnJvd3NlciB2aWV3cG9ydCBmcm9tIGF1dG8gc2Nyb2xsaW5nIG9uIGtleSBldmVudFxuICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbigpO1xuICAgICAgICBncmlkLm1vdmVTaW5nbGVTZWxlY3QoMCwgY291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8va2VlcCB0aGUgYnJvd3NlciB2aWV3cG9ydCBmcm9tIGF1dG8gc2Nyb2xsaW5nIG9uIGtleSBldmVudFxuICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbigpO1xuICAgICAgICBncmlkLm1vdmVTaW5nbGVTZWxlY3QoMCwgLWNvdW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgZ3JpZC5tb3ZlU2luZ2xlU2VsZWN0KC0xLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGdyaWQubW92ZVNpbmdsZVNlbGVjdCgxLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgc3RhcnQgdGltZSB0byByaWdodCBub3cgd2hlbiB3ZSBpbml0aWF0ZSBhbiBhdXRvIHNjcm9sbFxuICAgICAqL1xuICAgIHNldEF1dG9TY3JvbGxTdGFydFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNiQXV0b1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNoaWZ0U2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIGlmIChncmlkLmV4dGVuZFNlbGVjdChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsU2VsZWN0aW9uO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKiBnbG9iYWwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmZWF0dXJlIGlzIHJlc3BvbnNpYmxlIGZvciBjb2x1bW4gZHJhZyBhbmQgZHJvcCByZW9yZGVyaW5nLlxuLy8gVGhpcyBvYmplY3QgaXMgYSBtZXNzIGFuZCBkZXNwZXJhdGVseSBuZWVkcyBhIGNvbXBsZXRlIHJld3JpdGUuLi4uLlxuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG52YXIgY2FuRHJhZ0N1cnNvck5hbWUgPSAnLXdlYmtpdC1ncmFiJyxcbiAgICBkcmFnZ2luZ0N1cnNvck5hbWUgPSAnLXdlYmtpdC1ncmFiYmluZyc7XG5cbnZhciBjb2x1bW5BbmltYXRpb25UaW1lID0gMTUwO1xudmFyIGRyYWdnZXI7XG52YXIgZHJhZ2dlckNUWDtcbnZhciBmbG9hdENvbHVtbjtcbnZhciBmbG9hdENvbHVtbkNUWDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENvbHVtbk1vdmluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5Nb3ZpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBxdWV1ZSB1cCB0aGUgYW5pbWF0aW9ucyB0aGF0IG5lZWQgdG8gcGxheSBzbyB0aGV5IGFyZSBkb25lIHN5bmNocm9ub3VzbHlcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxvYXRlckFuaW1hdGlvblF1ZXVlOiBbXSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIHJpZ2h0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBhbSBJIGN1cnJlbnRseSBhdXRvIHNjcm9sbGluZyBsZWZ0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBkcmFnIG1lY2hhbmlzbSBjdXJyZW50bHkgZW5hYmxlZCAoXCJhcm1lZFwiKVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdBcm1lZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBhbSBJIGRyYWdnaW5nIHJpZ2h0IG5vd1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdnaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjb2x1bW4gaW5kZXggb2YgdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGNvbHVtblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0NvbDogLTEsXG5cbiAgICAvKipcbiAgICAgKiBhbiBvZmZzZXQgdG8gcG9zaXRpb24gdGhlIGRyYWdnZWQgaXRlbSBmcm9tIHRoZSBjdXJzb3JcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdPZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnaXZlIG1lIGFuIG9wcG9ydHVuaXR5IHRvIGluaXRpYWxpemUgc3R1ZmYgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVPbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLmlzRmxvYXRpbmdOb3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQW5pbWF0aW9uU3VwcG9ydChncmlkKTtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmluaXRpYWxpemVPbihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBpbml0aWFsaXplIGFuaW1hdGlvbiBzdXBwb3J0IG9uIHRoZSBncmlkXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplQW5pbWF0aW9uU3VwcG9ydDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWRyYWdnZXIpIHtcbiAgICAgICAgICAgIGRyYWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGRyYWdnZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcwcHgnKTtcbiAgICAgICAgICAgIGRyYWdnZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMHB4Jyk7XG4gICAgICAgICAgICBkcmFnZ2VyLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnZ2VyKTtcbiAgICAgICAgICAgIGRyYWdnZXJDVFggPSBkcmFnZ2VyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbG9hdENvbHVtbikge1xuICAgICAgICAgICAgZmxvYXRDb2x1bW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMHB4Jyk7XG4gICAgICAgICAgICBmbG9hdENvbHVtbi5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmbG9hdENvbHVtbik7XG4gICAgICAgICAgICBmbG9hdENvbHVtbkNUWCA9IGZsb2F0Q29sdW1uLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgLy92YXIgeTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuZHJhZ3N0YXJ0LnggLSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCk7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgMTAgfHwgZXZlbnQuaXNDb2x1bW5GaXhlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmlzSGVhZGVyQ2VsbCAmJiB0aGlzLmRyYWdBcm1lZCAmJiAhdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyYWdDb2wgPSBncmlkQ2VsbC54O1xuICAgICAgICAgICAgdGhpcy5kcmFnT2Zmc2V0ID0gZXZlbnQubW91c2VQb2ludC54O1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hDaGFpbigpO1xuICAgICAgICAgICAgeCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54IC0gdGhpcy5kcmFnT2Zmc2V0O1xuICAgICAgICAgICAgLy95ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURyYWdDb2x1bW4oZ3JpZCwgeCwgdGhpcy5kcmFnQ29sKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHggPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCAtIHRoaXMuZHJhZ09mZnNldDtcbiAgICAgICAgICAgIC8veSA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55O1xuICAgICAgICAgICAgdGhpcy5kcmFnQ29sdW1uKGdyaWQsIHgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQuYmVoYXZpb3IuaXNDb2x1bW5SZW9yZGVyYWJsZSgpICYmXG4gICAgICAgICAgICAhZXZlbnQuaXNDb2x1bW5GaXhlZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChldmVudC5pc0hlYWRlckNlbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBkcmFnZ2luZ0N1cnNvck5hbWU7XG4gICAgICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy92YXIgY29sID0gZXZlbnQuZ3JpZENlbGwueDtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIC8vZGVsYXkgaGVyZSB0byBnaXZlIG90aGVyIGV2ZW50cyBhIGNoYW5jZSB0byBiZSBkcm9wcGVkXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVuZERyYWdDb2x1bW4oZ3JpZCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnQ29sID0gLTE7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnQXJtZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncmlkLmJlaGF2aW9yLmlzQ29sdW1uUmVvcmRlcmFibGUoKSAmJlxuICAgICAgICAgICAgIWV2ZW50LmlzQ29sdW1uRml4ZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmRyYWdnaW5nICYmXG4gICAgICAgICAgICBldmVudC5pc0hlYWRlckNlbGwgJiZcbiAgICAgICAgICAgIGV2ZW50Lm1vdXNlUG9pbnQueSA8IGdyaWQucHJvcGVydGllcy5jb2x1bW5HcmFiTWFyZ2luXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBjYW5EcmFnQ3Vyc29yTmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmlzSGVhZGVyQ2VsbCAmJiB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IGRyYWdnaW5nQ3Vyc29yTmFtZTsgLy9tb3ZlJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGlzIHRoZSBtYWluIGV2ZW50IGhhbmRsZXIgdGhhdCBtYW5hZ2VzIHRoZSBkcmFnZ2luZyBvZiB0aGUgY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRyYWdnZWRUb1RoZVJpZ2h0IC0gYXJlIHdlIG1vdmluZyB0byB0aGUgcmlnaHRcbiAgICAgKi9cbiAgICBmbG9hdENvbHVtblRvOiBmdW5jdGlvbihncmlkLCBkcmFnZ2VkVG9UaGVSaWdodCkge1xuICAgICAgICB0aGlzLmZsb2F0aW5nTm93ID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdmlzaWJsZUNvbHVtbnMgPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBmbG9hdGVySW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHZhciBkcmFnZ2VySW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHZhciBoZHBpcmF0aW8gPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuaGRwaXJhdGlvO1xuXG4gICAgICAgIHZhciBkcmFnZ2VyU3RhcnRYO1xuICAgICAgICB2YXIgZmxvYXRlclN0YXJ0WDtcbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGRyYWdnZXJXaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoZHJhZ2dlckluZGV4KTtcbiAgICAgICAgdmFyIGZsb2F0ZXJXaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoZmxvYXRlckluZGV4KTtcblxuICAgICAgICB2YXIgbWF4ID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGRvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgZm9mZnNldCA9IDA7XG5cbiAgICAgICAgaWYgKGRyYWdnZXJJbmRleCA+PSBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBkb2Zmc2V0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxvYXRlckluZGV4ID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGZvZmZzZXQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdnZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgICAgICBkcmFnZ2VyU3RhcnRYID0gdmlzaWJsZUNvbHVtbnNbTWF0aC5taW4obWF4LCBkcmFnZ2VySW5kZXggLSBkb2Zmc2V0KV0ubGVmdDtcbiAgICAgICAgICAgIGZsb2F0ZXJTdGFydFggPSB2aXNpYmxlQ29sdW1uc1tNYXRoLm1pbihtYXgsIGZsb2F0ZXJJbmRleCAtIGZvZmZzZXQpXS5sZWZ0O1xuXG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuc3RhcnRYID0gKGRyYWdnZXJTdGFydFggKyBmbG9hdGVyV2lkdGgpICogaGRwaXJhdGlvO1xuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLnN0YXJ0WCA9IGRyYWdnZXJTdGFydFggKiBoZHBpcmF0aW87XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsb2F0ZXJTdGFydFggPSB2aXNpYmxlQ29sdW1uc1tNYXRoLm1pbihtYXgsIGZsb2F0ZXJJbmRleCAtIGZvZmZzZXQpXS5sZWZ0O1xuICAgICAgICAgICAgZHJhZ2dlclN0YXJ0WCA9IGZsb2F0ZXJTdGFydFggKyBkcmFnZ2VyV2lkdGg7XG5cbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5zdGFydFggPSBmbG9hdGVyU3RhcnRYICogaGRwaXJhdGlvO1xuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLnN0YXJ0WCA9IGRyYWdnZXJTdGFydFggKiBoZHBpcmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5zd2FwQ29sdW1ucyhkcmFnZ2VySW5kZXgsIGZsb2F0ZXJJbmRleCk7XG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleCA9IGZsb2F0ZXJJbmRleDtcbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLmNvbHVtbkluZGV4ID0gZHJhZ2dlckluZGV4O1xuXG5cbiAgICAgICAgdGhpcy5mbG9hdGVyQW5pbWF0aW9uUXVldWUudW5zaGlmdCh0aGlzLmRvQ29sdW1uTW92ZUFuaW1hdGlvbihncmlkLCBmbG9hdGVyU3RhcnRYLCBkcmFnZ2VyU3RhcnRYKSk7XG5cbiAgICAgICAgdGhpcy5kb0Zsb2F0ZXJBbmltYXRpb24oZ3JpZCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgbWFuaWZlc3QgdGhlIGNvbHVtbiBkcmFnIGFuZCBkcm9wIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZsb2F0ZXJTdGFydFggLSB0aGUgeCBzdGFydCBjb29yZGluYXRlIG9mIHRoZSBjb2x1bW4gdW5kZXJuZWF0aCB0aGF0IGZsb2F0cyBiZWhpbmQgdGhlIGRyYWdnZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRyYWdnZXJTdGFydFggLSB0aGUgeCBzdGFydCBjb29yZGluYXRlIG9mIHRoZSBkcmFnZ2VkIGNvbHVtblxuICAgICAqL1xuICAgIGRvQ29sdW1uTW92ZUFuaW1hdGlvbjogZnVuY3Rpb24oZ3JpZCwgZmxvYXRlclN0YXJ0WCwgZHJhZ2dlclN0YXJ0WCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gZmxvYXRDb2x1bW47XG4gICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGZsb2F0ZXJTdGFydFggKyAncHgsICcgKyAwICsgJ3B4KScpO1xuXG4gICAgICAgICAgICAvL2Quc3R5bGUud2Via2l0LXdlYmtpdC1UcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBmbG9hdGVyU3RhcnRYICsgJ3B4LCAnICsgMCArICdweCknO1xuICAgICAgICAgICAgLy9kLnN0eWxlLndlYmtpdC13ZWJraXQtVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZmxvYXRlclN0YXJ0WCArICdweCwgJyArIDAgKyAncHgpJztcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAoc2VsZi5pc1dlYmtpdCA/ICctd2Via2l0LScgOiAnJykgKyAndHJhbnNmb3JtICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UnKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBkcmFnZ2VyU3RhcnRYICsgJ3B4LCAnICsgLTIgKyAncHgpJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgLy9uZWVkIHRvIGNoYW5nZSB0aGlzIHRvIGtleSBmcmFtZXNcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5kb0Zsb2F0ZXJBbmltYXRpb24oZ3JpZCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaXNGbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY29sdW1uQW5pbWF0aW9uVGltZSArIDUwKTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgbWFuaWZlc3QgdGhlIGZsb2F0ZXIgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBkb0Zsb2F0ZXJBbmltYXRpb246IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxvYXRlckFuaW1hdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZmxvYXRlckFuaW1hdGlvblF1ZXVlLnBvcCgpO1xuICAgICAgICBhbmltYXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgY3JlYXRlIHRoZSBmbG9hdCBjb2x1bW4gYXQgY29sdW1uSW5kZXggdW5kZXJuZWF0aCB0aGUgZHJhZ2dlZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2lsbCBiZSBmbG9hdGluZ1xuICAgICAqL1xuICAgIGNyZWF0ZUZsb2F0Q29sdW1uOiBmdW5jdGlvbihncmlkLCBjb2x1bW5JbmRleCkge1xuXG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPCBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgpO1xuICAgICAgICB2YXIgY29sSGVpZ2h0ID0gZ3JpZC5kaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgZCA9IGZsb2F0Q29sdW1uO1xuICAgICAgICB2YXIgc3R5bGUgPSBkLnN0eWxlO1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBncmlkLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBzdHlsZS50b3AgPSAobG9jYXRpb24udG9wIC0gMikgKyAncHgnO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gbG9jYXRpb24ubGVmdCArICdweCc7XG5cbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IGdyaWQuZ2V0SGlEUEkoZmxvYXRDb2x1bW5DVFgpO1xuXG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIE1hdGgucm91bmQoY29sdW1uV2lkdGggKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBNYXRoLnJvdW5kKGNvbEhlaWdodCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgc3R5bGUuYm94U2hhZG93ID0gJzAgMTBweCAyMHB4IHJnYmEoMCwwLDAsMC4xOSksIDAgNnB4IDZweCByZ2JhKDAsMCwwLDAuMjMpJztcbiAgICAgICAgc3R5bGUud2lkdGggPSBjb2x1bW5XaWR0aCArICdweCc7IC8vTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAvIGhkcGlSYXRpbykgKyAncHgnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBjb2xIZWlnaHQgKyAncHgnOyAvL01hdGgucm91bmQoY29sSGVpZ2h0IC8gaGRwaVJhdGlvKSArICdweCc7XG4gICAgICAgIHN0eWxlLmJvcmRlclRvcCA9ICcxcHggc29saWQgJyArIGdyaWQucHJvcGVydGllcy5saW5lQ29sb3I7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IGdyaWQucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnNbY29sdW1uSW5kZXggLSBzY3JvbGxMZWZ0XS5sZWZ0ICogaGRwaVJhdGlvO1xuXG4gICAgICAgIGZsb2F0Q29sdW1uQ1RYLnNjYWxlKGhkcGlSYXRpbywgaGRwaVJhdGlvKTtcblxuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIgPSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICBjdHg6IGZsb2F0Q29sdW1uQ1RYLFxuICAgICAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbEhlaWdodCxcbiAgICAgICAgICAgIGhkcGlyYXRpbzogaGRwaVJhdGlvXG4gICAgICAgIH07XG5cbiAgICAgICAgc3R5bGUuekluZGV4ID0gJzQnO1xuICAgICAgICB0aGlzLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBzdGFydFggKyAncHgsICcgKyAtMiArICdweCknKTtcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gZHJhZ2dpbmdDdXJzb3JOYW1lO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiBmb3Igc2V0dGluZyBjcm9zcyBicm93c2VyIGNzcyBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGRlc2NyaXB0b25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICovXG4gICAgc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHk6IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdVByb3BlcnR5ID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICd3ZWJraXQnICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnTW96JyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ21zJyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ08nICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gSFRNTEVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGRlc2NyaXB0b25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICovXG4gICAgc2V0UHJvcDogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eSBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgZHJhZ2dlZCBjb2x1bW4gYXQgY29sdW1uSW5kZXggYWJvdmUgdGhlIGZsb2F0ZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2lsbCBiZSBmbG9hdGluZ1xuICAgICAqL1xuICAgIGNyZWF0ZURyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIHgsIGNvbHVtbkluZGV4KSB7XG5cbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IGdyaWQuZ2V0SGlEUEkoZHJhZ2dlckNUWCk7XG4gICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgpO1xuICAgICAgICB2YXIgY29sSGVpZ2h0ID0gZ3JpZC5kaXYuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgZCA9IGRyYWdnZXI7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgc3R5bGUgPSBkLnN0eWxlO1xuXG4gICAgICAgIHN0eWxlLnRvcCA9IGxvY2F0aW9uLnRvcCArICdweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBsb2NhdGlvbi5sZWZ0ICsgJ3B4JztcbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuODU7XG4gICAgICAgIHN0eWxlLmJveFNoYWRvdyA9ICcwIDE5cHggMzhweCByZ2JhKDAsMCwwLDAuMzApLCAwIDE1cHggMTJweCByZ2JhKDAsMCwwLDAuMjIpJztcbiAgICAgICAgLy9zdHlsZS56SW5kZXggPSAxMDA7XG4gICAgICAgIHN0eWxlLmJvcmRlclRvcCA9ICcxcHggc29saWQgJyArIGdyaWQucHJvcGVydGllcy5saW5lQ29sb3I7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IGdyaWQucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIE1hdGgucm91bmQoY29sSGVpZ2h0ICogaGRwaVJhdGlvKSArICdweCcpO1xuXG4gICAgICAgIHN0eWxlLndpZHRoID0gY29sdW1uV2lkdGggKyAncHgnOyAvL01hdGgucm91bmQoY29sdW1uV2lkdGggLyBoZHBpUmF0aW8pICsgJ3B4JztcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gY29sSGVpZ2h0ICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbEhlaWdodCAvIGhkcGlSYXRpbykgKyAncHgnO1xuXG4gICAgICAgIHZhciBzdGFydFggPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zW2NvbHVtbkluZGV4IC0gc2Nyb2xsTGVmdF0ubGVmdCAqIGhkcGlSYXRpbztcblxuICAgICAgICBkcmFnZ2VyQ1RYLnNjYWxlKGhkcGlSYXRpbywgaGRwaVJhdGlvKTtcblxuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIgPSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICBzdGFydEluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGN0eDogZHJhZ2dlckNUWCxcbiAgICAgICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWlnaHQsXG4gICAgICAgICAgICBoZHBpcmF0aW86IGhkcGlSYXRpb1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAncHgsIC01cHgpJyk7XG4gICAgICAgIHN0eWxlLnpJbmRleCA9ICc1JztcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gZHJhZ2dpbmdDdXJzb3JOYW1lO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyB0aGUgbWFpbiBkcmFnZ2luZyBsb2dpY1xuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBkcmFnQ29sdW1uOiBmdW5jdGlvbihncmlkLCB4KSB7XG5cbiAgICAgICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIG92ZXJseSBjb21wbGV4LCByZWZhY3RvciB0aGlzIGluIHRvIHNvbWV0aGluZyBtb3JlIHJlYXNvbmFibGVcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBhdXRvU2Nyb2xsaW5nTm93ID0gdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0IHx8IHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0O1xuXG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKGRyYWdnZXJDVFgpO1xuXG4gICAgICAgIHZhciBkcmFnQ29sdW1uSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG5cbiAgICAgICAgdmFyIG1pblggPSAwO1xuICAgICAgICB2YXIgbWF4WCA9IGdyaWQucmVuZGVyZXIuZ2V0RmluYWxWaXNpYmxlQ29sdW1uQm91bmRhcnkoKTtcbiAgICAgICAgeCA9IE1hdGgubWluKHgsIG1heFggKyAxNSk7XG4gICAgICAgIHggPSBNYXRoLm1heChtaW5YIC0gMTUsIHgpO1xuXG4gICAgICAgIC8vYW0gSSBhdCBteSBsb3dlciBib3VuZFxuICAgICAgICB2YXIgYXRNaW4gPSB4IDwgbWluWCAmJiBkcmFnQ29sdW1uSW5kZXggIT09IDA7XG5cbiAgICAgICAgLy9hbSBJIGF0IG15IHVwcGVyIGJvdW5kXG4gICAgICAgIHZhciBhdE1heCA9IHggPiBtYXhYO1xuXG4gICAgICAgIHZhciBkID0gZHJhZ2dlcjtcblxuICAgICAgICB0aGlzLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgKHNlbGYuaXNXZWJraXQgPyAnLXdlYmtpdC0nIDogJycpICsgJ3RyYW5zZm9ybSAnICsgMCArICdtcyBlYXNlLCBib3gtc2hhZG93ICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UnKTtcblxuICAgICAgICB0aGlzLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4ICsgJ3B4LCAnICsgLTEwICsgJ3B4KScpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG92ZXJDb2wgPSBncmlkLnJlbmRlcmVyLmdldENvbHVtbkZyb21QaXhlbFgoeCArIChkLndpZHRoIC8gMiAvIGhkcGlSYXRpbykpO1xuXG4gICAgICAgIGlmIChhdE1pbikge1xuICAgICAgICAgICAgb3ZlckNvbCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXRNYXgpIHtcbiAgICAgICAgICAgIG92ZXJDb2wgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRvQUZsb2F0ID0gZHJhZ0NvbHVtbkluZGV4ID4gb3ZlckNvbDtcbiAgICAgICAgZG9BRmxvYXQgPSBkb0FGbG9hdCB8fCAob3ZlckNvbCAtIGRyYWdDb2x1bW5JbmRleCA+PSAxKTtcblxuICAgICAgICBpZiAoZG9BRmxvYXQgJiYgIWF0TWF4ICYmICFhdXRvU2Nyb2xsaW5nTm93KSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dlZFRvVGhlUmlnaHQgPSBkcmFnQ29sdW1uSW5kZXggPCBvdmVyQ29sO1xuICAgICAgICAgICAgLy8gaWYgKGRyYWdnZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgICAgICAvLyAgICAgb3ZlckNvbCAtPSAxO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNGbG9hdGluZ05vdykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pc0Zsb2F0aW5nTm93ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRmxvYXRDb2x1bW4oZ3JpZCwgb3ZlckNvbCk7XG4gICAgICAgICAgICB0aGlzLmZsb2F0Q29sdW1uVG8oZ3JpZCwgZHJhZ2dlZFRvVGhlUmlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoeCA8IG1pblggLSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBdXRvU2Nyb2xsVG9MZWZ0KGdyaWQsIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPiBtaW5YIC0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9sZXRzIGNoZWNrIGZvciBhdXRvc2Nyb2xsIHRvIHJpZ2h0IGlmIHdlcmUgdXAgYWdhaW5zdCBpdFxuICAgICAgICAgICAgaWYgKGF0TWF4IHx8IHggPiBtYXhYICsgMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQXV0b1Njcm9sbFRvUmlnaHQoZ3JpZCwgeCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPCBtYXhYICsgMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhdXRvc2Nyb2xsIHRvIHRoZSByaWdodCBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICovXG4gICAgY2hlY2tBdXRvU2Nyb2xsVG9SaWdodDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9SaWdodChncmlkLCB4KTtcbiAgICB9LFxuXG4gICAgX2NoZWNrQXV0b1Njcm9sbFRvUmlnaHQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIGlmICghZ3JpZC5kcmFnZ2luZyB8fCBzY3JvbGxMZWZ0ID4gKGdyaWQuc2JIU2Nyb2xsZXIucmFuZ2UubWF4IC0gMikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhZ2dlZEluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICBncmlkLnNjcm9sbEJ5KDEsIDApO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSBkcmFnZ2VkSW5kZXggKyAxO1xuXG4gICAgICAgIGdyaWQuc3dhcENvbHVtbnMobmV3SW5kZXgsIGRyYWdnZWRJbmRleCk7XG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleCA9IG5ld0luZGV4O1xuXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9SaWdodC5iaW5kKHRoaXMsIGdyaWQsIHgpLCAyNTApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhdXRvc2Nyb2xsIHRvIHRoZSBsZWZ0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjaGVja0F1dG9TY3JvbGxUb0xlZnQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jaGVja0F1dG9TY3JvbGxUb0xlZnQoZ3JpZCwgeCk7XG4gICAgfSxcblxuICAgIF9jaGVja0F1dG9TY3JvbGxUb0xlZnQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICBpZiAoIWdyaWQuZHJhZ2dpbmcgfHwgc2Nyb2xsTGVmdCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhZ2dlZEluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICBncmlkLnN3YXBDb2x1bW5zKGRyYWdnZWRJbmRleCArIHNjcm9sbExlZnQsIGRyYWdnZWRJbmRleCArIHNjcm9sbExlZnQgLSAxKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSgtMSwgMCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9MZWZ0LmJpbmQodGhpcywgZ3JpZCwgeCksIDI1MCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGEgY29sdW1uIGRyYWcgaGFzIGNvbXBsZXRlZCwgdXBkYXRlIGRhdGEgYW5kIGNsZWFudXBcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGVuZERyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgdmFyIGNvbHVtbkluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhcnRYID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1uc1tjb2x1bW5JbmRleCAtIHNjcm9sbExlZnRdLmxlZnQ7XG4gICAgICAgIHZhciBkID0gZHJhZ2dlcjtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuc3RhcnRJbmRleCAhPT0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgKHNlbGYuaXNXZWJraXQgPyAnLXdlYmtpdC0nIDogJycpICsgJ3RyYW5zZm9ybSAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlLCBib3gtc2hhZG93ICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UnKTtcbiAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgc3RhcnRYICsgJ3B4LCAnICsgLTEgKyAncHgpJyk7XG4gICAgICAgIGQuc3R5bGUuYm94U2hhZG93ID0gJzBweCAwcHggMHB4ICM4ODg4ODgnO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIgPSBudWxsO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGdyaWQuZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbigpOyAvL2ludGVybmFsIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKXtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljT25Db2x1bW5zQ2hhbmdlZEV2ZW50KCk7IC8vcHVibGljIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBjb2x1bW5BbmltYXRpb25UaW1lICsgNTApO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5Nb3Zpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBDb2x1bW5SZXNpemluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5SZXNpemluZycsIHtcblxuICAgIC8qKlxuICAgICAqIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgd2hlcmUgdGhlIGRyYWcgd2FzIGluaXRpYXRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiAtMSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBzdGFydGluZyB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gd2UgYXJlIGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnU3RhcnRXaWR0aDogLTEsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSBtb3VzZSB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIHRoZSBtb3VzZSBldmVudCB0byBxdWVyeVxuICAgICAqL1xuICAgIGdldE1vdXNlVmFsdWU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybnMgdGhlIGluZGV4IG9mIHdoaWNoIGRpdmlkZXIgSSdtIG92ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvdmVyQXJlYURpdmlkZXI6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBsZWZ0TW9zdENvbHVtbkluZGV4ID0gZ3JpZC5wcm9wZXJ0aWVzLnNob3dSb3dOdW1iZXJzID8gLTEgOiAwO1xuICAgICAgICByZXR1cm4gZXZlbnQuZ3JpZENlbGwueCAhPT0gbGVmdE1vc3RDb2x1bW5JbmRleCAmJiBldmVudC5tb3VzZVBvaW50LnggPD0gMyB8fFxuICAgICAgICAgICAgZXZlbnQubW91c2VQb2ludC54ID49IGV2ZW50LmJvdW5kcy53aWR0aCAtIDM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGN1cnNvciBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtcmVzaXplJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdDb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHRoaXMuZ2V0TW91c2VWYWx1ZShldmVudCkgLSB0aGlzLmRyYWdTdGFydDtcbiAgICAgICAgICAgIGdyaWQuYmVoYXZpb3Iuc2V0Q29sdW1uV2lkdGgodGhpcy5kcmFnQ29sdW1uLCB0aGlzLmRyYWdTdGFydFdpZHRoICsgZGVsdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5pc0hlYWRlclJvdyAmJiB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCkpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5tb3VzZVBvaW50LnggPD0gMykge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5JbmRleCA9IGV2ZW50LmdyaWRDZWxsLnggLSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0NvbHVtbiA9IGdyaWQuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKGNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydFdpZHRoID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1uc1tjb2x1bW5JbmRleF0ud2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0NvbHVtbiA9IGV2ZW50LmNvbHVtbjtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydFdpZHRoID0gZXZlbnQuYm91bmRzLndpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydCA9IHRoaXMuZ2V0TW91c2VWYWx1ZShldmVudCk7XG4gICAgICAgICAgICB0aGlzLmRldGFjaENoYWluKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdDb2x1bW4pIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbHVtbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIC8vZGVsYXkgaGVyZSB0byBnaXZlIG90aGVyIGV2ZW50cyBhIGNoYW5jZSB0byBiZSBkcm9wcGVkXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBncmlkLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRhcmllcygpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaENoYWluKCk7XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ0NvbHVtbikge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gZXZlbnQuaXNIZWFkZXJSb3cgJiYgdGhpcy5vdmVyQXJlYURpdmlkZXIoZ3JpZCwgZXZlbnQpID8gdGhpcy5nZXRDdXJzb3JOYW1lKCkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR9IGNlbGxFdmVudFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmlzSGVhZGVyUm93ICYmIHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGV2ZW50Lm1vdXNlUG9pbnQueCA8PSAzXG4gICAgICAgICAgICAgICAgPyBncmlkLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihldmVudC5ncmlkQ2VsbC54IC0gMSlcbiAgICAgICAgICAgICAgICA6IGV2ZW50LmNvbHVtbjtcbiAgICAgICAgICAgIGNvbHVtbi5hZGRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBjb2x1bW5BdXRvc2l6aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbHVtbkF1dG9zaXplZDogZmFsc2UgLy8gdG9kbzogY29sdW1uQXV0b3NpemluZyBzaG91bGQgYmUgYSBzZXR0ZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHJlc2V0cyBjb2x1bW5BdXRvc2l6ZWQgb24gc3RhdGUgY2hhbmdlIHRvIHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgLy8gZG8gYWZ0ZXIgbmV4dCByZW5kZXIsIHdoaWNoIG1lYXN1cmVzIHRleHQgbm93IHRoYXQgYXV0by1zaXppbmcgaXMgb25cbiAgICAgICAgICAgICAgICBncmlkLmF1dG9zaXplQ29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblJlc2l6aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG4vKipcbiAqIEV4dHJhIG1zZWNzIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uIHdpdGggZmluY2FudmFzJ3MgZG91YmxlIGNsaWNrIHRpbWVyLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0dmFsdWUgNTBcbiAqIE5PVEU6IDUwIG1zZWNzIHNlZW1zIHRvIHdvcmsgd2VsbC4gMTAgYW5kIGV2ZW4gMjUgcHJvdmVkIGluc3VmZmljaWVudCBpbiBDaHJvbWUuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgUkFDRV9USU1FID0gNTA7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBDb2x1bW5TZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uU2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnREcmFnOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhvcml6b250YWwgY2VsbCBjb29yZGluYXRlIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ29sdW1uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkxhc3RBdXRvOiAwLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRpbWUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkF1dG9TdGFydDogMCxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRvdWJsZUNsaWNrVGltZXIpOyAvLyBwcmV2ZW50IG1vdXNlRG93biBmcm9tIGNvbnRpbnVpbmdcbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZG91YmxlQ2xpY2tUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9kbzogPj0gNSBkZXBlbmRzIG9uIGhlYWRlciBiZWluZyB0b3AtbW9zdCByb3cgd2hpY2ggaXMgY3VycmVudGx5IGFsd2F5cyB0cnVlIGJ1dCB3ZSBtYXkgYWxsb3cgaGVhZGVyIFwic2VjdGlvblwiIHRvIGJlIGFyYml0cmFyeSBwb3NpdGlvbiB3aXRoaW4gcXVhZHJhbnQgKHNlZSBhbHNvIGhhbmRsZU1vdXNlRG93biBpbiBDb2x1bW5Nb3ZpbmcuanMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQucHJvcGVydGllcy5jb2x1bW5TZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIGV2ZW50Lm1vdXNlUG9pbnQueSA+PSA1ICYmXG4gICAgICAgICAgICAhZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljayAmJlxuICAgICAgICAgICAgZXZlbnQuaXNIZWFkZXJDZWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gSE9MRCBPRkYgV0hJTEUgV0FJVElORyBGT1IgRE9VQkxFLUNMSUNLXG4gICAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBldmVudC5ncmlkQ2VsbC54LCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIGdyaWQucHJvcGVydGllcy5kb3VibGVDbGlja0RlbGF5ICsgUkFDRV9USU1FKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtblNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgIXRoaXMuaXNDb2x1bW5EcmFnZ2luZyhncmlkKSAmJlxuICAgICAgICAgICAgIWV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2sgJiZcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdDb2x1bW4gPSBldmVudC5ncmlkQ2VsbC54O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZyA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEcmFnU2Nyb2xsKGdyaWQsIHRoaXMuY3VycmVudERyYWcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIHRoaXMubGFzdERyYWdDb2x1bW4sIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSBldmVudC5kZXRhaWwsXG4gICAgICAgICAgICBoYW5kbGVyID0gZ3JpZC5nZXRMYXN0U2VsZWN0aW9uVHlwZSgpID09PSAnY29sdW1uJyAmJlxuICAgICAgICAgICAgICAgIHRoaXNbJ2hhbmRsZScgKyBkZXRhaWwuY2hhcl07XG5cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBncmlkLCBkZXRhaWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIGEgbW91c2VkcmFnIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIHgsIGtleXMpIHtcbiAgICAgICAgdmFyIG1vdXNlWCA9IGdyaWQuZ2V0TW91c2VEb3duKCkueDtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0Q29sdW1uKG1vdXNlWCwgeCk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KHggLSBtb3VzZVgsIDApKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGNoZWNrcyB3aGlsZSB3ZXJlIGRyYWdnaW5nIGlmIHdlIGdvIG91dHNpZGUgdGhlIHZpc2libGUgYm91bmRzLCBpZiBzbywga2ljayBvZmYgdGhlIGV4dGVybmFsIGF1dG9zY3JvbGwgY2hlY2sgZnVuY3Rpb24gKGFib3ZlKVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0RyYWdTY3JvbGw6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQucHJvcGVydGllcy5zY3JvbGxpbmdFbmFibGVkICYmXG4gICAgICAgICAgICBncmlkLmdldERhdGFCb3VuZHMoKS5jb250YWlucyhtb3VzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKSxcbiAgICAgICAgICAgIHhPZmZzZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA8IGIub3JpZ2luLngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPiBiLm9yaWdpbi54ICsgYi5leHRlbnQueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeE9mZnNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdERyYWdDb2x1bW4gPj0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmFnQ29sdW1uICs9IHhPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5KHhPZmZzZXQsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIHRoaXMubGFzdERyYWdDb2x1bW4sIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgeCwga2V5cykge1xuICAgICAgICBpZiAoIWdyaWQuYWJvcnRFZGl0aW5nKCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIG1vdXNlWCA9IGdyaWQuZ2V0TW91c2VEb3duKCkueCxcbiAgICAgICAgICAgIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpID4gMDtcblxuICAgICAgICBpZiAoeCA8IDApIHsgLy8gb3V0c2lkZSBvZiB0aGUgZ3JpZD9cbiAgICAgICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4oeCwgbW91c2VYKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KHggLSBtb3VzZVgsIDApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0Q29sdW1uKHgsIGtleXMpO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCAwKSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRE9XTjogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIC8vIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG4gICAgICAgIC8vIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICAvLyB2YXIgbmV3WCA9IG1vdXNlQ29ybmVyLng7XG4gICAgICAgIC8vIHZhciBuZXdZID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpICsgZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICAvLyBuZXdZID0gTWF0aC5taW4obWF4Um93cywgbmV3WSk7XG5cbiAgICAgICAgLy8gZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgLy8gZ3JpZC5zZWxlY3QobmV3WCwgbmV3WSwgMCwgMCk7XG4gICAgICAgIC8vIGdyaWQuc2V0TW91c2VEb3duKG5ldyBncmlkLnJlY3Rhbmd1bGFyLlBvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgLy8gZ3JpZC5zZXREcmFnRXh0ZW50KG5ldyBncmlkLnJlY3Rhbmd1bGFyLlBvaW50KDAsIDApKTtcblxuICAgICAgICAvLyBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVA6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgYXV0b3Njcm9sbCBzdGFydCB0aW1lIGlmIHdlIGhhdmVuJ3QgYXV0b3Njcm9sbGVkIHdpdGhpbiB0aGUgbGFzdCA1MDBtcyBvdGhlcndpc2UgdXBkYXRlIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgdGltZVxuICAgICAqL1xuICAgIHBpbmdBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbFN0YXJ0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2JMYXN0QXV0byA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCksXG4gICAgICAgICAgICBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKSxcbiAgICAgICAgICAgIG5ld1ggPSBleHRlbnQueCArIG9mZnNldFgsXG4gICAgICAgICAgICBtYXhWaWV3YWJsZUNvbHVtbnMgPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucHJvcGVydGllcy5zY3JvbGxpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gTWF0aC5taW4obWF4Q29sdW1ucywgbWF4Vmlld2FibGVDb2x1bW5zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zIC0gb3JpZ2luLngsIE1hdGgubWF4KC1vcmlnaW4ueCwgbmV3WCkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Q29sdW1uKG9yaWdpbi54LCBvcmlnaW4ueCArIG5ld1gpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCArIG9yaWdpbi54LCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpLFxuICAgICAgICAgICAgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZXh0ZW50KSxcbiAgICAgICAgICAgIG5ld1ggPSBtb3VzZUNvcm5lci54ICsgb2Zmc2V0WCxcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxLFxuICAgICAgICAgICAgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMsIE1hdGgubWF4KDAsIG5ld1gpKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihuZXdYKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbENvbElzVmlzaWJsZShuZXdYLCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIGlzQ29sdW1uRHJhZ2dpbmc6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIGRyYWdnZXIgPSBncmlkLmxvb2t1cEZlYXR1cmUoJ0NvbHVtbk1vdmluZycpO1xuICAgICAgICByZXR1cm4gZHJhZ2dlciAmJiBkcmFnZ2VyLmRyYWdnaW5nICYmICF0aGlzLmRyYWdnaW5nO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uU2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ29sdW1uU29ydGluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5Tb3J0aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNvcnRpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBjb2x1bW5Qcm9wZXJ0aWVzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudC5pc0hlYWRlckNlbGwgJiZcbiAgICAgICAgICAgIChjb2x1bW5Qcm9wZXJ0aWVzID0gZ3JpZC5iZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKGV2ZW50LmdyaWRDZWxsLngpKSAmJlxuICAgICAgICAgICAgIWNvbHVtblByb3BlcnRpZXMudW5zb3J0YWJsZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0NvbHVtblNvcnRFdmVudChldmVudC5ncmlkQ2VsbC54LCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Tb3J0aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBjb2x1bW5Qcm9wZXJ0aWVzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudC5pc1Jvd0ZpeGVkICYmXG4gICAgICAgICAgICBldmVudC5pc0hlYWRlckNlbGwgJiZcbiAgICAgICAgICAgIChjb2x1bW5Qcm9wZXJ0aWVzID0gZ3JpZC5iZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKGV2ZW50LmdyaWRDZWxsLngpKSAmJlxuICAgICAgICAgICAgIWNvbHVtblByb3BlcnRpZXMudW5zb3J0YWJsZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5Tb3J0aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcblxuLyoqXG4gKiBJbnN0YW5jZXMgb2YgZmVhdHVyZXMgYXJlIGNvbm5lY3RlZCB0byBvbmUgYW5vdGhlciB0byBtYWtlIGEgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkgZm9yIGhhbmRsaW5nIGFsbCB0aGUgaW5wdXQgdG8gdGhlIGh5cGVyZ3JpZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmVhdHVyZSA9IEJhc2UuZXh0ZW5kKCdGZWF0dXJlJywge1xuXG4gICAgLyoqXG4gICAgICogdGhlIG5leHQgZmVhdHVyZSB0byBiZSBnaXZlbiBhIGNoYW5jZSB0byBoYW5kbGUgaW5jb21pbmcgZXZlbnRzXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG5leHQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIHRlbXBvcmFyeSBob2xkaW5nIGZpZWxkIGZvciBteSBuZXh0IGZlYXR1cmUgd2hlbiBJJ20gaW4gYSBkaXNjb25uZWN0ZWQgc3RhdGVcbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgZGV0YWNoZWQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgY3Vyc29yIEkgd2FudCB0byBiZSBkaXNwbGF5ZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJzb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgY2VsbCBsb2NhdGlvbiB3aGVyZSB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseVxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudEhvdmVyQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCBteSBuZXh0IGZpZWxkLCBvciBpZiBpdCdzIHBvcHVsYXRlZCBkZWxlZ2F0ZSB0byB0aGUgZmVhdHVyZSBpbiBteSBuZXh0IGZpZWxkXG4gICAgICogQHBhcmFtIHtGZWF0dXJlfSBuZXh0RmVhdHVyZSAtIHRoaXMgaXMgaG93IHdlIGJ1aWxkIHRoZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBzZXROZXh0OiBmdW5jdGlvbihuZXh0RmVhdHVyZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuc2V0TmV4dChuZXh0RmVhdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkaXNjb25uZWN0IG15IGNoaWxkXG4gICAgICovXG4gICAgZGV0YWNoQ2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZWF0dGFjaCBteSBjaGlsZCBmcm9tIHRoZSBkZXRhY2hlZCByZWZlcmVuY2VcbiAgICAgKi9cbiAgICBhdHRhY2hDaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHRoaXMuZGV0YWNoZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSBtb3VzZSBtb3ZlIGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZUV4aXQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZUV4aXQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VFbnRlcjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRW50ZXIoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVXaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlV2hlZWxNb3ZlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZUNvbnRleHRNZW51OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ29udGV4dE1lbnUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRvZ2dsZSB0aGUgY29sdW1uIHBpY2tlclxuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCB4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpeGVkUm93OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2lzRml4ZWRSb3cnLCAnaXNGaXhlZFJvdyhncmlkLCBldmVudCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAgaW4gZmF2b3Igb2YgZXZlbnQuaXNSb3dGaXhlZC4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiknKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmlzUm93Rml4ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRSb3c6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5ncmlkQ2VsbC55IDwgMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgnaXNGaXhlZENvbHVtbicsICdpc0ZpeGVkQ29sdW1uKGdyaWQsIGV2ZW50KSBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHYxLjIuMCBpbiBmYXZvciBvZiBldmVudC5pc0NvbHVtbkZpeGVkLiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uKScpO1xuICAgICAgICByZXR1cm4gZXZlbnQuaXNDb2x1bW5GaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZENvbHVtbjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmdyaWRDZWxsLnggPT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc1RvcExlZnQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgnaXNUb3BMZWZ0JywgJ2lzVG9wTGVmdChncmlkLCBldmVudCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAgaW4gZmF2b3Igb2YgZXZlbnQuaXNDZWxsRml4ZWQuIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4pJyk7XG4gICAgICAgIHJldHVybiBldmVudC5pc0NlbGxGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBzZXRDdXJzb3I6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgIGdyaWQuYmVDdXJzb3IodGhpcy5jdXJzb3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5pbml0aWFsaXplT24oZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBGaWx0ZXJzID0gRmVhdHVyZS5leHRlbmQoJ0ZpbHRlcnMnLCB7XG5cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSBhd2F5IGZyb20gdGhlIGZpbHRlciBjZWxsIHdoZW46XG4gICAgICogMS4gQ29taW5nIGZyb20gYSBjZWxsIGVkaXRvciAoYGV2ZW50LmRldGFpbC5lZGl0b3JgIGRlZmluZWQpLlxuICAgICAqIDIuIFRoZSBjZWxsIGVkaXRvciB3YXMgZm9yIGEgZmlsdGVyIGNlbGwuXG4gICAgICogMy4gVGhlIGtleSAoYGV2ZW50LmRldGFpbC5jaGFyKSBtYXBzICh0aHJvdWdoIHtAbGluayBtb2R1bGU6ZGVmYXVsdHMubmF2S2V5TWFwfG5hdktleU1hcH0pIHRvIG9uZSBvZjpcbiAgICAgKiAgICAqIGAnVVAnYCBvciBgJ0RPV04nYCAtIFNlbGVjdHMgZmlyc3QgdmlzaWJsZSBkYXRhIGNlbGwgdW5kZXIgZmlsdGVyIGNlbGwuXG4gICAgICogICAgKiBgJ0xFRlQnYCAtIE9wZW5zIGZpbHRlciBjZWxsIGVkaXRvciBpbiBwcmV2aW91cyBmaWx0ZXJhYmxlIGNvbHVtbjsgaWYgbm9uZXN1Y2gsIHNlbGVjdHMgZmlyc3QgdmlzaWJsZSBkYXRhIGNlbGwgdW5kZXIgZmlsdGVyIGNlbGwuXG4gICAgICogICAgKiBgJ1JJR0hUJ2AgLSBPcGVucyBmaWx0ZXIgY2VsbCBlZGl0b3IgaW4gbmV4dCBmaWx0ZXJhYmxlIGNvbHVtbjsgaWYgbm9uZXN1Y2gsIHNlbGVjdHMgZmlyc3QgdmlzaWJsZSBkYXRhIGNlbGwgdW5kZXIgZmlsdGVyIGNlbGwuXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNlbGxFdmVudCwgbWFwcGVkTmF2S2V5LCBoYW5kbGVyLFxuICAgICAgICAgICAgZGV0YWlsID0gZXZlbnQuZGV0YWlsO1xuXG4gICAgICAgIGlmIChkZXRhaWwuZWRpdG9yKSB7XG4gICAgICAgICAgICBjZWxsRXZlbnQgPSBkZXRhaWwuZWRpdG9yLmV2ZW50O1xuICAgICAgICAgICAgaWYgKGNlbGxFdmVudC5pc0ZpbHRlckNlbGwpIHtcbiAgICAgICAgICAgICAgICBtYXBwZWROYXZLZXkgPSBjZWxsRXZlbnQucHJvcGVydGllcy5tYXBwZWROYXZLZXkoZGV0YWlsLmNoYXIpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzWydoYW5kbGUnICsgbWFwcGVkTmF2S2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVMRUZUOiBmdW5jdGlvbihncmlkLCBkZXRhaWwpIHsgbW92ZUxhdGVyYWxseShncmlkLCBkZXRhaWwsIC0xKTsgfSxcbiAgICBoYW5kbGVSSUdIVDogZnVuY3Rpb24oZ3JpZCwgZGV0YWlsKSB7IG1vdmVMYXRlcmFsbHkoZ3JpZCwgZGV0YWlsLCArMSk7IH0sXG4gICAgaGFuZGxlVVA6IG1vdmVEb3duLFxuICAgIGhhbmRsZURPV046IG1vdmVEb3duLFxuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5pc0ZpbHRlckNlbGwpIHtcbiAgICAgICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNGaWx0ZXJDZWxsKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIG1vdmVMYXRlcmFsbHkoZ3JpZCwgZGV0YWlsLCBkZWx0YVgpIHtcbiAgICB2YXIgY2VsbEV2ZW50ID0gZGV0YWlsLmVkaXRvci5ldmVudCxcbiAgICAgICAgZ3JpZFggPSBjZWxsRXZlbnQudmlzaWJsZUNvbHVtbi5pbmRleCxcbiAgICAgICAgZ3JpZFkgPSBjZWxsRXZlbnQudmlzaWJsZVJvdy5pbmRleCxcbiAgICAgICAgb3JpZ2luWCA9IGdyaWRYLFxuICAgICAgICBDID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1ucy5sZW5ndGg7XG5cbiAgICBjZWxsRXZlbnQgPSBuZXcgZ3JpZC5iZWhhdmlvci5DZWxsRXZlbnQ7IC8vIHJlZGVmaW5lIHNvIHdlIGRvbid0IHJlc2V0IHRoZSBvcmlnaW5hbCBiZWxvd1xuXG4gICAgd2hpbGUgKFxuICAgICAgICAoZ3JpZFggPSAoZ3JpZFggKyBkZWx0YVggKyBDKSAlIEMpICE9PSBvcmlnaW5YICYmXG4gICAgICAgIGNlbGxFdmVudC5yZXNldEdyaWRYWShncmlkWCwgZ3JpZFkpXG4gICAgKSB7XG4gICAgICAgIGlmIChjZWxsRXZlbnQucHJvcGVydGllcy5maWx0ZXJhYmxlKSB7XG4gICAgICAgICAgICAvLyBTZWxlY3QgcHJldmlvdXMgb3IgbmV4dCBmaWx0ZXJhYmxlIGNvbHVtbidzIGZpbHRlciBjZWxsXG4gICAgICAgICAgICBncmlkLmVkaXRBdChjZWxsRXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZURvd24oZ3JpZCwgY2VsbEV2ZW50KTtcbn1cblxuZnVuY3Rpb24gbW92ZURvd24oZ3JpZCwgZGV0YWlsKSB7XG4gICAgdmFyIGNlbGxFdmVudCA9IGRldGFpbC5lZGl0b3IuZXZlbnQsXG4gICAgICAgIGdyaWRYID0gY2VsbEV2ZW50LnZpc2libGVDb2x1bW4uY29sdW1uSW5kZXg7XG5cbiAgICAvLyBTZWxlY3QgZmlyc3QgdmlzaWJsZSBncmlkIGNlbGwgb2YgdGhpcyBjb2x1bW5cbiAgICBncmlkLnNlbGVjdFZpZXdwb3J0Q2VsbChncmlkWCwgMCk7XG4gICAgZ3JpZC50YWtlRm9jdXMoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG52YXIgY29tbWFuZHMgPSB7XG4gICAgUEFHRURPV046IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlRG93bigpOyB9LFxuICAgIFBBR0VVUDogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VVcCgpOyB9LFxuICAgIFBBR0VMRUZUOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZUxlZnQoKTsgfSxcbiAgICBQQUdFUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlUmlnaHQoKTsgfVxufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEtleVBhZ2luZyA9IEZlYXR1cmUuZXh0ZW5kKCdLZXlQYWdpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIEtleVBhZ2luZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZnVuYyA9IGNvbW1hbmRzW2V2ZW50LmRldGFpbC5jaGFyXTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIGZ1bmMoZ3JpZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhZ2luZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9uSG92ZXIgPSBGZWF0dXJlLmV4dGVuZCgnT25Ib3ZlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgT25Ib3Zlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBob3ZlckNlbGwgPSBncmlkLmhvdmVyQ2VsbDtcbiAgICAgICAgaWYgKCFldmVudC5ncmlkQ2VsbC5lcXVhbHMoaG92ZXJDZWxsKSkge1xuICAgICAgICAgICAgaWYgKGhvdmVyQ2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFeGl0KGdyaWQsIGhvdmVyQ2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRW50ZXIoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgZ3JpZC5zZXRIb3ZlckNlbGwoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9uSG92ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSb3dTZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnUm93U2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyB0aW1lIGFuIGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JBdXRvU3RhcnQ6IDAsXG5cbiAgICBkcmFnQXJtZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0FybWVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgcm93U2VsZWN0YWJsZSA9IGdyaWQucHJvcGVydGllcy5yb3dTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICFldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrICYmXG4gICAgICAgICAgICBncmlkLnByb3BlcnRpZXMuc2hvd1Jvd051bWJlcnMgJiZcbiAgICAgICAgICAgIGV2ZW50LmlzSGFuZGxlQ29sdW1uO1xuXG4gICAgICAgIGlmIChyb3dTZWxlY3RhYmxlICYmIGV2ZW50LmlzSGVhZGVySGFuZGxlKSB7XG4gICAgICAgICAgICAvL2dsb2JhbCByb3cgc2VsZWN0aW9uXG4gICAgICAgICAgICBncmlkLnRvZ2dsZVNlbGVjdEFsbFJvd3MoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyb3dTZWxlY3RhYmxlICYmIGV2ZW50LmlzRGF0YVJvdykgIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSwgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBldmVudC5kYXRhQ2VsbC55LCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkICYmXG4gICAgICAgICAgICBncmlkLnByb3BlcnRpZXMucm93U2VsZWN0aW9uICYmXG4gICAgICAgICAgICAhZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGlja1xuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ1JvdyA9IGV2ZW50LmRhdGFDZWxsLnk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCB0aGlzLmxhc3REcmFnUm93LCBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlcjtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5nZXRMYXN0U2VsZWN0aW9uVHlwZSgpID09PSAncm93JyAmJlxuICAgICAgICAgICAgKGhhbmRsZXIgPSB0aGlzWydoYW5kbGUnICsgZXZlbnQuZGV0YWlsLmNoYXJdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBncmlkLCBldmVudC5kZXRhaWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIGEgbW91c2VkcmFnIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIHksIGtleXMpIHtcbiAgICAgICAgdmFyIG1vdXNlWSA9IGdyaWQuZ2V0TW91c2VEb3duKCkueTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG1vdXNlWSwgeSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIHkgLSBtb3VzZVkpKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGNoZWNrcyB3aGlsZSB3ZXJlIGRyYWdnaW5nIGlmIHdlIGdvIG91dHNpZGUgdGhlIHZpc2libGUgYm91bmRzLCBpZiBzbywga2ljayBvZmYgdGhlIGV4dGVybmFsIGF1dG9zY3JvbGwgY2hlY2sgZnVuY3Rpb24gKGFib3ZlKVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0RyYWdTY3JvbGw6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQucHJvcGVydGllcy5zY3JvbGxpbmdFbmFibGVkICYmXG4gICAgICAgICAgICBncmlkLmdldERhdGFCb3VuZHMoKS5jb250YWlucyhtb3VzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKSxcbiAgICAgICAgICAgIHlPZmZzZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA8IGIub3JpZ2luLnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPiBiLm9yaWdpbi55ICsgYi5leHRlbnQueSkge1xuICAgICAgICAgICAgeU9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeU9mZnNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdERyYWdSb3cgPj0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmFnUm93ICs9IHlPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5KDAsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIHRoaXMubGFzdERyYWdSb3csIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgeSwga2V5cykge1xuICAgICAgICBpZiAoIWdyaWQuYWJvcnRFZGl0aW5nKCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIG1vdXNlWSA9IGdyaWQuZ2V0TW91c2VEb3duKCkueSxcbiAgICAgICAgICAgIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpID4gMDtcblxuICAgICAgICBpZiAoeSA8IDApIHsgLy8gb3V0c2lkZSBvZiB0aGUgZ3JpZD9cbiAgICAgICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RSb3coeSwgbW91c2VZKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIHkgLSBtb3VzZVkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0Um93KHksIGtleXMpO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCgwLCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVFNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRE9XTjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKSxcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxLFxuICAgICAgICAgICAgbmV3WCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCksXG4gICAgICAgICAgICBuZXdZID0gbW91c2VDb3JuZXIueTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgbmV3WCk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3QobmV3WCwgbmV3WSwgMCwgMCk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgYXV0b3Njcm9sbCBzdGFydCB0aW1lIGlmIHdlIGhhdmVuJ3QgYXV0b3Njcm9sbGVkIHdpdGhpbiB0aGUgbGFzdCA1MDBtcyBvdGhlcndpc2UgdXBkYXRlIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgdGltZVxuICAgICAqL1xuICAgIHBpbmdBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbFN0YXJ0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2JMYXN0QXV0byA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFkpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCksXG4gICAgICAgICAgICBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKSxcbiAgICAgICAgICAgIG1heFZpZXdhYmxlUm93cyA9IGdyaWQucmVuZGVyZXIudmlzaWJsZVJvd3MubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1kgPSBleHRlbnQueSArIG9mZnNldFk7XG5cbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MgLSBvcmlnaW4ueSwgTWF0aC5tYXgoLW9yaWdpbi55LCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RSb3cob3JpZ2luLnksIG9yaWdpbi55ICsgbmV3WSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIG5ld1kpKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZICsgb3JpZ2luLnksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WSkge1xuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDEsXG4gICAgICAgICAgICBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzQ291bnQoKSAtIDEsXG4gICAgICAgICAgICBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSksXG4gICAgICAgICAgICBuZXdZID0gbW91c2VDb3JuZXIueSArIG9mZnNldFk7XG5cbiAgICAgICAgaWYgKCFncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgoMCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG5ld1kpO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KDAsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsUm93SXNWaXNpYmxlKG5ld1ksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIGlzU2luZ2xlUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3dTZWxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUaHVtYndoZWVsU2Nyb2xsaW5nID0gRmVhdHVyZS5leHRlbmQoJ1RodW1id2hlZWxTY3JvbGxpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgVGh1bWJ3aGVlbFNjcm9sbGluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlV2hlZWxNb3ZlZDogZnVuY3Rpb24oZ3JpZCwgZSkge1xuICAgICAgICBpZiAoIWdyaWQucHJvcGVydGllcy5zY3JvbGxpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgIGRlbHRhWCA9IE1hdGguc2lnbihwcmltRXZlbnQud2hlZWxEZWx0YVggfHwgLXByaW1FdmVudC5kZWx0YVgpLFxuICAgICAgICAgICAgZGVsdGFZID0gTWF0aC5zaWduKHByaW1FdmVudC53aGVlbERlbHRhWSB8fCAtcHJpbUV2ZW50LmRlbHRhWSk7XG5cbiAgICAgICAgaWYgKGRlbHRhWCB8fCBkZWx0YVkpIHtcbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnkoXG4gICAgICAgICAgICAgICAgLWRlbHRhWCB8fCAwLCAvLyAwIGlmIE5hTlxuICAgICAgICAgICAgICAgIC1kZWx0YVkgfHwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUaHVtYndoZWVsU2Nyb2xsaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBGZWF0dXJlOiByZXF1aXJlKCcuL0ZlYXR1cmUnKSwgLy8gYWJzdHJhY3QgYmFzZSBjbGFzc1xuICAgIENlbGxDbGljazogcmVxdWlyZSgnLi9DZWxsQ2xpY2snKSxcbiAgICBDZWxsRWRpdGluZzogcmVxdWlyZSgnLi9DZWxsRWRpdGluZycpLFxuICAgIENlbGxTZWxlY3Rpb246IHJlcXVpcmUoJy4vQ2VsbFNlbGVjdGlvbicpLFxuICAgIENvbHVtbk1vdmluZzogcmVxdWlyZSgnLi9Db2x1bW5Nb3ZpbmcnKSxcbiAgICBDb2x1bW5SZXNpemluZzogcmVxdWlyZSgnLi9Db2x1bW5SZXNpemluZycpLFxuICAgIENvbHVtblNlbGVjdGlvbjogcmVxdWlyZSgnLi9Db2x1bW5TZWxlY3Rpb24nKSxcbiAgICBDb2x1bW5Tb3J0aW5nOiByZXF1aXJlKCcuL0NvbHVtblNvcnRpbmcnKSxcbiAgICBGaWx0ZXJzOiByZXF1aXJlKCcuL0ZpbHRlcnMnKSxcbiAgICBLZXlQYWdpbmc6IHJlcXVpcmUoJy4vS2V5UGFnaW5nJyksXG4gICAgT25Ib3ZlcjogcmVxdWlyZSgnLi9PbkhvdmVyJyksXG4gICAgLy8gUm93UmVzaXppbmc6IHJlcXVpcmUoJy4vUm93UmVzaXppbmcnKSxcbiAgICBSb3dTZWxlY3Rpb246IHJlcXVpcmUoJy4vUm93U2VsZWN0aW9uJyksXG4gICAgVGh1bWJ3aGVlbFNjcm9sbGluZzogcmVxdWlyZSgnLi9UaHVtYndoZWVsU2Nyb2xsaW5nJylcbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZCB9O1xuICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICAgIHJldHVybiBldnQ7XG4gICAgfTtcblxuICAgIHdpbmRvdy5DdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xufVxuXG52YXIgcmVjdGFuZ3VsYXIgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpO1xuXG52YXIgUkVTSVpFX1BPTExJTkdfSU5URVJWQUwgPSAyMDAsXG4gICAgcGFpbnRhYmxlcyA9IFtdLFxuICAgIHJlc2l6YWJsZXMgPSBbXSxcbiAgICBwYWludFJlcXVlc3QsXG4gICAgcmVzaXplSW50ZXJ2YWwsXG4gICAgY2hhck1hcCA9IG1ha2VDaGFyTWFwKCk7XG5cbmZ1bmN0aW9uIENhbnZhcyhkaXYsIGNvbXBvbmVudCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNyZWF0ZSB0aGUgY29udGFpbmluZyA8ZGl2Pi4uLjwvZGl2PlxuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXG4gICAgdGhpcy5kcmFnRW5kdGltZSA9IERhdGUubm93KCk7XG5cbiAgICAvLyBjcmVhdGUgYW5kIGFwcGVuZCB0aGUgaW5mbyA8ZGl2Pi4uLjwvZGl2PiAodG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlcmUgYXJlIG5vIGRhdGEgcm93cylcbiAgICB0aGlzLmluZm9EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmluZm9EaXYuY2xhc3NOYW1lID0gJ2luZm8nO1xuICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMuaW5mb0Rpdik7XG5cbiAgICAvLyBjcmVhdGUgYW5kIGFwcGVuZCB0aGUgY2FudmFzXG4gICAgdGhpcy5nYyA9IGdldENhY2hlZENvbnRleHQodGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XG4gICAgdGhpcy5iYyA9IGdldENhY2hlZENvbnRleHQodGhpcy5idWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XG5cbiAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG5cbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuXG4gICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgdGhpcy5kcmFnc3RhcnQgPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICAvL3RoaXMub3JpZ2luID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KDAsIDApO1xuICAgIHRoaXMuYm91bmRzID0gbmV3IHJlY3Rhbmd1bGFyLlJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcbiAgICB0aGlzLmhhc01vdXNlID0gZmFsc2U7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc01vdXNlIHx8IHNlbGYuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICBzZWxmLmZpbm1vdXNlbW92ZShlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlubW91c2V1cChlKTtcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW53aGVlbG1vdmVkKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlua2V5ZG93bihlKTtcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5rZXl1cChlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2FudmFzLm9ubW91c2VvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuaGFzTW91c2UgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5mb2N1c2dhaW5lZChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluZm9jdXNsb3N0KGUpO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbm1vdXNlZG93bihlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmhhc01vdXNlID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZmlubW91c2VvdXQoZSk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5jbGljayhlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmNvbnRleHRtZW51KGUpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICB0aGlzLmNhbnZhcy5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIHRoaXMuYmVnaW5SZXNpemluZygpO1xuICAgIHRoaXMuYmVnaW5QYWludGluZygpO1xufVxuXG5DYW52YXMucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDYW52YXMucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuICAgIGRpdjogbnVsbCxcbiAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgY2FudmFzOiBudWxsLFxuICAgIGZvY3VzZXI6IG51bGwsXG4gICAgYnVmZmVyOiBudWxsLFxuICAgIGN0eDogbnVsbCxcbiAgICBtb3VzZUxvY2F0aW9uOiBudWxsLFxuICAgIGRyYWdzdGFydDogbnVsbCxcbiAgICBvcmlnaW46IG51bGwsXG4gICAgYm91bmRzOiBudWxsLFxuICAgIGRpcnR5OiBmYWxzZSxcbiAgICBzaXplOiBudWxsLFxuICAgIG1vdXNlZG93bjogZmFsc2UsXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgIHJlcGVhdEtleUNvdW50OiAwLFxuICAgIHJlcGVhdEtleTogbnVsbCxcbiAgICByZXBlYXRLZXlTdGFydFRpbWU6IDAsXG4gICAgY3VycmVudEtleXM6IFtdLFxuICAgIGhhc01vdXNlOiBmYWxzZSxcbiAgICBsYXN0RG91YmxlQ2xpY2tUaW1lOiAwLFxuICAgIGRyYWdFbmRUaW1lOiAwLFxuICAgIGxhc3RSZXBhaW50VGltZTogMCxcbiAgICBjdXJyZW50UGFpbnRDb3VudDogMCxcbiAgICBjdXJyZW50RlBTOiAwLFxuICAgIGxhc3RGUFNDb21wdXRlVGltZTogMCxcblxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc3RvcFBhaW50TG9vcDogc3RvcFBhaW50TG9vcCxcbiAgICByZXN0YXJ0UGFpbnRMb29wOiByZXN0YXJ0UGFpbnRMb29wLFxuXG4gICAgc3RvcFJlc2l6ZUxvb3A6IHN0b3BSZXNpemVMb29wLFxuICAgIHJlc3RhcnRSZXNpemVMb29wOiByZXN0YXJ0UmVzaXplTG9vcCxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5zdG9wUmVzaXppbmcoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q3VycmVudEZQUzpmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZQUztcbiAgICB9LFxuXG5cbiAgICB0aWNrUGFpbnQ6IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgaXNDb250aW51b3VzUmVwYWludCA9IHRoaXMuY29tcG9uZW50LnByb3BlcnRpZXMuZW5hYmxlQ29udGludW91c1JlcGFpbnQsXG4gICAgICAgICAgICBmcHMgPSB0aGlzLmNvbXBvbmVudC5wcm9wZXJ0aWVzLnJlcGFpbnRJbnRlcnZhbFJhdGU7XG4gICAgICAgIGlmIChmcHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAxMDAwIC8gZnBzO1xuXG4gICAgICAgIHZhciBlbGFwc2VkID0gbm93IC0gdGhpcy5sYXN0UmVwYWludFRpbWU7XG4gICAgICAgIGlmIChlbGFwc2VkID4gaW50ZXJ2YWwgJiYgKGlzQ29udGludW91c1JlcGFpbnQgfHwgdGhpcy5kaXJ0eSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnROb3coKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlcGFpbnRUaW1lID0gbm93O1xuICAgICAgICAgICAgLyogLSAoZWxhcHNlZCAlIGludGVydmFsKTsqL1xuICAgICAgICAgICAgaWYgKGlzQ29udGludW91c1JlcGFpbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWludENvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdEZQU0NvbXB1dGVUaW1lID49IDEwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RlBTID0gKHRoaXMuY3VycmVudFBhaW50Q291bnQgKiAxMDAwKSAvIChub3cgLSB0aGlzLmxhc3RGUFNDb21wdXRlVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhaW50Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RGUFNDb21wdXRlVGltZSA9IG5vdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYmVnaW5QYWludGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudGlja1BhaW50ZXIgPSBmdW5jdGlvbihub3cpIHtcbiAgICAgICAgICAgIHNlbGYudGlja1BhaW50KG5vdyk7XG4gICAgICAgIH07XG4gICAgICAgIHBhaW50YWJsZXMucHVzaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgc3RvcFBhaW50aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcGFpbnRhYmxlcy5zcGxpY2UocGFpbnRhYmxlcy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICB9LFxuXG4gICAgYmVnaW5SZXNpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy50aWNrUmVzaXplciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jaGVja3NpemUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVzaXphYmxlcy5wdXNoKHRoaXMpO1xuICAgIH0sXG5cbiAgICBzdG9wUmVzaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNpemFibGVzLnNwbGljZShyZXNpemFibGVzLmluZGV4T2YodGhpcyksIDEpO1xuICAgIH0sXG5cbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVnaW5QYWludGluZygpO1xuICAgICAgICB0aGlzLmJlZ2luUmVzaXppbmcoKTtcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RvcFBhaW50aW5nKCk7XG4gICAgICAgIHRoaXMuc3RvcFJlc2l6aW5nKCk7XG4gICAgfSxcblxuICAgIGNoZWNrc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vdGhpcyBpcyBleHBlbnNpdmUgbGV0cyBkbyBpdCBhdCBzb21lIG1vZHVsb1xuICAgICAgICB2YXIgc2l6ZU5vdyA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoc2l6ZU5vdy53aWR0aCAhPT0gdGhpcy5zaXplLndpZHRoIHx8IHNpemVOb3cuaGVpZ2h0ICE9PSB0aGlzLnNpemUuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLnNpemUgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLndpZHRoID0gYm94LndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGJveC5oZWlnaHQ7XG5cbiAgICAgICAgLy9maXggYWxhIHNpciBzcGlua2EsIHNlZVxuICAgICAgICAvL2h0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS9cbiAgICAgICAgLy9qdXN0IGFkZCAnaGRwaScgYXMgYW4gYXR0cmlidXRlIHRvIHRoZSBmaW4tY2FudmFzIHRhZ1xuICAgICAgICB2YXIgcmF0aW8gPSAxO1xuICAgICAgICB2YXIgaXNISURQSSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMuY29tcG9uZW50LnByb3BlcnRpZXMudXNlSGlEUEk7XG4gICAgICAgIGlmIChpc0hJRFBJKSB7XG4gICAgICAgICAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgICB2YXIgYmFja2luZ1N0b3JlUmF0aW8gPSB0aGlzLmdjLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdjLm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdjLm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZ2Mub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdjLmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgICAgICAgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgICAgICAvL3RoaXMuY2FudmFzQ1RYLnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1ZmZlci53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aCAqIHJhdGlvO1xuICAgICAgICB0aGlzLmJ1ZmZlci5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodCAqIHJhdGlvO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy5idWZmZXIuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy5idWZmZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuYmMuc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgaWYgKGlzSElEUEkgJiYgIXRoaXMuY29tcG9uZW50LnByb3BlcnRpZXMudXNlQml0QmxpdCkge1xuICAgICAgICAgICAgdGhpcy5nYy5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib3VuZHMgPSBuZXcgcmVjdGFuZ3VsYXIuUmVjdGFuZ2xlKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuc2V0Qm91bmRzKHRoaXMuYm91bmRzKTtcbiAgICAgICAgdGhpcy5yZXNpemVOb3RpZmljYXRpb24oKTtcbiAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgIH0sXG5cbiAgICByZXNpemVOb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQodW5kZWZpbmVkLCAnZmluLWNhbnZhcy1yZXNpemVkJywge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHM7XG4gICAgfSxcblxuICAgIHBhaW50Tm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVzZUJpdEJsaXQgPSB0aGlzLmNvbXBvbmVudC5wcm9wZXJ0aWVzLnVzZUJpdEJsaXQsXG4gICAgICAgICAgICBnYyA9IHVzZUJpdEJsaXQgPyB0aGlzLmJjIDogdGhpcy5nYztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2MuY2FjaGUuc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucGFpbnQoZ2MpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZ2MuY2FjaGUucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZUJpdEJsaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmbHVzaEJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci53aWR0aCA+IDAgJiYgdGhpcy5idWZmZXIuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5nYy5kcmF3SW1hZ2UodGhpcy5idWZmZXIsIDAsIDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5ld0V2ZW50OiBmdW5jdGlvbihwcmltaXRpdmVFdmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcmltaXRpdmVFdmVudCkge1xuICAgICAgICAgICAgZXZlbnQuZGV0YWlsLnByaW1pdGl2ZUV2ZW50ID0gcHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChuYW1lLCBldmVudCk7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoTmV3RXZlbnQ6IGZ1bmN0aW9uKHByaW1pdGl2ZUV2ZW50LCBuYW1lLCBkZXRhaWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQodGhpcy5uZXdFdmVudChwcmltaXRpdmVFdmVudCwgbmFtZSwgZGV0YWlsKSk7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBuYW1lLCBkZXRhaWwpIHtcbiAgICAgICAgZGV0YWlsID0gZGV0YWlsIHx8IHt9O1xuICAgICAgICBkZXRhaWwubW91c2UgPSB0aGlzLm1vdXNlTG9jYXRpb247XG4gICAgICAgIGRldGFpbC5rZXlzID0gdGhpcy5jdXJyZW50S2V5cztcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChldmVudCwgbmFtZSwgZGV0YWlsKTtcbiAgICB9LFxuXG4gICAgZmlubW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkgJiYgdGhpcy5tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMuYmVEcmFnZ2luZygpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWRyYWdzdGFydCcsIHtcbiAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ3N0YXJ0ID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KHRoaXMubW91c2VMb2NhdGlvbi54LCB0aGlzLm1vdXNlTG9jYXRpb24ueSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm1vdXNlTG9jYXRpb24pO1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnJywge1xuICAgICAgICAgICAgICAgIGRyYWdzdGFydDogdGhpcy5kcmFnc3RhcnQsXG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm91bmRzLmNvbnRhaW5zKHRoaXMubW91c2VMb2NhdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZW1vdmUnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5tb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5tb3VzZURvd25Mb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMubW91c2Vkb3duID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2Vkb3duJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YWtlRm9jdXMoKTtcbiAgICB9LFxuXG4gICAgZmlubW91c2V1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnZW5kJywge1xuICAgICAgICAgICAgICAgIGRyYWdzdGFydDogdGhpcy5kcmFnc3RhcnQsXG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJlTm90RHJhZ2dpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VuZHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZXVwJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICAgICAgLy90aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB9LFxuXG4gICAgZmlubW91c2VvdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNlb3V0Jyk7XG4gICAgfSxcblxuICAgIGZpbndoZWVsbW92ZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpIHx8ICF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy13aGVlbG1vdmVkJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmluY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5jb21wb25lbnQucHJvcGVydGllcy5kb3VibGVDbGlja0RlbGF5O1xuICAgICAgICBpZiAoZGVsYXkgPCAxMDApIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ2xpY2tFdmVudC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZG91YmxlQ2xpY2tUaW1lciAmJiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0Q2xpY2tUaW1lIDwgZGVsYXkpIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tUaW1lcik7IC8vIHByZXZlbnQgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZmluZGJsY2xpY2soZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gc2V0VGltZW91dChkaXNwYXRjaENsaWNrRXZlbnQuYmluZCh0aGlzLCBlKSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmRibGNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMubGFzdERvdWJsZUNsaWNrVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kYmxjbGljaycsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2RibGNsaWNrJywgdGhpcy5jdXJyZW50S2V5cyk7XG4gICAgfSxcblxuICAgIGdldENoYXJNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2hhck1hcDtcbiAgICB9LFxuXG4gICAgZ2V0S2V5Q2hhcjogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIga2V5ID0gZS5rZXlDb2RlIHx8IGUuZGV0YWlsLmtleSxcbiAgICAgICAgICAgIHNoaWZ0ID0gZS5zaGlmdEtleSB8fCBlLmRldGFpbC5zaGlmdDtcbiAgICAgICAgcmV0dXJuIGNoYXJNYXBba2V5XVtzaGlmdCA/IDEgOiAwXTtcbiAgICB9LFxuXG4gICAgZmlua2V5ZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCBUQUIgZnJvbSBtb3ZpbmcgZm9jdXMgb2ZmIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSA5KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5Q2hhciA9IHRoaXMuZ2V0S2V5Q2hhcihlKTtcbiAgICAgICAgaWYgKGUucmVwZWF0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRLZXkgPT09IGtleUNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0S2V5ID0ga2V5Q2hhcjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0S2V5U3RhcnRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50S2V5cy5pbmRleE9mKGtleUNoYXIpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKGtleUNoYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld0V2ZW50KGUsICdmaW4tY2FudmFzLWtleWRvd24nLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdENvdW50OiB0aGlzLnJlcGVhdEtleUNvdW50LFxuICAgICAgICAgICAgcmVwZWF0U3RhcnRUaW1lOiB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSxcbiAgICAgICAgICAgIHNoaWZ0OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgaWRlbnRpZmllcjogZS5rZXksXG4gICAgICAgICAgICBjdXJyZW50S2V5czogdGhpcy5jdXJyZW50S2V5cy5zbGljZSgwKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmlua2V5dXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgVEFCIGZyb20gbW92aW5nIGZvY3VzIG9mZiB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gOSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleUNoYXIgPSB0aGlzLmdldEtleUNoYXIoZSk7XG4gICAgICAgIHRoaXMuY3VycmVudEtleXMuc3BsaWNlKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSwgMSk7XG4gICAgICAgIHRoaXMucmVwZWF0S2V5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlcGVhdEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVwZWF0S2V5U3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld0V2ZW50KGUsICdmaW4tY2FudmFzLWtleXVwJywge1xuICAgICAgICAgICAgYWx0OiBlLmFsdEtleSxcbiAgICAgICAgICAgIGN0cmw6IGUuY3RybEtleSxcbiAgICAgICAgICAgIGNoYXI6IGtleUNoYXIsXG4gICAgICAgICAgICBjb2RlOiBlLmNoYXJDb2RlLFxuICAgICAgICAgICAga2V5OiBlLmtleUNvZGUsXG4gICAgICAgICAgICBtZXRhOiBlLm1ldGFLZXksXG4gICAgICAgICAgICByZXBlYXQ6IGUucmVwZWF0LFxuICAgICAgICAgICAgc2hpZnQ6IGUuc2hpZnRLZXksXG4gICAgICAgICAgICBpZGVudGlmaWVyOiBlLmtleSxcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5mb2N1c2dhaW5lZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtZ2FpbmVkJyk7XG4gICAgfSxcblxuICAgIGZpbmZvY3VzbG9zdDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtbG9zdCcpO1xuICAgIH0sXG5cbiAgICBmaW5jb250ZXh0bWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLmNvbXBvbmVudC5wcm9wZXJ0aWVzLmRvdWJsZUNsaWNrRGVsYXk7XG5cbiAgICAgICAgaWYgKGUuY3RybEtleSAmJiB0aGlzLmN1cnJlbnRLZXlzLmluZGV4T2YoJ0NUUkwnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleXMucHVzaCgnQ1RSTCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbGF5IDwgMTAwKSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbnRleHRNZW51RXZlbnQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRvdWJsZVJpZ2h0Q2xpY2tUaW1lciAmJiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0Q2xpY2tUaW1lIDwgZGVsYXkpIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyKTsgLy8gcHJldmVudCBjb250ZXh0IG1lbnUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gc2V0VGltZW91dChkaXNwYXRjaENvbnRleHRNZW51RXZlbnQuYmluZCh0aGlzLCBlKSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlcGFpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFwYWludFJlcXVlc3QgfHwgdGhpcy5jb21wb25lbnQucHJvcGVydGllcy5yZXBhaW50SW50ZXJ2YWxSYXRlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50Tm93KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TW91c2VMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlTG9jYXRpb247XG4gICAgfSxcblxuICAgIGdldE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KHJlY3QubGVmdCwgcmVjdC50b3ApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgZ2V0TG9jYWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHAgPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoZS5jbGllbnRYIC0gcmVjdC5sZWZ0LCBlLmNsaWVudFkgLSByZWN0LnRvcCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmNhbnZhcztcbiAgICB9LFxuXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbnZhcy5mb2N1cygpO1xuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJlRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIGJlTm90RHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIGlzRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnZ2luZztcbiAgICB9LFxuXG4gICAgZGlzYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSBzdHlsZS5jc3NUZXh0ICsgJy13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmUnO1xuICAgIH0sXG5cbiAgICBlbmFibGVEb2N1bWVudEVsZW1lbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gc3R5bGUuY3NzVGV4dC5yZXBsYWNlKCctd2Via2l0LXVzZXItc2VsZWN0OiBub25lJywgJycpO1xuICAgIH0sXG5cbiAgICBzZXRGb2N1c2FibGU6IGZ1bmN0aW9uKHRydXRoeSkge1xuICAgICAgICB0aGlzLmZvY3VzZXIuc3R5bGUuZGlzcGxheSA9IHRydXRoeSA/ICcnIDogJ25vbmUnO1xuICAgIH0sXG5cbiAgICBpc1JpZ2h0Q2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGlzUmlnaHRNQjtcbiAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgIGlmICgnd2hpY2gnIGluIGUpIHsgLy8gR2Vja28gKEZpcmVmb3gpLCBXZWJLaXQgKFNhZmFyaS9DaHJvbWUpICYgT3BlcmFcbiAgICAgICAgICAgIGlzUmlnaHRNQiA9IGUud2hpY2ggPT09IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2J1dHRvbicgaW4gZSkgeyAvLyBJRSwgT3BlcmFcbiAgICAgICAgICAgIGlzUmlnaHRNQiA9IGUuYnV0dG9uID09PSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1JpZ2h0TUI7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIHNldEluZm86IGZ1bmN0aW9uKG1lc3NhZ2UsIHdpZHRoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAod2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh3aWR0aCAmJiAhaXNOYU4oTnVtYmVyKHdpZHRoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gJ3B4JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluZGV4T2YoJzwnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0Rpdi5pbm5lckhUTUwgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm9EaXYuaW5uZXJUZXh0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5kaXNwbGF5ID0gbWVzc2FnZSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGlzcGF0Y2hDbGlja0V2ZW50KGUpIHtcbiAgICB0aGlzLmRvdWJsZUNsaWNrVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtY2xpY2snLCB7XG4gICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb250ZXh0TWVudUV2ZW50KGUpIHtcbiAgICB0aGlzLmRvdWJsZVJpZ2h0Q2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51Jywge1xuICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhaW50TG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmIChwYWludFJlcXVlc3QpIHtcbiAgICAgICAgcGFpbnRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHBhaW50YWJsZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYWludGFibGUudGlja1BhaW50ZXIobm93KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFpbnRhYmxlLmNvbXBvbmVudC50aWNrTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFpbnRhYmxlLmNvbXBvbmVudC50aWNrTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYWludFJlcXVlc3QgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc3RhcnRQYWludExvb3AoKSB7XG4gICAgcGFpbnRSZXF1ZXN0ID0gcGFpbnRSZXF1ZXN0IHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG59XG5mdW5jdGlvbiBzdG9wUGFpbnRMb29wKCkge1xuICAgIGlmIChwYWludFJlcXVlc3QpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocGFpbnRSZXF1ZXN0KTtcbiAgICAgICAgcGFpbnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbnJlc3RhcnRQYWludExvb3AoKTtcblxuZnVuY3Rpb24gcmVzaXphYmxlc0xvb3BGdW5jdGlvbihub3cpIHtcbiAgICBpZiAocmVzaXplSW50ZXJ2YWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNpemFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc2l6YWJsZXNbaV0udGlja1Jlc2l6ZXIobm93KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzdGFydFJlc2l6ZUxvb3AoKSB7XG4gICAgcmVzaXplSW50ZXJ2YWwgPSByZXNpemVJbnRlcnZhbCB8fCBzZXRJbnRlcnZhbChyZXNpemFibGVzTG9vcEZ1bmN0aW9uLCBSRVNJWkVfUE9MTElOR19JTlRFUlZBTCk7XG59XG5mdW5jdGlvbiBzdG9wUmVzaXplTG9vcCgpIHtcbiAgICBpZiAocmVzaXplSW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChyZXNpemVJbnRlcnZhbCk7XG4gICAgICAgIHJlc2l6ZUludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbnJlc3RhcnRSZXNpemVMb29wKCk7XG5cbmZ1bmN0aW9uIG1ha2VDaGFyTWFwKCkge1xuICAgIHZhciBtYXAgPSBbXTtcblxuICAgIHZhciBlbXB0eSA9IFsnJywgJyddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBtYXBbaV0gPSBlbXB0eTtcbiAgICB9XG5cbiAgICBtYXBbMjddID0gWydFU0MnLCAnRVNDU0hJRlQnXTtcbiAgICBtYXBbMTkyXSA9IFsnYCcsICd+J107XG4gICAgbWFwWzQ5XSA9IFsnMScsICchJ107XG4gICAgbWFwWzUwXSA9IFsnMicsICdAJ107XG4gICAgbWFwWzUxXSA9IFsnMycsICcjJ107XG4gICAgbWFwWzUyXSA9IFsnNCcsICckJ107XG4gICAgbWFwWzUzXSA9IFsnNScsICclJ107XG4gICAgbWFwWzU0XSA9IFsnNicsICdeJ107XG4gICAgbWFwWzU1XSA9IFsnNycsICcmJ107XG4gICAgbWFwWzU2XSA9IFsnOCcsICcqJ107XG4gICAgbWFwWzU3XSA9IFsnOScsICcoJ107XG4gICAgbWFwWzQ4XSA9IFsnMCcsICcpJ107XG4gICAgbWFwWzE4OV0gPSBbJy0nLCAnXyddO1xuICAgIG1hcFsxODddID0gWyc9JywgJysnXTtcbiAgICBtYXBbOF0gPSBbJ0JBQ0tTUEFDRScsICdCQUNLU1BBQ0VTSElGVCddO1xuICAgIG1hcFs0Nl0gPSBbJ0RFTEVURScsICdERUxFVEVTSElGVCddO1xuICAgIG1hcFs5XSA9IFsnVEFCJywgJ1RBQlNISUZUJ107XG4gICAgbWFwWzgxXSA9IFsncScsICdRJ107XG4gICAgbWFwWzg3XSA9IFsndycsICdXJ107XG4gICAgbWFwWzY5XSA9IFsnZScsICdFJ107XG4gICAgbWFwWzgyXSA9IFsncicsICdSJ107XG4gICAgbWFwWzg0XSA9IFsndCcsICdUJ107XG4gICAgbWFwWzg5XSA9IFsneScsICdZJ107XG4gICAgbWFwWzg1XSA9IFsndScsICdVJ107XG4gICAgbWFwWzczXSA9IFsnaScsICdJJ107XG4gICAgbWFwWzc5XSA9IFsnbycsICdPJ107XG4gICAgbWFwWzgwXSA9IFsncCcsICdQJ107XG4gICAgbWFwWzIxOV0gPSBbJ1snLCAneyddO1xuICAgIG1hcFsyMjFdID0gWyddJywgJ30nXTtcbiAgICBtYXBbMjIwXSA9IFsnXFxcXCcsICd8J107XG4gICAgbWFwWzIyMF0gPSBbJ0NBUFNMT0NLJywgJ0NBUFNMT0NLU0hJRlQnXTtcbiAgICBtYXBbNjVdID0gWydhJywgJ0EnXTtcbiAgICBtYXBbODNdID0gWydzJywgJ1MnXTtcbiAgICBtYXBbNjhdID0gWydkJywgJ0QnXTtcbiAgICBtYXBbNzBdID0gWydmJywgJ0YnXTtcbiAgICBtYXBbNzFdID0gWydnJywgJ0cnXTtcbiAgICBtYXBbNzJdID0gWydoJywgJ0gnXTtcbiAgICBtYXBbNzRdID0gWydqJywgJ0onXTtcbiAgICBtYXBbNzVdID0gWydrJywgJ0snXTtcbiAgICBtYXBbNzZdID0gWydsJywgJ0wnXTtcbiAgICBtYXBbMTg2XSA9IFsnOycsICc6J107XG4gICAgbWFwWzIyMl0gPSBbJ1xcJycsICd8J107XG4gICAgbWFwWzEzXSA9IFsnUkVUVVJOJywgJ1JFVFVSTlNISUZUJ107XG4gICAgbWFwWzE2XSA9IFsnU0hJRlQnLCAnU0hJRlQnXTtcbiAgICBtYXBbOTBdID0gWyd6JywgJ1onXTtcbiAgICBtYXBbODhdID0gWyd4JywgJ1gnXTtcbiAgICBtYXBbNjddID0gWydjJywgJ0MnXTtcbiAgICBtYXBbODZdID0gWyd2JywgJ1YnXTtcbiAgICBtYXBbNjZdID0gWydiJywgJ0InXTtcbiAgICBtYXBbNzhdID0gWyduJywgJ04nXTtcbiAgICBtYXBbNzddID0gWydtJywgJ00nXTtcbiAgICBtYXBbMTg4XSA9IFsnLCcsICc8J107XG4gICAgbWFwWzE5MF0gPSBbJy4nLCAnPiddO1xuICAgIG1hcFsxOTFdID0gWycvJywgJz8nXTtcbiAgICBtYXBbMTZdID0gWydTSElGVCcsICdTSElGVCddO1xuICAgIG1hcFsxN10gPSBbJ0NUUkwnLCAnQ1RSTFNISUZUJ107XG4gICAgbWFwWzE4XSA9IFsnQUxUJywgJ0FMVFNISUZUJ107XG4gICAgbWFwWzkxXSA9IFsnQ09NTUFORExFRlQnLCAnQ09NTUFORExFRlRTSElGVCddO1xuICAgIG1hcFszMl0gPSBbJ1NQQUNFJywgJ1NQQUNFU0hJRlQnXTtcbiAgICBtYXBbOTNdID0gWydDT01NQU5EUklHSFQnLCAnQ09NTUFORFJJR0hUU0hJRlQnXTtcbiAgICBtYXBbMThdID0gWydBTFQnLCAnQUxUU0hJRlQnXTtcbiAgICBtYXBbMzhdID0gWydVUCcsICdVUFNISUZUJ107XG4gICAgbWFwWzM3XSA9IFsnTEVGVCcsICdMRUZUU0hJRlQnXTtcbiAgICBtYXBbNDBdID0gWydET1dOJywgJ0RPV05TSElGVCddO1xuICAgIG1hcFszOV0gPSBbJ1JJR0hUJywgJ1JJR0hUU0hJRlQnXTtcblxuICAgIG1hcFszM10gPSBbJ1BBR0VVUCcsICdQQUdFVVBTSElGVCddO1xuICAgIG1hcFszNF0gPSBbJ1BBR0VET1dOJywgJ1BBR0VET1dOU0hJRlQnXTtcbiAgICBtYXBbMzVdID0gWydQQUdFUklHSFQnLCAnUEFHRVJJR0hUU0hJRlQnXTsgLy8gRU5EXG4gICAgbWFwWzM2XSA9IFsnUEFHRUxFRlQnLCAnUEFHRUxFRlRTSElGVCddOyAvLyBIT01FXG5cbiAgICBtYXBbMTEyXSA9IFsnRjEnLCAnRjFTSElGVCddO1xuICAgIG1hcFsxMTNdID0gWydGMicsICdGMlNISUZUJ107XG4gICAgbWFwWzExNF0gPSBbJ0YzJywgJ0YzU0hJRlQnXTtcbiAgICBtYXBbMTE1XSA9IFsnRjQnLCAnRjRTSElGVCddO1xuICAgIG1hcFsxMTZdID0gWydGNScsICdGNVNISUZUJ107XG4gICAgbWFwWzExN10gPSBbJ0Y2JywgJ0Y2U0hJRlQnXTtcbiAgICBtYXBbMTE4XSA9IFsnRjcnLCAnRjdTSElGVCddO1xuICAgIG1hcFsxMTldID0gWydGOCcsICdGOFNISUZUJ107XG4gICAgbWFwWzEyMF0gPSBbJ0Y5JywgJ0Y5U0hJRlQnXTtcbiAgICBtYXBbMTIxXSA9IFsnRjEwJywgJ0YxMFNISUZUJ107XG4gICAgbWFwWzEyMl0gPSBbJ0YxMScsICdGMVMxSElGVCddO1xuICAgIG1hcFsxMjNdID0gWydGMTInLCAnRjEyMUhJRlQnXTtcblxuICAgIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlZENvbnRleHQoY2FudmFzRWxlbWVudCwgdHlwZSkge1xuICAgIHZhciBnYyA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCh0eXBlIHx8ICcyZCcpLFxuICAgICAgICBwcm9wcyA9IHt9LFxuICAgICAgICB2YWx1ZXMgPSB7fTtcblxuICAgIC8vIFN0dWIgb3V0IGFsbCB0aGUgcHJvdG90eXBlIG1lbWJlcnMgb2YgdGhlIGNhbnZhcyAyRCBncmFwaGljcyBjb250ZXh0OlxuICAgIE9iamVjdC5rZXlzKE9iamVjdC5nZXRQcm90b3R5cGVPZihnYykpLmZvckVhY2gobWFrZVN0dWIpO1xuXG4gICAgLy8gU29tZSBvbGRlciBicm93c2VycyAoZS5nLiwgQ2hyb21lIDQwKSBkaWQgbm90IGhhdmUgYWxsIG1lbWJlcnMgb2YgY2FudmFzXG4gICAgLy8gMkQgZ3JhcGhpY3MgY29udGV4dCBpbiB0aGUgcHJvdG90eXBlIHNvIHdlIG1ha2UgdGhpcyBhZGRpdGlvbmFsIGNhbGw6XG4gICAgT2JqZWN0LmtleXMoZ2MpLmZvckVhY2gobWFrZVN0dWIpO1xuXG4gICAgZnVuY3Rpb24gbWFrZVN0dWIoa2V5KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEoa2V5IGluIHByb3BzKSAmJlxuICAgICAgICAgICAgIS9eKHdlYmtpdHxtb3p8bXN8bylbQS1aXS8udGVzdChrZXkpICYmXG4gICAgICAgICAgICB0eXBlb2YgZ2Nba2V5XSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXNba2V5XSA9IHZhbHVlc1trZXldIHx8IGdjW2tleV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHZhbHVlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnY1trZXldID0gdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2MuY2FjaGUgPSBwcm9wcztcblxuICAgIGdjLmNhY2hlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlcyk7XG4gICAgfTtcblxuICAgIGdjLmNhY2hlLnJlc3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgZ2MuY29uZGl0aW9uYWxzU3RhY2sgPSBbXTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdjLCByZXF1aXJlKCcuL2dyYXBoaWNzJykpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKiBAbW9kdWxlIGVmZmVjdHMgKi9cblxuLyoqIEB0eXBlZGVmIHtmdW5jdGlvbn0gZWZmZWN0RnVuY3Rpb25cbiAqIEBkZXNjIEVsZW1lbnQgdG8gcGVyZm9ybSB0cmFuc2l0aW9ucyB1cG9uIGlzIGBvcHRpb25zLmVsYCBpZiBkZWZpbmVkIG9yIGB0aGlzLmVsYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtvcHRpb25zLmVsPXRoaXMuZWxdXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja10gRnVuY3Rpb24gdG8gY2FsbCBhdCBjb25jbHVzaW9uIG9mIHRyYW5zaXRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmR1cmF0aW9uPScwLjA2NXMnXSAtIER1cmF0aW9uIG9mIGVhY2ggdHJhbnNpdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5zdHlsZXM9ZGVmYXVsdEdsb3dlclN0eWxlc10gLSBIYXNoIG9mIENTUyBzdHlsZXMgYW5kIHZhbHVlcyB0byB0cmFuc2l0aW9uLiAoRm9yIHtAbGluayBlZmZlY3Rzfmdsb3dlcnxnbG93ZXJ9IG9ubHkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNoYWtlIGVsZW1lbnQgYmFjayBhbmQgZm91cnRoIGEgZmV3IHRpbWVzIGFzIGlmIHRvIHNheSwgXCJOb3BlIVwiXG4gKiBAdHlwZSB7ZWZmZWN0RnVuY3Rpb259XG4gKiBAbWVtYmVyT2YgbW9kdWxlOmVmZmVjdHNcbiAqL1xuZXhwb3J0cy5zaGFrZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICBlbCA9IG9wdGlvbnMuZWwgfHwgY29udGV4dC5lbCxcbiAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8ICcwLjA2NXMnLFxuICAgICAgICBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLFxuICAgICAgICB0cmFuc2l0aW9ucyA9IGNvbXB1dGVkU3R5bGUudHJhbnNpdGlvbi5zcGxpdCgnLCcpLFxuICAgICAgICBwb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUucG9zaXRpb24sXG4gICAgICAgIHggPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmxlZnQpLFxuICAgICAgICBkeCA9IC0zLFxuICAgICAgICBzaGFrZXMgPSA2O1xuXG4gICAgdHJhbnNpdGlvbnMucHVzaCgnbGVmdCAnICsgZHVyYXRpb24pO1xuICAgIGVsLnN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9ucy5qb2luKCcsJyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHNoYWtlcik7XG4gICAgc2hha2VyKCk7XG4gICAgZnVuY3Rpb24gc2hha2VyKGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQgfHwgZXZlbnQucHJvcGVydHlOYW1lID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmxlZnQgPSB4ICsgZHggKyAncHgnO1xuICAgICAgICAgICAgaWYgKCFzaGFrZXMtLSkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzaGFrZXIpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9ucy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrLmNhbGwoY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHggPSBzaGFrZXMgPyAtZHggOiAwO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGRlZmF1bHRHbG93ZXJTdHlsZXMgPSB7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAneWVsbG93JyxcbiAgICAnYm94LXNoYWRvdyc6ICcwIDAgMTBweCByZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zaXRpb24gc3R5bGVzIG9uIGVsZW1lbnQgZm9yIGEgbW9tZW50IGFuZCByZXZlcnQgYXMgaWYgdG8gc2F5LCBcIldob2EhLlwiXG4gKiBAdHlwZSB7ZWZmZWN0RnVuY3Rpb259XG4gKiBAbWVtYmVyT2YgbW9kdWxlOmVmZmVjdHNcbiAqL1xuZXhwb3J0cy5nbG93ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICBlbCA9IG9wdGlvbnMuZWwgfHwgY29udGV4dC5lbCxcbiAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8ICcwLjI1cycsXG4gICAgICAgIHN0eWxlcyA9IG9wdGlvbnMuc3R5bGVzIHx8IGRlZmF1bHRHbG93ZXJTdHlsZXMsXG4gICAgICAgIHZhbHVlcyA9IHN0eWxlcy5sZW5ndGgsXG4gICAgICAgIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCksXG4gICAgICAgIHN0eWxlV2FzID0ge30sXG4gICAgICAgIHRyYW5zaXRpb24gPSBjb21wdXRlZFN0eWxlLnRyYW5zaXRpb24sXG4gICAgICAgIHRyYW5zaXRpb25zID0gdHJhbnNpdGlvbi5zcGxpdCgnLCcpO1xuXG4gICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIHN0eWxlV2FzW3N0eWxlXSA9IHtcbiAgICAgICAgICAgIHN0eWxlOiBjb21wdXRlZFN0eWxlW3N0eWxlXSxcbiAgICAgICAgICAgIHVuZG86IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNpdGlvbnMucHVzaChzdHlsZSArICcgJyArIGR1cmF0aW9uKTtcbiAgICB9KTtcblxuICAgIGVsLnN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9ucy5qb2luKCcsJyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGdsb3dlcik7XG4gICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIGVsLnN0eWxlW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnbG93ZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIHdhcyA9IHN0eWxlV2FzW2V2ZW50LnByb3BlcnR5TmFtZV07XG4gICAgICAgIGlmICh3YXMudW5kbykge1xuICAgICAgICAgICAgZWwuc3R5bGVbZXZlbnQucHJvcGVydHlOYW1lXSA9IHdhcy5zdHlsZTtcbiAgICAgICAgICAgIHdhcy51bmRvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIS0tdmFsdWVzKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZ2xvd2VyKTtcbiAgICAgICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrLmNhbGwoY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMuZWFjaCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKChjb250ZXh0IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSwgaXRlcmF0ZWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZmluZCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKChjb250ZXh0IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSwgaXRlcmF0ZWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUXVldWVsZXNzKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG59XG5cblF1ZXVlbGVzcy5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIGVuZCh0cmFuc0V2ZW50KSB7XG4gICAgICAgIHNlbGYuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZW5kKTtcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdHJhbnNFdmVudCwgc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWVsZXNzO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VCYXNlID0gcmVxdWlyZSgnZmluLWh5cGVyZ3JpZC1kYXRhLXNvdXJjZS1iYXNlJyk7XG5cbnZhciBnZXRGaWVsZE5hbWVzID0gcmVxdWlyZSgnLi9maWVsZHMnKS5nZXRGaWVsZE5hbWVzO1xuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVNvdXJjZU9yaWdpbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgcGFyYW1ldGVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGF0YVNvdXJjZU9yaWdpbiA9IERhdGFTb3VyY2VCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZU9yaWdpbicsICB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50bHkgYSBzeW5vbnltIGZvciB7QGxpbmsgRGF0YVNvdXJjZU9yaWdpbiNzZXREYXRhfSAoc2VlKS5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhLCBzY2hlbWEpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVNvdXJjZTsgLy8gYWRkZWQgYnkgRGF0YVNvdXJjZUJhc2UjaW5pdGlhbGl6ZSBidXQgd2UgZG9uJ3Qgd2FudCBoZXJlXG4gICAgICAgIHRoaXMuX3NjaGVtYSA9IFtdO1xuICAgICAgICB0aGlzLnNldERhdGEoZGF0YSwgc2NoZW1hKTtcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlZGVmIHtvYmplY3R9IGNvbHVtblNjaGVtYU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIHJlcXVpcmVkIGNvbHVtbiBuYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaGVhZGVyXSAtIEFuIG92ZXJyaWRlIGZvciBkZXJpdmVkIGhlYWRlclxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtjYWxjdWxhdG9yXSAtIEEgZnVuY3Rpb24gZm9yIGEgY29tcHV0ZWQgY29sdW1uLiBVbmRlZmluZWQgZm9yIG5vcm1hbCBkYXRhIGNvbHVtbnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXSAtIFVzZWQgZm9yIHNvcnRpbmcgd2hlbiBhbmQgb25seSB3aGVuIGNvbXBhcmF0b3Igbm90IGdpdmVuLlxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbY29tcGFyYXRvcl0gLSBGb3Igc29ydGluZywgYm90aCBvZiBmb2xsb3dpbmcgcmVxdWlyZWQ6XG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gY29tcGFyYXRvci5hc2MgLSBhc2NlbmRpbmcgY29tcGFyYXRvclxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNvbXBhcmF0b3IuZGVzYyAtIGRlc2NlbmRpbmcgY29tcGFyYXRvclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gW2RhdGE9W11dIC0gQXJyYXkgb2YgdW5pZm9ybSBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGdyaWQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge2NvbHVtblNjaGVtYU9iamVjdFtdfSBbc2NoZW1hPVtdXVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEsIHNjaGVtYSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIGFycmF5IG9mIHVuaWZvcm0gZGF0YSBvYmplY3RzLlxuICAgICAgICAgKiBAbmFtZSBzY2hlbWFcbiAgICAgICAgICogQHR5cGUge2NvbHVtblNjaGVtYU9iamVjdFtdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgW107XG5cbiAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEubGVuZ3RoICYmICF0aGlzLnNjaGVtYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2NoZW1hKFtdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQgc2NoZW1hKCkgeyByZXR1cm4gdGhpcy5fc2NoZW1hOyB9LFxuICAgIHNldCBzY2hlbWEoc2NoZW1hKSB7IHRoaXMuX3NjaGVtYSA9IHNjaGVtYTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqIEByZXR1cm5zIHtjb2x1bW5TY2hlbWFPYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRTY2hlbWE6ICBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NoZW1hO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQ2F2ZWF0OiBEbyBub3QgY2FsbCBvbiBhIGRhdGEgdXBkYXRlIHdoZW4geW91IGV4cGVjdCB0byByZXVzZSB0aGUgZXhpc3Rpbmcgc2NoZW1hLlxuICAgICAqIEBwYXJhbSBzY2hlbWFcbiAgICAgKi9cbiAgICBzZXRTY2hlbWE6IGZ1bmN0aW9uKHNjaGVtYSl7XG4gICAgICAgIGlmICghc2NoZW1hLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IGdldEZpZWxkTmFtZXModGhpcy5kYXRhWzBdKTtcblxuICAgICAgICAgICAgc2NoZW1hID0gQXJyYXkoZmllbGRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hW2ldID0geyBuYW1lOiBmaWVsZHNbaV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgYXJyYXkgb2YgY29sdW1uIHNjaGVtYSBvYmplY3RzLlxuICAgICAgICAgKiBAbmFtZSBzY2hlbWFcbiAgICAgICAgICogQHR5cGUge2NvbHVtblNjaGVtYU9iamVjdFtdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NjaGVtYSA9IHNjaGVtYTtcbiAgICB9LFxuXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7ZGF0YVJvd09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRmluZCwgcmVwbGFjZSwgb3IgdXBkYXRlIGEgcm93IGJ5IGl0J3MgcHJpbWFyeSBrZXkgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gY29sdW1uTmFtZSAtIE9uZSBvZjpcbiAgICAgKiAqIF9zdHJpbmdfIC0gQ29sdW1uIG5hbWUuIFNlZSBgdmFsdWVgLlxuICAgICAqICogX29iamVjdF8gLSBIYXNoIG9mIDAgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfCp9IFt2YWx1ZV0gLSBPbmUgb2Y6XG4gICAgICogX29taXR0ZWRfIC0gV2hlbiBgY29sdW1uTmFtZWAgaXMgYSBoYXNoIGFuZCB5b3Ugd2FudCB0byBzZWFyY2ggYWxsIGl0cyBrZXlzLlxuICAgICAqIF9zdHJpbmdbXV8gLSBXaGVuIGBjb2x1bW5OYW1lYCBpcyBhIGhhc2ggYnV0IHlvdSBvbmx5IHdhbnQgdG8gc2VhcmNoIGNlcnRhaW4ga2V5cy5cbiAgICAgKiBfb3RoZXJ3aXNlXyAtIFdoZW4gYGNvbHVtbk5hbWVgIGlzIGEgc3RyaW5nLiBWYWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIE5vdGUgdGhhdCBgbnVsbGAgaXMgYSB2YWxpZCBzZWFyY2ggdmFsdWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R8bnVsbHx1bmRlZmluZWR9IFtyZXBsYWNlbWVudF0gLSBPbmUgb2Y6XG4gICAgICogKiBfb21pdHRlZF8gLSBJZ25vcmVkLlxuICAgICAqICogX29iamVjdF8gLSBSZXBsYWNlbWVudCBmb3IgdGhlIGRhdGEgcm93IGlmIGZvdW5kLlxuICAgICAqICogYG51bGxgIC0gRmxhZyB0byBkZWxldGUgdGhlIGRhdGEgcm93IGlmIGZvdW5kLiBUaGUgZm91bmQgZGF0YSByb3cgaXMgbm9uZXRoZWxlc3MgcmV0dXJuZWQuXG4gICAgICogKiBgdW5kZWZpbmVkYCAtIEZsYWcgdG8gcmV0dXJuIGluZGV4IG9mIGZvdW5kIHJvdyBpbnN0ZWFkIG9mIHJvdyBvYmplY3QgaXRzZWxmLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVtYmVyfHVuZGVmaW5lZH0gT25lIG9mOlxuICAgICAqICogYHVuZGVmaW5lZGAgLSBkYXRhIHJvdyBub3QgZm91bmRcbiAgICAgKiAqIF9vYmplY3RfIC0gZm91bmQgZGF0YSByb3cgb2JqZWN0ICh3aWxsIGhhdmUgYmVlbiBkZWxldGVkIGlmIGByZXBsYWNlbWVudGAgd2FzIGBudWxsYClcbiAgICAgKiAqIF9udW1iZXJfIC0gaW5kZXggb2YgZm91bmQgZGF0YSByb3cgb2JqZWN0IGluIGB0aGlzLmRhdGFgIChpZiBgcmVwbGFjZW1lbnRgIHdhcyBgdW5kZWZpbmVkYClcbiAgICAgKiBAdG9kbyBVc2UgYSBiaW5hcnkgc2VhcmNoIChyYXRoZXIgdGhhbiBgQXJyYXkuLmZpbmRgKSB3aGVuIGNvbHVtbiBpcyBrbm93biB0byBiZSBpbmRleGVkIChzb3J0ZWQpLlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqL1xuICAgIGZpbmRSb3c6IGZ1bmN0aW9uIGZpbmRSb3coY29sdW1uTmFtZSwgdmFsdWUsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQsIGluZGV4LCBrZXlzLCBoYXNoLCBhcmdzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGhhc2ggPSBjb2x1bW5OYW1lO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSAyO1xuICAgICAgICAgICAgICAgIGtleXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCkgIT09IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBhbGwga2V5cyBnaXZlbiBpbiAybmQgYXJnIHRvIGJlIGZvdW5kIGluIGhhc2ggZ2l2ZW4gaW4gMXN0IGFyZy4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IDE7XG4gICAgICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGhhc2gpO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gdmFsdWU7IC8vIHByb21vdGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uTmFtZSA9IGtleXNbMF07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBoYXNoW2NvbHVtbk5hbWVdO1xuICAgICAgICAgICAgICAgIGhhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kYXRhLmZpbmQoZnVuY3Rpb24ocm93LCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBrZXlzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93W2NvbHVtbk5hbWVdICE9PSBoYXNoW2NvbHVtbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBiYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGZvdW5kIVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGF0IGxlYXN0IDIgYXJndW1lbnRzIHdoZW4gZmlyc3QgYXJndW1lbnQgbm90IG9iamVjdCBidXQgZm91bmQgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kYXRhLmZpbmQoZnVuY3Rpb24ocm93LCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdykgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IGlkeDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93W2NvbHVtbk5hbWVdID09PSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5mb3VuZFJvd0luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gYXJncykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBudWxsLCB1bmRlZmluZWQsIG9yIG9iamVjdCBidXQgZm91bmQgJyArIHR5cGVvZiByZXBsYWNlbWVudCArICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmRSb3dJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZpbmQsIHJlcGxhY2UsIG9yIHVwZGF0ZSBhIHJvdyBieSBpdCdzIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFJvdyBpbmRleCB0aGF0IGlzIGJlaW5nIGFjY2Vzc2VkXG4gICAgICogQHBhcmFtIHtvYmplY3R8bnVsbHx1bmRlZmluZWR9IFtyZXBsYWNlbWVudF0gLSBPbmUgb2Y6XG4gICAgICogKiBfb21pdHRlZF8gLSBJZ25vcmVkLlxuICAgICAqICogX29iamVjdF8gLSBSZXBsYWNlbWVudCBmb3IgdGhlIGRhdGEgcm93IGlmIGZvdW5kLlxuICAgICAqICogYG51bGxgIC0gRmxhZyB0byBkZWxldGUgdGhlIGRhdGEgcm93IGlmIGZvdW5kLiBUaGUgZm91bmQgZGF0YSByb3cgaXMgbm9uZXRoZWxlc3MgcmV0dXJuZWQuXG4gICAgICogKiBgdW5kZWZpbmVkYCAtIEZsYWcgdG8gZGVsZXRlIHRoZSByb3cgYXQgdGhhdCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bWJlcnx1bmRlZmluZWR9IE9uZSBvZjpcbiAgICAgKiAqIGB1bmRlZmluZWRgIC0gZGF0YSByb3cgbm90IGZvdW5kXG4gICAgICogKiBfb2JqZWN0XyAtIGZvdW5kIGRhdGEgcm93IG9iamVjdCAod2lsbCBoYXZlIGJlZW4gZGVsZXRlZCBpZiBgcmVwbGFjZW1lbnRgIHdhcyBgbnVsbGApXG4gICAgICogQHRvZG8gVXNlIGEgYmluYXJ5IHNlYXJjaCAocmF0aGVyIHRoYW4gYEFycmF5Li5maW5kYCkgd2hlbiBjb2x1bW4gaXMga25vd24gdG8gYmUgaW5kZXhlZCAoc29ydGVkKS5cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKi9cbiAgICBmaW5kUm93QnlJbmRleDogZnVuY3Rpb24gZmluZFJvdyhpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBhdCBsZWFzdCAxIGFyZ3VtZW50IGJ1dCBmb3VuZCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgYXQgaW5kZXggdG8gYmUgYSBudW1iZXIgYnV0IGdvdCAnICsgaW5kZXggKyAnLic7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0aGlzLmRhdGFbaW5kZXhdO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkICYmIGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIG51bGwsIHVuZGVmaW5lZCwgb3Igb2JqZWN0IGJ1dCBmb3VuZCAnICsgdHlwZW9mIHJlcGxhY2VtZW50ICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Um93KHkpO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd1t0aGlzLnNjaGVtYVt4XS5uYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldFJvdyh5KVt0aGlzLnNjaGVtYVt4XS5uYW1lXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLm1hcChmdW5jdGlvbihjb2x1bW5TY2hlbWEpIHsgcmV0dXJuIGNvbHVtblNjaGVtYS5uYW1lOyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEubWFwKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSkgeyByZXR1cm4gY29sdW1uU2NoZW1hLmhlYWRlcjsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkc1xuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiBmaWVsZHMubGVuZ3RoID09PSB0aGlzLnNjaGVtYS5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdGhpcy5EYXRhU291cmNlRXJyb3IoJ0V4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIGFycmF5IHdpdGggY29ycmVjdCBsZW5ndGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hW2ldLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbaGVhZGVyc10gLSBJZiBvbWl0dGVkLCBoZWFkZXJzIHdpbGwgYmUgcmVzZXQgdG8gdGhlaXIgZGVyaXZlZCBkZWZhdWx0cyBvbiBuZXh0IGNhbGwgdG8gYGdldEhlYWRlcnNgLlxuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShoZWFkZXJzKSAmJiBoZWFkZXJzLmxlbmd0aCA9PT0gdGhpcy5zY2hlbWEubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuRGF0YVNvdXJjZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBhcnJheSB3aXRoIGNvcnJlY3QgbGVuZ3RoLicpO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIsIGkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hW2ldLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlT3JpZ2luO1xuXG5cbi8vIENyZWF0ZSB0aGUgYGRhdGFzYXVyYCBuYW1lc3BhY2UgYW5kIHRoZSBgZGF0YXNhdXIuYmFzZWAgb2JqZWN0IGZvciB1c2UgYnkgZGF0YSBzb3VyY2VzIGluY2x1ZGVkIHZpYSA8c2NyaXB0PiB0YWdzOlxuKHdpbmRvdy5kYXRhc2F1ciA9IHdpbmRvdy5kYXRhc2F1ciB8fCB7fSkuYmFzZSA9IHJlcXVpcmUoJ2Zpbi1oeXBlcmdyaWQtZGF0YS1zb3VyY2UtYmFzZScpO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogQG1vZHVsZSBsb2NhbGl6YXRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vQmFzZScpO1xudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWQnKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0TG9jYWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xvY2FsZT1kZWZhdWx0bG9jYWxlXVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmludmFsaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWQgPSBvcHRpb25zLmludmFsaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RhdGlvbiA9IG9wdGlvbnMuZXhwZWN0YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBTYWZhcmkgaGFzIG5vIEludGwgaW1wbGVtZW50YXRpb25cbmlmICghd2luZG93LkludGwpIHtcbiAgICB3aW5kb3cuSW50bCA9IHtcbiAgICAgICAgTnVtYmVyRm9ybWF0OiBmdW5jdGlvbihsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBkaWdpdHMgPSAnMDEyMzQ1Njc4OSc7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy51c2VHcm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlR3JvdXBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRwID0gcy5pbmRleE9mKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwID0gcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChkcCAtPSAzKSA+IDAgJiYgZGlnaXRzLmluZGV4T2Yoc1tkcCAtIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5zdWJzdHIoMCwgZHApICsgJywnICsgcy5zdWJzdHIoZHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgRGF0ZVRpbWVGb3JtYXQ6IGZ1bmN0aW9uKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGRhdGUuZ2V0TW9udGgoKSArIDEgKyAnLScgKyBkYXRlLmdldERhdGUoKSArICctJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKipcbiAqIEBzdW1tYXJ5IENyZWF0ZSBhIG51bWJlciBsb2NhbGl6ZXIuXG4gKiBAaW1wbGVtZW50cyBsb2NhbGl6ZXJJbnRlcmZhY2VcbiAqIEBkZXNjIENyZWF0ZSBhbiBvYmplY3QgY29uZm9ybWluZyB0byB7QGxpbmsgbG9jYWxpemVySW50ZXJmYWNlfSBmb3IgbnVtYmVycywgdXNpbmcge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlckZvcm1hdHxJbnRsLk51bWJlckZvcm1hdH0uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdExvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSBQYXNzZWQgdG8gdGhlIHtAbGluayBJbnRsLk51bWJlckZvcm1hdHxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXJGb3JtYXR9IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgYEludGwuTnVtYmVyRm9ybWF0YCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHM9ZmFsc2VdIC0gQWNjZXB0IHN0YW5kYXJkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludCBpbnRlcmNoYW5nZWFibHkgd2l0aCBsb2NhbGl6ZWQgZGlnaXRzIGFuZCBkZWNpbWFsIHBvaW50LiAoVGhpcyBvcHRpb24gaXMgaW50ZXJwcmV0ZWQgaGVyZTsgaXQgaXMgbm90IHVzZWQgYnkgYEludGwuTnVtYmVyRm9ybWF0YC4pXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZvcm1hdHRlclxuICogQHR1dG9yaWFsIGxvY2FsaXphdGlvblxuICovXG52YXIgTnVtYmVyRm9ybWF0dGVyID0gRm9ybWF0dGVyLmV4dGVuZCgnTnVtYmVyRm9ybWF0dGVyJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRlZmF1bHRMb2NhbGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBsb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLmZvcm1hdCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSwgb3B0aW9ucykuZm9ybWF0O1xuXG4gICAgICAgIHZhciBtYXBwZXJPcHRpb25zID0geyB1c2VHcm91cGluZzogZmFsc2UgfSxcbiAgICAgICAgICAgIG1hcHBlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSwgbWFwcGVyT3B0aW9ucykuZm9ybWF0O1xuXG4gICAgICAgIHRoaXMuZGVtYXBwZXIgPSBkZW1hcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBBIHN0cmluZyBjb250YWluaW5nIHRoZSB2YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAgICAgKiBAZGVzYyBDb250YWlucyBhbGwgbG9jYWxpemVkIGRpZ2l0cyArIGxvY2FsaXplZCBkZWNpbWFsIHBvaW50LlxuICAgICAgICAgKiBJZiB3ZSdyZSBhY2NlcHRpbmcgc3RhbmRhcmQgZGlnaXRzLCB3aWxsIGFsc28gY29udGFpbiBhbGwgdGhlIHN0YW5kYXJkIGRpZ2l0cyArIHN0YW5kYXJkIGRlY2ltYWwgcG9pbnQgKGlmIGRpZmZlcmVudCB0aGFuIGxvY2FsaXplZCB2ZXJzaW9ucykuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZXNjIExvY2FsaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQuIFdpbGwgYWxzbyBpbmNsdWRlIHN0YW5kYXJkaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgaWYgYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGlzIHRydXRoeS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGludGVybmFsIHVzZSBieSB0aGUge0BsaW5rIE51bWJlckZvcm1hdHRlciNwYXJzZXxwYXJzZX0gbWV0aG9kLlxuICAgICAgICAgKiBAbWVtYmVyT2YgTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXAgPSBtYXBwZXIoMTAxMjM0NTY3ODkuNSkuc3Vic3RyKDEsIDExKTsgLy8gbG9jYWxpemVkICcwMTIzNDU2Nzg5LidcblxuICAgICAgICBpZiAob3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0cyAmJiB0aGlzLm1hcCAhPT0gJzAxMjM0NTY3ODkuJykge1xuICAgICAgICAgICAgdGhpcy5tYXAgKz0gJzAxMjM0NTY3ODkuJzsgIC8vIHN0YW5kYXJkICcwMTIzNDU2Nzg5LidcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAc3VtbWFyeSBBIHJlZ2V4IHRoYXQgdGVzdHMgYHRydWVgIG9uIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyLlxuICAgICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAZGVzYyBWYWxpZCBjaGFyYWN0ZXJzIGluY2x1ZGU6XG4gICAgICAgICAqXG4gICAgICAgICAqICogTG9jYWxpemVkIGRpZ2l0c1xuICAgICAgICAgKiAqIExvY2FsaXplZCBkZWNpbWFsIHBvaW50XG4gICAgICAgICAqICogU3RhbmRhcmQgZGlnaXRzICh3aGVuIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBpcyB0cnV0aHkpXG4gICAgICAgICAqICogU3RhbmRhcmQgZGVjaW1hbCBwb2ludCAod2hlbiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgaXMgdHJ1dGh5KVxuICAgICAgICAgKiAqIENvc21ldGljIGNoYXJhY3RlcnMgYWRkZWQgYnkgZm9ybWF0dGVyIGFzIHBlciBgb3B0aW9uc2AgKGZvciBodW1hbi1mcmllbmRseSByZWFkYWJpbGl0eSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBjaGFyYWN0ZXJzIG91dHNpZGUgdGhpcyBzZXQgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvcjsgY29uc3VtZWQgYnkgdGhlIHtAbGluayBtb2R1bGU6bG9jYWxpemF0aW9ufk51bWJlckZvcm1hdHRlciNpbnZhbGlkfGludmFsaWR9IG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGVzdGluZyBhIHN0cmluZyBhZ2FpbnN0IHRoaXMgcGF0dGVybiB5aWVsZHMgYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBpbnZhbGlkIGNoYXJhY3RlciBvciBgZmFsc2VgIGlmIGFsbCBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgICAgICogQG1lbWJlck9mIE51bWJlckZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW52YWxpZHMgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ1teJyArXG4gICAgICAgICAgICB0aGlzLmZvcm1hdCgxMTExMSkucmVwbGFjZSh0aGlzLm1hcFsxXSwgJycpICsgLy8gdGhvdXNhbmRzIHNlcGFyYXRvciBpZiBpbiB1c2VcbiAgICAgICAgICAgIHRoaXMubWFwICsgLy8gZGlnaXRzICsgZGVjaW1hbCBwb2ludFxuICAgICAgICAgICAgJ10nXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBUZXN0cyBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBkZXNjIFRlc3RzIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlciB0aGF0IGl0IGNvbnRhaW5zIGFueSBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG1heSBiZSB1bmZvcm1hdHRlZCBvciBpdCBtYXkgYmUgZm9ybWF0dGVkIHdpdGggYW55IG9mIHRoZSBwZXJtaXR0ZWQgZm9ybWF0dGluZyBjaGFyYWN0ZXJzLCBhcyBpbXBsaWVkIGJ5IHRoZSBjb25zdHJ1Y3RvcidzIGBvcHRpb25zYCAocGFzc2VkIHRvIGBJbnRsLk51bWJlckZvcm1hdGApLiBBbnkgb3RoZXIgY2hhcmFjdGVycyBhcmUgY29uc2lkZXJlZCBpbnZhbGlkLlxuICAgICAqXG4gICAgICogSG93ZXZlciwgc3RhbmRhcmQgZGlnaXRzIGFuZCB0aGUgc3RhbmRhcmQgZGVjaW1hbCBwb2ludCBhcmUgY29uc2lkZXJlZCB2YWxpZCBpZiB0aGUgdmFsdWUgb2YgYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGFzIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciB3YXMgdHJ1dGh5LiAoT2YgY291cnNlLCB0aGVzZSBhcmUgYWx3YXlzIHZhbGlkIGZvciBsb2NhbGVzIHRoYXQgdXNlIHRoZW0uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvOlxuICAgICAqIDEuIEZpbHRlciBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIG9uIGEgYG9ua2V5ZG93bmAgZXZlbnQ7IG9yXG4gICAgICogMi4gVGVzdCBhbiBlZGl0ZWQgc3RyaW5nIHByaW9yIHRvIGNhbGxpbmcgdGhlIHtAbGluayBtb2R1bGU6bG9jYWxpemF0aW9ufk51bWJlckZvcm1hdHRlciNwYXJzZXxwYXJzZX0uXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjaGVjayBncmFtbWF0aWNhbCBzeW50YXg7IGl0IG9ubHkgY2hlY2tzIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtYmVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58c3RyaW5nfSBGYWxzeSBtZWFucyB2YWxpZCB3aGljaCBpbiB0aGlzIGNhc2UgbWVhbnMgY29udGFpbnMgb25seSB2YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBtZW1iZXJPZiBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmFsaWRzLnRlc3QobnVtYmVyKTtcbiAgICB9LFxuXG4gICAgZXhwZWN0YXRpb246XG4gICAgICAgICdFeHBlY3RlZCBhIG51bWJlciB3aXRoIG9wdGlvbmFsIGNvbW1hcyAodGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvciksIG9wdGlvbmFsIGRlY2ltYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBmcmFjdGlvbmFsIHBhcnQuXFxuJyArXG4gICAgICAgICdDb21tYSBzZXBhcmF0b3JzIGFyZSBwYXJ0IG9mIHRoZSBmb3JtYXQgYW5kIHdpbGwgYWx3YXlzIGJlIGRpc3BsYXllZCBmb3IgdmFsdWVzID49IDEwMDAuXFxuJyArXG4gICAgICAgICdFZGl0ZWQgdmFsdWVzIGFyZSBhbHdheXMgc2F2ZWQgaW4gdGhlaXIgZW50aXJldHkgZXZlbiB0aG91Z2ggdGhlIGZvcm1hdHRlZCB2YWx1ZSBpcyByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLicsXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsOlxuICAgICAqICogQ29udmVydCBsb2NhbGl6ZWQgZGlnaXRzIGFuZCBkZWNpbWFsIHBvaW50IGNoYXJhY3RlcnMgdG8gc3RhbmRhcmQgZGlnaXRzIGFuZCBkZWNpbWFsIHBvaW50IGNoYXJhY3RlcnMuXG4gICAgICogKiBcIkNsZWFuXCIgdGhlIHN0cmluZyBieSBpZ25vcmluZyBhbGwgb3RoZXIgY2hhcmFjdGVycy5cbiAgICAgKiAqIENvZXJjZSB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTG9jYWxpemVkTnVtYmVyIC0gTWF5IG9yIG1heSBub3QgYmUgZm9ybWF0dGVkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBwcmltaXRpdmUuXG4gICAgICogQHRocm93cyB7c3RyaW5nfSBJbnZhbGlkIG51bWJlci5cbiAgICAgKiBAbWVtYmVyT2YgTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihmb3JtYXR0ZWRMb2NhbGl6ZWROdW1iZXIpIHtcbiAgICAgICAgdmFyIG51bWJlciA9IE51bWJlcihcbiAgICAgICAgICAgIGZvcm1hdHRlZExvY2FsaXplZE51bWJlci5zcGxpdCgnJykubWFwKHRoaXMuZGVtYXBwZXIpLmpvaW4oJycpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIE51bWJlcic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBkZW1hcChjKSB7XG4gICAgdmFyIGQgPSB0aGlzLm1hcC5pbmRleE9mKGMpICUgMTE7XG4gICAgcmV0dXJuIGQgPCAwID8gJycgOiBkIDwgMTAgPyBkIDogJy4nO1xufVxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIGxvY2FsaXplckludGVyZmFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRMb2NhbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbG9jYWxlPWRlZmF1bHRsb2NhbGVdIC0gUGFzc2VkIHRvIHRoZSB7QGxpbmsgSW50bC5EYXRlRm9ybWF0fGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVGb3JtYXR9IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgYEludGwuRGF0ZUZvcm1hdGAgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZvcm1hdHRlclxuICovXG52YXIgRGF0ZUZvcm1hdHRlciA9IEZvcm1hdHRlci5leHRlbmQoJ0RhdGVGb3JtYXR0ZXInLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKiBAc3VtbWFyeSBUcmFuc2Zvcm0gYSBkYXRlIG9iamVjdCBpbnRvIGh1bWFuLWZyaWVuZGx5IHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgb3B0aW9ucykuZm9ybWF0O1xuXG4gICAgICAgIC8vIEdldCBkaWdpdHMgYmVjYXVzZSBtYXkgYmUgY2hpbmVzZSBvciBcInJlYWwgQXJhYmljXCIgbnVtZXJhbHMuXG4gICAgICAgIHZhciB0ZXN0T3B0aW9ucyA9IHsgdXNlR3JvdXBpbmc6IGZhbHNlLCBzdHlsZTogJ2RlY2ltYWwnIH0sXG4gICAgICAgICAgICBsb2NhbGl6ZU51bWJlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSwgdGVzdE9wdGlvbnMpLmZvcm1hdCxcbiAgICAgICAgICAgIGxvY2FsaXplZERpZ2l0cyA9IHRoaXMubG9jYWxpemVkRGlnaXRzID0gbG9jYWxpemVOdW1iZXIoMTAxMjM0NTY3ODkpLnN1YnN0cigxLCAxMCk7IC8vIGFsbCBsb2NhbGl6ZWQgZGlnaXRzIGluIG51bWVyaWNhbCBvcmRlclxuXG4gICAgICAgIHRoaXMuZGlnaXRGb3JtYXR0ZXIgPSBmb3JtYXREaWdpdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpZ2l0UGFyc2VyID0gcGFyc2VEaWdpdC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIExvY2FsaXplIGEgdGVzdCBkYXRlIHdpdGggdGhlIGRlZmF1bHQgbnVtZXJpYyBwYXJ0cyB0byBmaW5kIG91dCB0aGUgcmVzdWx0aW5nIG9yZGVyIG9mIHRoZXNlIHBhcnRzLlxuICAgICAgICB2YXIgeXkgPSAxOTg3LFxuICAgICAgICAgICAgbW0gPSAxMixcbiAgICAgICAgICAgIGRkID0gMzAsXG4gICAgICAgICAgICBZWSA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRGb3JtYXR0ZXIsIHl5KSxcbiAgICAgICAgICAgIE1NID0gdGhpcy50cmFuc2Zvcm1OdW1iZXIodGhpcy5kaWdpdEZvcm1hdHRlciwgbW0pLFxuICAgICAgICAgICAgREQgPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0Rm9ybWF0dGVyLCBkZCksXG4gICAgICAgICAgICB0ZXN0RGF0ZSA9IG5ldyBEYXRlKHl5LCBtbSAtIDEsIGRkKSxcbiAgICAgICAgICAgIGxvY2FsaXplRGF0ZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlKS5mb3JtYXQsXG4gICAgICAgICAgICBsb2NhbGl6ZWREYXRlID0gbG9jYWxpemVEYXRlKHRlc3REYXRlKSwgLy8gYWxsIGxvY2FsaXplZCBkaWdpdHMgKyBsb2NhbGl6ZWQgcHVuY3R1YXRpb25cbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUpLmZvcm1hdCg0NTYpLFxuICAgICAgICAgICAgbG9jYWxpemVkTnVtYmVyUGF0dGVybiA9IHRoaXMubG9jYWxpemVkTnVtYmVyUGF0dGVybiA9IG5ldyBSZWdFeHAoJ1snICsgbG9jYWxpemVkRGlnaXRzICsgJ10rJywgJ2cnKSxcbiAgICAgICAgICAgIHBhcnRzID0gbG9jYWxpemVkRGF0ZS5tYXRjaChsb2NhbGl6ZWROdW1iZXJQYXR0ZXJuKTtcblxuICAgICAgICB0aGlzLnBhcnRzTWFwID0ge1xuICAgICAgICAgICAgeXk6IHBhcnRzLmluZGV4T2YoWVkpLFxuICAgICAgICAgICAgbW06IHBhcnRzLmluZGV4T2YoTU0pLFxuICAgICAgICAgICAgZGQ6IHBhcnRzLmluZGV4T2YoREQpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHMpIHtcbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgKz0gJzEyMzQ1Njc4OTAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBzdW1tYXJ5IEEgcmVnZXggdGhhdCB0ZXN0cyBgdHJ1ZWAgb24gZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZXNjIFZhbGlkIGNoYXJhY3RlcnMgaW5jbHVkZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBMb2NhbGl6ZWQgZGlnaXRzXG4gICAgICAgICAqICogU3RhbmRhcmQgZGlnaXRzICh3aGVuIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBpcyB0cnV0aHkpXG4gICAgICAgICAqICogTG9jYWxpemVkIHB1bmN0dWF0aW9uIHRvIGRlbGltaXQgZGF0ZSBwYXJ0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgY2hhcmFjdGVycyBvdXRzaWRlIHRoaXMgc2V0IGFyZSBjb25zaWRlcmVkIGludmFsaWQuIE5vdGUgdGhhdCB0aGlzIG9ubHkgY3VycmVudGx5IGltcGxlbWVudGVkIHdoZW4gYWxsIHRocmVlIGRhdGUgcGFydHMgYXJlIG51bWVyaWNcbiAgICAgICAgICpcbiAgICAgICAgICogU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvcjsgY29uc3VtZWQgYnkgdGhlIHtAbGluayBOdW1iZXJGb3JtYXR0ZXIjdmFsaWR8dmFsaWR9IG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGVzdGluZyBhIHN0cmluZyBhZ2FpbnN0IHRoaXMgcGF0dGVybiB5aWVsZHMgYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBpbnZhbGlkIGNoYXJhY3RlciBvciBgZmFsc2VgIGlmIGFsbCBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludmFsaWRzID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdbXicgK1xuICAgICAgICAgICAgbG9jYWxpemVkRGF0ZS5yZXBsYWNlKC8tL2csICdcXFxcLScpICtcbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgK1xuICAgICAgICAgICAgJ10nXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBUZXN0cyBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBkZXNjIFRlc3RzIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlciB0aGF0IGl0IGNvbnRhaW5zIGFueSBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgZGF0ZSBpcyBhc3N1bWVkIHRvIGNvbnRhaW4gbG9jYWxpemVkIGRpZ2l0cyBhbmQgcHVuY3R1YXRpb24gYXMgd291bGQgYmUgcmV0dXJuZWQgYnkgYEludGwuRGF0ZUZvcm1hdGAgd2l0aCB0aGUgZ2l2ZW4gYGxvY2FsZWAgYW5kIGBvcHRpb25zYC4gQW55IG90aGVyIGNoYXJhY3RlcnMgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIHN0YW5kYXJkIGRpZ2l0cyBhbmQgdGhlIHN0YW5kYXJkIGRlY2ltYWwgcG9pbnQgYXJlIGFsc28gY29uc2lkZXJlZCB2YWxpZCBpZiB0aGUgdmFsdWUgb2YgYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGFzIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciB3YXMgdHJ1dGh5LiAoT2YgY291cnNlLCB0aGVzZSBhcmUgYWx3YXlzIHZhbGlkIGZvciBsb2NhbGVzIHRoYXQgdXNlIHRoZW0uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvOlxuICAgICAqIDEuIEZpbHRlciBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIG9uIGEgYG9ua2V5ZG93bmAgZXZlbnQ7IG9yXG4gICAgICogMi4gVGVzdCBhbiBlZGl0ZWQgc3RyaW5nIHByaW9yIHRvIGNhbGxpbmcgdGhlIHtAbGluayBtb2R1bGU6bG9jYWxpemF0aW9ufkRhdGVGb3JtYXR0ZXIjcGFyc2V8cGFyc2V9LlxuICAgICAqXG4gICAgICogTk9URTogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBkYXRlIGZvcm1hdHMgdXNpbmcgYWxsIG51bWVyaWNzICh3aGljaCBpcyB0aGUgZGVmYXVsdCBmb3IgYEludGwuRGF0ZUZvcm1hdGApLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBtZXRob2QgZG9lcyBub3QgY2hlY2sgZ3JhbW1hdGljYWwgc3ludGF4OyBpdCBvbmx5IGNoZWNrcyBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG51bWJlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBDb250YWlucyBvbmx5IHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQG1lbWJlck9mIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmFsaWRzLnRlc3QobnVtYmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbDpcbiAgICAgKiAqIENvbnZlcnQgbG9jYWxpemVkIGRhdGUgdG8gRGF0ZSBvYmplY3QuXG4gICAgICogKiBcIkNsZWFuXCIgdGhlIHN0cmluZyBieSBpZ25vcmluZyBhbGwgb3RoZXIgY2hhcmFjdGVycy5cbiAgICAgKiAqIENvZXJjZSB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxpemVkRGF0ZVxuICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAqIEB0aHJvd3Mge3N0cmluZ30gSW52YWxpZCBkYXRlLlxuICAgICAqIEBtZW1iZXJPZiBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihsb2NhbGl6ZWREYXRlKSB7XG4gICAgICAgIHZhciBkYXRlLFxuICAgICAgICAgICAgcGFydHMgPSBsb2NhbGl6ZWREYXRlLm1hdGNoKHRoaXMubG9jYWxpemVkTnVtYmVyUGF0dGVybik7XG5cbiAgICAgICAgaWYgKHBhcnRzICYmIHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0UGFyc2VyLCBwYXJ0c1t0aGlzLnBhcnRzTWFwLnl5XSksXG4gICAgICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRQYXJzZXIsIHBhcnRzW3RoaXMucGFydHNNYXAubW1dKSAtIDEsXG4gICAgICAgICAgICAgICAgZCA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRQYXJzZXIsIHBhcnRzW3RoaXMucGFydHNNYXAuZGRdKTtcblxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgRGF0ZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgbnVtYmVyIHRvIG9yIGZyb20gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gd2l0aCBsb2NhbGl6ZWQgZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpZ2l0VHJhbnNmb3JtZXIgLSBBIGZ1bmN0aW9uIGJvdW5kIHRvIGB0aGlzYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRyYW5zZm9ybU51bWJlcjogZnVuY3Rpb24oZGlnaXRUcmFuc2Zvcm1lciwgbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKS5zcGxpdCgnJykubWFwKGRpZ2l0VHJhbnNmb3JtZXIpLmpvaW4oJycpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXREaWdpdChkKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemVkRGlnaXRzW2RdO1xufVxuXG5mdW5jdGlvbiBwYXJzZURpZ2l0KGMpIHtcbiAgICB2YXIgZCA9IHRoaXMubG9jYWxpemVkRGlnaXRzLmluZGV4T2YoYyk7XG4gICAgaWYgKGQgPCAwKSB7IGQgPSAnJzsgfVxuICAgIHJldHVybiBkO1xufVxuXG4vKipcbiAqIEFsbCBtZW1iZXJzIGFyZSBsb2NhbGl6ZXJzIChjb25mb3JtIHRvIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2V9KSB3aXRoIGV4Y2VwdGlvbiBvZiBgZ2V0YCwgYHNldGAsIGFuZCBsb2NhbGl6ZXIgY29uc3RydWN0b3JzIHdoaWNoIGFyZSBuYW1lZCAoYnkgY29udmVudGlvbikgZW5kaW5nIGluIFwiRm9ybW1hdHRlclwiLlxuICpcbiAqIFRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgaXMgZnJlZSB0byBhZGQgbG9jYWxpemVycyBhbmQgbG9jYWxpemVyIGZhY3RvcnkgbWV0aG9kcy4gU2VlIHRoZSB7QGxpbmsgTG9jYWxpemF0aW9uI2NvbnN0cnVjdHxjb25zdHJ1Y3R9IGNvbnZlbmllbmNlIG1ldGhvZCB3aGljaCBtYXkgYmUgaGVscGZ1bCBpbiB0aGlzIHJlZ2FyZC5cbiAqIEBwYXJhbSBsb2NhbGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbbnVtYmVyT3B0aW9uc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0ZU9wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTG9jYWxpemF0aW9uKGxvY2FsZSwgbnVtYmVyT3B0aW9ucywgZGF0ZU9wdGlvbnMpIHtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIG51bWJlclxuICAgICAqIEBzZWUgVGhlIHtAbGluayBOdW1iZXJGb3JtYXR0ZXJ8TnVtYmVyRm9ybWF0dGVyfSBjbGFzc1xuICAgICAqIEBtZW1iZXJPZiBMb2NhbGl6YXRpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5pbnQgPSB0aGlzLmZsb2F0ID0gdGhpcy5jb25zdHJ1Y3QoJ251bWJlcicsIE51bWJlckZvcm1hdHRlciwgbnVtYmVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgRGF0ZUZvcm1hdHRlcnxEYXRlRm9ybWF0dGVyfSBjbGFzc1xuICAgICAqIEBtZW1iZXJPZiBMb2NhbGl6YXRpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5jb25zdHJ1Y3QoJ2RhdGUnLCBEYXRlRm9ybWF0dGVyLCBkYXRlT3B0aW9ucyk7XG59XG5cbkxvY2FsaXphdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IExvY2FsaXphdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgJCRDTEFTU19OQU1FOiAnTG9jYWxpemF0aW9uJyxcbiAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuXG4gICAgLyoqIEBzdW1tYXJ5IENyZWF0ZXMgYSBsb2NhbGl6ZXIgZnJvbSBhIGxvY2FsaXplciBmYWN0b3J5IG9iamVjdCB1c2luZyB0aGUgZGVmYXVsdCBsb2NhbGUuXG4gICAgICogQGRlc2MgUGVyZm9ybXMgdGhlIGZvbGxvd2luZyBhY3Rpb25zOlxuICAgICAqIDEuIEJpbmRzIGBDb25zdHJ1Y3RvcmAgdG8gYGxvY2FsZWAuXG4gICAgICogMi4gQWRkcyB0aGUgbmV3bHkgYm91bmQgY29uc3RydWN0b3IgdG8gdGhpcyBvYmplY3QgKGZvciBmdXR1cmUgcmVmZXJlbmNlKSB3aXRoIHRoZSBrZXkgXCJOYW1lRm9ybWF0dGVyXCIgKHdoZXJlIFwiTmFtZVwiIGlzIHRoZSBsb2NhbGl6ZXIgbmFtZSwgYWxsIGxvd2VyIGNhc2UgYnV0IHdpdGggYW4gaW5pdGlhbCBjYXBpdGFsKS5cbiAgICAgKiAzLiBVc2VzIHRoZSBuZXdseSBib3VuZCBjb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBuZXcgbG9jYWxpemVkIGxvY2FsaXplciB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIDQuIEFkZHMgbmV3IGxvY2FsaXplciB0byB0aGlzIG9iamVjdCB2aWEge0BsaW5rIExvY2FsaXphdGlvbiNhZGR8YWRkfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGl6ZXJOYW1lXG4gICAgICogQHBhcmFtIHtDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB7ZmFjdG9yeU9wdGlvbnN9XG4gICAgICogQHJldHVybnMge2xvY2FsaXplckludGVyZmFjZX0gVGhlIG5ldyBsb2NhbGl6ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbihsb2NhbGl6ZXJOYW1lLCBDb25zdHJ1Y3RvciwgZmFjdG9yeU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9IGxvY2FsaXplck5hbWVbMF0udG9VcHBlckNhc2UoKSArIGxvY2FsaXplck5hbWUuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkgKyAnRm9ybWF0dGVyJyxcbiAgICAgICAgICAgIEJvdW5kQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3Rvci5iaW5kKG51bGwsIHRoaXMubG9jYWxlKSxcbiAgICAgICAgICAgIGxvY2FsaXplciA9IG5ldyBCb3VuZENvbnN0cnVjdG9yKGZhY3RvcnlPcHRpb25zKTtcblxuICAgICAgICB0aGlzW2NvbnN0cnVjdG9yTmFtZV0gPSBCb3VuZENvbnN0cnVjdG9yO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChsb2NhbGl6ZXJOYW1lLCBsb2NhbGl6ZXIpO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgUmVnaXN0ZXIgYSBsb2NhbGl6ZXIuXG4gICAgICogQGRlc2MgQ2hlY2tzIHRoZSBwcm92aWRlZCBsb2NhbGl6ZXIgdGhhdCBpdCBjb25mb3JtcyB0byB7QGxpbmsgbG9jYWxpemVySW50ZXJmYWNlfVxuICAgICAqIGFuZCBhZGRzIGl0IHRvIHRoZSBvYmplY3QgdXNpbmcgbG9jYWxpemVyTmFtZSBhbGwgbG93ZXIgY2FzZSBhcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtsb2NhbGl6ZXJJbnRlcmZhY2V9IGxvY2FsaXplclxuICAgICAqIEBtZW1iZXJPZiBMb2NhbGl6YXRpb24ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2xvY2FsaXplckludGVyZmFjZX0gVGhlIHByb3ZpZGVkIGxvY2FsaXplci5cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIGxvY2FsaXplcikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsb2NhbGl6ZXIgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBsb2NhbGl6ZXIgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgbG9jYWxpemVyLmZvcm1hdCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGxvY2FsaXplci5wYXJzZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgbG9jYWxpemVyLmludmFsaWQgJiYgdHlwZW9mIGxvY2FsaXplci5pbnZhbGlkICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBsb2NhbGl6ZXIuZXhwZWN0YXRpb24gJiYgdHlwZW9mIGxvY2FsaXplci5leHBlY3RhdGlvbiAhPT0gJ3N0cmluZydcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgbG9jYWxpemVyIG9iamVjdCB0byBjb25mb3JtIHRvIGludGVyZmFjZS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgbG9jYWxpemVyLm5hbWU7XG4gICAgICAgIG5hbWUgPSBuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpc1tuYW1lXSA9IGxvY2FsaXplcjtcblxuICAgICAgICByZXR1cm4gbG9jYWxpemVyO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnc2V0KG5hbWUsIGxvY2FsaXplciknLCAnYWRkKG5hbWUsIGxvY2FsaXplciknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGl6ZXJOYW1lXG4gICAgICogQHJldHVybnMge2xvY2FsaXplckludGVyZmFjZX1cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWxpemF0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKV0gfHwgdGhpcy5zdHJpbmc7XG4gICAgfSxcblxuICAgIC8vLyAgLy8vICAvLy8gIC8vLyAgLy8vICAgIExPQ0FMSVpFUlMgICAgLy8vICAvLy8gIC8vLyAgLy8vICAvLy9cblxuICAgIC8vIFNwZWNpYWwgbG9jYWxpemVyIGZvciB1c2UgYnkgQ2hyb21lJ3MgZGF0ZSBpbnB1dCBjb250cm9sLlxuICAgIGNocm9tZURhdGU6IHtcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHl5ID0gZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgICAgICBtID0gZGF0ZS5nZXRNb250aCgpICsgMSwgbW0gPSBtIDwgMTAgPyAnMCcgKyBtIDogbSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGRhdGUuZ2V0RGF0ZSgpLCBkZCA9IGQgPCAxMCA/ICcwJyArIGQgOiBkO1xuXG4gICAgICAgICAgICAgICAgZGF0ZSA9IHl5ICsgJy0nICsgbW0gKyAnLScgKyBkZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGRhdGUsXG4gICAgICAgICAgICAgICAgcGFydHMgPSBzdHIuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUocGFydHNbMF0sIHBhcnRzWzFdIC0gMSwgcGFydHNbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG51bGw6IHtcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHN0cmluZzoge1xuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAnJztcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ciArICcnO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbGl6YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBSYW5nZVNlbGVjdGlvbk1vZGVsID0gcmVxdWlyZSgnc3BhcnNlLWJvb2xlYW4tYXJyYXknKTtcblxuLyoqXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzYyBXZSByZXByZXNlbnQgc2VsZWN0aW9ucyBhcyBhIGxpc3Qgb2YgcmVjdGFuZ2xlcyBiZWNhdXNlIGxhcmdlIGFyZWFzIGNhbiBiZSByZXByZXNlbnRlZCBhbmQgdGVzdGVkIGFnYWluc3QgcXVpY2tseSB3aXRoIGEgbWluaW1hbCBhbW91bnQgb2YgbWVtb3J5IHVzYWdlLiBBbHNvIHdlIG5lZWQgdG8gbWFpbnRhaW4gdGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBjb3VudGVyIHBhcnRzIHNvIHdlIGNhbiB0ZXN0IGZvciBzaW5nbGUgZGltZW5zaW9uIGNvbnRhaW5zLiBUaGlzIGlzIGhvdyB3ZSBrbm93IHRvIGhpZ2hsaWdodCB0aGUgZml4ZWQgcmVnaW9ucyBvbiB0aGUgZWRnZXMgb2YgdGhlIGdyaWQuXG4gKi9cblxuZnVuY3Rpb24gU2VsZWN0aW9uTW9kZWwoZ3JpZCkge1xuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgdGhpcy5yZXNldCgpO1xufVxuXG5TZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFsbFJvd3NTZWxlY3RlZDogZmFsc2UsXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBzZWxlY3Rpb25zXG4gICAgICAgICAqIEB0eXBlIHtSZWN0YW5nbGVbXX1cbiAgICAgICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGZsYXR0ZW5lZFhcbiAgICAgICAgICogQHR5cGUge1JlY3RhbmdsZVtdfVxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMgZmxhdHRlbmVkIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbiAobm8gd2lkdGgpLlxuICAgICAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGF0dGVuZWRYID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGZsYXR0ZW5lZFlcbiAgICAgICAgICogQHR5cGUge1JlY3RhbmdsZVtdfVxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMgZmxhdHRlbmVkIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24gKG5vIGhlaWdodCkuXG4gICAgICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYW4gZW1wdHkgYXJyYXkgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFkgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgcm93U2VsZWN0aW9uTW9kZWxcbiAgICAgICAgICogQHR5cGUge1JhbmdlU2VsZWN0aW9uTW9kZWx9XG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcy5cbiAgICAgICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhIG5ldyBSYW5nZVNlbGVjdGlvbk1vZGVsIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbCA9IG5ldyBSYW5nZVNlbGVjdGlvbk1vZGVsKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGNvbHVtblNlbGVjdGlvbk1vZGVsXG4gICAgICAgICAqIEB0eXBlIHtSYW5nZVNlbGVjdGlvbk1vZGVsfVxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMuXG4gICAgICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwgPSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpO1xuXG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0TGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb25zO1xuICAgICAgICB2YXIgc2VsID0gc2Vsc1tzZWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gc2VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0U2VsZWN0aW9uVHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVHlwZSA9IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2VsZWN0IHRoZSByZWdpb24gZGVzY3JpYmVkIGJ5IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveCAtIG9yaWdpbiB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleSAtIGV4dGVudCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCAtIHdoZXRoZXIgdG8gZmlyZSBzZWxlY3Rpb24gY2hhbmdlZCBldmVudFxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXksIHNpbGVudCkge1xuICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5ncmlkLm5ld1JlY3RhbmdsZShveCwgb3ksIGV4LCBleSk7XG5cbiAgICAgICAgLy9DYWNoZSB0aGUgZmlyc3Qgc2VsZWN0ZWQgY2VsbCBiZWZvcmUgaXQgZ2V0cyBub3JtYWxpemVkIHRvIHRvcC1sZWZ0IG9yaWdpblxuICAgICAgICBuZXdTZWxlY3Rpb24uZmlyc3RTZWxlY3RlZENlbGwgPSB0aGlzLmdyaWQubmV3UG9pbnQob3gsIG95KTtcblxuICAgICAgICBuZXdTZWxlY3Rpb24ubGFzdFNlbGVjdGVkQ2VsbCA9IChcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbi5maXJzdFNlbGVjdGVkQ2VsbC54ID09PSBuZXdTZWxlY3Rpb24ub3JpZ2luLnggJiZcbiAgICAgICAgICAgIG5ld1NlbGVjdGlvbi5maXJzdFNlbGVjdGVkQ2VsbC55ID09PSBuZXdTZWxlY3Rpb24ub3JpZ2luLnlcbiAgICAgICAgKVxuICAgICAgICAgICAgPyBuZXdTZWxlY3Rpb24uY29ybmVyXG4gICAgICAgICAgICA6IG5ld1NlbGVjdGlvbi5vcmlnaW47XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLm11bHRpcGxlU2VsZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25zLnB1c2gobmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWC5wdXNoKG5ld1NlbGVjdGlvbi5mbGF0dGVuWEF0KDApKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWS5wdXNoKG5ld1NlbGVjdGlvbi5mbGF0dGVuWUF0KDApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uc1swXSA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWFswXSA9IG5ld1NlbGVjdGlvbi5mbGF0dGVuWEF0KDApO1xuICAgICAgICAgICAgdGhpcy5mbGF0dGVuZWRZWzBdID0gbmV3U2VsZWN0aW9uLmZsYXR0ZW5ZQXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY2VsbCcpO1xuXG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG95IC0gb3JpZ2luIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXkgLSBleHRlbnQgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgdG9nZ2xlU2VsZWN0OiBmdW5jdGlvbihveCwgb3ksIGV4LCBleSkge1xuXG4gICAgICAgIHZhciBzZWxlY3RlZCwgaW5kZXg7XG5cbiAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvbnMuZmluZChmdW5jdGlvbihzZWxlY3Rpb24sIGlkeCkge1xuICAgICAgICAgICAgaW5kZXggPSBpZHg7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vcmlnaW4ueCA9PT0gb3ggJiYgc2VsZWN0aW9uLm9yaWdpbi55ID09PSBveSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5leHRlbnQueCA9PT0gZXggJiYgc2VsZWN0aW9uLmV4dGVudC55ID09PSBleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5mbGF0dGVuZWRZLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3gsIG95LCBleCwgZXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZW1vdmUgdGhlIGxhc3Qgc2VsZWN0aW9uIHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbihrZWVwUm93U2VsZWN0aW9ucykge1xuICAgICAgICBpZiAoIWtlZXBSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9ucy5sZW5ndGgpIHsgLS10aGlzLnNlbGVjdGlvbnMubGVuZ3RoOyB9XG4gICAgICAgIGlmICh0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoKSB7IC0tdGhpcy5mbGF0dGVuZWRYLmxlbmd0aDsgfVxuICAgICAgICBpZiAodGhpcy5mbGF0dGVuZWRZLmxlbmd0aCkgeyAtLXRoaXMuZmxhdHRlbmVkWS5sZW5ndGg7IH1cbiAgICAgICAgLy90aGlzLmdldEdyaWQoKS5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlcmUgYXJlIGFjdGl2ZSBzZWxlY3Rpb24ocykuXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnMubGVuZ3RoICE9PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUm93U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDb2x1bW5TZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFNlbGVjdGlvbiBjb3ZlcnMgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLmZsYXR0ZW5lZFgsIDAsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgU2VsZWN0aW9uIGNvdmVycyBhIHNwZWNpZmljIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuZmxhdHRlbmVkWSwgeCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZWxlY3Rpb24gcXVlcnkgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjZWxsIGlzIHNlbGVjdGVkIChwYXJ0IG9mIGFuIGFjdGl2ZSBzZWxlY3Rpb24pLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlW119IHNlbGVjdGlvbnMgLSBTZWxlY3Rpb24gcmVjdGFuZ2xlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0NvbHVtblNlbGVjdGVkKHgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzUm93U2VsZWN0ZWQoeSkgfHxcbiAgICAgICAgICAgIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuc2VsZWN0aW9ucywgeCwgeSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25zLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25zXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2VsbFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3Rpb25zLCB4LCB5KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuICEhc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVjdGFuZ2xlQ29udGFpbnMoc2VsZWN0aW9uLCB4LCB5KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBlbXB0eSBvdXQgYWxsIG91ciBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGtlZXBSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRZLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgaWYgKCFrZWVwUm93U2VsZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy5nZXRHcmlkKCkuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUmVjdGFuZ2xlU2VsZWN0ZWQ6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub3JpZ2luLnggPT09IG94ICYmIHNlbGVjdGlvbi5vcmlnaW4ueSA9PT0gb3kgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZXh0ZW50LnggPT09IGV4ICYmIHNlbGVjdGlvbi5leHRlbnQueSA9PT0gZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0NvbHVtblNlbGVjdGVkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp9XG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RlZDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSb3dzU2VsZWN0ZWQgfHwgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHgxXG4gICAgICogQHBhcmFtIHgyXG4gICAgICovXG4gICAgc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5zZWxlY3QoeDEsIHgyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgc2V0QWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbihpc0l0KSB7XG4gICAgICAgIHRoaXMuYWxsUm93c1NlbGVjdGVkID0gaXNJdDtcbiAgICB9LFxuXG4gICAgYXJlQWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsUm93c1NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHkxXG4gICAgICogQHBhcmFtIHkyXG4gICAgICovXG4gICAgc2VsZWN0Um93OiBmdW5jdGlvbih5MSwgeTIpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5zZWxlY3QoeTEsIHkyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geDFcbiAgICAgKiBAcGFyYW0geDJcbiAgICAgKi9cbiAgICBkZXNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoeDEsIHgyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geTFcbiAgICAgKiBAcGFyYW0geTJcbiAgICAgKi9cbiAgICBkZXNlbGVjdFJvdzogZnVuY3Rpb24oeTEsIHkyKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZUFsbFJvd3NTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAvLyBUbyBkZXNlbGVjdCBhIHJvdywgd2UgbXVzdCBmaXJzdCByZW1vdmUgdGhlIGFsbCByb3dzIGZsYWcuLi5cbiAgICAgICAgICAgIHRoaXMuc2V0QWxsUm93c1NlbGVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIC8vIC4uLmFuZCBjcmVhdGUgYSBzaW5nbGUgcmFuZ2UgcmVwcmVzZW50aW5nIGFsbCByb3dzXG4gICAgICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLnNlbGVjdCgwLCB0aGlzLmdyaWQuZ2V0Um93Q291bnQoKSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoeTEsIHkyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hcmVBbGxSb3dzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlclJvd3MgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRSb3dDb3VudCgpIC0gaGVhZGVyUm93cztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaSArIGhlYWRlclJvd3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfEFycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAgaXNDb2x1bW5PclJvd1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKSB8fCAhdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0RmxhdHRlbmVkWXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gc2VsZWN0aW9uLm9yaWdpbi55O1xuICAgICAgICAgICAgdmFyIHNpemUgPSBzZWxlY3Rpb24uZXh0ZW50LnkgKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzaXplOyByKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGkgPSByICsgdG9wO1xuICAgICAgICAgICAgICAgIGlmICghc2V0W3RpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFt0aV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4IC0geTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgc2VsZWN0Um93c0Zyb21DZWxsczogZnVuY3Rpb24ob2Zmc2V0LCBrZWVwUm93U2VsZWN0aW9ucykge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgICB2YXIgc20gPSB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsO1xuXG4gICAgICAgIGlmICgha2VlcFJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWxsUm93c1NlbGVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHNtLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBzZWxlY3Rpb24ub3JpZ2luLnksXG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudC55O1xuICAgICAgICAgICAgdG9wICs9IG9mZnNldDtcbiAgICAgICAgICAgIHNtLnNlbGVjdCh0b3AsIHRvcCArIGV4dGVudCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqL1xuICAgIHNlbGVjdENvbHVtbnNGcm9tQ2VsbHM6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgICB2YXIgc20gPSB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsO1xuICAgICAgICBzbS5jbGVhcigpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBzZWxlY3Rpb24ub3JpZ2luLngsXG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudC54O1xuICAgICAgICAgICAgbGVmdCArPSBvZmZzZXQ7XG4gICAgICAgICAgICBzbS5zZWxlY3QobGVmdCwgbGVmdCArIGV4dGVudCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5zZWxlY3Rpb25zW3RoaXMuc2VsZWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGxhc3QgJiYgdGhpcy5yZWN0YW5nbGVDb250YWlucyhsYXN0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSByZWN0XG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHJlY3RhbmdsZUNvbnRhaW5zOiBmdW5jdGlvbihyZWN0LCB4LCB5KSB7IC8vVE9ETzogZXhwbG9yZSB3aHkgdGhpcyB3b3JrcyBhbmQgY29udGFpbnMgb24gcmVjdGFuZ2x1bGFyIGRvZXMgbm90XG4gICAgICAgIHZhciBtaW5YID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgdmFyIG1pblkgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB2YXIgbWF4WCA9IG1pblggKyByZWN0LmV4dGVudC54O1xuICAgICAgICB2YXIgbWF4WSA9IG1pblkgKyByZWN0LmV4dGVudC55O1xuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC54IDwgMCkge1xuICAgICAgICAgICAgbWluWCA9IG1heFg7XG4gICAgICAgICAgICBtYXhYID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC55IDwgMCkge1xuICAgICAgICAgICAgbWluWSA9IG1heFk7XG4gICAgICAgICAgICBtYXhZID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPVxuICAgICAgICAgICAgeCA+PSBtaW5YICYmXG4gICAgICAgICAgICB5ID49IG1pblkgJiZcbiAgICAgICAgICAgIHggPD0gbWF4WCAmJlxuICAgICAgICAgICAgeSA8PSBtYXhZO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3Rpb25Nb2RlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKS5Qb2ludDtcblxuLyoqXG4gKiBWYXJpYXRpb24gb2YgYHJlY3Rhbmd1bGFyLlBvaW50YCBidXQgd2l0aCB3cml0YWJsZSBgeGAgYW5kIGB5YFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRhYmxlUG9pbnQoeCwgeSkge1xuICAgIC8vIHNraXAgeCBhbmQgeSBpbml0aWFsaXphdGlvbiBoZXJlIGZvciBwZXJmb3JtYW5jZVxuICAgIC8vIGJlY2F1c2UgdHlwaWNhbGx5IHJlc2V0IGFmdGVyIGluc3RhbnRpYXRpb25cbn1cblxuV3JpdGFibGVQb2ludC5wcm90b3R5cGUgPSBQb2ludC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGVQb2ludDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZWQnKTtcbnZhciBXcml0YWJsZVBvaW50ID0gcmVxdWlyZSgnLi9Xcml0YWJsZVBvaW50Jyk7XG5cbnZhciB3cml0YWJsZURlc2NyaXB0b3IgPSB7IHdyaXRhYmxlOiB0cnVlIH07XG52YXIgZXVtZXJhYmxlRGVzY3JpcHRvciA9IHsgd3JpdGFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfTtcblxuLy8gVGhlIG51bGxTdWJncmlkIGlzIGZvciBDZWxsRXZlbnRzIHJlcHJlc2VudGluZyBjbGlja3MgYmVsb3cgbGFzdCByb3cuXG4vLyB2YXIgbnVsbFN1YmdyaWQgPSB7fTtcblxudmFyIHByb3RvdHlwZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gICAgdmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlzaWJsZVJvdy5zdWJncmlkLmdldFZhbHVlKHRoaXMuZGF0YUNlbGwueCwgdGhpcy5kYXRhQ2VsbC55KTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnZpc2libGVSb3cuc3ViZ3JpZC5zZXRWYWx1ZSh0aGlzLmRhdGFDZWxsLngsIHRoaXMuZGF0YUNlbGwueSwgdmFsdWUpOyB9XG4gICAgfSxcblxuICAgIGRhdGFSb3c6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlzaWJsZVJvdy5zdWJncmlkLmdldFJvdyh0aGlzLmRhdGFDZWxsLnkpOyB9XG4gICAgfSxcblxuICAgIGZvcm1hdHRlZFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWQuZm9ybWF0VmFsdWUodGhpcy5wcm9wZXJ0aWVzLmZvcm1hdCwgdGhpcy52YWx1ZSk7IH1cbiAgICB9LFxuXG4gICAgYm91bmRzOiB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMgfHwgKHRoaXMuX2JvdW5kcyA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMudmlzaWJsZUNvbHVtbi5sZWZ0LFxuICAgICAgICAgICAgeTogdGhpcy52aXNpYmxlUm93LnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnZpc2libGVDb2x1bW4ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMudmlzaWJsZVJvdy5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfSB9LFxuXG4gICAgY29sdW1uUHJvcGVydGllczogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSB0aGlzLl9jb2x1bW5Qcm9wZXJ0aWVzO1xuICAgICAgICBpZiAoIWNwKSB7XG4gICAgICAgICAgICBjcCA9IHRoaXMuY29sdW1uLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hhbmRsZUNvbHVtbiB8fCB0aGlzLmlzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY3AgPSBjcC5yb3dIZWFkZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXRhUm93KSB7XG4gICAgICAgICAgICAgICAgLy8gY3AgYWxyZWFkeSBzZXQgdG8gYmFzaWMgcHJvcHNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZpbHRlclJvdykge1xuICAgICAgICAgICAgICAgIGNwID0gY3AuZmlsdGVyUHJvcGVydGllcztcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVuc2VsZWN0ZWQgaGVhZGVyLCBzdW1tYXJ5LCBldGMuLCBhbGwgaGF2ZSBzYXZlIGxvb2sgYXMgdW5zZWxlY3RlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICBjcCA9IGNwLmNvbHVtbkhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbHVtblByb3BlcnRpZXMgPSBjcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3A7XG4gICAgfSB9LFxuICAgIGNlbGxPd25Qcm9wZXJ0aWVzOiB7IGdldDogZnVuY3Rpb24oKSB7IC8vIGRvIG5vdCB1c2UgZm9yIGdldC9zZXQgcHJvcCBiZWNhdXNlIG1heSByZXR1cm4gbnVsbDsgaW5zdGVhZCB1c2UgIC5nZXRDZWxsUHJvcGVydHkoJ3Byb3AnKSBvciAucHJvcGVydGllcy5wcm9wIChwcmVmZXJyZWQpIHRvIGdldCBhbmQgc2V0Q2VsbFByb3BlcnR5KCdwcm9wJywgdmFsdWUpIHRvIHNldFxuICAgICAgICBpZiAodGhpcy5fY2VsbE93blByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY2VsbE93blByb3BlcnRpZXMgPSB0aGlzLmNvbHVtbi5nZXRDZWxsT3duUHJvcGVydGllcyh0aGlzLmRhdGFDZWxsLnksIHRoaXMudmlzaWJsZVJvdy5zdWJncmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2VsbE93blByb3BlcnRpZXM7IC8vIG51bGwgcmV0dXJuIG1lYW5zIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3RcbiAgICB9IH0sXG4gICAgcHJvcGVydGllczogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsT3duUHJvcGVydGllcyB8fCB0aGlzLmNvbHVtblByb3BlcnRpZXM7XG4gICAgfSB9LFxuICAgIGdldENlbGxQcm9wZXJ0eTogeyB2YWx1ZTogZnVuY3Rpb24oa2V5KSB7IC8vIGluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3MgYnV0IC5wcm9wZXJ0aWVzW2tleV0gaXMgcHJlZmVycmVkXG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNba2V5XTtcbiAgICB9IH0sXG4gICAgc2V0Q2VsbFByb3BlcnR5OiB7IHZhbHVlOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7IC8vIGRvIG5vdCB1c2UgLmNlbGxPd25Qcm9wZXJ0aWVzW2tleV0gPSB2YWx1ZSBiZWNhdXNlIG9iamVjdCBtYXkgYmUgbnVsbCAodGhpcyBtZXRob2QgY3JlYXRlcyBvYmplY3QgYXMgbmVlZGVkKVxuICAgICAgICB0aGlzLl9jZWxsT3duUHJvcGVydGllcyA9IHRoaXMuY29sdW1uLnNldENlbGxQcm9wZXJ0eSh0aGlzLmRhdGFDZWxsLnksIGtleSwgdmFsdWUsIHRoaXMudmlzaWJsZVJvdy5zdWJncmlkKTtcbiAgICB9IH0sXG5cbiAgICAvLyBzcGVjaWFsIG1ldGhvZHMgZm9yIHVzZSBieSByZW5kZXJlciB3aGljaCByZXVzZXMgY2VsbEV2ZW50IG9iamVjdCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgIHJlc2V0OiB7IHZhbHVlOiBmdW5jdGlvbih2aXNpYmxlQ29sdW1uLCB2aXNpYmxlUm93KSB7XG4gICAgICAgIC8vIGdldHRlciBjYWNoZXNcbiAgICAgICAgdGhpcy5fY29sdW1uUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2VsbE93blByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBwYXJ0aWFsIHJlbmRlciBzdXBwb3J0XG4gICAgICAgIHRoaXMuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWluV2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1uID0gdmlzaWJsZUNvbHVtbjtcbiAgICAgICAgdGhpcy52aXNpYmxlUm93ID0gdmlzaWJsZVJvdztcblxuICAgICAgICB0aGlzLnN1YmdyaWQgPSB2aXNpYmxlUm93LnN1YmdyaWQ7XG5cbiAgICAgICAgdGhpcy5jb2x1bW4gPSB2aXNpYmxlQ29sdW1uLmNvbHVtbjsgLy8gZW51bWVyYWJsZSBzbyB3aWxsIGJlIGNvcGllZCB0byBjZWxsIHJlbmRlcmVyIG9iamVjdFxuXG4gICAgICAgIHRoaXMuZ3JpZENlbGwueCA9IHZpc2libGVDb2x1bW4uY29sdW1uSW5kZXg7XG4gICAgICAgIHRoaXMuZ3JpZENlbGwueSA9IHZpc2libGVSb3cuaW5kZXg7XG5cbiAgICAgICAgdGhpcy5kYXRhQ2VsbC54ID0gdGhpcy5jb2x1bW4gJiYgdGhpcy5jb2x1bW4uaW5kZXg7XG4gICAgICAgIHRoaXMuZGF0YUNlbGwueSA9IHZpc2libGVSb3cucm93SW5kZXg7XG4gICAgfSB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoaXMgYENlbGxFdmVudGAgaW5zdGFuY2UgdG8gcG9pbnQgdG8gdGhlIGNlbGwgYXQgdGhlIGdpdmVuIGdyaWQgY29vcmRpbmF0ZXMuXG4gICAgICogQGRlc2MgSWYgdGhlIHJlcXVlc3RlZCBjZWxsIGlzIG5vdCBiZSB2aXNpYmxlIChkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgb3Igb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSByZW5kZXJlZCBncmlkKSwgdGhlIGluc3RhbmNlIGlzIG5vdCByZXNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JpZEMgLSBIb3Jpem9udGFsIGdyaWQgY2VsbCBjb29yZGluYXRlIGFkanVzdGVkIGZvciBob3Jpem9udGFsIHNjcm9sbGluZyBhZnRlciBmaXhlZCBjb2x1bW5zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncmlkWSAtIFJhdyB2ZXJ0aWNhbCBncmlkIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmlzaWJpbGl0eS5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIHJlc2V0R3JpZENZOiB7IHZhbHVlOiBmdW5jdGlvbihncmlkQywgZ3JpZFkpIHtcbiAgICAgICAgdmFyIHZyLCB2YywgdmlzaWJsZSA9ICh2YyA9IHRoaXMucmVuZGVyZXIuZ2V0VmlzaWJsZUNvbHVtbihncmlkQykpICYmICh2ciA9IHRoaXMucmVuZGVyZXIuZ2V0VmlzaWJsZVJvdyhncmlkWSkpO1xuICAgICAgICBpZiAodmlzaWJsZSkgeyB0aGlzLnJlc2V0KHZjLCB2cik7IH1cbiAgICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgfSB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoaXMgYENlbGxFdmVudGAgaW5zdGFuY2UgdG8gcG9pbnQgdG8gdGhlIGNlbGwgYXQgdGhlIGdpdmVuIGdyaWQgY29vcmRpbmF0ZXMuXG4gICAgICogQGRlc2MgSWYgdGhlIHJlcXVlc3RlZCBjZWxsIGlzIG5vdCBiZSB2aXNpYmxlIChkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgb3Igb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSByZW5kZXJlZCBncmlkKSwgdGhlIGluc3RhbmNlIGlzIG5vdCByZXNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JpZFggLSBSYXcgaG9yaXpvbnRhbCBncmlkIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JpZFkgLSBSYXcgdmVydGljYWwgZ3JpZCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFZpc2liaWxpdHkuXG4gICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgKi9cbiAgICByZXNldEdyaWRYWTogeyB2YWx1ZTogZnVuY3Rpb24oZ3JpZFgsIGdyaWRZKSB7XG4gICAgICAgIHZhciB2ciwgdmMsIHZpc2libGUgPSAodmMgPSB0aGlzLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zW2dyaWRYXSkgJiYgKHZyID0gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlUm93KGdyaWRZKSk7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7IHRoaXMucmVzZXQodmMsIHZyKTsgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9IH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgdXAgdGhpcyBgQ2VsbEV2ZW50YCBpbnN0YW5jZSB0byBwb2ludCB0byB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gZGF0YSBjb29yZGluYXRlcy5cbiAgICAgKiBAZGVzYyBJZiB0aGUgcmVxdWVzdGVkIGNlbGwgaXMgbm90IGJlIHZpc2libGUgKGR1ZSB0byBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldyksIHRoZSBpbnN0YW5jZSBpcyBub3QgcmVzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFYIC0gSG9yaXpvbnRhbCBkYXRhIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVkgLSBWZXJ0aWNhbCBkYXRhIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW3N1YmdyaWQ9dGhpcy5iZWhhdmlvci5zdWJncmlkcy5kYXRhXVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBWaXNpYmlsaXR5LlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICovXG4gICAgcmVzZXREYXRhWFk6IHsgdmFsdWU6IGZ1bmN0aW9uKGRhdGFYLCBkYXRhWSwgc3ViZ3JpZCkge1xuICAgICAgICB2YXIgdnIsIHZjLCB2aXNpYmxlID0gKHZjID0gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlRGF0YUNvbHVtbihkYXRhWCkpICYmICh2ciA9IHRoaXMucmVuZGVyZXIuZ2V0VmlzaWJsZURhdGFSb3coZGF0YVksIHN1YmdyaWQpKTtcbiAgICAgICAgaWYgKHZpc2libGUpIHsgdGhpcy5yZXNldCh2YywgdnIpOyB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH0gfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB1cCB0aGlzIGBDZWxsRXZlbnRgIGluc3RhbmNlIHRvIHBvaW50IHRvIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBncmlkIGNvbHVtbiBhbmQgZGF0YSByb3cgY29vcmRpbmF0ZXMuXG4gICAgICogQGRlc2MgSWYgdGhlIHJlcXVlc3RlZCBjZWxsIGlzIG5vdCBiZSB2aXNpYmxlIChkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgb3Igb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSByZW5kZXJlZCBncmlkKSwgdGhlIGluc3RhbmNlIGlzIG5vdCByZXNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JpZFggLSBIb3Jpem9udGFsIGdyaWQgY2VsbCBjb29yZGluYXRlIChhZGp1c3RlZCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcgYWZ0ZXIgZml4ZWQgY29sdW1ucykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFZIC0gVmVydGljYWwgZGF0YSBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtzdWJncmlkPXRoaXMuYmVoYXZpb3Iuc3ViZ3JpZHMuZGF0YV1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmlzaWJpbGl0eS5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIHJlc2V0R3JpZFhEYXRhWTogeyB2YWx1ZTogZnVuY3Rpb24oZ3JpZFgsIGRhdGFZLCBzdWJncmlkKSB7XG4gICAgICAgIHZhciB2ciwgdmMsIHZpc2libGUgPSAodmMgPSB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVDb2x1bW4oZ3JpZFgpKSAmJiAodnIgPSB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVEYXRhUm93KGRhdGFZLCBzdWJncmlkKSk7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7IHRoaXMucmVzZXQodmMsIHZyKTsgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZSAmJiB0aGlzO1xuICAgIH0gfSxcblxuICAgIC8qKlxuICAgICAqIENvcHkgc2VsZiB3aXRoIG9yIHdpdGhvdXQgb3duIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xhbn0gW2Fzc2lnbj1mYWxzZV0gLSBDb3B5IHRoZSBvd24gcHJvcGVydGllcyB0byB0aGUgY2xvbmUuXG4gICAgICogQHJldHVybnMge0NlbGxFdmVudH1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAqL1xuICAgIGNsb25lOiB7IHZhbHVlOiBmdW5jdGlvbihhc3NpZ24pIHtcbiAgICAgICAgdmFyIGNlbGxFdmVudCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIGNlbGxFdmVudC5yZXNldEdyaWRYWSh0aGlzLnZpc2libGVDb2x1bW4uaW5kZXgsIHRoaXMudmlzaWJsZVJvdy5pbmRleCk7XG5cbiAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgLy8gY29weSBvd24gcHJvcHNcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2VsbEV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRXZlbnQ7XG4gICAgfSB9LFxuXG4gICAgZWRpdFBvaW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGhlIGAuZWRpdFBvaW50YCBwcm9wZXJ0eSBpcyBubyBsb25nZXIgYXZhaWxhYmxlIGFzIG9mIHYxLjIuMTAuIFVzZSB0aGUgZm9sbG93aW5nIGNvb3JkaW5hdGVzIGluc3RlYWQ6XFxuJyArXG4gICAgICAgICAgICAnYC5ncmlkQ2VsbC54YCAtIFRoZSBhY3RpdmUgY29sdW1uIGluZGV4LiAoQWRqdXN0ZWQgZm9yIGNvbHVtbiBzY3JvbGxpbmcgYWZ0ZXIgZml4ZWQgY29sdW1ucy4pXFxuJyArXG4gICAgICAgICAgICAnYC5ncmlkQ2VsbC55YCAtIFRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUuIChVbmFmZmVjdGVkIGJ5IHJvdyBzY3JvbGxpbmcuKVxcbicgK1xuICAgICAgICAgICAgJ2AuZGF0YUNlbGwueGAgLSBUaGUgZGF0YSBtb2RlbFxcJ3MgY29sdW1uIGluZGV4LiAoVW5hZmZlY3RlZCBieSBjb2x1bW4gc2Nyb2xsaW5nLilcXG4nICtcbiAgICAgICAgICAgICdgLmRhdGFDZWxsLnlgIC0gVGhlIGRhdGEgbW9kZWxcXCdzIHJvdyBpbmRleC4gKEFkanVzdGVkIGZvciBkYXRhIHJvdyBzY3JvbGxpbmcgYWZ0ZXIgZml4ZWQgcm93cy4pXFxuJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBcIlZpc2libGVcIiBtZWFucyBzY3JvbGxlZCBpbnRvIHZpZXcuXG4gICAgaXNSb3dWaXNpYmxlOiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAhIXRoaXMudmlzaWJsZVJvdzsgfSB9LFxuICAgIGlzQ29sdW1uVmlzaWJsZTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISF0aGlzLnZpc2libGVDb2x1bW47IH0gfSxcbiAgICBpc0NlbGxWaXNpYmxlOiAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNSb3dWaXNpYmxlICYmIHRoaXMuaXNDb2x1bW5WaXNpYmxlOyB9IH0sXG5cbiAgICBpc0RhdGFSb3c6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlzaWJsZVJvdy5zdWJncmlkLmlzRGF0YTsgfSB9LFxuICAgIGlzRGF0YUNvbHVtbjogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ncmlkQ2VsbC54ID49IDA7IH0gfSxcbiAgICBpc0RhdGFDZWxsOiAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNEYXRhUm93ICYmIHRoaXMuaXNEYXRhQ29sdW1uOyB9IH0sXG5cbiAgICBpc1Jvd1NlbGVjdGVkOiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzRGF0YVJvdyAmJiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzUm93U2VsZWN0ZWQodGhpcy5kYXRhQ2VsbC55KTsgfSB9LFxuICAgIGlzQ29sdW1uU2VsZWN0ZWQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNEYXRhQ29sdW1uICYmIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDb2x1bW5TZWxlY3RlZCh0aGlzLmdyaWRDZWxsLngpOyB9IH0sXG4gICAgaXNDZWxsU2VsZWN0ZWQ6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZCh0aGlzLmdyaWRDZWxsLngsIHRoaXMuZGF0YUNlbGwueSk7IH0gfSxcblxuICAgIGlzUm93SG92ZXJlZDogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0RhdGFSb3cgJiYgdGhpcy5ncmlkLmhvdmVyQ2VsbCAmJiB0aGlzLmdyaWQuaG92ZXJDZWxsLnkgPT09IHRoaXMuZ3JpZENlbGwueTsgfSB9LFxuICAgIGlzQ29sdW1uSG92ZXJlZDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0RhdGFDb2x1bW4gJiYgdGhpcy5ncmlkLmhvdmVyQ2VsbCAmJiB0aGlzLmdyaWQuaG92ZXJDZWxsLnggPT09IHRoaXMuZ3JpZENlbGwueDsgfSB9LFxuICAgIGlzQ2VsbEhvdmVyZWQ6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc1Jvd0hvdmVyZWQgJiYgdGhpcy5pc0NvbHVtbkhvdmVyZWQ7IH0gfSxcblxuICAgIGlzUm93Rml4ZWQ6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNEYXRhUm93ICYmIHRoaXMuZGF0YUNlbGwueSA8IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmZpeGVkUm93Q291bnQ7IH0gfSxcbiAgICBpc0NvbHVtbkZpeGVkOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzRGF0YUNvbHVtbiAmJiB0aGlzLmdyaWRDZWxsLnggPCB0aGlzLmdyaWQucHJvcGVydGllcy5maXhlZENvbHVtbkNvdW50OyB9IH0sXG4gICAgaXNDZWxsRml4ZWQ6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc1Jvd0ZpeGVkICYmIHRoaXMuaXNDb2x1bW5GaXhlZDsgfSB9LFxuXG4gICAgaXNIYW5kbGVDb2x1bW46IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICF0aGlzLmlzRGF0YUNvbHVtbjsgfSB9LFxuICAgIGlzSGFuZGxlQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzSGFuZGxlQ29sdW1uICYmIHRoaXMuaXNEYXRhUm93OyB9IH0sXG5cbiAgICBpc0hpZXJhcmNoeUNvbHVtbjogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ncmlkQ2VsbC54ID09PSAwICYmIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLnNob3dUcmVlQ29sdW1uICYmIHRoaXMuZGF0YU1vZGVsLmlzRHJpbGxEb3duKHRoaXMuZGF0YUNlbGwueCk7IH0gfSxcblxuICAgIGlzSGVhZGVyUm93OiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpc2libGVSb3cuc3ViZ3JpZC5pc0hlYWRlcjsgfSB9LFxuICAgIGlzSGVhZGVySGFuZGxlOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzSGVhZGVyUm93ICYmIHRoaXMuaXNIYW5kbGVDb2x1bW47IH0gfSxcbiAgICBpc0hlYWRlckNlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0hlYWRlclJvdyAmJiB0aGlzLmlzRGF0YUNvbHVtbjsgfSB9LFxuXG4gICAgaXNGaWx0ZXJSb3c6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlzaWJsZVJvdy5zdWJncmlkLmlzRmlsdGVyOyB9IH0sXG4gICAgaXNGaWx0ZXJIYW5kbGU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNGaWx0ZXJSb3cgJiYgdGhpcy5pc0hhbmRsZUNvbHVtbjsgfSB9LFxuICAgIGlzRmlsdGVyQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzRmlsdGVyUm93ICYmIHRoaXMuaXNEYXRhQ29sdW1uOyB9IH0sXG5cbiAgICBpc1N1bW1hcnlSb3c6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlzaWJsZVJvdy5zdWJncmlkLmlzU3VtbWFyeTsgfSB9LFxuICAgIGlzU3VtbWFyeUhhbmRsZTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc1N1bW1hcnlSb3cgJiYgdGhpcy5pc0hhbmRsZUNvbHVtbjsgfSB9LFxuICAgIGlzU3VtbWFyeUNlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc1N1bW1hcnlSb3cgJiYgdGhpcy5pc0RhdGFDb2x1bW47IH0gfSxcblxuICAgIGlzVG9wVG90YWxzUm93OiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpc2libGVSb3cuc3ViZ3JpZCA9PT0gdGhpcy5iZWhhdmlvci5zdWJncmlkcy5sb29rdXAudG9wVG90YWxzOyB9IH0sXG4gICAgaXNUb3BUb3RhbHNIYW5kbGU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNUb3BUb3RhbHNSb3cgJiYgdGhpcy5pc0hhbmRsZUNvbHVtbjsgfSB9LFxuICAgIGlzVG9wVG90YWxzQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzVG9wVG90YWxzUm93ICYmIHRoaXMuaXNEYXRhQ29sdW1uOyB9IH0sXG5cbiAgICBpc0JvdHRvbVRvdGFsc1JvdzogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52aXNpYmxlUm93LnN1YmdyaWQgPT09IHRoaXMuYmVoYXZpb3Iuc3ViZ3JpZHMubG9va3VwLmJvdHRvbVRvdGFsczsgfSB9LFxuICAgIGlzQm90dG9tVG90YWxzSGFuZGxlOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzQm90dG9tVG90YWxzUm93ICYmIHRoaXMuaXNIYW5kbGVDb2x1bW47IH0gfSxcbiAgICBpc0JvdHRvbVRvdGFsc0NlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0JvdHRvbVRvdGFsc1JvdyAmJiB0aGlzLmlzRGF0YUNvbHVtbjsgfSB9LFxuXG4gICAgJCRDTEFTU19OQU1FOiB7IHZhbHVlOiAnQ2VsbEV2ZW50JyB9LFxuICAgIGRlcHJlY2F0ZWQ6IHsgdmFsdWU6IGRlcHJlY2F0ZWQgfSxcblxuICAgIGlzR3JpZFJvdzogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2lzR3JpZFJvdycsICcuaXNHcmlkUm93IGlzIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMi4xMCBpbiBmYXZvciBvZiAuaXNEYXRhUm93LiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKScpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RhdGFSb3c7XG4gICAgfSB9LFxuICAgIGlzR3JpZENvbHVtbjogeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2lzR3JpZENvbHVtbicsICcuaXNHcmlkQ29sdW1uIGlzIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMi4xMCBpbiBmYXZvciBvZiAuaXNEYXRhQ29sdW1uLiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKScpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RhdGFDb2x1bW47XG4gICAgfSB9LFxuICAgIGlzR3JpZENlbGw6IHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdpc0dyaWRDZWxsJywgJy5pc0dyaWRDZWxsIGlzIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMi4xMCBpbiBmYXZvciBvZiAuaXNEYXRhQ2VsbC4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEYXRhQ2VsbDtcbiAgICB9IH0sXG59KTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIGBDZWxsRXZlbnRgIGlzIGEgdmVyeSBsb3ctbGV2ZWwgb2JqZWN0IHRoYXQgbmVlZHMgdG8gYmUgc3VwZXItZWZmaWNpZW50LiBKYXZhU2NyaXB0IG9iamVjdHMgYXJlIHdlbGwga25vd24gdG8gYmUgbGlnaHQgd2VpZ2h0IGluIGdlbmVyYWwsIGJ1dCBhdCB0aGlzIGxldmVsIHdlIG5lZWQgdG8gYmUgY2FyZWZ1bC5cbiAqXG4gKiBUaGVzZSBvYmplY3RzIHdlcmUgb3JpZ2luYWxseSBvbmx5IGJlaW5nIGNyZWF0ZWQgb24gbW91c2UgZXZlbnRzLiBUaGlzIHdhcyBubyBiaWcgZGVhbCBhcyBtb3VzZSBldmVudHMgYXJlIGZldyBhbmQgZmFyIGJldHdlZW4uIEhvd2V2ZXIsIGFzIG9mIHYxLjIuMCwgdGhlIHJlbmRlcmVyIG5vdyBhbHNvIGNyZWF0ZXMgb25lIGZvciBlYWNoIHZpc2libGUgY2VsbCBvbiBlYWNoIGFuZCBldmVyeSBncmlkIHBhaW50LlxuICpcbiAqIEZvciB0aGlzIHJlYXNvbiwgdG8gbWFpbnRhaW4gcGVyZm9ybWFuY2UsIGVhY2ggZ3JpZCBnZXRzIGEgY3VzdG9tIGRlZmluaXRpb24gb2YgYENlbGxFdmVudGAsIGNyZWF0ZWQgYnkgdGhpcyBjbGFzcyBmYWN0b3J5LCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW1pemF0aW9uczpcbiAqXG4gKiAqIFVzZSBvZiBgZXh0ZW5kLW1lYCBpcyBhdm9pZGVkIGJlY2F1c2UgaXRzIGBpbml0aWFsaXplYCBjaGFpbiBpcyBhIGJpdCB0b28gaGVhdnkgaGVyZS5cbiAqICogQ3VzdG9tIHZlcnNpb25zIG9mIGBDZWxsRXZlbnRgIGZvciBlYWNoIGdyaWQgbGlnaHRlbnMgdGhlIGxvYWQgb24gdGhlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBzdW1tYXJ5IENyZWF0ZSBhIGN1c3RvbSBgQ2VsbEV2ZW50YCBjbGFzcy5cbiAqXG4gKiBAZGVzYyBDcmVhdGUgYSBjdXN0b20gZGVmaW5pdGlvbiBvZiBgQ2VsbEV2ZW50YCBmb3IgZWFjaCBncmlkIGluc3RhbmNlLCBzZXR0aW5nIHRoZSBgZ3JpZGAsIGBiZWhhdmlvcmAsIGFuZCBgZGF0YU1vZGVsYCBwcm9wZXJ0aWVzIG9uIHRoZSBwcm90b3R5cGUuIEFzIHRoaXMgaGFwcGVucyBvbmNlIHBlciBncmlkIGluc3RhbnRpYXRpb24sIGl0IGF2b2lkcyBoYXZpbmcgdG8gcGVyZm9ybSB0aGlzIHNldCB1cCB3b3JrIG9uIGV2ZXJ5IGBDZWxsRXZlbnRgIGluc3RhbnRpYXRpb24uXG4gKlxuICogQHBhcmFtIHtIeXBlckdyaWR9IGdyaWRcbiAqXG4gKiBAcmV0dXJucyB7Q2VsbEV2ZW50fVxuICovXG5mdW5jdGlvbiBmYWN0b3J5KGdyaWQpIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBDZWxsRXZlbnQgb2JqZWN0LlxuICAgICAqIEBkZXNjIEFsbCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBtaXhlZCBpbnRvIGNlbGwgZWRpdG9yOlxuICAgICAqICogSW5jbHVkZXMgYHRoaXMuY29sdW1uYCBkZWZpbmVkIGJ5IGNvbnN0cnVjdG9yIChhcyBlbnVtZXJhYmxlKS5cbiAgICAgKiAqIEV4Y2x1ZGVzIGB0aGlzLmdyaWRDZWxsYCwgYHRoaXMuZGF0YUNlbGxgLCBgdGhpcy52aXNpYmxlUm93LnN1YmdyaWRgIGRlZmluZWQgYnkgY29uc3RydWN0b3IgKGFzIG5vbi1lbnVtZXJhYmxlKS5cbiAgICAgKiAqIEFueSBhZGRpdGlvbmFsIChlbnVtZXJhYmxlKSBtZW1iZXJzIG1peGVkIGluIGJ5IGFwcGxpY2F0aW9uJ3MgYGdldENlbGxFZGl0b3JBdGAgb3ZlcnJpZGUuXG4gICAgICpcbiAgICAgKiBPbWl0IHBhcmFtcyB0byBkZWZlciB0aGUgY29udmVuaWVuY2UgY2FsbCB0byB7Q2VsbEV2ZW50I3Jlc2V0R3JpZENZfS5cbiAgICAgKiAoU2VlIGFsc28gdGhlIGFsdGVybmF0aXZlIHtAbGluayBDZWxsRXZlbnQjcmVzZXRHcmlkWFl9OyBhbmQge0BsaW5rIENlbGxFdmVudCNyZXNldERhdGFYWX0gd2hpY2ggYWNjZXB0cyBgZGF0YVhgLCBgZGF0YVlgLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZ3JpZFhdIC0gZ3JpZCBjZWxsIGNvb3JkaW5hdGUgKGFkanVzdGVkIGZvciBob3Jpem9udGFsIHNjcm9sbGluZyBhZnRlciBmaXhlZCBjb2x1bW5zKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2dyaWRZXSAtIGdyaWQgY2VsbCBjb29yZGluYXRlLCBhZGp1c3RlZCAoYWRqdXN0ZWQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZyBpZiBkYXRhIHN1YmdyaWQpXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2VsbEV2ZW50KGdyaWRYLCBncmlkWSkge1xuICAgICAgICAvLyByZW1haW5pbmcgaW5zdGFuY2UgdmFycyBhcmUgbm9uLWVudW1lcmFibGUgc28gYENlbGxFZGl0b3JgIGNvbnN0cnVjdG9yIHdvbid0IG1peCB0aGVtIGluIChmb3IgbXVzdGFjaGUgdXNlKS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbmFtZSB2aXNpYmxlQ29sdW1uXG4gICAgICAgICAgICAgKiBAdHlwZSB7dmlzaWJsZUNvbHVtbkRlc2NyaXB0b3J9XG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpYmxlQ29sdW1uOiB3cml0YWJsZURlc2NyaXB0b3IsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5hbWUgdmlzaWJsZVJvd1xuICAgICAgICAgICAgICogQHR5cGUge3Zpc2libGVSb3dEZXNjcmlwdG9yfVxuICAgICAgICAgICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaWJsZVJvdzogd3JpdGFibGVEZXNjcmlwdG9yLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBuYW1lIHN1YmdyaWRcbiAgICAgICAgICAgICAqIEB0eXBlIHtkYXRhTW9kZWxBUEl9XG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdWJncmlkOiB3cml0YWJsZURlc2NyaXB0b3IsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5hbWUgZ3JpZENlbGxcbiAgICAgICAgICAgICAqIEB0eXBlIHtXcml0YWJsZVBvaW50fVxuICAgICAgICAgICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ3JpZENlbGw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFdyaXRhYmxlUG9pbnRcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5hbWUgZGF0YUNlbGxcbiAgICAgICAgICAgICAqIEB0eXBlIHtXcml0YWJsZVBvaW50fVxuICAgICAgICAgICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGF0YUNlbGw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFdyaXRhYmxlUG9pbnRcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGNvbHVtbiBpcyBlbnVtZXJhYmxlIHNvIGl0IHdpbGwgYmUgY29waWVkIHRvIGNlbGwgZXZlbnQgb24gQ2VsbEV2ZW50LnByb3RvdHlwZS5pbml0aWFsaXplLlxuICAgICAgICAgICAgY29sdW1uOiBldW1lcmFibGVEZXNjcmlwdG9yLFxuXG4gICAgICAgICAgICAvLyBnZXR0ZXIgY2FjaGVzXG4gICAgICAgICAgICBfY29sdW1uUHJvcGVydGllczogd3JpdGFibGVEZXNjcmlwdG9yLFxuICAgICAgICAgICAgX2NlbGxPd25Qcm9wZXJ0aWVzOiB3cml0YWJsZURlc2NyaXB0b3IsXG4gICAgICAgICAgICBfYm91bmRzOiB3cml0YWJsZURlc2NyaXB0b3IsXG5cbiAgICAgICAgICAgIC8vIEZvbGxvd2luZyBzdXBwb3J0cyBjZWxsIHJlbmRlcmVycycgXCJwYXJ0aWFsIHJlbmRlclwiIGNhcGFiaWxpdHk6XG4gICAgICAgICAgICBzbmFwc2hvdDogd3JpdGFibGVEZXNjcmlwdG9yLFxuICAgICAgICAgICAgbWluV2lkdGg6IHdyaXRhYmxlRGVzY3JpcHRvcixcbiAgICAgICAgICAgIGRpc2FibGVkOiB3cml0YWJsZURlc2NyaXB0b3JcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRHcmlkQ1koZ3JpZFgsIGdyaWRZKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENlbGxFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDZWxsRXZlbnQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBDZWxsRXZlbnQgfSxcbiAgICAgICAgZ3JpZDogeyB2YWx1ZTogZ3JpZCB9LFxuICAgICAgICByZW5kZXJlcjogeyB2YWx1ZTogZ3JpZC5yZW5kZXJlciB9LFxuICAgICAgICBzZWxlY3Rpb25Nb2RlbDogeyB2YWx1ZTogZ3JpZC5zZWxlY3Rpb25Nb2RlbCB9LFxuICAgICAgICBiZWhhdmlvcjogeyB2YWx1ZTogZ3JpZC5iZWhhdmlvciB9LFxuICAgICAgICBkYXRhTW9kZWw6IHsgdmFsdWU6IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBDZWxsRXZlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gY29uc29sZS53YXJuIHBvbHlmaWxsIGFzIG5lZWRlZFxuLy8gdXNlZCBmb3IgZGVwcmVjYXRpb24gd2FybmluZ3NcbmlmICghY29uc29sZS53YXJuKSB7XG4gICAgY29uc29sZS53YXJuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFsnV0FSTklORzonXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG59XG5cbnZhciBjbGFzc1dhcm5lZCA9IHt9O1xuXG52YXIgcmVnZXhJc01ldGhvZCA9IC9eXFx3K1xcKC4qXFwpJC87XG5cbi8qKlxuICogVXNlciBpcyB3YXJuZWQgYW5kIG5ldyBwcm9wZXJ0eSBpcyByZXR1cm5lZCBvciBuZXcgbWV0aG9kIGlzIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gV2FybmluZyBrZXkgcGFpcmVkIHdpdGggYXJiaXRyYXJ5IHdhcm5pbmcgaW4gYGRvdFByb3BzYCBPUiBkZXByZWNhdGVkIG1ldGhvZCBuYW1lIHdpdGggcGFyZW50aGVzZXMgY29udGFpbmluZyBvcHRpb25hbCBhcmd1bWVudCBsaXN0IHBhaXJlZCB3aXRoIHJlcGxhY2VtZW50IHByb3BlcnR5IG9yIG1ldGhvZCBpbiBgZG90UHJvcHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvdFByb3BzIC0gQXJiaXRyYXJ5IHdhcm5pbmcgcGFpcmVkIHdpdGggd2FybmluZyBrZXkgaW4gYG1ldGhvZE5hbWVgIE9SIGRvdC1zZXBhcmF0ZWQgbmV3IHByb3BlcnR5IG5hbWUgdG8gaW52b2tlIG9yIG1ldGhvZCBuYW1lIHRvIGNhbGwuIE1ldGhvZCBuYW1lcyBhcmUgaW5kaWNhdGVkIGJ5IGluY2x1ZGluZyBwYXJlbnRoZXNlcyB3aXRoIG9wdGlvbmFsIGFyZ3VtZW50IGxpc3QuIFRoZSBhcmd1bWVudHMgaW4gZWFjaCBsaXN0IGFyZSBkcmF3biBmcm9tIHRoZSBhcmd1bWVudHMgcHJlc2VudGVkIGluIHRoZSBgbWV0aG9kTmFtZWAgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHNpbmNlIC0gVmVyc2lvbiBpbiB3aGljaCB0aGUgbmFtZSB3YXMgZGVwcmVjYXRlZC5cbiAqIEBwYXJhbSB7QXJndW1lbnRzfEFycmF5fSBbYXJnc10gLSBUaGUgYWN0dWFsIGFyZ3VtZW50cyBpbiB0aGUgb3JkZXIgbGlzdGVkIGluIGBtZXRob2ROYW1lYC4gT25seSBuZWVkZWQgd2hlbiBhcmd1bWVudHMgbmVlZCB0byBiZSBmb3J3YXJkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW25vdGVzXSAtIE5vdGVzIHRvIGFkZCB0byBtZXNzYWdlLlxuICogQHJldHVybnMgeyp9IFJldHVybiB2YWx1ZSBvZiBuZXcgcHJvcGVydHkgb3IgbWV0aG9kIGNhbGwuXG4gKi9cbnZhciBkZXByZWNhdGVkID0gZnVuY3Rpb24obWV0aG9kTmFtZSwgZG90UHJvcHMsIHNpbmNlLCBhcmdzLCBub3Rlcykge1xuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gYGFyZ3NgIG9taXR0ZWRcbiAgICAgICAgbm90ZXMgPSBhcmdzO1xuICAgICAgICBhcmdzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBjaGFpbiA9IGRvdFByb3BzLnNwbGl0KCcuJyksXG4gICAgICAgIHdhcm5lZCA9IGNsYXNzV2FybmVkW3RoaXMuJCRDTEFTU19OQU1FXSA9IGNsYXNzV2FybmVkW3RoaXMuJCRDTEFTU19OQU1FXSB8fCB7fSxcbiAgICAgICAgcmVzdWx0ID0gdGhpcyxcbiAgICAgICAgaXNTaW1wbGVXYXJuaW5nID0gZG90UHJvcHMuaW5kZXhPZignICcpID49IDAsXG4gICAgICAgIGlzTWV0aG9kQ2FsbCA9IHJlZ2V4SXNNZXRob2QudGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgbWVtYmVyVHlwZSxcbiAgICAgICAgd2FybmluZztcblxuICAgIGlmICghKG1ldGhvZE5hbWUgaW4gd2FybmVkKSkge1xuICAgICAgICB3YXJuZWRbbWV0aG9kTmFtZV0gPSBkZXByZWNhdGVkLndhcm5pbmdzO1xuICAgIH1cblxuICAgIGlmIChpc01ldGhvZENhbGwpIHtcbiAgICAgICAgaWYgKGlzU2ltcGxlV2FybmluZykge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHJlcGxhY2VtZW50IG1ldGhvZCBvciBwcm9wZXJ0eSBpbiAybmQgcGFyYW1ldGVyIG9mIGRlcHJlY2F0ZWQoKSBjYWxsLic7XG4gICAgICAgIH0gZWxzZSBpZiAod2FybmVkW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICAtLXdhcm5lZFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIG1lbWJlclR5cGUgPSByZWdleElzTWV0aG9kLnRlc3QoZG90UHJvcHMpID8gJ21ldGhvZCcgOiAncHJvcGVydHknO1xuICAgICAgICAgICAgd2FybmluZyA9ICdUaGUgLicgKyBtZXRob2ROYW1lICsgJyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhcyBvZiB2JyArIHNpbmNlICtcbiAgICAgICAgICAgICAgICAnIGluIGZhdm9yIG9mIHRoZSAuJyArIGNoYWluLmpvaW4oJy4nKSArICcgJyArIG1lbWJlclR5cGUgKyAnLicgK1xuICAgICAgICAgICAgICAgICcgKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiknO1xuXG4gICAgICAgICAgICBpZiAobm90ZXMpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nICs9ICcgJyArIG5vdGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2ltcGxlV2FybmluZykge1xuICAgICAgICBpZiAod2FybmVkW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICAtLXdhcm5lZFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihkb3RQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBtZXRob2QgbmFtZSB3aXRoIHBhcmVudGhlc2VzIGluIDFzdCBwYXJhbWV0ZXIgT1Igc2ltcGxlIHdhcm5pbmcgKGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3BhY2VzKSBpbiAybmQgcGFyYW1ldGVyIG9mIGRlcHJlY2F0ZWQoKSBjYWxsLic7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hbEFyZ0xpc3QgPSBhcmdMaXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgZnVuY3Rpb24gbWFwVG9Gb3JtYWxBcmcoYXJnTmFtZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBmb3JtYWxBcmdMaXN0LmluZGV4T2YoYXJnTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93ICdBY3R1YWwgYXJnIFwiJyArIGFyZ05hbWUgKyAnXCIgbm90IGZvdW5kIGluIGZvcm1hbCBhcmcgbGlzdCAnICsgZm9ybWFsQXJnTGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxhc3QgPSBjaGFpbi5sZW5ndGggLSAxOyBpIDw9IGxhc3Q7ICsraSkge1xuICAgICAgICB2YXIgbGluayA9IGNoYWluW2ldLFxuICAgICAgICAgICAgbmFtZSA9IGxpbmsubWF0Y2goL1xcdysvKVswXSxcbiAgICAgICAgICAgIGxpbmtJc01ldGhvZENhbGwgPSByZWdleElzTWV0aG9kLnRlc3QobGluayksXG4gICAgICAgICAgICBhY3R1YWxBcmdMaXN0ID0gbGlua0lzTWV0aG9kQ2FsbCA/IGFyZ0xpc3QobGluaykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhY3R1YWxBcmdzID0gW107XG5cbiAgICAgICAgaWYgKGFjdHVhbEFyZ0xpc3QpIHtcbiAgICAgICAgICAgIGFjdHVhbEFyZ3MgPSBhY3R1YWxBcmdMaXN0Lm1hcChtYXBUb0Zvcm1hbEFyZyk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbbmFtZV0uYXBwbHkocmVzdWx0LCBhY3R1YWxBcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5rSXNNZXRob2RDYWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbbmFtZV0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5kZXByZWNhdGVkLndhcm5pbmdzID0gMTsgLy8gMyBvciA1IHdvdWxkIGdldCBtb3JlIGF0dGVudGlvblxuXG5mdW5jdGlvbiBhcmdMaXN0KHMpIHtcbiAgICByZXR1cm4gcy5tYXRjaCgvXlxcdytcXCgoLiopXFwpJC8pWzFdLm1hdGNoKC8oXFx3KykvZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBAc3VtbWFyeSBEeW5hbWljIHByb3BlcnR5IGdldHRlci9zZXR0ZXJzLlxuICogQGRlc2MgRHluYW1pYyBwcm9wZXJ0aWVzIGNhbiBtYWtlIHVzZSBvZiBhIGJhY2tpbmcgc3RvcmUuXG4gKiBUaGlzIGJhY2tpbmcgc3RvcmUgaXMgY3JlYXRlZCBpbiB0aGUgXCJvd25cIiBsYXllciBieSB7QGxpbmsgSHlwZXJncmlkI2NsZWFyU3RhdGV8Y2xlYXJTdGF0ZX0uXG4gKiBUaGUgbWVtYmVycyBvZiB0aGUgYmFja2luZyBzdG9yZSBoYXZlIHRoZSBzYW1lIG5hbWVzIGFzIHRoZSBkeW5hbWljIHByb3BlcnRpZXMgdGhhdCB1dGlsaXplIHRoZW0uXG4gKiBUaGV5IGFyZSBpbml0aWFsaXplZCBieSB7QGxpbmsgSHlwZXJncmlkI2NsZWFyU3RhdGV8Y2xlYXJTdGF0ZX0gdG8gdGhlIGRlZmF1bHQgdmFsdWVzIGZyb20ge0BsaW5rIG1vZHVsZTpkZWZhdWx0c3xkZWZhdWx0c30gb2JqZWN0IG1lbWJlcnMgKGFsc28pIG9mIHRoZSBzYW1lIG5hbWUuXG4gKlxuICogTm90ZTogQmVjYXVzZSB0aGlzIGluaXRpYWxpemF0aW9uIHBpY2tzIHVwIHRoZSB2YWx1ZXMgZnJvbSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzfGRlZmF1bHRzfSB3aGVuIHtAbGluayBIeXBlcmdyaWQjY2xlYXJTdGF0ZXxjbGVhclN0YXRlfSBpcyBjYWxsZWQsIGFueSBjaGFuZ2VzIHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgbWF5IHdpc2ggdG8gbWFrZSB0byB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzfGRlZmF1bHRzfSBzaG91bGQgYmUgbWFkZSBfcHJpb3IgdG9fIGFueSBncmlkIGluc3RhbnRpYXRpb25zLlxuICogQG5hbWUgZHluYW1pY1Byb3BlcnRpZXNcbiAqIEBtb2R1bGVcbiAqL1xudmFyIGR5bmFtaWNQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShkZWZhdWx0cywge1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZHluYW1pY1Byb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhci5ncmlkUmVuZGVyZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24ocmVuZGVyZXJOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnZhci5ncmlkUmVuZGVyZXIgPSByZW5kZXJlck5hbWU7XG4gICAgICAgICAgICB0aGlzLmdyaWQucmVuZGVyZXIuc2V0R3JpZFJlbmRlcmVyKHJlbmRlcmVyTmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkeW5hbWljUHJvcGVydGllc1xuICAgICAqL1xuICAgIGNvbHVtbkluZGV4ZXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1ucygpLm1hcChmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5pbmRleDsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oY29sdW1uSW5kZXhlcykge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLnNldENvbHVtbk9yZGVyKGNvbHVtbkluZGV4ZXMpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkeW5hbWljUHJvcGVydGllcztcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gSHlwZXJncmlkRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbi8vIGV4dGVuZCBmcm9tIGBFcnJvcmBcbkh5cGVyZ3JpZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuLy8gb3ZlcnJpZGUgZXJyb3IgbmFtZSBkaXNwbGF5ZWQgaW4gY29uc29sZVxuSHlwZXJncmlkRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSHlwZXJncmlkRXJyb3InO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh5cGVyZ3JpZEVycm9yO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG5cbnZhciBCZWhhdmlvciA9IHJlcXVpcmUoJy4uL2JlaGF2aW9ycy9CZWhhdmlvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBtZS5cbiAgICAgKiBAZGVzYyBMaXN0ZW5lcnMgYWRkZWQgYnkgdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgcmVtb3ZlZCBieSB7QGxpbmsgSHlwZXJncmlkI3JlbW92ZUV2ZW50TGlzdGVuZXJ8Z3JpZC5yZW1vdmVFdmVudExpc3RlbmVyfSAob3Ige0BsaW5rIEh5cGVyZ3JpZCNyZW1vdmVBbGxFdmVudExpc3RlbmVyc3xncmlkLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzfSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJuYWw9ZmFsc2VdIC0gVXNlZCBieSB7QGxpbmsgSHlwZXJncmlkI2FkZEludGVybmFsRXZlbnRMaXN0ZW5lcnxncmlkLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcn0gKHNlZSkuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyLCBpbnRlcm5hbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXSxcbiAgICAgICAgICAgIGFscmVhZHlBdHRhY2hlZCA9IGxpc3RlbmVycy5maW5kKGZ1bmN0aW9uKGluZm8pIHsgcmV0dXJuIGluZm8ubGlzdGVuZXIgPT09IGxpc3RlbmVyOyB9KTtcblxuICAgICAgICBpZiAoIWFscmVhZHlBdHRhY2hlZCkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWw6IGludGVybmFsLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWxsb3dFdmVudEhhbmRsZXJzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGluZm8pO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGluZm8uZGVjb3JhdG9yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGQgYW4gaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXIgdG8gbWUuXG4gICAgICogQGRlc2MgVGhlIG5ldyBsaXN0ZW5lciBpcyBmbGFnZ2VkIGFzIFwiaW50ZXJuYWwuXCIgSW50ZXJuYWwgbGlzdGVuZXJzIGFyZSByZW1vdmVkIGFzIHVzdWFsIGJ5IHtAbGluayBIeXBlcmdyaWQjcmVtb3ZlRXZlbnRMaXN0ZW5lcnxncmlkLnJlbW92ZUV2ZW50TGlzdGVuZXJ9LiBIb3dldmVyLCB0aGV5IGFyZSBpZ25vcmVkIGJ5IHtAbGluayBIeXBlcmdyaWQjcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnN8Z3JpZC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpfSAoYXMgY2FsbGVkIGJ5IHtAbGluayBIeXBlcmdyaWQjcmVzZXR8cmVzZXR9KS4gKEJ1dCBzZWUge0BsaW5rIEh5cGVyZ3JpZCNyZW1vdmVBbGxFdmVudExpc3RlbmVyc3xncmlkLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKHRydWUpfS4pXG4gICAgICpcbiAgICAgKiBMaXN0ZW5lcnMgYWRkZWQgYnkgdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgcmVtb3ZlZCBieSB7QGxpbmsgSHlwZXJncmlkI3JlbW92ZUV2ZW50TGlzdGVuZXJ8Z3JpZC5yZW1vdmVFdmVudExpc3RlbmVyfSAob3Ige0BsaW5rIEh5cGVyZ3JpZCNyZW1vdmVBbGxFdmVudExpc3RlbmVyc3xncmlkLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKHRydWUpfSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBhZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBkZXNjIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVyIHdpdGggbWF0Y2hpbmcgbmFtZSBhbmQgZnVuY3Rpb24gdGhhdCB3YXMgYWRkZWQgYnkge0BsaW5rIEh5cGVyZ3JpZCNhZGRFdmVudExpc3RlbmVyfGdyaWQuYWRkRXZlbnRMaXN0ZW5lcn0uXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBjYW5ub3QgcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBhZGRlZCBieSBvdGhlciBtZWFucy5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyTGlzdCA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyTGlzdCkge1xuICAgICAgICAgICAgbGlzdGVuZXJMaXN0LmZpbmQoZnVuY3Rpb24oaW5mbywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJMaXN0LnNwbGljZShpbmRleCwgMSk7IC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBpbmZvLmRlY29yYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBkZXNjIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycyBhZGRlZCB3aXRoIHtAbGluayBIeXBlcmdyaWQjYWRkRXZlbnRMaXN0ZW5lcnxncmlkLmFkZEV2ZW50TGlzdGVuZXJ9IGV4Y2VwdCB0aG9zZSBhZGRlZCBhcyBcImludGVybmFsLlwiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJuYWw9ZmFsc2VdIC0gSW5jbHVkZSBpbnRlcm5hbCBsaXN0ZW5lcnMuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICByZW1vdmVBbGxFdmVudExpc3RlbmVyczogZnVuY3Rpb24oaW50ZXJuYWwpIHtcbiAgICAgICAgXyh0aGlzLmxpc3RlbmVycykuZWFjaChmdW5jdGlvbihsaXN0ZW5lckxpc3QsIGtleSkge1xuICAgICAgICAgICAgbGlzdGVuZXJMaXN0LmZvckVhY2goZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbCB8fCAhaW5mby5pbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LCBpbmZvLmxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGFsbG93RXZlbnRzOiBmdW5jdGlvbihhbGxvdyl7XG4gICAgICAgIGlmICgodGhpcy5hbGxvd0V2ZW50SGFuZGxlcnMgPSAhIWFsbG93KSl7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmZlYXR1cmVDaGFpbi5hdHRhY2hDaGFpbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5mZWF0dXJlQ2hhaW4uZGV0YWNoQ2hhaW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gZ3JpZCBjb2x1bW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5c1xuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNDb2x1bW5Tb3J0RXZlbnQ6IGZ1bmN0aW9uKGMsIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWNvbHVtbi1zb3J0Jywge1xuICAgICAgICAgICAgY29sdW1uOiBjLFxuICAgICAgICAgICAga2V5czoga2V5c1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleVVwRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWVkaXRvci1rZXl1cCcsIHtcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnQsXG4gICAgICAgICAgICBjaGFyOiB0aGlzLmNhbnZhcy5nZXRDaGFyTWFwKClba2V5RXZlbnQua2V5Q29kZV1ba2V5RXZlbnQuc2hpZnRLZXkgPyAxIDogMF1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNFZGl0b3JLZXlEb3duRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWVkaXRvci1rZXlkb3duJywge1xuICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgIGtleUV2ZW50OiBrZXlFdmVudCxcbiAgICAgICAgICAgIGNoYXI6IHRoaXMuY2FudmFzLmdldENoYXJNYXAoKVtrZXlFdmVudC5rZXlDb2RlXVtrZXlFdmVudC5zaGlmdEtleSA/IDEgOiAwXVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleVByZXNzRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWVkaXRvci1rZXlwcmVzcycsIHtcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnQsXG4gICAgICAgICAgICBjaGFyOiB0aGlzLmNhbnZhcy5nZXRDaGFyTWFwKClba2V5RXZlbnQua2V5Q29kZV1ba2V5RXZlbnQuc2hpZnRLZXkgPyAxIDogMF1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNFZGl0b3JEYXRhQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1lZGl0b3ItZGF0YS1jaGFuZ2UnLCB0cnVlLCB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLXJvdy1zZWxlY3Rpb24tY2hhbmdlZGAgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1yb3ctc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpLFxuICAgICAgICB9KTtcbiAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljQ29sdW1uU2VsZWN0aW9uQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWNvbHVtbi1zZWxlY3Rpb24tY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIHJvd3M6IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY29udGV4dC1tZW51YCBldmVudFxuICAgICAqIEBwYXJhbSB7a2V5RXZlbnR9IGV2ZW50IC0gVGhlIGNhbnZhcyBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljQ29udGV4dE1lbnVFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucm93cyA9IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIGV2ZW50LmNvbHVtbnMgPSB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgICAgICBldmVudC5zZWxlY3Rpb25zID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1jb250ZXh0LW1lbnUnLCB7fSwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VVcEV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5yb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgZXZlbnQuY29sdW1ucyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgICAgIGV2ZW50LnNlbGVjdGlvbnMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLW1vdXNldXAnLCB7fSwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VEb3duRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnJvd3MgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICBldmVudC5jb2x1bW5zID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICAgICAgZXZlbnQuc2VsZWN0aW9ucyA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tbW91c2Vkb3duJywge30sIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY01vdXNlTW92ZUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tbW91c2Vtb3ZlJywge30sIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3YWJsZUJ1dHRvbihldmVudC5kYXRhQ2VsbC54LCBldmVudC5ncmlkQ2VsbC55KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWJ1dHRvbi1wcmVzc2VkJywge30sIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNvbHVtbi1kcmFnLXN0YXJ0YCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljT25Db2x1bW5zQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWNvbHVtbi1jaGFuZ2VkLWV2ZW50Jywge30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWtleWRvd25gIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7a2V5RXZlbnR9IGV2ZW50IC0gVGhlIGNhbnZhcyBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljS2V5ZG93bkV2ZW50OiBmdW5jdGlvbihrZXlFdmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4ta2V5ZG93bicsIGtleUV2ZW50LmRldGFpbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4ta2V5dXBgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7a2V5RXZlbnR9IGV2ZW50IC0gVGhlIGNhbnZhcyBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljS2V5dXBFdmVudDogZnVuY3Rpb24oa2V5RXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWtleXVwJywga2V5RXZlbnQuZGV0YWlsKTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0ZpbHRlckFwcGxpZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1maWx0ZXItYXBwbGllZCcsIHt9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jZWxsLWVudGVyYCBldmVudFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGNlbGwgaW4gd2hpY2ggdGhlIGNsaWNrIGV2ZW50IG9jY3VycmVkLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNPbkNlbGxFbnRlckV2ZW50OiBmdW5jdGlvbihjZWxsRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWNlbGwtZW50ZXInLCBjZWxsRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtZXhpdGAgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJlZC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljT25DZWxsRXhpdEV2ZW50OiBmdW5jdGlvbihjZWxsRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWNlbGwtZXhpdCcsIGNlbGxFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY2VsbC1jbGlja2AgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJlZC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljQ2xpY2tFdmVudDogZnVuY3Rpb24oY2VsbEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1jbGljaycsIHt9LCBjZWxsRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWRvdWJsZS1jbGlja2AgZXZlbnQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0RvdWJsZUNsaWNrRXZlbnQ6IGZ1bmN0aW9uKGNlbGxFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWJvcnRFZGl0aW5nKCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKHRoaXMuYmVoYXZpb3IuY2VsbERvdWJsZUNsaWNrZWQgIT09IEJlaGF2aW9yLnByb3RvdHlwZS5jZWxsRG91YmxlQ2xpY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdmaW4tZG91YmxlLWNsaWNrJywgJ2JlaGF2aW9yLmNlbGxEb3VibGVDbGlja2VkKGdyaWRDZWxsLCBjZWxsRXZlbnQpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMi42IGluIGZhdm9yIG9mIGhhbmRsaW5nIGluIGEgXFwnZmluLWRvdWJsZS1jbGlja1xcJyBldmVudCAoZXZlbnQuZGV0YWlsLmdyaWRDZWxsLCBldmVudC5wcmltaXRpdmVFdmVudCkgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvIGRlcHJlY2F0ZSwgcmVtb3ZlIGFib3ZlIHdhcm5pbmcgKyBmb2xsb3dpbmcgbGluZSArIGFic3RyYWN0IGltcGxlbWVudGF0aW9uIGluIEJlaGF2aW9yLmpzXG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2VsbERvdWJsZUNsaWNrZWQoY2VsbEV2ZW50LmdyaWRDZWxsLCBjZWxsRXZlbnQpO1xuXG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1kb3VibGUtY2xpY2snLCB7fSwgY2VsbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgcmVuZGVyZWQgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0dyaWRSZW5kZXJlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tZ3JpZC1yZW5kZXJlZCcsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljVGlja0V2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLXRpY2snLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0dyaWRSZXNpemVkRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCAnZmluLWdyaWQtcmVzaXplZCcsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBzY3JvbGwgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBTaG91bGQgYmUgZWl0aGVyIGBmaW4tc2Nyb2xsLXhgIG9yIGBmaW4tc2Nyb2xsLXlgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRWYWx1ZSAtIFRoZSBvbGQgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGZpcmVTY3JvbGxFdmVudDogZnVuY3Rpb24oZXZlbnROYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCBldmVudE5hbWUsIHtcbiAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmlyZVJlcXVlc3RDZWxsRWRpdDogZnVuY3Rpb24oY2VsbEV2ZW50LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsICdmaW4tcmVxdWVzdC1jZWxsLWVkaXQnLCB0cnVlLCB7IHZhbHVlOiB2YWx1ZSB9LCBjZWxsRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBmaW4tYmVmb3JlLWNlbGwtZWRpdCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUHJvY2VlZCAoZG9uJ3QgY2FuY2VsKS5cbiAgICAgKi9cbiAgICBmaXJlQmVmb3JlQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGxFdmVudCwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjb250cm9sKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1iZWZvcmUtY2VsbC1lZGl0JywgdHJ1ZSwge1xuICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgaW5wdXQ6IGNvbnRyb2xcbiAgICAgICAgfSwgY2VsbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IHN1Yi1jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWUgLSBUaGUgb2xkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUuXG4gICAgICovXG4gICAgZmlyZUFmdGVyQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGxFdmVudCwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjb250cm9sKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgJ2Zpbi1hZnRlci1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICBpbnB1dDogY29udHJvbFxuICAgICAgICB9LCBjZWxsRXZlbnQpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZUNhbnZhc0V2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZUV2ZW50KGUsIGNiKSB7XG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQoZS5kZXRhaWwubW91c2UpLFxuICAgICAgICAgICAgICAgIGRlY29yYXRlZEV2ZW50O1xuXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBkZWNvcmF0ZWRFdmVudCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICdwcmltaXRpdmVFdmVudCcsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKHNlbGYsIGRlY29yYXRlZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLXJlc2l6ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLnJlc2l6ZWQoKTtcbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0dyaWRSZXNpemVkRXZlbnQoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50KGUsIGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlTW91c2VNb3ZlKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY01vdXNlTW92ZUV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuYWJvcnRFZGl0aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnQoZSwgZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICAgICAgICAgIG1vdXNlRXZlbnQua2V5cyA9IGUuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZURvd25TdGF0ZSA9IG1vdXNlRXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZU1vdXNlRG93bihtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNNb3VzZURvd25FdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEludGVybmFsRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1jbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50KGUsIGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBtb3VzZUV2ZW50LmtleXMgPSBlLmRldGFpbC5rZXlzOyAvLyB0b2RvOiB0aGlzIHdhcyBpbiBmaW4tdGFwIGJ1dCB3YXNuJ3QgaGVyZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0NsaWNrRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZUNsaWNrKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudChlLCBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZU1vdXNlVXAobW91c2VFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW91c2VEb3duU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljQnV0dG9uUHJlc3NlZEV2ZW50KHNlbGYubW91c2VEb3duU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlRG93blN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNNb3VzZVVwRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudChlLCBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlU3ludGhldGljRG91YmxlQ2xpY2tFdmVudChtb3VzZUV2ZW50LCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlRG91YmxlQ2xpY2sobW91c2VFdmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZHJhZycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnQoZSwgc2VsZi5kZWxlZ2F0ZU1vdXNlRHJhZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWtleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljS2V5ZG93bkV2ZW50KGUpO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUtleURvd24oZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWtleXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucHJvcGVydGllcy5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0tleXVwRXZlbnQoZSk7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlS2V5VXAoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWxFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLXdoZWVsbW92ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50KGUsIHNlbGYuZGVsZWdhdGVXaGVlbE1vdmVkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudChlLCBzZWxmLmRlbGVnYXRlTW91c2VFeGl0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudChlLCBmdW5jdGlvbihtb3VzZUV2ZW50KXtcbiAgICAgICAgICAgICAgICBzZWxmLmRlbGVnYXRlQ29udGV4dE1lbnUobW91c2VFdmVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljQ29udGV4dE1lbnVFdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL1JlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIHRoZSBjb3B5IGV2ZW50IHNvIHdlIGNhbiBjb3B5IG91ciBzZWxlY3RlZCByZWdpb24gdG8gdGhlIHBhc3RlYnVmZmVyIGlmIGNvbmRpdGlvbnMgYXJlIHJpZ2h0LlxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tDbGlwYm9hcmRDb3B5KGV2dCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIERlbGVnYXRlIHRoZSB3aGVlbCBtb3ZlZCBldmVudCB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlV2hlZWxNb3ZlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbldoZWVsTW92ZWQodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlRXhpdCB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZUV4aXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuaGFuZGxlTW91c2VFeGl0KHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBNb3VzZUV4aXQgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Db250ZXh0TWVudSh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgRGVsZWdhdGUgTW91c2VNb3ZlIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZU1vdmU6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uTW91c2VNb3ZlKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgRGVsZWdhdGUgbW91c2Vkb3duIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZURvd246IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmhhbmRsZU1vdXNlRG93bih0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIERlbGVnYXRlIG1vdXNldXAgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlVXA6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uTW91c2VVcCh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIERlbGVnYXRlIGNsaWNrIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVDbGljazogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25DbGljayh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIERlbGVnYXRlIG1vdXNlRHJhZyB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VEcmFnOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlRHJhZyh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFdlJ3ZlIGJlZW4gZG91YmxlY2xpY2tlZCBvbi4gRGVsZWdhdGUgdGhyb3VnaCB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uRG91YmxlQ2xpY2sodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAc3VtbWFyeSBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG5hbWUgYW5kIGNhbGwgaXQgb24gc2VsZi5cbiAgICAgKiBAZGVzYyBUaGlzIHNob3VsZCBhbHNvIGJlIGRlbGVnYXRlZCB0aHJvdWdoIEJlaGF2aW9yIGtlZXBpbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGVyZSB0aG91Z2guXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbktleURvd24odGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IEdlbmVyYXRlIGEgZnVuY3Rpb24gbmFtZSBhbmQgY2FsbCBpdCBvbiBzZWxmLlxuICAgICAqIEBkZXNjIFRoaXMgc2hvdWxkIGFsc28gYmUgZGVsZWdhdGVkIHRocm91Z2ggQmVoYXZpb3Iga2VlcGluZyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoZXJlIHRob3VnaC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVLZXlVcDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbktleVVwKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxufTtcblxudmFyIGRldGFpbHMgPSBbXG4gICAgJ2dyaWRDZWxsJyxcbiAgICAnZGF0YUNlbGwnLFxuICAgICdtb3VzZVBvaW50JyxcbiAgICAna2V5cycsXG4gICAgJ3Jvdydcbl07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbmNlbGFibGU9ZmFsc2VdXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAqIEBwYXJhbSB7Q2VsbEV2ZW50fE1vdXNlRXZlbnR8S2V5Ym9hcmRFdmVudHxvYmplY3R9IFtwcmltaXRpdmVFdmVudF1cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudE5hbWUsIGNhbmNlbGFibGUsIGV2ZW50LCBwcmltaXRpdmVFdmVudCkge1xuICAgIHZhciBkZXRhaWwsIHJlc3VsdDtcblxuICAgIGlmICh0eXBlb2YgY2FuY2VsYWJsZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHByaW1pdGl2ZUV2ZW50ID0gZXZlbnQ7IC8vIHByb3Btb3RlIHByaW1pdGl2ZUV2ZW50IHRvIDNyZCBwb3NpdGlvblxuICAgICAgICBldmVudCA9IGNhbmNlbGFibGU7IC8vIHByb21vdGUgZXZlbnQgdG8gMm5kIHBvc2l0aW9uXG4gICAgICAgIGNhbmNlbGFibGUgPSBmYWxzZTsgLy8gZGVmYXVsdCB3aGVuIG9taXR0ZWRcbiAgICB9XG5cbiAgICBpZiAoIWV2ZW50LmRldGFpbCkge1xuICAgICAgICBldmVudCA9IHsgZGV0YWlsOiBldmVudCB9O1xuICAgIH1cblxuICAgIGRldGFpbCA9IGV2ZW50LmRldGFpbDtcblxuICAgIGlmICghZGV0YWlsLmdyaWQpIHsgLy8gQ2VsbEV2ZW50IG9iamVjdHMgYWxyZWFkeSBoYXZlIGEgKHJlYWQtb25seSkgYGdyaWRgIHByb3BcbiAgICAgICAgZGV0YWlsLmdyaWQgPSB0aGlzO1xuICAgIH1cblxuICAgIGRldGFpbC50aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIGlmIChwcmltaXRpdmVFdmVudCkge1xuICAgICAgICBpZiAoIWRldGFpbC5wcmltaXRpdmVFdmVudCkge1xuICAgICAgICAgICAgZGV0YWlsLnByaW1pdGl2ZUV2ZW50ID0gcHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBwcmltaXRpdmVFdmVudCAmJiAhKGtleSBpbiBkZXRhaWwpKSB7XG4gICAgICAgICAgICAgICAgZGV0YWlsW2tleV0gPSBwcmltaXRpdmVFdmVudFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsYWJsZSkge1xuICAgICAgICBldmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIGV2ZW50KSk7XG5cbiAgICBpZiAoY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZSBmaWVsZHNcbiAqIEBtb2R1bGVcbiAqL1xuXG52YXIgUkVHRVhQX01FVEFfUFJFRklYID0gL15fXy8sIC8vIHN0YXJ0cyB3aXRoIGRvdWJsZSB1bmRlcnNjb3JlXG4gICAgUkVHRVhQX1dPUkRfU0VQQVJBVE9SUyA9IC9bXFxzXFwtX10qKFteXFxzXFwtX10pKFteXFxzXFwtX10rKS9nLFxuICAgIFJFR0VYUF9DQVBJVEFMX0xFVFRFUlMgPSAvW0EtWl0vZyxcbiAgICBSRUdFWFBfTE9XRVJfQ0FTRV9MRVRURVIgPSAvW2Etel0vO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IE1lbWJlciBuYW1lcyBmcm9tIGBoYXNoYCB0aGF0IGRvIF9ub3RfIGJlZ2luIHdpdGggZG91YmxlLXVuZGVyc2NvcmUuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmZpZWxkc1xuICovXG5mdW5jdGlvbiBnZXRGaWVsZE5hbWVzKGhhc2gpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaGFzaCB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uKGZpZWxkTmFtZSkge1xuICAgICAgICByZXR1cm4gIVJFR0VYUF9NRVRBX1BSRUZJWC50ZXN0KGZpZWxkTmFtZSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoYSwgYiwgYykge1xuICAgIHJldHVybiBiLnRvVXBwZXJDYXNlKCkgKyBjO1xufVxuXG4vKipcbiAqIFNlcGFyYXRlcyBjYW1lbCBjYXNlIG9yIHdoaXRlLXNwYWNlLSwgaHlwZW4tLCBvciB1bmRlcnNjb3JlLXNlcGFyYXRlZC13b3JkcyBpbnRvIHRydWx5IHNlcGFyYXRlIHdvcmRzIGFuZCBjYXBpdGFsaXppbmcgdGhlIGZpcnN0IGxldHRlciBvZiBlYWNoLlxuICogQHBhcmFtIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZmllbGRzXG4gKi9cbmZ1bmN0aW9uIHRpdGxlaXplKHN0cmluZykge1xuICAgIHJldHVybiAoUkVHRVhQX0xPV0VSX0NBU0VfTEVUVEVSLnRlc3Qoc3RyaW5nKSA/IHN0cmluZyA6IHN0cmluZy50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAucmVwbGFjZShSRUdFWFBfV09SRF9TRVBBUkFUT1JTLCBjYXBpdGFsaXplKVxuICAgICAgICAucmVwbGFjZShSRUdFWFBfQ0FQSVRBTF9MRVRURVJTLCAnICQmJylcbiAgICAgICAgLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NoZW1hKGRhdGEpe1xuICAgIHJldHVybiBnZXRGaWVsZE5hbWVzKGRhdGEgJiYgZGF0YVswXSB8fCB7fSkubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgaGVhZGVyOiB0aXRsZWl6ZShuYW1lKSB9O1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRGaWVsZE5hbWVzOiBnZXRGaWVsZE5hbWVzLFxuICAgIHRpdGxlaXplOiB0aXRsZWl6ZSxcbiAgICBnZXRTY2hlbWE6IGdldFNjaGVtYVxufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUEk7XG5cbmZ1bmN0aW9uIGNsZWFyRmlsbCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xuICAgIHZhciBhID0gYWxwaGEoY29sb3IpO1xuICAgIGlmIChhIDwgMSkge1xuICAgICAgICAvLyBJZiBiYWNrZ3JvdW5kIGlzIHRyYW5zbHVjZW50LCB3ZSBtdXN0IGNsZWFyIHRoZSByZWN0IGJlZm9yZSB0aGUgZmlsbFJlY3RcbiAgICAgICAgLy8gYmVsb3cgdG8gcHJldmVudCBtaXhpbmcgd2l0aCBwcmV2aW91cyBmcmFtZSdzIHJlbmRlciBvZiB0aGlzIGNlbGwuXG4gICAgICAgIHRoaXMuY2xlYXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBpZiAoYSA+IDApIHtcbiAgICAgICAgdGhpcy5jYWNoZS5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG59XG5cbnZhciBBTFBIQV9SRUdFWCA9IC9eKHRyYW5zcGFyZW50fCgoUkdCfEhTTClBXFwoLiosXFxzKihbXFxkXFwuXSspXFwpKSkkL2k7XG4vLyBUcmllZCB1c2luZyBhbiBgYWxwaGFDYWNoZWAgaGVyZSBidXQgaXQgZGlkbid0IG1ha2UgYSBtZWFzdXJhYmxlIGRpZmZlcmVuY2UuXG5mdW5jdGlvbiBhbHBoYShjc3NDb2xvclNwZWMpIHtcbiAgICB2YXIgbWF0Y2hlcywgcmVzdWx0O1xuXG4gICAgaWYgKCFjc3NDb2xvclNwZWMpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIHNvIG5vdCB2aXNpYmxlOyB0cmVhdCBhcyB0cmFuc3BhcmVudFxuICAgICAgICByZXN1bHQgPSAwO1xuICAgIH0gZWxzZSBpZiAoKG1hdGNoZXMgPSBjc3NDb2xvclNwZWMubWF0Y2goQUxQSEFfUkVHRVgpKSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBhbiBvcGFxdWUgY29sb3IgKGEgY29sb3Igc3BlYyB3aXRoIG5vIGFscGhhIGNoYW5uZWwpXG4gICAgICAgIHJlc3VsdCA9IDE7XG4gICAgfSBlbHNlIGlmIChtYXRjaGVzWzRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3NzQ29sb3JTcGVjIG11c3QgaGF2ZSBiZWVuICd0cmFuc3BhcmVudCdcbiAgICAgICAgcmVzdWx0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBOdW1iZXIobWF0Y2hlc1s0XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIGZvbnRNZXRyaWNzID0ge307XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2lkdGggb2Ygc3RyaW5nIGluIHBpeGVscywgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlciwgYnkgY2hhY2hpbmcgY2hhcmFjdGVyIHdpZHRocyBhbmQgcmV1c2luZyB0aG9zZSB2YWx1ZXMgd2hlbiBwcmV2aW91c2x5IGNhY2hlZC5cbiAqXG4gKiBOT1RFOiBUaGVyZSBpcyBhIG1pbm9yIG1lYXN1cmluZyBlcnJvciB3aGVuIHRha2luZyB0aGUgc3VtIG9mIHRoZSBwaXhlbCB3aWR0aHMgb2YgaW5kaXZpZHVhbCBjaGFyYWN0ZXJzIHRoYXQgbWFrZSB1cCBhIHN0cmluZyB2cy4gdGhlIHBpeGVsIHdpZHRoIG9mIHRoZSBzdHJpbmcgdGFrZW4gYXMgYSB3aG9sZS4gVGhpcyBpcyBwb3NzaWJseSBkdWUgdG8ga2VybmluZyBvciByb3VuZGluZy4gVGhlIGVycm9yIGlzIHR5cGljYWxseSBhYm91dCAwLjElLlxuICogQG1lbWJlck9mIG1vZHVsZTpkZWZhdWx0c1xuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGV4dCB0byBtZWFzdXJlLlxuICogQHJldHVybnMge251Ym1lcn0gV2lkdGggb2Ygc3RyaW5nIGluIHBpeGVscy5cbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dFdpZHRoKHN0cmluZykge1xuICAgIHZhciBtZXRyaWNzID0gZm9udE1ldHJpY3NbdGhpcy5jYWNoZS5mb250XSA9IGZvbnRNZXRyaWNzW3RoaXMuY2FjaGUuZm9udF0gfHwge307XG4gICAgc3RyaW5nICs9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwLCBzdW0gPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmdbaV07XG4gICAgICAgIHN1bSArPSBtZXRyaWNzW2NdID0gbWV0cmljc1tjXSB8fCB0aGlzLm1lYXN1cmVUZXh0KGMpLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG52YXIgRUxMSVBTSVMgPSAnXFx1MjAyNic7IC8vIFRoZSBcIuKAplwiIChkb3QtZG90LWRvdCkgY2hhcmFjdGVyXG5cbi8qKlxuICogU2ltaWxhciB0byBgZ2V0VGV4dFdpZHRoYCBleGNlcHQ6XG4gKiAxLiBBYm9ydHMgYWNjdW11bGF0aW5nIHdoZW4gc3VtIGV4Y2VlZHMgZ2l2ZW4gYHdpZHRoYC5cbiAqIDIuIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYm90aCB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhbmQgdGhlIHN1bSAocmF0aGVyIHRoYW4gYSBudW1iZXIgcHJpbWl0aXZlIGNvbnRhaW5pbmcgdGhlIHN1bSBhbG9uZSkuXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUZXh0IHRvIG1lYXN1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0YXJnZXQgY2VsbDsgb3ZlcmZsb3cgcG9pbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW58bnVsbHx1bmRlZmluZWR9IHRydW5jYXRlVGV4dFdpdGhFbGxpcHNpcyAtIFNlZSB7QGxpbmsgbW9kdWxlOmRlZmF1bHRzLnRydW5jYXRlVGV4dFdpdGhFbGxpcHNpc30uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthYm9ydD1mYWxzZV0gLSBBYm9ydCBtZWFzdXJpbmcgdXBvbiBvdmVyZmxvdy4gUmV0dXJuZWQgYHdpZHRoYCBzdW0gd2lsbCByZWZsZWN0IHRydW5jYXRlZCBzdHJpbmcgcmF0aGVyIHRoYW4gdW50cnVuY2F0ZWQgc3RyaW5nLiBOb3RlIHRoYXQgcmV0dXJuZWQgYHN0cmluZ2AgaXMgdHJ1bmNhdGVkIGluIGVpdGhlciBjYXNlLlxuICogQHJldHVybnMge3tzdHJpbmc6c3RyaW5nLHdpZHRoOm51bWJlcn19XG4gKiAqIGBvYmplY3Quc3RyaW5nYCAtIGB1bmRlZmluZWRgIGlmIGl0IGZpdHM7IHRydW5jYXRlZCB2ZXJzaW9uIG9mIHByb3ZpZGVkIGBzdHJpbmdgIGlmIGl0IGRvZXMgbm90LlxuICogKiBgb2JqZWN0LndpZHRoYCAtIFdpZHRoIG9mIHByb3ZpZGVkIGBzdHJpbmdgIGlmIGl0IGZpdHM7IHdpZHRoIG9mIHRydW5jYXRlZCBzdHJpbmcgaWYgaXQgZG9lcyBub3QuXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRXaWR0aFRydW5jYXRlZChzdHJpbmcsIHdpZHRoLCB0cnVuY2F0ZVRleHRXaXRoRWxsaXBzaXMsIGFib3J0KSB7XG4gICAgdmFyIG1ldHJpY3MgPSBmb250TWV0cmljc1t0aGlzLmNhY2hlLmZvbnRdLFxuICAgICAgICB0cnVuY2F0aW5nID0gdHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHRydW5jU3RyaW5nLCB0cnVuY1dpZHRoLCB0cnVuY0F0O1xuXG4gICAgaWYgKCFtZXRyaWNzKSB7XG4gICAgICAgIG1ldHJpY3MgPSBmb250TWV0cmljc1t0aGlzLmNhY2hlLmZvbnRdID0ge307XG4gICAgICAgIG1ldHJpY3NbRUxMSVBTSVNdID0gdGhpcy5tZWFzdXJlVGV4dChFTExJUFNJUykud2lkdGg7XG4gICAgfVxuXG4gICAgc3RyaW5nICs9ICcnOyAvLyBjb252ZXJ0IHRvIHN0cmluZ1xuICAgIHdpZHRoICs9IHRydW5jYXRlVGV4dFdpdGhFbGxpcHNpcyA9PT0gZmFsc2UgPyAyIDogLTE7IC8vIGZ1ZGdlIGZvciBpbmVxdWFsaXR5XG4gICAgZm9yICh2YXIgaSA9IDAsIHN1bSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2hhciA9IHN0cmluZ1tpXTtcbiAgICAgICAgdmFyIGNoYXJXaWR0aCA9IG1ldHJpY3NbY2hhcl0gPSBtZXRyaWNzW2NoYXJdIHx8IHRoaXMubWVhc3VyZVRleHQoY2hhcikud2lkdGg7XG4gICAgICAgIHN1bSArPSBjaGFyV2lkdGg7XG4gICAgICAgIGlmICghdHJ1bmNTdHJpbmcgJiYgdHJ1bmNhdGluZyAmJiBzdW0gPiB3aWR0aCkge1xuICAgICAgICAgICAgdHJ1bmNBdCA9IGk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydW5jYXRlVGV4dFdpdGhFbGxpcHNpcykge1xuICAgICAgICAgICAgICAgIGNhc2UgdHJ1ZTogLy8gdHJ1bmNhdGUgc3VmZmljaWVudCBjaGFyYWN0ZXJzIHRvIGZpdCBlbGxpcHNpcyBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICB0cnVuY1dpZHRoID0gc3VtIC0gY2hhcldpZHRoICsgbWV0cmljc1tFTExJUFNJU107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVuY0F0ICYmIHRydW5jV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1bmNXaWR0aCAtPSBtZXRyaWNzW3N0cmluZ1stLXRydW5jQXRdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnVuY1N0cmluZyA9IHRydW5jV2lkdGggPiB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJyAvLyBub3QgZW5vdWdoIHJvb20gZXZlbiBmb3IgZWxsaXBzaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1bmNTdHJpbmcgPSBzdHJpbmcuc3Vic3RyKDAsIHRydW5jQXQpICsgRUxMSVBTSVM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZmFsc2U6IC8vIHRydW5jYXRlICpiZWZvcmUqIGxhc3QgcGFydGlhbGx5IHZpc2libGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIHRydW5jU3RyaW5nID0gc3RyaW5nLnN1YnN0cigwLCB0cnVuY0F0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogLy8gdHJ1bmNhdGUgKmFmdGVyKiBwYXJ0aWFsbHkgdmlzaWJsZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrdHJ1bmNBdCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydW5jU3RyaW5nID0gc3RyaW5nLnN1YnN0cigwLCB0cnVuY0F0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0KSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaW5nOiB0cnVuY1N0cmluZyxcbiAgICAgICAgd2lkdGg6IHN1bVxuICAgIH07XG59XG5cbnZhciBmb250RGF0YSA9IHt9O1xuXG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZGVmYXVsdHNcbiAqIEBwYXJhbSBmb250XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dEhlaWdodChmb250KSB7XG4gICAgdmFyIHJlc3VsdCA9IGZvbnREYXRhW2ZvbnRdO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgdmFyIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHRleHQudGV4dENvbnRlbnQgPSAnSGcnO1xuICAgICAgICB0ZXh0LnN0eWxlLmZvbnQgPSBmb250O1xuXG4gICAgICAgIHZhciBibG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBibG9jay5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgIGJsb2NrLnN0eWxlLndpZHRoID0gJzFweCc7XG4gICAgICAgIGJsb2NrLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoYmxvY2spO1xuXG4gICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ2Jhc2VsaW5lJztcblxuICAgICAgICAgICAgdmFyIGJsb2NrUmVjdCA9IGJsb2NrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgcmVzdWx0LmFzY2VudCA9IGJsb2NrUmVjdC50b3AgLSB0ZXh0UmVjdC50b3A7XG5cbiAgICAgICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgICAgIHJlc3VsdC5oZWlnaHQgPSBibG9ja1JlY3QudG9wIC0gdGV4dFJlY3QudG9wO1xuXG4gICAgICAgICAgICByZXN1bHQuZGVzY2VudCA9IHJlc3VsdC5oZWlnaHQgLSByZXN1bHQuYXNjZW50O1xuXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIGZvbnREYXRhW2ZvbnRdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2xpcFNhdmUoY29uZGl0aW9uYWwsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmNvbmRpdGlvbmFsc1N0YWNrLnB1c2goY29uZGl0aW9uYWwpO1xuICAgIGlmIChjb25kaXRpb25hbCkge1xuICAgICAgICB0aGlzLmNhY2hlLnNhdmUoKTtcbiAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmNsaXAoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBSZXN0b3JlKGNvbmRpdGlvbmFsKSB7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uYWxzU3RhY2sucG9wKCkpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5yZXN0b3JlKCk7IC8vIFJlbW92ZSBjbGlwIHJlZ2lvblxuICAgIH1cbn1cblxuQVBJID0ge1xuICAgIGNsZWFyRmlsbDogY2xlYXJGaWxsLFxuICAgIGFscGhhOiBhbHBoYSxcbiAgICBnZXRUZXh0V2lkdGg6IGdldFRleHRXaWR0aCxcbiAgICBnZXRUZXh0V2lkdGhUcnVuY2F0ZWQ6IGdldFRleHRXaWR0aFRydW5jYXRlZCxcbiAgICBnZXRUZXh0SGVpZ2h0OiBnZXRUZXh0SGVpZ2h0LFxuICAgIGNsaXBTYXZlOiBjbGlwU2F2ZSxcbiAgICBjbGlwUmVzdG9yZTogY2xpcFJlc3RvcmUsXG4gICAgdHJ1bmNhdGVUZXh0V2l0aEVsbGlwc2lzOiB0cnVlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFQSTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZmllbGRzOiByZXF1aXJlKCcuL2ZpZWxkcycpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8qIElNUE9SVEFOVCBOT1RFOlxuICogSWYgYW55IG9mIHRoZSBtb2R1bGVzIGxpc3RlZCBiZWxvdyBpcyByZW1vdmVkIGZyb20gSHlwZXJncmlkLCB0aGUgcG9seWZpbGwocykgdGhleSBkZWZpbmUgbXVzdCBiZSBhZGRlZCBoZXJlISEhXG4gKlxuICogMS4gb2JqZWN0LWl0ZXJhdG9ycyBkZWZpbmVzIEFycmF5LnByb3RvdHlwZS5maW5kXG4gKi9cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnbiNQb2x5ZmlsbFxuLy8gKFNhZmFyaSBub3cgc3VwcG9ydHMgTWF0aC5zaWduIGJ1dCBJRSBzdGlsbCBkb2VzIG5vdCBhcyBvZiB2MTEuKVxuTWF0aC5zaWduID0gTWF0aC5zaWduID0gZnVuY3Rpb24oeCkge1xuICAgIHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuICAgIGlmICh4ID09PSAwIHx8IGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICByZXR1cm4geCA+IDAgPyAxIDogLTE7XG59O1xuXG4vLyBMaXRlIHZlcnNpb24gb2Y6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRJbmRleCNQb2x5ZmlsbFxuaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB0aGlzW2ldLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuXG4vLyBTaW1wbGVyIHZlcnNpb24gb2Y6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbGwjUG9seWZpbGxcbmlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbGwgIT09ICdmdW5jdGlvbicpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IDAgOiBzdGFydCA8IDAgPyB0aGlzLmxlbmd0aCArIHN0YXJ0IDogc3RhcnQ7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPCAwID8gdGhpcy5sZW5ndGggKyBlbmQgOiBlbmQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCB8fCAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuXG4vLyBMaXRlIHZlcnNpb24gb2Y6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24jUG9seWZpbGxcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpLlJlY3RhbmdsZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2UgaGF2ZSBhbnkgc2VsZWN0aW9ucy5cbiAgICAgKi9cbiAgICBoYXNTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFNlbGVjdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHdlcmUgbm90IGZ1bGx5IGluaXRpYWxpemVkIHlldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmhhc1NlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUYWIgc2VwYXJhdGVkIHZhbHVlIHN0cmluZyBmcm9tIHRoZSBzZWxlY3Rpb24gYW5kIG91ciBkYXRhLlxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkFzVFNWOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNtID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgaWYgKHNtLmhhc1NlbGVjdGlvbnMoKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IHNlbGVjdGlvbnNbc2VsZWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeFNlbGVjdGlvbkFzVFNWKHNlbGVjdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHNtLmhhc1Jvd1NlbGVjdGlvbnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1YodGhpcy5nZXRSb3dTZWxlY3Rpb25NYXRyaXgoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc20uaGFzQ29sdW1uU2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVih0aGlzLmdldENvbHVtblNlbGVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVjogZnVuY3Rpb24oc2VsZWN0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgLy9vbmx5IHVzZSB0aGUgZGF0YSBmcm9tIHRoZSBsYXN0IHNlbGVjdGlvblxuICAgICAgICBpZiAoc2VsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNlbGVjdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHNlbGVjdGlvbnNbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFyZWEgPSB3aWR0aCAqIGhlaWdodCxcbiAgICAgICAgICAgICAgICBsYXN0Q29sID0gd2lkdGggLSAxLFxuICAgICAgICAgICAgICAgIC8vV2hpdGVzcGFjZSB3aWxsIG9ubHkgYmUgYWRkZWQgb24gbm9uLXNpbmd1bGFyIHJvd3MsIHNlbGVjdGlvbnNcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlRGVsaW1pdGVyRm9yUm93ID0gKGhlaWdodCA+IDEgPyAnXFxuJyA6ICcnKTtcblxuICAgICAgICAgICAgLy9kaXNhbGxvdyBpZiBzZWxlY3Rpb24gaXMgdG9vIGJpZ1xuICAgICAgICAgICAgaWYgKGFyZWEgPiAyMDAwMCkge1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdzZWxlY3Rpb24gc2l6ZSBpcyB0b28gYmlnIHRvIGNvcHkgdG8gdGhlIHBhc3RlIGJ1ZmZlcicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGhlaWdodDsgaCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3aWR0aDsgdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzZWxlY3Rpb25zW3ddW2hdICsgKHcgPCBsYXN0Q29sID8gJ1xcdCcgOiB3aGl0ZVNwYWNlRGVsaW1pdGVyRm9yUm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIENsZWFyIGFsbCB0aGUgc2VsZWN0aW9ucy5cbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2VlcFJvd1NlbGVjdGlvbnMgPSB0aGlzLnByb3BlcnRpZXMuY2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhcihrZWVwUm93U2VsZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuY2xlYXJNb3VzZURvd24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZWVwUm93U2VsZWN0aW9ucyA9IHRoaXMucHJvcGVydGllcy5jaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbihrZWVwUm93U2VsZWN0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICogQGRlc2MgQ2xlYXIgdGhlIG1vc3QgcmVjZW50IGNvbHVtbiBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgcm93IHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7IC8vIGNvbW1lbnRlZCBvZmYgYXMgcGVyIEdSSUQtMTEyXG4gICAgfSxcblxuICAgIGNsZWFyUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmRhdGFNb2RlbC5jbGVhclNlbGVjdGVkRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBzdW1tYXJ5IFNlbGVjdCBnaXZlbiByZWdpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHlcbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIGlmIChveCA8IDAgfHwgb3kgPCAwKSB7XG4gICAgICAgICAgICAvL3dlIGRvbid0IHNlbGVjdCBuZWdhdGl2ZSBhcmVhXG4gICAgICAgICAgICAvL2Fsc28gdGhpcyBtZWFucyB0aGVyZSBpcyBubyBvcmlnaW4gbW91c2UgZG93biBmb3IgYSBzZWxlY3Rpb24gcmVjdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0KG94LCBveSwgZXgsIGV5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gR2l2ZW4gcG9pbnQgaXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIHNlbGVjdGVkIGFueXdoZXJlIGluIHRoZSBlbnRpcmUgdGFibGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgcm93IGluZGV4LlxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Sb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWRJblJvdyh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIHJvdyBpcyBzZWxlY3RlZCBhbnl3aGVyZSBpbiB0aGUgZW50aXJlIHRhYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluQ29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4oeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJbXXxzdHJpbmdbXX0gW2hpZGRlbkNvbHVtbnM9ZmFsc2VdIC0gU2VlIHtAbGluayBIeXBlcmdyaWR+Z2V0Q29sdW1uc30uXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgZ2V0Um93U2VsZWN0aW9uOiBmdW5jdGlvbihoaWRkZW5Db2x1bW5zKSB7XG4gICAgICAgIHZhciBjb2x1bW4sIHJvd3MsXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcyA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICBjb2x1bW5zID0gZ2V0Q29sdW1ucy5jYWxsKHRoaXMsIGhpZGRlbkNvbHVtbnMpLFxuICAgICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDAsIEMgPSBjb2x1bW5zLmxlbmd0aDsgYyA8IEM7IGMrKykge1xuICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tjXTtcbiAgICAgICAgICAgIHJvd3MgPSByZXN1bHRbY29sdW1uLm5hbWVdID0gbmV3IEFycmF5KHNlbGVjdGVkUm93SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzLmZvckVhY2goZ2V0VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoc2VsZWN0ZWRSb3dJbmRleCwgaikge1xuICAgICAgICAgICAgdmFyIGRhdGFSb3cgPSBzZWxmLmdldFJvdyhzZWxlY3RlZFJvd0luZGV4KTtcbiAgICAgICAgICAgIHJvd3Nbal0gPSB2YWxPckZ1bmMuY2FsbChkYXRhUm93LCBjb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcltdfHN0cmluZ1tdfSBbaGlkZGVuQ29sdW1ucz1mYWxzZV0gLSBTZWUge0BsaW5rIEh5cGVyZ3JpZH5nZXRDb2x1bW5zfS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZCNcbiAgICAgKi9cbiAgICBnZXRSb3dTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKGhpZGRlbkNvbHVtbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgIGNvbHVtbnMgPSBnZXRDb2x1bW5zLmNhbGwodGhpcywgaGlkZGVuQ29sdW1ucyksXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkoY29sdW1ucy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwLCBDID0gY29sdW1ucy5sZW5ndGg7IGMgPCBDOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zW2NdO1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gbmV3IEFycmF5KHNlbGVjdGVkUm93SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzLmZvckVhY2goZ2V0VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoc2VsZWN0ZWRSb3dJbmRleCwgcikge1xuICAgICAgICAgICAgdmFyIGRhdGFSb3cgPSBzZWxmLmdldFJvdyhzZWxlY3RlZFJvd0luZGV4KTtcbiAgICAgICAgICAgIHJlc3VsdFtjXVtyXSA9IHZhbE9yRnVuYy5jYWxsKGRhdGFSb3csIGNvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YVJvdyxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBzZWxlY3RlZENvbHVtbkluZGV4ZXMgPSB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzZWxlY3RlZENvbHVtbkluZGV4ZXMubGVuZ3RoKTtcblxuICAgICAgICBzZWxlY3RlZENvbHVtbkluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZENvbHVtbkluZGV4LCBjKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gc2VsZi5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oc2VsZWN0ZWRDb2x1bW5JbmRleCksXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gcmVzdWx0W2NdID0gbmV3IEFycmF5KG51bVJvd3MpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciByID0gaGVhZGVyUm93Q291bnQ7IHIgPCBudW1Sb3dzOyByKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhUm93ID0gc2VsZi5nZXRSb3cocik7XG4gICAgICAgICAgICAgICAgdmFsdWVzW3JdID0gdmFsT3JGdW5jLmNhbGwoZGF0YVJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGFSb3csXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpLFxuICAgICAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleGVzID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgcm93Q291bnQgPSB0aGlzLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0ZWRDb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHNlbGYuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKHNlbGVjdGVkQ29sdW1uSW5kZXgpLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHJlc3VsdFtjb2x1bW4ubmFtZV0gPSBuZXcgQXJyYXkocm93Q291bnQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciByID0gaGVhZGVyUm93Q291bnQ7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVJvdyA9IHNlbGYuZ2V0Um93KHIpO1xuICAgICAgICAgICAgICAgIHZhbHVlc1tyXSA9IHZhbE9yRnVuYy5jYWxsKGRhdGFSb3csIGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhUm93LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCksXG4gICAgICAgICAgICByZWN0cyA9IG5ldyBBcnJheShzZWxlY3Rpb25zLmxlbmd0aCk7XG5cbiAgICAgICAgc2VsZWN0aW9ucy5mb3JFYWNoKGdldFJlY3QpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJlY3Qoc2VsZWN0aW9uUmVjdCwgaSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBub3JtYWxpemVSZWN0KHNlbGVjdGlvblJlY3QpLFxuICAgICAgICAgICAgICAgIGNvbENvdW50ID0gcmVjdC5leHRlbnQueCArIDEsXG4gICAgICAgICAgICAgICAgcm93Q291bnQgPSByZWN0LmV4dGVudC55ICsgMSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwLCB4ID0gcmVjdC5vcmlnaW4ueDsgYyA8IGNvbENvdW50OyBjKyssIHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBzZWxmLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbih4KSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gY29sdW1uc1tjb2x1bW4ubmFtZV0gPSBuZXcgQXJyYXkocm93Q291bnQpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDAsIHkgPSByZWN0Lm9yaWdpbi55OyByIDwgcm93Q291bnQ7IHIrKywgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFSb3cgPSBzZWxmLmdldFJvdyh5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3JdID0gdmFsT3JGdW5jLmNhbGwoZGF0YVJvdywgY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY3RzW2ldID0gY29sdW1ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0cztcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGFSb3csXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIHJlY3RzID0gbmV3IEFycmF5KHNlbGVjdGlvbnMubGVuZ3RoKTtcblxuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goZ2V0UmVjdCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVjdChzZWxlY3Rpb25SZWN0LCBpKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5vcm1hbGl6ZVJlY3Qoc2VsZWN0aW9uUmVjdCksXG4gICAgICAgICAgICAgICAgY29sQ291bnQgPSByZWN0LmV4dGVudC54ICsgMSxcbiAgICAgICAgICAgICAgICByb3dDb3VudCA9IHJlY3QuZXh0ZW50LnkgKyAxLFxuICAgICAgICAgICAgICAgIHJvd3MgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIHggPSByZWN0Lm9yaWdpbi54OyBjIDwgY29sQ291bnQ7IGMrKywgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHJvd3NbY10gPSBuZXcgQXJyYXkocm93Q291bnQpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBzZWxmLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbih4KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCB5ID0gcmVjdC5vcmlnaW4ueTsgciA8IHJvd0NvdW50OyByKyssIHkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhUm93ID0gc2VsZi5nZXRSb3coeSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tyXSA9IHZhbE9yRnVuYy5jYWxsKGRhdGFSb3csIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWN0c1tpXSA9IHJvd3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjdHM7XG4gICAgfSxcblxuICAgIHNlbGVjdENlbGw6IGZ1bmN0aW9uKHgsIHksIHNpbGVudCkge1xuICAgICAgICB2YXIga2VlcFJvd1NlbGVjdGlvbnMgPSB0aGlzLnByb3BlcnRpZXMuY2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhcihrZWVwUm93U2VsZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHgsIHksIDAsIDAsIHNpbGVudCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNlbGVjdENvbHVtbjogZnVuY3Rpb24oeCwga2V5cykge1xuICAgICAgICBrZXlzID0ga2V5cyB8fCBbXTtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IG1vZGVsLmlzQ29sdW1uU2VsZWN0ZWQoeCk7XG4gICAgICAgIHZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgPiAtMTtcbiAgICAgICAgdmFyIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpID4gLTE7XG4gICAgICAgIGlmICghaGFzQ1RSTCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIG1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdENvbHVtbih4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDVFJMKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kZXNlbGVjdENvbHVtbih4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RDb2x1bW4odGhpcy5sYXN0RWRnZVNlbGVjdGlvblswXSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbHJlYWR5U2VsZWN0ZWQgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzBdID0geDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljQ29sdW1uU2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNlbGVjdFJvdzogZnVuY3Rpb24oeSwga2V5cykge1xuICAgICAgICAvL3dlIGNhbiBzZWxlY3QgdGhlIHRvdGFscyByb3dzIGlmIHRoZXkgZXhpc3QsIGJ1dCBub3Qgcm93cyBhYm92ZSB0aGF0XG4gICAgICAgIGtleXMgPSBrZXlzIHx8IFtdO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSBzbS5pc1Jvd1NlbGVjdGVkKHkpO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPj0gMDtcblxuICAgICAgICBpZiAoYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzbS5kZXNlbGVjdFJvdyh5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0KCk7XG4gICAgICAgICAgICBzbS5zZWxlY3RSb3coeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIHNtLmNsZWFyKCk7XG4gICAgICAgICAgICBzbS5zZWxlY3RSb3codGhpcy5sYXN0RWRnZVNlbGVjdGlvblsxXSwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMV0gPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNpbmdsZVNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnByb3BlcnRpZXMuc2luZ2xlUm93U2VsZWN0aW9uTW9kZTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBzZWxlY3RWaWV3cG9ydENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB4ID0gdGhpcy5yZW5kZXJlci52aXNpYmxlQ29sdW1uc1t4XS5jb2x1bW5JbmRleDtcbiAgICAgICAgeSA9IHRoaXMucmVuZGVyZXIudmlzaWJsZVJvd3NbeSArIGhlYWRlclJvd0NvdW50XS5yb3dJbmRleDtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoeCwgeSwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0TW91c2VEb3duKHRoaXMubmV3UG9pbnQoeCwgeSkpO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb1ZpZXdwb3J0Q2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoc2VsZWN0aW9ucyAmJiBzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIHggPSB0aGlzLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zW3hdLmNvbHVtbkluZGV4O1xuICAgICAgICAgICAgeSA9IHRoaXMucmVuZGVyZXIudmlzaWJsZVJvd3NbeSArIGhlYWRlclJvd0NvdW50XS5yb3dJbmRleDtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KHggLSBvcmlnaW4ueCwgeSAtIG9yaWdpbi55KSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIHggLSBvcmlnaW4ueCwgeSAtIG9yaWdpbi55KTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdEZpbmFsQ2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gMSxcbiAgICAgICAgICAgIHkgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpWzBdLFxuICAgICAgICAgICAgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQnkodGhpcy5nZXRDb2x1bW5Db3VudCgpLCAwKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoeCwgeSArIGhlYWRlclJvd0NvdW50LCAwLCAwKTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZURvd24odGhpcy5uZXdQb2ludCh4LCB5ICsgaGVhZGVyUm93Q291bnQpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaW5hbENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoc2VsZWN0aW9ucyAmJiBzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbixcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50LFxuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeShjb2x1bW5Db3VudCwgMCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIGNvbHVtbkNvdW50IC0gb3JpZ2luLnggLSAxLCBleHRlbnQueSk7XG5cbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdEZpcnN0Q2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgIHkgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpWzBdLFxuICAgICAgICAgICAgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKDApO1xuICAgICAgICB0aGlzLnNlbGVjdCh4LCB5ICsgaGVhZGVyUm93Q291bnQsIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KHgsIHkgKyBoZWFkZXJSb3dDb3VudCkpO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb0ZpcnN0Q2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXSxcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luLFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQ7XG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCAtb3JpZ2luLngsIGV4dGVudC55KTtcbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKDApO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0RmluYWxDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RDZWxsQW5kU2Nyb2xsVG9NYWtlVmlzaWJsZSh0aGlzLmdldENvbHVtbkNvdW50KCkgLSAxLCB0aGlzLmdldFJvd0NvdW50KCkgLSAxKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvRmluYWxDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgJiYgc2VsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdLFxuICAgICAgICAgICAgICAgIG9yaWdpbiA9IHNlbGVjdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICAgICAgcm93Q291bnQgPSB0aGlzLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIGNvbHVtbkNvdW50IC0gb3JpZ2luLnggLSAxLCByb3dDb3VudCAtIG9yaWdpbi55IC0gMSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJ5KGNvbHVtbkNvdW50LCByb3dDb3VudCk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnRseSBzZWxlY3Rpb24gcm93LlxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIGNvbENvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgICAgIHRvcFJvdyA9IHNlbHNbMF0ub3JpZ2luLnksXG4gICAgICAgICAgICAgICAgcm93ID0ge1xuICAgICAgICAgICAgICAgICAgICAvL2hpZXJhcmNoeTogYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5WYWx1ZSgwLCB0b3BSb3cpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb2xDb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgcm93W2JlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihjKS5oZWFkZXJdID0gYmVoYXZpb3IuZ2V0VmFsdWUoYywgdG9wUm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGRpc3BhdGNoIGEgYGZpbi1zZWxlY3Rpb24tY2hhbmdlZGAgZXZlbnQuXG4gICAgICovXG4gICAgc2VsZWN0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFByb2plY3QgdGhlIGNlbGwgc2VsZWN0aW9uIGludG8gdGhlIHJvd3NcbiAgICAgICAgdGhpcy5zZWxlY3RSb3dzRnJvbUNlbGxzKCk7XG5cbiAgICAgICAgLy8gUHJvamVjdCB0aGUgY2VsbCBzZWxlY3Rpb24gaW50byB0aGUgY29sdW1uc1xuICAgICAgICB0aGlzLnNlbGVjdENvbHVtbnNGcm9tQ2VsbHMoKTtcblxuICAgICAgICB2YXIgc2VsZWN0aW9uRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1zZWxlY3Rpb24tY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuICAgIH0sXG5cbiAgICBpc0NvbHVtbk9yUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NvbHVtbk9yUm93U2VsZWN0ZWQoKTtcbiAgICB9LFxuICAgIHNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0Q29sdW1uKHgxLCB4Mik7XG4gICAgfSxcbiAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICB2YXIgc20gPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVNlbGVjdCgpKSB7XG4gICAgICAgICAgICB5MSA9IHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbXVsdGlwbGUgcm93IHNlbGVjdGlvblxuICAgICAgICAgICAgeTIgPSB5MiB8fCB5MTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNtLnNlbGVjdFJvdyhNYXRoLm1pbih5MSwgeTIpLCBNYXRoLm1heCh5MSwgeTIpKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Um93c0Zyb21DZWxsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmNoZWNrYm94T25seVJvd1NlbGVjdGlvbnMgJiYgdGhpcy5wcm9wZXJ0aWVzLmF1dG9TZWxlY3RSb3dzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuc2luZ2xlUm93U2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0Um93c0Zyb21DZWxscygwLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGxhc3QgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFJvdyhudWxsLCBsYXN0LmNvcm5lci55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RDb2x1bW5zRnJvbUNlbGxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcy5hdXRvU2VsZWN0Q29sdW1ucykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RDb2x1bW5zRnJvbUNlbGxzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFNlbGVjdGVkUm93cygpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG4gICAgZ2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uVHlwZSgpO1xuICAgIH0sXG4gICAgaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGUoeCwgeSk7XG4gICAgfSxcbiAgICBzZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RBbGxSb3dzKCk7XG4gICAgfSxcbiAgICBhcmVBbGxSb3dzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5hcmVBbGxSb3dzU2VsZWN0ZWQoKTtcbiAgICB9LFxuICAgIHRvZ2dsZVNlbGVjdEFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hcmVBbGxSb3dzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGxSb3dzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcbiAgICBpc0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdpc0NlbGxTZWxlY3Rpb24oKScsICdwcm9wZXJ0aWVzLmNlbGxTZWxlY3Rpb24nLCAnMS4yLjInKTtcbiAgICB9LFxuICAgIGlzUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnaXNSb3dTZWxlY3Rpb24oKScsICdwcm9wZXJ0aWVzLnJvd1NlbGVjdGlvbicsICcxLjIuMicpO1xuICAgIH0sXG4gICAgaXNDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdpc0NvbHVtblNlbGVjdGlvbigpJywgJ3Byb3BlcnRpZXMuY29sdW1uU2VsZWN0aW9uJywgJzEuMi4yJyk7XG4gICAgfSxcbiAgICBpc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdpc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGUoKScsICdwcm9wZXJ0aWVzLnNpbmdsZVJvd1NlbGVjdGlvbk1vZGUnLCAnMS4yLjE0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE1vdmUgY2VsbCBzZWxlY3Rpb24gYnkgb2Zmc2V0LlxuICAgICAqIEBkZXNjIFJlcGxhY2UgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiB3aXRoIGEgc2luZ2xlIGNlbGwgc2VsZWN0aW9uIHRoYXQgaXMgbW92ZWQgKG9mZnNldFgsb2Zmc2V0WSkgZnJvbSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGV4dGVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggb2Zmc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IG9mZnNldFxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSB0aGlzLmdldE1vdXNlRG93bigpLnBsdXModGhpcy5nZXREcmFnRXh0ZW50KCkpO1xuICAgICAgICB0aGlzLm1vdmVUb1NpbmdsZVNlbGVjdChcbiAgICAgICAgICAgIG1vdXNlQ29ybmVyLnggKyBvZmZzZXRYLFxuICAgICAgICAgICAgbW91c2VDb3JuZXIueSArIG9mZnNldFlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTW92ZSBjZWxsIHNlbGVjdGlvbiBieSBvZmZzZXQuXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1kgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkI1xuICAgICAqL1xuICAgIG1vdmVUb1NpbmdsZVNlbGVjdDogZnVuY3Rpb24obmV3WCwgbmV3WSkge1xuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsXG4gICAgICAgICAgICBtYXhSb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpIC0gMSxcblxuICAgICAgICAgICAgbWF4Vmlld2FibGVDb2x1bW5zID0gdGhpcy5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxLFxuICAgICAgICAgICAgbWF4Vmlld2FibGVSb3dzID0gdGhpcy5nZXRWaXNpYmxlUm93c0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgTWF0aC5tYXgoMCwgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgoMCwgbmV3WSkpO1xuXG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0Q2VsbEFuZFNjcm9sbFRvTWFrZVZpc2libGUobmV3WCwgbmV3WSk7XG5cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBFeHRlbmQgY2VsbCBzZWxlY3Rpb24gYnkgb2Zmc2V0LlxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0OiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gMSxcbiAgICAgICAgICAgIG1heFJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCkgLSAxLFxuXG4gICAgICAgICAgICBtYXhWaWV3YWJsZUNvbHVtbnMgPSB0aGlzLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBtYXhWaWV3YWJsZVJvd3MgPSB0aGlzLnJlbmRlcmVyLnZpc2libGVSb3dzLmxlbmd0aCAtIDEsXG5cbiAgICAgICAgICAgIG9yaWdpbiA9IHRoaXMuZ2V0TW91c2VEb3duKCksXG4gICAgICAgICAgICBleHRlbnQgPSB0aGlzLmdldERyYWdFeHRlbnQoKSxcblxuICAgICAgICAgICAgbmV3WCA9IGV4dGVudC54ICsgb2Zmc2V0WCxcbiAgICAgICAgICAgIG5ld1kgPSBleHRlbnQueSArIG9mZnNldFk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zIC0gb3JpZ2luLngsIE1hdGgubWF4KC1vcmlnaW4ueCwgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cyAtIG9yaWdpbi55LCBNYXRoLm1heCgtb3JpZ2luLnksIG5ld1kpKTtcblxuICAgICAgICB0aGlzLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIG5ld1gsIG5ld1kpO1xuXG4gICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcblxuICAgICAgICB2YXIgY29sU2Nyb2xsZWQgPSB0aGlzLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1ggKyBvcmlnaW4ueCwgb2Zmc2V0WCksXG4gICAgICAgICAgICByb3dTY3JvbGxlZCA9IHRoaXMuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSArIG9yaWdpbi55LCBvZmZzZXRZKTtcblxuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcblxuICAgICAgICByZXR1cm4gY29sU2Nyb2xsZWQgfHwgcm93U2Nyb2xsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEV2ZW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQjXG4gICAgICovXG4gICAgZ2V0R3JpZENlbGxGcm9tTGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZWxsRXZlbnQsXG4gICAgICAgICAgICBzZWwgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZiAoc2VsKSB7XG4gICAgICAgICAgICBjZWxsRXZlbnQgPSBuZXcgdGhpcy5iZWhhdmlvci5DZWxsRXZlbnQ7XG4gICAgICAgICAgICBjZWxsRXZlbnQucmVzZXRHcmlkWERhdGFZKHNlbC5vcmlnaW4ueCwgc2VsLm9yaWdpbi55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRXZlbnQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyW118c3RyaW5nW119IFtoaWRkZW5Db2x1bW5zPWZhbHNlXSAtIE9uZSBvZjpcbiAqIGBmYWxzZWAgLSBBY3RpdmUgY29sdW1uIGxpc3RcbiAqIGB0cnVlYCAtIEFsbCBjb2x1bW4gbGlzdFxuICogYEFycmF5YCAtIEFjdGl2ZSBjb2x1bW4gbGlzdCB3aXRoIGxpc3RlZCBjb2x1bW5zIHByZWZpeGVkIGFzIG5lZWRlZCAod2hlbiBub3QgYWxyZWFkeSBpbiB0aGUgbGlzdCkuIEVhY2ggaXRlbSBpbiB0aGUgYXJyYXkgbWF5IGJlIGVpdGhlcjpcbiAqICogYG51bWJlcmAgLSBpbmRleCBpbnRvIGFsbCBjb2x1bW4gbGlzdFxuICogKiBgc3RyaW5nYCAtIG5hbWUgb2YgYSBjb2x1bW4gZnJvbSB0aGUgYWxsIGNvbHVtbiBsaXN0XG4gKiBAcmV0dXJucyB7Q29sdW1uW119XG4gKiBAbWVtYmVyT2YgSHlwZXJncmlkflxuICovXG5mdW5jdGlvbiBnZXRDb2x1bW5zKGhpZGRlbkNvbHVtbnMpIHtcbiAgICB2YXIgY29sdW1ucyxcbiAgICAgICAgYWxsQ29sdW1ucyA9IHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1ucygpLFxuICAgICAgICBhY3RpdmVDb2x1bW5zID0gdGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5zKCk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoaWRkZW5Db2x1bW5zKSkge1xuICAgICAgICBjb2x1bW5zID0gW107XG4gICAgICAgIGhpZGRlbkNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyAnaW5kZXgnIDogJ25hbWUnLFxuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGFsbENvbHVtbnMuZmluZChmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbltrZXldID09PSBpbmRleDsgfSk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlQ29sdW1ucy5pbmRleE9mKGNvbHVtbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb2x1bW5zID0gY29sdW1ucy5jb25jYXQoYWN0aXZlQ29sdW1ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1ucyA9IGhpZGRlbkNvbHVtbnMgPyBhbGxDb2x1bW5zIDogYWN0aXZlQ29sdW1ucztcbiAgICB9XG5cbiAgICByZXR1cm4gY29sdW1ucztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgdmFyIG8gPSByZWN0Lm9yaWdpbixcbiAgICAgICAgYyA9IHJlY3QuY29ybmVyLFxuXG4gICAgICAgIG94ID0gTWF0aC5taW4oby54LCBjLngpLFxuICAgICAgICBveSA9IE1hdGgubWluKG8ueSwgYy55KSxcblxuICAgICAgICBjeCA9IE1hdGgubWF4KG8ueCwgYy54KSxcbiAgICAgICAgY3kgPSBNYXRoLm1heChvLnksIGMueSk7XG5cbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShveCwgb3ksIGN4IC0gb3gsIGN5IC0gb3kpO1xufVxuXG4vKipcbiAqIEB0aGlzIHtkYXRhUm93T2JqZWN0fVxuICogQHBhcmFtIGNvbHVtblxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdmFsT3JGdW5jKGNvbHVtbikge1xuICAgIHZhciByZXN1bHQsIGNhbGN1bGF0b3I7XG4gICAgaWYgKHRoaXMpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpc1tjb2x1bW4ubmFtZV07XG4gICAgICAgIGNhbGN1bGF0b3IgPSAodHlwZW9mIHJlc3VsdClbMF0gPT09ICdmJyAmJiByZXN1bHQgfHwgY29sdW1uLmNhbGN1bGF0b3I7XG4gICAgICAgIGlmIChjYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxjdWxhdG9yLmNhbGwodGhpcywgY29sdW1uLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgfHwgcmVzdWx0ID09PSAwIHx8IHJlc3VsdCA9PT0gZmFsc2UgPyByZXN1bHQgOiAnJztcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdXRvbWF0ID0gcmVxdWlyZSgnYXV0b21hdCcpO1xuXG52YXIgY3NzID0gcmVxdWlyZSgnLi4vLi4vY3NzJyk7XG5cbi8vIG5vdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSAgZmlyc3QgXCJuYXR1cmFsXCIgc3R5bGVzaGVldC4gV2Ugd2lsbCBpbnNlcnQgb3VyIHN0eWxlc2hlZXRzIGJlZm9yZSB0aGlzIG5vZGUuXG52YXIgaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbnZhciByZWZOb2RlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaGVhZC5jaGlsZHJlbikuZmluZChmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC50YWdOYW1lID09PSAnU1RZTEUnIHx8XG4gICAgICAgIGNoaWxkLnRhZ05hbWUgPT09ICdMSU5LJyAmJlxuICAgICAgICBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnc3R5bGVzaGVldCcgJiZcbiAgICAgICAgY2hpbGQuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICd0ZXh0L2Nzcyc7XG59KTtcblxuZXhwb3J0cy5wcmVmaXggPSAnaW5qZWN0ZWQtc3R5bGVzaGVldC0nO1xuXG5leHBvcnRzLmluamVjdCA9IGZ1bmN0aW9uKGlkLCBvdmVycmlkZURpcikge1xuICAgIHZhciBzdHlsZXNoZWV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyB0aGlzLnByZWZpeCArIGlkKTtcbiAgICB2YXIgcmVwbyA9IG92ZXJyaWRlRGlyIHx8IGNzcztcblxuICAgIGlmICghc3R5bGVzaGVldCkge1xuICAgICAgICBzdHlsZXNoZWV0ID0gcmVwb1tpZF07XG4gICAgICAgIHN0eWxlc2hlZXQgPSAnPHN0eWxlPlxcbicgKyBzdHlsZXNoZWV0ICsgJ1xcbjwvc3R5bGU+XFxuJztcbiAgICAgICAgdmFyIGFyZ3MgPSBbc3R5bGVzaGVldCwgaGVhZCwgcmVmTm9kZV0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICBzdHlsZXNoZWV0ID0gYXV0b21hdC5hcHBlbmQuYXBwbHkobnVsbCwgYXJncylbMF07XG4gICAgICAgIHN0eWxlc2hlZXQuaWQgPSB0aGlzLnByZWZpeCArIGlkO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXNoZWV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufHN0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN3aXRjaCAodHlwZW9mIHN0cmluZykge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgc3RyaW5nLCBmdW5jdGlvbiwgb3IgdW5kZWZpbmVkLic7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3MgPSBzdHJpbmcubWF0Y2goL2Z1bmN0aW9uXFxzKlxcKChbXl0qPylcXCkvKTtcbiAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGZ1bmN0aW9uIGtleXdvcmQgd2l0aCBmb3JtYWwgcGFyYW1ldGVyIGxpc3QuJztcbiAgICB9XG4gICAgYXJncyA9IGFyZ3NbMV0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24ocywgaSkge1xuICAgICAgICBzID0gcy5tYXRjaCgvXFxzKihcXHcqKVxccyovKTsgLy8gdHJpbSBlYWNoIGFyZ3VtZW50XG4gICAgICAgIGlmICghcyAmJiBpKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgZm9ybWFsIHBhcmFtZXRlci4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzWzFdO1xuICAgIH0pO1xuXG4gICAgdmFyIGJvZHkgPSBzdHJpbmcubWF0Y2goL3tcXHMqKFteXSo/KVxccyp9Lyk7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBmdW5jdGlvbiBib2R5Lic7XG4gICAgfVxuICAgIGJvZHkgPSBib2R5WzFdO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmICFhcmdzWzBdKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChib2R5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkobnVsbCwgYXJncyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBidW5kbGVDb2x1bW5zKHJlc2V0Q2VsbEV2ZW50cykge1xuICAgIHZhciBncmlkUHJvcHMgPSB0aGlzLmdyaWQucHJvcGVydGllcyxcbiAgICAgICAgdmMsIHZpc2libGVDb2x1bW5zID0gdGhpcy52aXNpYmxlQ29sdW1ucyxcbiAgICAgICAgdnIsIHZpc2libGVSb3dzID0gdGhpcy52aXNpYmxlUm93cyxcbiAgICAgICAgYywgQyA9IHZpc2libGVDb2x1bW5zLmxlbmd0aCwgYzAgPSBncmlkUHJvcHMuc2hvd1Jvd051bWJlcnMgPyAtMSA6IDAsXG4gICAgICAgIHIsIFIgPSB2aXNpYmxlUm93cy5sZW5ndGgsXG4gICAgICAgIHAsIHBvb2w7XG5cbiAgICBpZiAocmVzZXRDZWxsRXZlbnRzKSB7XG4gICAgICAgIHBvb2wgPSB0aGlzLmNlbGxFdmVudFBvb2w7XG4gICAgICAgIGZvciAocCA9IDAsIGMgPSBjMDsgYyA8IEM7IGMrKykge1xuICAgICAgICAgICAgdmMgPSB2aXNpYmxlQ29sdW1uc1tjXTtcbiAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCBSOyByKyssIHArKykge1xuICAgICAgICAgICAgICAgIHZyID0gdmlzaWJsZVJvd3Nbcl07XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgcG9vbCBtZW1iZXIgdG8gcmVmbGVjdCBjb29yZGluYXRlcyBvZiBjZWxsIGluIG5ld2x5IHNoYXBlZCBncmlkXG4gICAgICAgICAgICAgICAgcG9vbFtwXS5yZXNldCh2YywgdnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJ1bmRsZSxcbiAgICAgICAgY29sdW1uQnVuZGxlcyA9IFtdLFxuICAgICAgICBncmlkUHJlZmlsbENvbG9yID0gZ3JpZFByb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yO1xuXG4gICAgZm9yIChjID0gYzA7IGMgPCBDOyBjKyspIHtcbiAgICAgICAgdmMgPSB2aXNpYmxlQ29sdW1uc1tjXTtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yID0gdmMuY29sdW1uLnByb3BlcnRpZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpZiAoYnVuZGxlICYmIGJ1bmRsZS5iYWNrZ3JvdW5kQ29sb3IgPT09IGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgYnVuZGxlLnJpZ2h0ID0gdmMucmlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFja2dyb3VuZENvbG9yID09PSBncmlkUHJlZmlsbENvbG9yKSB7XG4gICAgICAgICAgICBidW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidW5kbGUgPSB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgbGVmdDogdmMubGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogdmMucmlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb2x1bW5CdW5kbGVzLnB1c2goYnVuZGxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29sdW1uQnVuZGxlcyA9IGNvbHVtbkJ1bmRsZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVuZGxlQ29sdW1ucztcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYnVuZGxlUm93cyhyZXNldENlbGxFdmVudHMpIHtcbiAgICB2YXIgZ3JpZFByb3BzID0gdGhpcy5ncmlkLnByb3BlcnRpZXMsXG4gICAgICAgIHZjLCB2aXNpYmxlQ29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnMsXG4gICAgICAgIHZyLCB2aXNpYmxlUm93cyA9IHRoaXMudmlzaWJsZVJvd3MsXG4gICAgICAgIGMsIEMgPSB2aXNpYmxlQ29sdW1ucy5sZW5ndGgsIGMwID0gZ3JpZFByb3BzLnNob3dSb3dOdW1iZXJzID8gLTEgOiAwLFxuICAgICAgICByLCBSID0gdmlzaWJsZVJvd3MubGVuZ3RoLFxuICAgICAgICBwLCBwb29sO1xuXG4gICAgaWYgKHJlc2V0Q2VsbEV2ZW50cykge1xuICAgICAgICBwb29sID0gdGhpcy5jZWxsRXZlbnRQb29sO1xuICAgICAgICBmb3IgKHAgPSAwLCByID0gMDsgciA8IFI7IHIrKykge1xuICAgICAgICAgICAgdnIgPSB2aXNpYmxlUm93c1tyXTtcbiAgICAgICAgICAgIGZvciAoYyA9IGMwOyBjIDwgQzsgYysrLCBwKyspIHtcbiAgICAgICAgICAgICAgICB2YyA9IHZpc2libGVDb2x1bW5zW2NdO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHBvb2wgbWVtYmVyIHRvIHJlZmxlY3QgY29vcmRpbmF0ZXMgb2YgY2VsbCBpbiBuZXdseSBzaGFwZWQgZ3JpZFxuICAgICAgICAgICAgICAgIHBvb2xbcF0ucmVzZXQodmMsIHZyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidW5kbGUsIHJvd0J1bmRsZXMgPSBbXSxcbiAgICAgICAgZ3JpZFByZWZpbGxDb2xvciA9IGdyaWRQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIHJvd1Byb3BzTGlzdCA9IGdyaWRQcm9wcy5yb3dQcm9wZXJ0aWVzLFxuICAgICAgICByb3dQcmVmaWxsQ29sb3JzID0gQXJyYXkoUiksXG4gICAgICAgIHJvd1Byb3BlcnRpZXMsIGJhY2tncm91bmRDb2xvcjtcblxuICAgIGZvciAociA9IDA7IHIgPCBSOyByKyspIHtcbiAgICAgICAgdnIgPSB2aXNpYmxlUm93c1tyXTsgLy8gZmlyc3QgY2VsbCBpbiByb3cgclxuICAgICAgICByb3dQcm9wZXJ0aWVzID0gdnIuc3ViZ3JpZC5pc0RhdGEgJiYgcm93UHJvcHNMaXN0ICYmIHJvd1Byb3BzTGlzdFt2ci5yb3dJbmRleCAlIHJvd1Byb3BzTGlzdC5sZW5ndGhdO1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSByb3dQcmVmaWxsQ29sb3JzW3JdID0gcm93UHJvcGVydGllcyAmJiByb3dQcm9wZXJ0aWVzLmJhY2tncm91bmRDb2xvciB8fCBncmlkUHJlZmlsbENvbG9yO1xuICAgICAgICBpZiAoYnVuZGxlICYmIGJ1bmRsZS5iYWNrZ3JvdW5kQ29sb3IgPT09IGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgYnVuZGxlLmJvdHRvbSA9IHZyLmJvdHRvbTtcbiAgICAgICAgfSBlbHNlIGlmIChiYWNrZ3JvdW5kQ29sb3IgPT09IGdyaWRQcmVmaWxsQ29sb3IpIHtcbiAgICAgICAgICAgIGJ1bmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1bmRsZSA9IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICB0b3A6IHZyLnRvcCxcbiAgICAgICAgICAgICAgICBib3R0b206IHZyLmJvdHRvbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvd0J1bmRsZXMucHVzaChidW5kbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yb3dCdW5kbGVzID0gcm93QnVuZGxlcztcbiAgICB0aGlzLnJvd1ByZWZpbGxDb2xvcnMgPSByb3dQcmVmaWxsQ29sb3JzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1bmRsZVJvd3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYWludENlbGxzQnlDb2x1bW5zQW5kUm93cyA9IHJlcXVpcmUoJy4vYnktY29sdW1ucy1hbmQtcm93cycpO1xuXG4vKiogQHN1bW1hcnkgUmVuZGVyIHRoZSBncmlkIG9ubHkgYXMgbmVlZGVkIChcInBhcnRpYWwgcmVuZGVyXCIpLlxuICogQGRlc2MgUGFpbnRzIGFsbCB0aGUgY2VsbHMgb2YgYSBncmlkLCBvbmUgY29sdW1uIGF0IGEgdGltZSwgYnV0IG9ubHkgYXMgbmVlZGVkLlxuICpcbiAqIFBhaW50cyBhbGwgdGhlIGNlbGxzIG9mIGEgZ3JpZCwgb25lIHJvdyBhdCBhIHRpbWUuXG4gKlxuICogIyMjIyBPbiByZXNldFxuICpcbiAqIERlZmVycyB0byB7QGxpbmsgUmVuZGVyZXIjcGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3N8cGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3N9LCB3aGljaCBjbGVhcnMgdGhlIGNhbnZhcywgZHJhd3MgdGhlIGdyaWQsIGFuZCBkcmF3cyB0aGUgZ3JpZCBsaW5lcy5cbiAqXG4gKiAjIyMjIE9uIHRoZSBuZXh0IGNhbGwgKGFmZXIgcmVzZXQpXG4gKlxuICogRmlyc3QsIGEgYmFja2dyb3VuZCByZWN0IGlzIGRyYXduIHVzaW5nIHRoZSBncmlkIGJhY2tncm91bmQgY29sb3IuXG4gKlxuICogVGhlbiwgZWFjaCBjZWxsIGlzIGRyYXduLiBJZiBpdHMgYmFja2dyb3VuZCBkaWZmZXJzIGZyb20gdGhlIGdyaWQgYmFja2dyb3VuZCwgdGhlIGJhY2tncm91bmQgaXMgcmVwYWludGVkLlxuICpcbiAqIGB0cnkuLi5jYXRjaGAgc3Vycm91bmRzIGVhY2ggY2VsbCBwYWludCBpbiBjYXNlIGEgY2VsbCByZW5kZXJlciB0aHJvd3MgYW4gZXJyb3IuXG4gKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gKlxuICogIyMjIyBPbiBzdWJzZXF1ZW50IGNhbGxzXG4gKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBlYWNoIGNlbGwsIGNhbGxpbmcgYF9wYWludENlbGxgIHdpdGggYHVuZGVmaW5lZGAgcHJlZmlsbCBjb2xvci4gVGhpcyBzaWduaWZpZXMgcGFydGlhbCByZW5kZXIgdG8gdGhlIHtAbGluayBTaW1wbGVDZWxsfSBjZWxsIHJlbmRlcmVyLCB3aGljaCBvbmx5IHJlbmRlcnMgdGhlIGNlbGwgd2hlbiBpdCdzIHRleHQsIGZvbnQsIG9yIGNvbG9ycyBoYXZlIGNoYW5nZWQuXG4gKlxuICogRWFjaCBjZWxsIHRvIGJlIHJlbmRlcmVkIGlzIGRlc2NyaWJlZCBieSBhIHtAbGluayBDZWxsRXZlbnR9IG9iamVjdC4gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRvIGF2b2lkIGNvbnN0YW50bHkgaW5zdGFudGlhdGluZyB0aGVzZSBvYmplY3RzLCB3ZSBtYWludGFpbiBhIHBvb2wgb2YgdGhlc2UuIFdoZW4gdGhlIGdyaWQgc2hhcGUgY2hhbmdlcywgd2UgcmVzZXQgdGhlaXIgY29vcmRpbmF0ZXMgYnkgc2V0dGluZyB7QGxpbmsgQ2VsbEV2ZW50I3Jlc2V0fHJlc2V0fSBvbiBlYWNoLlxuICpcbiAqIFNlZSBhbHNvIHRoZSBkaXNjdXNzaW9uIG9mIGNsaXBwaW5nIGluIHtAbGluayBSZW5kZXJlciNwYWludENlbGxzQnlDb2x1bW5zfHBhaW50Q2VsbHNCeUNvbHVtbnN9LlxuICogQHRoaXMge1JlbmRlcmVyfVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gKi9cbmZ1bmN0aW9uIHBhaW50Q2VsbHNBc05lZWRlZChnYykge1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBncmlkUHJvcHMgPSBncmlkLnByb3BlcnRpZXMsXG4gICAgICAgIGNlbGxFdmVudCxcbiAgICAgICAgdmMsIHZpc2libGVDb2x1bW5zID0gdGhpcy52aXNpYmxlQ29sdW1ucyxcbiAgICAgICAgdmlzaWJsZVJvd3MgPSB0aGlzLnZpc2libGVSb3dzLFxuICAgICAgICBjLCBDID0gdmlzaWJsZUNvbHVtbnMubGVuZ3RoLCBjMCA9IGdyaWRQcm9wcy5zaG93Um93TnVtYmVycyA/IC0xIDogMCwgY0xhc3QgPSBDIC0gMSxcbiAgICAgICAgciwgUiA9IHZpc2libGVSb3dzLmxlbmd0aCxcbiAgICAgICAgcCwgcG9vbCA9IHRoaXMuY2VsbEV2ZW50UG9vbCxcbiAgICAgICAgcHJlZmVycmVkV2lkdGgsXG4gICAgICAgIGNvbHVtbkNsaXAsXG4gICAgICAgIC8vIGNsaXBUb0dyaWQsXG4gICAgICAgIC8vIHZpZXdXaWR0aCA9IEMgPyB2aXNpYmxlQ29sdW1uc1tjTGFzdF0ucmlnaHQgOiAwLFxuICAgICAgICB2aWV3SGVpZ2h0ID0gUiA/IHZpc2libGVSb3dzW1IgLSAxXS5ib3R0b20gOiAwO1xuXG4gICAgaWYgKCFDIHx8ICFSKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHBhaW50Q2VsbHNBc05lZWRlZC5yZXNldCkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsR3JpZFJlbmRlcmVycygpO1xuICAgICAgICBwYWludENlbGxzQnlDb2x1bW5zQW5kUm93cy5jYWxsKHRoaXMsIGdjKTtcbiAgICAgICAgcGFpbnRDZWxsc0FzTmVlZGVkLnJlc2V0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZ2MuY2xpcFNhdmUoY2xpcFRvR3JpZCwgMCwgMCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcblxuICAgIC8vIEZvciBlYWNoIGNvbHVtbi4uLlxuICAgIGZvciAocCA9IDAsIGMgPSBjMDsgYyA8IEM7IGMrKykge1xuICAgICAgICBjZWxsRXZlbnQgPSBwb29sW3BdOyAvLyBmaXJzdCBjZWxsIGluIGNvbHVtbiBjXG4gICAgICAgIHZjID0gY2VsbEV2ZW50LnZpc2libGVDb2x1bW47XG5cbiAgICAgICAgLy8gT3B0aW9uYWxseSBjbGlwIHRvIHZpc2libGUgcG9ydGlvbiBvZiBjb2x1bW4gdG8gcHJldmVudCB0ZXh0IGZyb20gb3ZlcmZsb3dpbmcgdG8gcmlnaHQuXG4gICAgICAgIGNvbHVtbkNsaXAgPSB2Yy5jb2x1bW4ucHJvcGVydGllcy5jb2x1bW5DbGlwO1xuICAgICAgICBnYy5jbGlwU2F2ZShjb2x1bW5DbGlwIHx8IGNvbHVtbkNsaXAgPT09IG51bGwgJiYgYyA9PT0gY0xhc3QsIDAsIDAsIHZjLnJpZ2h0LCB2aWV3SGVpZ2h0KTtcblxuICAgICAgICAvLyBGb3IgZWFjaCByb3cgb2YgZWFjaCBzdWJncmlkIChvZiBlYWNoIGNvbHVtbikuLi5cbiAgICAgICAgZm9yIChwcmVmZXJyZWRXaWR0aCA9IHIgPSAwOyByIDwgUjsgcisrLCBwKyspIHtcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IHBvb2xbcF07IC8vIG5leHQgY2VsbCBkb3duIHRoZSBjb2x1bW4gKHJlZHVuZGFudCBmb3IgZmlyc3QgY2VsbCBpbiBjb2x1bW4pXG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJlZmVycmVkV2lkdGggPSBNYXRoLm1heChwcmVmZXJyZWRXaWR0aCwgdGhpcy5fcGFpbnRDZWxsKGdjLCBwb29sW3BdKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvckNlbGwoZSwgZ2MsIHZjLCBwb29sW3BdLnZpc2libGVSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2MuY2xpcFJlc3RvcmUoY29sdW1uQ2xpcCk7XG5cbiAgICAgICAgY2VsbEV2ZW50LmNvbHVtbi5wcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoID0gTWF0aC5yb3VuZChwcmVmZXJyZWRXaWR0aCk7XG4gICAgfVxuXG4gICAgLy8gZ2MuY2xpcFJlc3RvcmUoY2xpcFRvR3JpZCk7XG59XG5cbnBhaW50Q2VsbHNBc05lZWRlZC5rZXkgPSAnYnktY2VsbHMnO1xuXG5wYWludENlbGxzQXNOZWVkZWQucGFydGlhbCA9IHRydWU7IC8vIHNraXAgcGFpbnRpbmcgc2VsZWN0aW9uUmVnaW9uT3ZlcmxheUNvbG9yXG5cbm1vZHVsZS5leHBvcnRzID0gcGFpbnRDZWxsc0FzTmVlZGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVuZGxlQ29sdW1ucyA9IHJlcXVpcmUoJy4vYnVuZGxlLWNvbHVtbnMnKTtcbnZhciBidW5kbGVSb3dzID0gcmVxdWlyZSgnLi9idW5kbGUtcm93cycpO1xuXG4vKiogQHN1bW1hcnkgUmVuZGVyIHRoZSBncmlkIHdpdGggY29uc29saWRhdGVkIHJvdyBPUiBjb2x1bW4gcmVjdHMuXG4gKiBAZGVzYyBQYWludHMgYWxsIHRoZSBjZWxscyBvZiBhIGdyaWQsIG9uZSBjb2x1bW4gYXQgYSB0aW1lLlxuICpcbiAqIEZpcnN0LCBhIGJhY2tncm91bmQgcmVjdCBpcyBkcmF3biB1c2luZyB0aGUgZ3JpZCBiYWNrZ3JvdW5kIGNvbG9yLlxuICpcbiAqIFRoZW4sIGlmIHRoZXJlIGFyZSBhbnkgcm93cyB3aXRoIHRoZWlyIG93biBiYWNrZ3JvdW5kIGNvbG9yIF90aGF0IGRpZmZlcnMgZnJvbSB0aGUgZ3JpZCBiYWNrZ3JvdW5kIGNvbG9yLF8gdGhlc2UgYXJlIGNvbnNvbGlkYXRlZCBhbmQgdGhlIGNvbnNvbGlkYXRlZCBncm91cHMgb2Ygcm93IGJhY2tncm91bmRzIGFyZSBhbGwgZHJhd24gYmVmb3JlIGl0ZXJhdGluZyB0aHJvdWdoIGNlbGxzLiBUaGVzZSByb3cgYmFja2dyb3VuZHMgZ2V0IHByaW9yaXR5IG92ZXIgY29sdW1uIGJhY2tncm91bmRzLlxuICpcbiAqIElmIHRoZXJlIGFyZSBubyBzdWNoIHJvdyBiYWNrZ3JvdW5kIHJlY3RzIHRvIGRyYXcsIHRoZSBjb2x1bW4gcmVjdHMgYXJlIGNvbnNvbGlkYXRlZCBhbmQgZHJhd24gaW5zdGVhZCAoYWdhaW4sIGJlZm9yZSB0aGUgY2VsbHMpLiBOb3RlIHRoYXQgdGhlc2UgY29sdW1uIHJlY3RzIGFyZSBfbm90XyBzdWl0YWJsZSBmb3IgY2xpcHBpbmcgb3ZlcmZsb3cgdGV4dCBmcm9tIHByZXZpb3VzIGNvbHVtbnMuIElmIHlvdSBoYXZlIG92ZXJmbG93IHRleHQsIGVpdGhlciB0dXJuIG9uIGNsaXBwaW5nIChiaWcgcGVyZm9ybWFuY2UgaGl0KSBvciB0dXJuIG9uIG9uZSBvZiB0aGUgYHRydW5jYXRlVGV4dFdpdGhFbGxpcHNpc2Agb3B0aW9ucy5cbiAqXG4gKiBgdHJ5Li4uY2F0Y2hgIHN1cnJvdW5kcyBlYWNoIGNlbGwgcGFpbnQgaW4gY2FzZSBhIGNlbGwgcmVuZGVyZXIgdGhyb3dzIGFuIGVycm9yLlxuICogVGhlIGVycm9yIG1lc3NhZ2UgaXMgZXJyb3ItbG9nZ2VkIHRvIGNvbnNvbGUgQU5EIGRpc3BsYXllZCBpbiBjZWxsLlxuICpcbiAqIEVhY2ggY2VsbCB0byBiZSByZW5kZXJlZCBpcyBkZXNjcmliZWQgYnkgYSB7QGxpbmsgQ2VsbEV2ZW50fSBvYmplY3QuIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0byBhdm9pZCBjb25zdGFudGx5IGluc3RhbnRpYXRpbmcgdGhlc2Ugb2JqZWN0cywgd2UgbWFpbnRhaW4gYSBwb29sIG9mIHRoZXNlLiBXaGVuIHRoZSBncmlkIHNoYXBlIGNoYW5nZXMsIHdlIHJlc2V0IHRoZWlyIGNvb3JkaW5hdGVzIGJ5IHNldHRpbmcge0BsaW5rIENlbGxFdmVudCNyZXNldHxyZXNldH0gb24gZWFjaC5cbiAqXG4gKiBTZWUgYWxzbyB0aGUgZGlzY3Vzc2lvbiBvZiBjbGlwcGluZyBpbiB7QGxpbmsgUmVuZGVyZXIjcGFpbnRDZWxsc0J5Q29sdW1uc3xwYWludENlbGxzQnlDb2x1bW5zfS5cbiAqIEB0aGlzIHtSZW5kZXJlcn1cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBwYWludENlbGxzQnlDb2x1bW5zQW5kUm93cyhnYykge1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBncmlkUHJvcHMgPSBncmlkLnByb3BlcnRpZXMsXG4gICAgICAgIHByZWZpbGxDb2xvciwgcm93UHJlZmlsbENvbG9ycywgZ3JpZFByZWZpbGxDb2xvciA9IGdyaWRQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGNlbGxFdmVudCxcbiAgICAgICAgcm93QnVuZGxlLCByb3dCdW5kbGVzLFxuICAgICAgICBjb2x1bW5CdW5kbGUsIGNvbHVtbkJ1bmRsZXMsXG4gICAgICAgIHZjLCB2aXNpYmxlQ29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnMsXG4gICAgICAgIHZpc2libGVSb3dzID0gdGhpcy52aXNpYmxlUm93cyxcbiAgICAgICAgYywgQyA9IHZpc2libGVDb2x1bW5zLmxlbmd0aCwgYzAgPSBncmlkUHJvcHMuc2hvd1Jvd051bWJlcnMgPyAtMSA6IDAsIGNMYXN0ID0gQyAtIDEsXG4gICAgICAgIHIsIFIgPSB2aXNpYmxlUm93cy5sZW5ndGgsXG4gICAgICAgIHAsIHBvb2wgPSB0aGlzLmNlbGxFdmVudFBvb2wsXG4gICAgICAgIHByZWZlcnJlZFdpZHRoLFxuICAgICAgICBjb2x1bW5DbGlwLFxuICAgICAgICAvLyBjbGlwVG9HcmlkLFxuICAgICAgICB2aWV3V2lkdGggPSBDID8gdmlzaWJsZUNvbHVtbnNbQyAtIDFdLnJpZ2h0IDogMCxcbiAgICAgICAgdmlld0hlaWdodCA9IFIgPyB2aXNpYmxlUm93c1tSIC0gMV0uYm90dG9tIDogMDtcblxuICAgIGdjLmNsZWFyUmVjdCgwLCAwLCB0aGlzLmJvdW5kcy53aWR0aCwgdGhpcy5ib3VuZHMuaGVpZ2h0KTtcblxuICAgIGlmICghQyB8fCAhUikgeyByZXR1cm47IH1cblxuICAgIGlmIChnYy5hbHBoYShncmlkUHJlZmlsbENvbG9yKSA+IDApIHtcbiAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gZ3JpZFByZWZpbGxDb2xvcjtcbiAgICAgICAgZ2MuZmlsbFJlY3QoMCwgMCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAocGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3MucmVzZXQpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEdyaWRSZW5kZXJlcnMoKTtcbiAgICAgICAgcGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3MucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgYnVuZGxlUm93cy5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnVuZGxlQ29sdW1ucy5jYWxsKHRoaXMsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAocGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3MucmVidW5kbGUpIHtcbiAgICAgICAgcGFpbnRDZWxsc0J5Q29sdW1uc0FuZFJvd3MucmVidW5kbGUgPSBmYWxzZTtcbiAgICAgICAgYnVuZGxlQ29sdW1ucy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHJvd0J1bmRsZXMgPSB0aGlzLnJvd0J1bmRsZXM7XG4gICAgaWYgKHJvd0J1bmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJvd1ByZWZpbGxDb2xvcnMgPSB0aGlzLnJvd1ByZWZpbGxDb2xvcnM7XG4gICAgICAgIGZvciAociA9IHJvd0J1bmRsZXMubGVuZ3RoOyByLS07KSB7XG4gICAgICAgICAgICByb3dCdW5kbGUgPSByb3dCdW5kbGVzW3JdO1xuICAgICAgICAgICAgZ2MuY2xlYXJGaWxsKDAsIHJvd0J1bmRsZS50b3AsIHZpZXdXaWR0aCwgcm93QnVuZGxlLmJvdHRvbSAtIHJvd0J1bmRsZS50b3AsIHJvd0J1bmRsZS5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb2x1bW5CdW5kbGVzID0gdGhpcy5jb2x1bW5CdW5kbGVzLCBjID0gY29sdW1uQnVuZGxlcy5sZW5ndGg7IGMtLTspIHtcbiAgICAgICAgICAgIGNvbHVtbkJ1bmRsZSA9IGNvbHVtbkJ1bmRsZXNbY107XG4gICAgICAgICAgICBnYy5jbGVhckZpbGwoY29sdW1uQnVuZGxlLmxlZnQsIDAsIGNvbHVtbkJ1bmRsZS5yaWdodCAtIGNvbHVtbkJ1bmRsZS5sZWZ0LCB2aWV3SGVpZ2h0LCBjb2x1bW5CdW5kbGUuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdjLmNsaXBTYXZlKGNsaXBUb0dyaWQsIDAsIDAsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG5cbiAgICAvLyBGb3IgZWFjaCBjb2x1bW4uLi5cbiAgICBmb3IgKHAgPSAwLCBjID0gYzA7IGMgPCBDOyBjKyspIHtcbiAgICAgICAgY2VsbEV2ZW50ID0gcG9vbFtwXTtcbiAgICAgICAgdmMgPSBjZWxsRXZlbnQudmlzaWJsZUNvbHVtbjtcblxuICAgICAgICBpZiAoIXJvd1ByZWZpbGxDb2xvcnMpIHtcbiAgICAgICAgICAgIHByZWZpbGxDb2xvciA9IGNlbGxFdmVudC5jb2x1bW4ucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbGx5IGNsaXAgdG8gdmlzaWJsZSBwb3J0aW9uIG9mIGNvbHVtbiB0byBwcmV2ZW50IHRleHQgZnJvbSBvdmVyZmxvd2luZyB0byByaWdodC5cbiAgICAgICAgY29sdW1uQ2xpcCA9IHZjLmNvbHVtbi5wcm9wZXJ0aWVzLmNvbHVtbkNsaXA7XG4gICAgICAgIGdjLmNsaXBTYXZlKGNvbHVtbkNsaXAgfHwgY29sdW1uQ2xpcCA9PT0gbnVsbCAmJiBjID09PSBjTGFzdCwgMCwgMCwgdmMucmlnaHQsIHZpZXdIZWlnaHQpO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHJvdyBvZiBlYWNoIHN1YmdyaWQgKG9mIGVhY2ggY29sdW1uKS4uLlxuICAgICAgICBmb3IgKHByZWZlcnJlZFdpZHRoID0gciA9IDA7IHIgPCBSOyByKyssIHArKykge1xuICAgICAgICAgICAgaWYgKCFwb29sW3BdLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd1ByZWZpbGxDb2xvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZmlsbENvbG9yID0gcm93UHJlZmlsbENvbG9yc1tyXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWRXaWR0aCA9IE1hdGgubWF4KHByZWZlcnJlZFdpZHRoLCB0aGlzLl9wYWludENlbGwoZ2MsIHBvb2xbcF0sIHByZWZpbGxDb2xvcikpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvckNlbGwoZSwgZ2MsIHZjLCBwb29sW3BdLnZpc2libGVSb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmNsaXBSZXN0b3JlKGNvbHVtbkNsaXApO1xuXG4gICAgICAgIGNlbGxFdmVudC5jb2x1bW4ucHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IE1hdGgucm91bmQocHJlZmVycmVkV2lkdGgpO1xuICAgIH1cblxuICAgIC8vIGdjLmNsaXBSZXN0b3JlKGNsaXBUb0dyaWQpO1xuXG4gICAgdGhpcy5wYWludEdyaWRsaW5lcyhnYyk7XG59XG5cbnBhaW50Q2VsbHNCeUNvbHVtbnNBbmRSb3dzLmtleSA9ICdieS1jb2x1bW5zLWFuZC1yb3dzJztcbnBhaW50Q2VsbHNCeUNvbHVtbnNBbmRSb3dzLnJlYnVuZGxlID0gZmFsc2U7IC8vIHNlZSByZWJ1bmRsZUdyaWRSZW5kZXJlcnNcblxubW9kdWxlLmV4cG9ydHMgPSBwYWludENlbGxzQnlDb2x1bW5zQW5kUm93cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1bmRsZUNvbHVtbnMgPSByZXF1aXJlKCcuL2J1bmRsZS1jb2x1bW5zJyk7XG5cbi8qKiBAc3VtbWFyeSBSZW5kZXIgdGhlIGdyaWQgd2l0aCBkaXNjcmV0ZSBjb2x1bW4gcmVjdHMuXG4gKiBAZGVzYyBQYWludHMgYWxsIHRoZSBjZWxscyBvZiBhIGdyaWQsIG9uZSBjb2x1bW4gYXQgYSB0aW1lLlxuICpcbiAqIEluIHRoaXMgZ3JpZCByZW5kZXJlciwgYSBiYWNrZ3JvdW5kIHJlY3QgaXMgX25vdF8gZHJhd24gdXNpbmcgdGhlIGdyaWQgYmFja2dyb3VuZCBjb2xvci5cbiAqXG4gKiBSYXRoZXIsIGFsbCBjb2x1bW5zIHBhaW50IHRoZWlyIG93biBiYWNrZ3JvdW5kIHJlY3RzLCB3aXRoIGNvbG9yIGRlZmF1bHRpbmcgdG8gZ3JpZCBiYWNrZ3JvdW5kIGNvbG9yLlxuICpcbiAqIFRoZSBpZGVhIG9mIHBhaW50aW5nIGVhY2ggY29sdW1uIHJlY3QgaXMgdG8gXCJjbGlwXCIgdGV4dCB0aGF0IG1pZ2h0IGhhdmUgb3ZlcmZsb3dlZCBmcm9tIHRoZSBwcmV2aW91cyBjb2x1bW4gYnkgcGFpbnRpbmcgb3ZlciBpdCB3aXRoIHRoZSBiYWNrZ3JvdW5kIGZyb20gdGhpcyBjb2x1bW4uIE9ubHkgdGhlIGxhc3QgY29sdW1uIHdpbGwgc2hvdyBvdmVyZmxvd2luZyB0ZXh0LCBhbmQgb25seSBpZiB0aGUgY2FudmFzIHdpZHRoIGV4Y2VlZHMgdGhlIGdyaWQgd2lkdGguIElmIHRoaXMgaXMgdGhlIGNhc2UsIHlvdSBjYW4gdHVybiBvbiBjbGlwcGluZyBmb3IgdGhlIGxhc3QgY29sdW1uIG9ubHkgYnkgc2V0dGluZyBgY29sdW1uQ2xpcGAgdG8gYHRydWVgIGZvciB0aGUgbGFzdCBjb2x1bW4uXG4gKlxuICogTk9URTogQXMgYSBjb252ZW5pZW5jZSBmZWF0dXJlLCBzZXR0aW5nIGBjb2x1bW5DbGlwYCB0byBgbnVsbGAgd2lsbCBjbGlwIG9ubHkgdGhlIGxhc3QgY29sdW1uLCBzbyBzaW1wbHkgc2V0dGluZyBpdCBvbiB0aGUgZ3JpZCAocmF0aGVyIHRoYW4gdGhlIGxhc3QgY29sdW1uKSB3aWxsIGhhdmUgdGhlIHNhbWUgZWZmZWN0LiBUaGlzIGlzIG11Y2ggbW9yZSBjb252ZW5pZW50IGJlY2F1c2UgeW91IGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhlIGxhc3QgY29sdW1uIGJlaW5nIHJlZGVmaW5lZCAobW92ZWQsIGhpZGRlbiwgZXRjKS5cbiAqXG4gKiBgdHJ5Li4uY2F0Y2hgIHN1cnJvdW5kcyBlYWNoIGNlbGwgcGFpbnQgaW4gY2FzZSBhIGNlbGwgcmVuZGVyZXIgdGhyb3dzIGFuIGVycm9yLlxuICogVGhlIGVycm9yIG1lc3NhZ2UgaXMgZXJyb3ItbG9nZ2VkIHRvIGNvbnNvbGUgQU5EIGRpc3BsYXllZCBpbiBjZWxsLlxuICpcbiAqIEVhY2ggY2VsbCB0byBiZSByZW5kZXJlZCBpcyBkZXNjcmliZWQgYnkgYSB7QGxpbmsgQ2VsbEV2ZW50fSBvYmplY3QuIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0byBhdm9pZCBjb25zdGFudGx5IGluc3RhbnRpYXRpbmcgdGhlc2Ugb2JqZWN0cywgd2UgbWFpbnRhaW4gYSBwb29sIG9mIHRoZXNlLiBXaGVuIHRoZSBncmlkIHNoYXBlIGNoYW5nZXMsIHdlIHJlc2V0IHRoZWlyIGNvb3JkaW5hdGVzIGJ5IHNldHRpbmcge0BsaW5rIENlbGxFdmVudCNyZXNldHxyZXNldH0gb24gZWFjaC5cbiAqXG4gKiBTZWUgYWxzbyB0aGUgZGlzY3Vzc2lvbiBvZiBjbGlwcGluZyBpbiB7QGxpbmsgUmVuZGVyZXIjcGFpbnRDZWxsc0J5Q29sdW1uc0Rpc2NyZXRlfHBhaW50Q2VsbHNCeUNvbHVtbnNEaXNjcmV0ZX0uXG5cbiAqIEB0aGlzIHtSZW5kZXJlcn1cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBwYWludENlbGxzQnlDb2x1bW5zRGlzY3JldGUoZ2MpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgZ3JpZFByb3BzID0gZ3JpZC5wcm9wZXJ0aWVzLFxuICAgICAgICBwcmVmaWxsQ29sb3IsXG4gICAgICAgIGNlbGxFdmVudCxcbiAgICAgICAgdmMsIHZpc2libGVDb2x1bW5zID0gdGhpcy52aXNpYmxlQ29sdW1ucyxcbiAgICAgICAgdmlzaWJsZVJvd3MgPSB0aGlzLnZpc2libGVSb3dzLFxuICAgICAgICBjLCBDID0gdmlzaWJsZUNvbHVtbnMubGVuZ3RoLCBjMCA9IGdyaWRQcm9wcy5zaG93Um93TnVtYmVycyA/IC0xIDogMCwgY0xhc3QgPSBDIC0gMSxcbiAgICAgICAgciwgUiA9IHZpc2libGVSb3dzLmxlbmd0aCxcbiAgICAgICAgcCwgcG9vbCA9IHRoaXMuY2VsbEV2ZW50UG9vbCxcbiAgICAgICAgcHJlZmVycmVkV2lkdGgsXG4gICAgICAgIGNvbHVtbkNsaXAsXG4gICAgICAgIC8vIGNsaXBUb0dyaWQsXG4gICAgICAgIC8vIHZpZXdXaWR0aCA9IEMgPyB2aXNpYmxlQ29sdW1uc1tDIC0gMV0ucmlnaHQgOiAwLFxuICAgICAgICB2aWV3SGVpZ2h0ID0gUiA/IHZpc2libGVSb3dzW1IgLSAxXS5ib3R0b20gOiAwO1xuXG4gICAgZ2MuY2xlYXJSZWN0KDAsIDAsIHRoaXMuYm91bmRzLndpZHRoLCB0aGlzLmJvdW5kcy5oZWlnaHQpO1xuXG4gICAgaWYgKCFDIHx8ICFSKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHBhaW50Q2VsbHNCeUNvbHVtbnNEaXNjcmV0ZS5yZXNldCkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsR3JpZFJlbmRlcmVycyhbJ2J5LWNvbHVtbnMnXSk7XG4gICAgICAgIHBhaW50Q2VsbHNCeUNvbHVtbnNEaXNjcmV0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBidW5kbGVDb2x1bW5zLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gZ2MuY2xpcFNhdmUoY2xpcFRvR3JpZCwgMCwgMCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KTtcblxuICAgIC8vIEZvciBlYWNoIGNvbHVtbi4uLlxuICAgIGZvciAocCA9IDAsIGMgPSBjMDsgYyA8IEM7IGMrKykge1xuICAgICAgICBjZWxsRXZlbnQgPSBwb29sW3BdOyAvLyBmaXJzdCBjZWxsIGluIGNvbHVtbiBjXG4gICAgICAgIHZjID0gY2VsbEV2ZW50LnZpc2libGVDb2x1bW47XG5cbiAgICAgICAgcHJlZmlsbENvbG9yID0gY2VsbEV2ZW50LmNvbHVtbi5wcm9wZXJ0aWVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgZ2MuY2xlYXJGaWxsKHZjLmxlZnQsIDAsIHZjLndpZHRoLCB2aWV3SGVpZ2h0LCBwcmVmaWxsQ29sb3IpO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsbHkgY2xpcCB0byB2aXNpYmxlIHBvcnRpb24gb2YgY29sdW1uIHRvIHByZXZlbnQgdGV4dCBmcm9tIG92ZXJmbG93aW5nIHRvIHJpZ2h0LlxuICAgICAgICBjb2x1bW5DbGlwID0gdmMuY29sdW1uLnByb3BlcnRpZXMuY29sdW1uQ2xpcDtcbiAgICAgICAgZ2MuY2xpcFNhdmUoY29sdW1uQ2xpcCB8fCBjb2x1bW5DbGlwID09PSBudWxsICYmIGMgPT09IGNMYXN0LCAwLCAwLCB2Yy5yaWdodCwgdmlld0hlaWdodCk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggcm93IG9mIGVhY2ggc3ViZ3JpZCAob2YgZWFjaCBjb2x1bW4pLi4uXG4gICAgICAgIGZvciAocHJlZmVycmVkV2lkdGggPSByID0gMDsgciA8IFI7IHIrKywgcCsrKSB7XG4gICAgICAgICAgICBjZWxsRXZlbnQgPSBwb29sW3BdOyAvLyBuZXh0IGNlbGwgZG93biB0aGUgY29sdW1uIChyZWR1bmRhbnQgZm9yIGZpcnN0IGNlbGwgaW4gY29sdW1uKVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByZWZlcnJlZFdpZHRoID0gTWF0aC5tYXgocHJlZmVycmVkV2lkdGgsIHRoaXMuX3BhaW50Q2VsbChnYywgY2VsbEV2ZW50LCBwcmVmaWxsQ29sb3IpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckVycm9yQ2VsbChlLCBnYywgdmMsIGNlbGxFdmVudC52aXNpYmxlUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmNsaXBSZXN0b3JlKGNvbHVtbkNsaXApO1xuXG4gICAgICAgIGNlbGxFdmVudC5jb2x1bW4ucHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IE1hdGgucm91bmQocHJlZmVycmVkV2lkdGgpO1xuICAgIH1cblxuICAgIC8vIGdjLmNsaXBSZXN0b3JlKGNsaXBUb0dyaWQpO1xuXG4gICAgdGhpcy5wYWludEdyaWRsaW5lcyhnYyk7XG59XG5cbnBhaW50Q2VsbHNCeUNvbHVtbnNEaXNjcmV0ZS5rZXkgPSAnYnktY29sdW1ucy1kaXNjcmV0ZSc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFpbnRDZWxsc0J5Q29sdW1uc0Rpc2NyZXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVuZGxlQ29sdW1ucyA9IHJlcXVpcmUoJy4vYnVuZGxlLWNvbHVtbnMnKTtcblxuLyoqIEBzdW1tYXJ5IFJlbmRlciB0aGUgZ3JpZCB3aXRoIGNvbnNvbGlkYXRlZCBjb2x1bW4gcmVjdHMuXG4gKiBAZGVzYyBQYWludHMgYWxsIHRoZSBjZWxscyBvZiBhIGdyaWQsIG9uZSBjb2x1bW4gYXQgYSB0aW1lLlxuICpcbiAqIEZpcnN0LCBhIGJhY2tncm91bmQgcmVjdCBpcyBkcmF3biB1c2luZyB0aGUgZ3JpZCBiYWNrZ3JvdW5kIGNvbG9yLlxuICpcbiAqIFRoZW4sIGlmIHRoZXJlIGFyZSBhbnkgY29sdW1ucyB3aXRoIHRoZWlyIG93biBiYWNrZ3JvdW5kIGNvbG9yIF90aGF0IGRpZmZlcnMgZnJvbSB0aGUgZ3JpZCBiYWNrZ3JvdW5kIGNvbG9yLF8gdGhlc2UgYXJlIGNvbnNvbGlkYXRlZCBhbmQgdGhlIGNvbnNvbGlkYXRlZCBncm91cHMgb2YgY29sdW1uIGJhY2tncm91bmRzIGFyZSBhbGwgZHJhd24gYmVmb3JlIGl0ZXJhdGluZyB0aHJvdWdoIGNlbGxzLiBOb3RlIHRoYXQgdGhlc2UgY29sdW1uIHJlY3RzIGFyZSBfbm90XyBzdWl0YWJsZSBmb3IgY2xpcHBpbmcgb3ZlcmZsb3cgdGV4dCBmcm9tIHByZXZpb3VzIGNvbHVtbnMuIElmIHlvdSBoYXZlIG92ZXJmbG93IHRleHQsIGVpdGhlciB0dXJuIG9uIGNsaXBwaW5nIChiaWcgcGVyZm9ybWFuY2UgaGl0KSBvciB0dXJuIG9uIG9uZSBvZiB0aGUgYHRydW5jYXRlVGV4dFdpdGhFbGxpcHNpc2Agb3B0aW9ucy5cbiAqXG4gKiBgdHJ5Li4uY2F0Y2hgIHN1cnJvdW5kcyBlYWNoIGNlbGwgcGFpbnQgaW4gY2FzZSBhIGNlbGwgcmVuZGVyZXIgdGhyb3dzIGFuIGVycm9yLlxuICogVGhlIGVycm9yIG1lc3NhZ2UgaXMgZXJyb3ItbG9nZ2VkIHRvIGNvbnNvbGUgQU5EIGRpc3BsYXllZCBpbiBjZWxsLlxuICpcbiAqIEVhY2ggY2VsbCB0byBiZSByZW5kZXJlZCBpcyBkZXNjcmliZWQgYnkgYSB7QGxpbmsgQ2VsbEV2ZW50fSBvYmplY3QuIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0byBhdm9pZCBjb25zdGFudGx5IGluc3RhbnRpYXRpbmcgdGhlc2Ugb2JqZWN0cywgd2UgbWFpbnRhaW4gYSBwb29sIG9mIHRoZXNlLiBXaGVuIHRoZSBncmlkIHNoYXBlIGNoYW5nZXMsIHdlIHJlc2V0IHRoZWlyIGNvb3JkaW5hdGVzIGJ5IHNldHRpbmcge0BsaW5rIENlbGxFdmVudCNyZXNldHxyZXNldH0gb24gZWFjaC5cbiAqXG4gKiAqKlJlZ2FkaW5nIGNsaXBwaW5nLioqIFRoZSByZWFzb24gZm9yIGNsaXBwaW5nIGlzIHRvIHByZXZlbnQgdGV4dCBmcm9tIG92ZXJmbG93aW5nIGludG8gdGhlIG5leHQgY29sdW1uLiBIb3dldmVyIHRoZXJlIGlzIGEgc2VyaW91cyBwZXJmb3JtYW5jZSBjb3N0LlxuICpcbiAqIEZvciBwZXJmb3JtYW5jZSByZWFzb25zIHtAbGluayBSZW5kZXJlciNfcGFpbnRDZWxsfF9wYWludENlbGx9IGRvZXMgbm90IHNldCB1cCBhIGNsaXBwaW5nIHJlZ2lvbiBmb3IgZWFjaCBjZWxsLiBIb3dldmVyLCBpZmYgZ3JpZCBwcm9wZXJ0eSBgY29sdW1uQ2xpcGAgaXMgdHJ1dGh5LCB0aGlzIGdyaWQgcmVuZGVyZXIgd2lsbCBzZXQgdXAgYSBjbGlwcGluZyByZWdpb24gdG8gcHJldmVudCB0ZXh0IG92ZXJmbG93IHRvIHJpZ2h0LiBJZiBgY29sdW1uQ2xpcGAgaXMgYG51bGxgLCBhIGNsaXBwaW5nIHJlZ2lvbiB3aWxsIG9ubHkgYmUgc2V0IHVwIG9uIHRoZSBsYXN0IGNvbHVtbi4gT3RoZXJ3aXNlLCB0aGVyZSB3aWxsIGJlIG5vIGNsaXBwaW5nIHJlZ2lvbi5cbiAqXG4gKiBUaGUgaWRlYSBvZiBjbGlwcGluZyBqdXN0IHRoZSBsYXN0IGNvbHVtbiBpcyBiZWNhdXNlIGluIGFkZGl0aW9uIHRvIHRoZSBvcHRpb25hbCBncmFwaGljcyBjbGlwcGluZywgd2UgYWxzbyBjbGlwIChcInRydW5jYXRlXCIpIHRleHQuIFRleHQgY2FuIGJlIHRydW5jYXRlZCBjb25zZXJ2YXRpdmVseSBzbyBpdCB3aWxsIG5ldmVyIG92ZXJmbG93LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXMgaXMgdGhhdCBjaGFyYWN0ZXJzIHZhbmlzaCBhcyB0aGV5IGhpdCB0aGUgcmlnaHQgY2VsbCBib3VuZGFyeSwgd2hpY2ggbWF5IG9yIG1heSBiZSBvYnZpb3VzIGRlcGVuZGluZyBvbiBmb250IHNpemUuIEFsdGVybmF0aXZlbHksIHRleHQgY2FuIGJlIHRydW5jYXRlZCBzbyB0aGF0IHRoZSBvdmVyZmxvdyB3aWxsIGJlIGEgbWF4aW11bSBvZiAxIGNoYXJhY3Rlci4gVGhpcyBhbGxvd3MgcGFydGlhbCBjaGFyYWN0ZXJzIHRvIGJlIHJlbmRlcmVkLiBCdXQgdGhpcyBpcyB3aGVyZSBncmFwaGljcyBjbGlwcGluZyBpcyByZXF1aXJlZC5cbiAqXG4gKiBXaGVuIHJlbmRlcmVyaW5nIGNvbHVtbiBieSBjb2x1bW4gYXMgdGhpcyBwYXJ0aWN1bGFyIHJlbmRlcmVyIGRvZXMsIF9hbmRfIHdoZW4gdGhlIGJhY2tncm91bmQgY29sb3IgX29mIHRoZSBuZXh0IGNlbGwgdG8gdGhlIHJpZ2h0XyBpcyBvcGFxdWUgKGFscGhhID0gMSksIGNsaXBwaW5nIGNhbiBiZSB0dXJuZWQgb2ZmIGJlY2F1c2UgZWFjaCBjb2x1bW4gd2lsbCBfb3ZlcnBhaW50XyBhbnkgdGV4dCB0aGF0IG92ZXJmbG93ZWQgZnJvbSB0aGUgb25lIGJlZm9yZS4gSG93ZXZlciwgYW55IHRleHQgdGhhdCBvdmVyZmxvd3MgdGhlIGxhc3QgY29sdW1uIHdpbGwgcGFpbnQgaW50byB1bnVzZWQgY2FudmFzIHJlZ2lvbiB0byB0aGUgcmlnaHQgb2YgdGhlIGdyaWQuIFRoaXMgaXMgdGhlIF9yYWlzb24gZCfDqnRyZV8gZm9yIFwiY2xpcCBsYXN0IGNvbHVtbiBvbmx5XCIgb3B0aW9uIG1lbnRpb25lZCBhYm92ZSAod2hlbiBgY29sdW1uQ2xpcGAgaXMgc2V0IHRvIGBudWxsYCkuIFRvIGF2b2lkIGV2ZW4gdGhpcyBwZXJmb3JtYW5jZSBjb3N0IChvZiBjbGlwcGluZyBqdXN0IHRoZSBsYXN0IGNvbHVtbiksIGNvbHVtbiB3aWR0aHMgY2FuIGJlIHNldCB0byBmaWxsIHRoZSBhdmFpbGFibGUgY2FudmFzLlxuICpcbiAqIE5vdGUgdGhhdCB0ZXh0IG5ldmVyIG92ZXJmbG93cyB0byBsZWZ0IGJlY2F1c2UgdGV4dCBzdGFydGluZyBwb2ludCBpcyBuZXZlciA8IDAuIFRoZSByZWFzb24gd2UgZG9uJ3QgY2xpcCB0byB0aGUgbGVmdCBpcyBmb3IgY2VsbCByZW5kZXJlcnMgdGhhdCBuZWVkIHRvIHJlLXJlbmRlciB0byB0aGUgbGVmdCB0byBwcm9kdWNlIGEgbWVyZ2VkIGNlbGwgZWZmZWN0LCBzdWNoIGFzIGdyb3VwZWQgY29sdW1uIGhlYWRlci5cblxuICogQHRoaXMge1JlbmRlcmVyfVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gKi9cbmZ1bmN0aW9uIHBhaW50Q2VsbHNCeUNvbHVtbnMoZ2MpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgZ3JpZFByb3BzID0gZ3JpZC5wcm9wZXJ0aWVzLFxuICAgICAgICBwcmVmaWxsQ29sb3IsIGdyaWRQcmVmaWxsQ29sb3IgPSBncmlkUHJvcHMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBjZWxsRXZlbnQsXG4gICAgICAgIGNvbHVtbkJ1bmRsZSwgY29sdW1uQnVuZGxlcyxcbiAgICAgICAgdmMsIHZpc2libGVDb2x1bW5zID0gdGhpcy52aXNpYmxlQ29sdW1ucyxcbiAgICAgICAgdmlzaWJsZVJvd3MgPSB0aGlzLnZpc2libGVSb3dzLFxuICAgICAgICBjLCBDID0gdmlzaWJsZUNvbHVtbnMubGVuZ3RoLCBjMCA9IGdyaWRQcm9wcy5zaG93Um93TnVtYmVycyA/IC0xIDogMCwgY0xhc3QgPSBDIC0gMSxcbiAgICAgICAgciwgUiA9IHZpc2libGVSb3dzLmxlbmd0aCxcbiAgICAgICAgcCwgcG9vbCA9IHRoaXMuY2VsbEV2ZW50UG9vbCxcbiAgICAgICAgcHJlZmVycmVkV2lkdGgsXG4gICAgICAgIGNvbHVtbkNsaXAsXG4gICAgICAgIC8vIGNsaXBUb0dyaWQsXG4gICAgICAgIHZpZXdXaWR0aCA9IEMgPyB2aXNpYmxlQ29sdW1uc1tjTGFzdF0ucmlnaHQgOiAwLFxuICAgICAgICB2aWV3SGVpZ2h0ID0gUiA/IHZpc2libGVSb3dzW1IgLSAxXS5ib3R0b20gOiAwO1xuXG4gICAgZ2MuY2xlYXJSZWN0KDAsIDAsIHRoaXMuYm91bmRzLndpZHRoLCB0aGlzLmJvdW5kcy5oZWlnaHQpO1xuXG4gICAgaWYgKCFDIHx8ICFSKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGdjLmFscGhhKGdyaWRQcmVmaWxsQ29sb3IpID4gMCkge1xuICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBncmlkUHJlZmlsbENvbG9yO1xuICAgICAgICBnYy5maWxsUmVjdCgwLCAwLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChwYWludENlbGxzQnlDb2x1bW5zLnJlc2V0KSB7XG4gICAgICAgIHRoaXMucmVzZXRBbGxHcmlkUmVuZGVyZXJzKFsnYnktY29sdW1ucy1kaXNjcmV0ZSddKTtcbiAgICAgICAgcGFpbnRDZWxsc0J5Q29sdW1ucy5yZXNldCA9IGZhbHNlO1xuICAgICAgICBidW5kbGVDb2x1bW5zLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChwYWludENlbGxzQnlDb2x1bW5zLnJlYnVuZGxlKSB7XG4gICAgICAgIHBhaW50Q2VsbHNCeUNvbHVtbnMucmVidW5kbGUgPSBmYWxzZTtcbiAgICAgICAgYnVuZGxlQ29sdW1ucy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGZvciAoY29sdW1uQnVuZGxlcyA9IHRoaXMuY29sdW1uQnVuZGxlcywgYyA9IGNvbHVtbkJ1bmRsZXMubGVuZ3RoOyBjLS07KSB7XG4gICAgICAgIGNvbHVtbkJ1bmRsZSA9IGNvbHVtbkJ1bmRsZXNbY107XG4gICAgICAgIGdjLmNsZWFyRmlsbChjb2x1bW5CdW5kbGUubGVmdCwgMCwgY29sdW1uQnVuZGxlLnJpZ2h0IC0gY29sdW1uQnVuZGxlLmxlZnQsIHZpZXdIZWlnaHQsIGNvbHVtbkJ1bmRsZS5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIH1cblxuICAgIC8vIGdjLmNsaXBTYXZlKGNsaXBUb0dyaWQsIDAsIDAsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG5cbiAgICAvLyBGb3IgZWFjaCBjb2x1bW4uLi5cbiAgICBmb3IgKHAgPSAwLCBjID0gYzA7IGMgPCBDOyBjKyspIHtcbiAgICAgICAgY2VsbEV2ZW50ID0gcG9vbFtwXTsgLy8gZmlyc3QgY2VsbCBpbiBjb2x1bW4gY1xuICAgICAgICB2YyA9IGNlbGxFdmVudC52aXNpYmxlQ29sdW1uO1xuXG4gICAgICAgIHByZWZpbGxDb2xvciA9IGNlbGxFdmVudC5jb2x1bW4ucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgICAgLy8gT3B0aW9uYWxseSBjbGlwIHRvIHZpc2libGUgcG9ydGlvbiBvZiBjb2x1bW4gdG8gcHJldmVudCB0ZXh0IGZyb20gb3ZlcmZsb3dpbmcgdG8gcmlnaHQuXG4gICAgICAgIGNvbHVtbkNsaXAgPSB2Yy5jb2x1bW4ucHJvcGVydGllcy5jb2x1bW5DbGlwO1xuICAgICAgICBnYy5jbGlwU2F2ZShjb2x1bW5DbGlwIHx8IGNvbHVtbkNsaXAgPT09IG51bGwgJiYgYyA9PT0gY0xhc3QsIDAsIDAsIHZjLnJpZ2h0LCB2aWV3SGVpZ2h0KTtcblxuICAgICAgICAvLyBGb3IgZWFjaCByb3cgb2YgZWFjaCBzdWJncmlkIChvZiBlYWNoIGNvbHVtbikuLi5cbiAgICAgICAgZm9yIChwcmVmZXJyZWRXaWR0aCA9IHIgPSAwOyByIDwgUjsgcisrLCBwKyspIHtcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IHBvb2xbcF07IC8vIG5leHQgY2VsbCBkb3duIHRoZSBjb2x1bW4gKHJlZHVuZGFudCBmb3IgZmlyc3QgY2VsbCBpbiBjb2x1bW4pXG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJlZmVycmVkV2lkdGggPSBNYXRoLm1heChwcmVmZXJyZWRXaWR0aCwgdGhpcy5fcGFpbnRDZWxsKGdjLCBjZWxsRXZlbnQsIHByZWZpbGxDb2xvcikpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRXJyb3JDZWxsKGUsIGdjLCB2YywgY2VsbEV2ZW50LnZpc2libGVSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2MuY2xpcFJlc3RvcmUoY29sdW1uQ2xpcCk7XG5cbiAgICAgICAgY2VsbEV2ZW50LmNvbHVtbi5wcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoID0gTWF0aC5yb3VuZChwcmVmZXJyZWRXaWR0aCk7XG4gICAgfVxuXG4gICAgLy8gZ2MuY2xpcFJlc3RvcmUoY2xpcFRvR3JpZCk7XG5cbiAgICB0aGlzLnBhaW50R3JpZGxpbmVzKGdjKTtcbn1cblxucGFpbnRDZWxsc0J5Q29sdW1ucy5rZXkgPSAnYnktY29sdW1ucyc7XG5wYWludENlbGxzQnlDb2x1bW5zLnJlYnVuZGxlID0gZmFsc2U7IC8vIHNlZSByZWJ1bmRsZUdyaWRSZW5kZXJlcnNcblxubW9kdWxlLmV4cG9ydHMgPSBwYWludENlbGxzQnlDb2x1bW5zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVuZGxlUm93cyA9IHJlcXVpcmUoJy4vYnVuZGxlLXJvd3MnKTtcblxuLyoqIEBzdW1tYXJ5IFJlbmRlciB0aGUgZ3JpZC5cbiAqIEBkZXNjIF8qKk5PVEU6KiogVGhpcyBncmlkIHJlbmRlcmVyIGlzIG5vdCBhcyBwZXJmb3JtYW50IGFzIHRoZSBvdGhlcnMgYW5kIGl0J3MgdXNlIGlzIG5vdCByZWNvbW1lbmRlZCBpZiB5b3UgY2FyZSBhYm91dCBwZXJmb3JtYW5jZS4gVGhlIHJlYXNvbnMgZm9yIHRoZSB3YW50aW5nIHBlcmZvcm1hbmNlIGFyZSB1bmNsZWFyLCBwb3NzaWJseSBoYXZpbmcgdG8gZG8gd2l0aCB0aGUgd2F5IENocm9tZSBvcHRpbWl6ZXMgYWNjZXNzIHRvIHRoZSBjb2x1bW4gb2JqZWN0cz9fXG4gKlxuICogUGFpbnRzIGFsbCB0aGUgY2VsbHMgb2YgYSBncmlkLCBvbmUgcm93IGF0IGEgdGltZS5cbiAqXG4gKiBGaXJzdCwgYSBiYWNrZ3JvdW5kIHJlY3QgaXMgZHJhd24gdXNpbmcgdGhlIGdyaWQgYmFja2dyb3VuZCBjb2xvci5cbiAqXG4gKiBUaGVuLCBpZiB0aGVyZSBhcmUgYW55IHJvd3Mgd2l0aCB0aGVpciBvd24gYmFja2dyb3VuZCBjb2xvciBfdGhhdCBkaWZmZXJzIGZyb20gdGhlIGdyaWQgYmFja2dyb3VuZCBjb2xvcixfIHRoZXNlIGFyZSBjb25zb2xpZGF0ZWQgYW5kIHRoZSBjb25zb2xpZGF0ZWQgZ3JvdXBzIG9mIHJvdyBiYWNrZ3JvdW5kcyBhcmUgYWxsIGRyYXduIGJlZm9yZSBpdGVyYXRpbmcgdGhyb3VnaCBjZWxscy5cbiAqXG4gKiBgdHJ5Li4uY2F0Y2hgIHN1cnJvdW5kcyBlYWNoIGNlbGwgcGFpbnQgaW4gY2FzZSBhIGNlbGwgcmVuZGVyZXIgdGhyb3dzIGFuIGVycm9yLlxuICogVGhlIGVycm9yIG1lc3NhZ2UgaXMgZXJyb3ItbG9nZ2VkIHRvIGNvbnNvbGUgQU5EIGRpc3BsYXllZCBpbiBjZWxsLlxuICpcbiAqIEVhY2ggY2VsbCB0byBiZSByZW5kZXJlZCBpcyBkZXNjcmliZWQgYnkgYSB7QGxpbmsgQ2VsbEV2ZW50fSBvYmplY3QuIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0byBhdm9pZCBjb25zdGFudGx5IGluc3RhbnRpYXRpbmcgdGhlc2Ugb2JqZWN0cywgd2UgbWFpbnRhaW4gYSBwb29sIG9mIHRoZXNlLiBXaGVuIHRoZSBncmlkIHNoYXBlIGNoYW5nZXMsIHdlIHJlc2V0IHRoZWlyIGNvb3JkaW5hdGVzIGJ5IHNldHRpbmcge0BsaW5rIENlbGxFdmVudCNyZXNldHxyZXNldH0gb24gZWFjaC5cbiAqXG4gKiBTZWUgYWxzbyB0aGUgZGlzY3Vzc2lvbiBvZiBjbGlwcGluZyBpbiB7QGxpbmsgUmVuZGVyZXIjcGFpbnRDZWxsc0J5Q29sdW1uc3xwYWludENlbGxzQnlDb2x1bW5zfS5cbiAqIEB0aGlzIHtSZW5kZXJlcn1cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBwYWludENlbGxzQnlSb3dzKGdjKSB7XG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgIGdyaWRQcm9wcyA9IGdyaWQucHJvcGVydGllcyxcbiAgICAgICAgcHJlZmlsbENvbG9yLCByb3dQcmVmaWxsQ29sb3JzLCBncmlkUHJlZmlsbENvbG9yID0gZ3JpZFByb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgY2VsbEV2ZW50LFxuICAgICAgICByb3dCdW5kbGUsIHJvd0J1bmRsZXMgPSB0aGlzLnJvd0J1bmRsZXMsXG4gICAgICAgIHZjLCB2aXNpYmxlQ29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnMsXG4gICAgICAgIHZyLCB2aXNpYmxlUm93cyA9IHRoaXMudmlzaWJsZVJvd3MsXG4gICAgICAgIGMsIEMgPSB2aXNpYmxlQ29sdW1ucy5sZW5ndGgsIGMwID0gZ3JpZFByb3BzLnNob3dSb3dOdW1iZXJzID8gLTEgOiAwLCBjTGFzdCA9IEMgLSAxLFxuICAgICAgICByLCBSID0gdmlzaWJsZVJvd3MubGVuZ3RoLFxuICAgICAgICBwLCBwb29sID0gdGhpcy5jZWxsRXZlbnRQb29sLFxuICAgICAgICBwcmVmZXJyZWRXaWR0aCA9IEFycmF5KEMgLSBjMCkuZmlsbCgwKSxcbiAgICAgICAgY29sdW1uQ2xpcCxcbiAgICAgICAgLy8gY2xpcFRvR3JpZCxcbiAgICAgICAgdmlld1dpZHRoID0gQyA/IHZpc2libGVDb2x1bW5zW0MgLSAxXS5yaWdodCA6IDAsXG4gICAgICAgIHZpZXdIZWlnaHQgPSBSID8gdmlzaWJsZVJvd3NbUiAtIDFdLmJvdHRvbSA6IDAsXG4gICAgICAgIGxpbmVXaWR0aCA9IGdyaWRQcm9wcy5saW5lV2lkdGgsXG4gICAgICAgIGxpbmVDb2xvciA9IGdyaWRQcm9wcy5saW5lQ29sb3I7XG5cbiAgICBnYy5jbGVhclJlY3QoMCwgMCwgdGhpcy5ib3VuZHMud2lkdGgsIHRoaXMuYm91bmRzLmhlaWdodCk7XG5cbiAgICBpZiAoIUMgfHwgIVIpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoZ2MuYWxwaGEoZ3JpZFByZWZpbGxDb2xvcikgPiAwKSB7XG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IGdyaWRQcmVmaWxsQ29sb3I7XG4gICAgICAgIGdjLmZpbGxSZWN0KDAsIDAsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKHBhaW50Q2VsbHNCeVJvd3MucmVzZXQpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEdyaWRSZW5kZXJlcnMoKTtcbiAgICAgICAgcGFpbnRDZWxsc0J5Um93cy5yZXNldCA9IGZhbHNlO1xuICAgICAgICBidW5kbGVSb3dzLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcm93UHJlZmlsbENvbG9ycyA9IHRoaXMucm93UHJlZmlsbENvbG9ycztcblxuICAgIGZvciAociA9IHJvd0J1bmRsZXMubGVuZ3RoOyByLS07KSB7XG4gICAgICAgIHJvd0J1bmRsZSA9IHJvd0J1bmRsZXNbcl07XG4gICAgICAgIGdjLmNsZWFyRmlsbCgwLCByb3dCdW5kbGUudG9wLCB2aWV3V2lkdGgsIHJvd0J1bmRsZS5ib3R0b20gLSByb3dCdW5kbGUudG9wLCByb3dCdW5kbGUuYmFja2dyb3VuZENvbG9yKTtcbiAgICB9XG5cbiAgICAvLyBnYy5jbGlwU2F2ZShjbGlwVG9HcmlkLCAwLCAwLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpO1xuXG4gICAgLy8gRm9yIGVhY2ggcm93IG9mIGVhY2ggc3ViZ3JpZC4uLlxuICAgIGZvciAocCA9IDAsIHIgPSAwOyByIDwgUjsgcisrKSB7XG4gICAgICAgIHByZWZpbGxDb2xvciA9IHJvd1ByZWZpbGxDb2xvcnNbcl07XG5cbiAgICAgICAgaWYgKGdyaWRQcm9wcy5ncmlkTGluZXNIKSB7XG4gICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBsaW5lQ29sb3I7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCgwLCBwb29sW3BdLnZpc2libGVSb3cuYm90dG9tLCB2aWV3V2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgZWFjaCBjb2x1bW4gKG9mIGVhY2ggcm93KS4uLlxuICAgICAgICBmb3IgKGMgPSBjMDsgYyA8IEM7IGMrKywgcCsrKSB7XG4gICAgICAgICAgICBjZWxsRXZlbnQgPSBwb29sW3BdOyAvLyBuZXh0IGNlbGwgYWNyb3NzIHRoZSByb3cgKHJlZHVuZGFudCBmb3IgZmlyc3QgY2VsbCBpbiByb3cpXG4gICAgICAgICAgICB2YyA9IGNlbGxFdmVudC52aXNpYmxlQ29sdW1uO1xuXG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IGNsaXAgdG8gdmlzaWJsZSBwb3J0aW9uIG9mIGNvbHVtbiB0byBwcmV2ZW50IHRleHQgZnJvbSBvdmVyZmxvd2luZyB0byByaWdodC5cbiAgICAgICAgICAgIGNvbHVtbkNsaXAgPSB2Yy5jb2x1bW4ucHJvcGVydGllcy5jb2x1bW5DbGlwO1xuICAgICAgICAgICAgZ2MuY2xpcFNhdmUoY29sdW1uQ2xpcCB8fCBjb2x1bW5DbGlwID09PSBudWxsICYmIGMgPT09IGNMYXN0LCAwLCAwLCB2Yy5yaWdodCwgdmlld0hlaWdodCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJlZmVycmVkV2lkdGhbY10gPSBNYXRoLm1heChwcmVmZXJyZWRXaWR0aFtjXSwgdGhpcy5fcGFpbnRDZWxsKGdjLCBjZWxsRXZlbnQsIHByZWZpbGxDb2xvcikpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRXJyb3JDZWxsKGUsIGdjLCB2YywgdnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnYy5jbGlwUmVzdG9yZShjb2x1bW5DbGlwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdjLmNsaXBSZXN0b3JlKGNsaXBUb0dyaWQpO1xuXG4gICAgdGhpcy5wYWludEdyaWRsaW5lcyhnYyk7XG5cbiAgICBmb3IgKGMgPSBjMDsgYyA8IEM7IGMrKykge1xuICAgICAgICB2aXNpYmxlQ29sdW1uc1tjXS5jb2x1bW4ucHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IE1hdGgucm91bmQocHJlZmVycmVkV2lkdGhbY10pO1xuICAgIH1cbn1cblxucGFpbnRDZWxsc0J5Um93cy5rZXkgPSAnYnktcm93cyc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFpbnRDZWxsc0J5Um93cztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vQmFzZScpO1xudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcy9pbmRleCcpO1xuXG5cbnZhciB2aXNpYmxlQ29sdW1uUHJvcGVydGllc0Rlc2NyaXB0b3IgPSB7XG4gICAgZmluZDoge1xuICAgICAgICAvLyBMaWtlIEFycmF5LnByb3RvdHlwZS5maW5kIGV4Y2VwdCBzZWFyY2hlcyBuZWdhdGl2ZSBpbmRleGVzIGFzIHdlbGwuXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IC0xOyBpIGluIHRoaXM7IC0taSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICAgICAgICAgIHdoaWxlICgrK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCB0aGlzW2ldLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbCh0aGlzLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAqIEBzZWUgW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gdmlzaWJsZUNvbHVtbkRlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCAtIEEgYmFjayByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQncyBhcnJheSBpbmRleCBpbiB7QGxpbmsgUmVuZGVyZXIjdmlzaWJsZUNvbHVtbnN9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gRGVyZWZlcmVuY2VzIHtAbGluayBCZWhhdmlvciNjb2x1bW5zfSwgdGhlIHN1YnNldCBvZiBfYWN0aXZlXyBjb2x1bW5zLCBzcGVjaWZ5aW5nIHdoaWNoIGNvbHVtbiB0byBzaG93IGluIHRoYXQgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVmdCAtIFBpeGVsIGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgZWRnZSBvZiB0aGlzIGNvbHVtbiwgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmlnaHQgLSBQaXhlbCBjb29yZGluYXRlIG9mIHRoZSByaWdodCBlZGdlIG9mIHRoaXMgY29sdW1uLCByb3VuZGVkIHRvIG5lYXJlc3QgaW50ZWdlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoaXMgY29sdW1uIGluIHBpeGVscywgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IHZpc2libGVSb3dEZXNjcmlwdG9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggLSBBIGJhY2sgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50J3MgYXJyYXkgaW5kZXggaW4ge0BsaW5rIFJlbmRlcmVyI3Zpc2libGVSb3dzfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3dJbmRleCAtIExvY2FsIHZlcnRpY2FsIHJvdyBjb29yZGluYXRlIHdpdGhpbiB0aGUgc3ViZ3JpZCB0byB3aGljaCB0aGUgcm93IGJlbG9uZ3MsIGFkanVzdGVkIGZvciBzY3JvbGxpbmcuXG4gKiBAcHJvcGVydHkge2RhdGFNb2RlbEFQSX0gc3ViZ3JpZCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBzdWJncmlkIHRvIHdoaWNoIHRoZSByb3cgYmVsb25ncy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3AgLSBQaXhlbCBjb29yZGluYXRlIG9mIHRoZSB0b3AgZWRnZSBvZiB0aGlzIHJvdywgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm90dG9tIC0gUGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhpcyByb3csIHJvdW5kZWQgdG8gbmVhcmVzdCBpbnRlZ2VyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGlzIHJvdyBpbiBwaXhlbHMsIHJvdW5kZWQgdG8gbmVhcmVzdCBpbnRlZ2VyLlxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzYyBmaW4taHlwZXJncmlkLXJlbmRlcmVyIGlzIHRoZSBjYW52YXMgZW5hYmxlZCB0b3AgbGV2ZWwgc3ViIGNvbXBvbmVudCB0aGF0IGhhbmRsZXMgdGhlIHJlbmRlcmVyaW5nIG9mIHRoZSBHcmlkLlxuICpcbiAqIEl0IHJlbGllcyBvbiB0d28gb3RoZXIgZXh0ZXJuYWwgc3VicHJvamVjdHNcbiAqXG4gKiAxLiBmaW4tY2FudmFzOiBhIHdyYXBwZXIgdG8gcHJvdmlkZSBhIHNpbXBsZXIgaW50ZXJmYWNlIHRvIHRoZSBIVE1MNSBjYW52YXMgY29tcG9uZW50XG4gKiAyLiByZWN0YW5ndWxhcjogYSBzbWFsbCBucG0gbW9kdWxlIHByb3ZpZGluZyBQb2ludCBhbmQgUmVjdGFuZ2xlIG9iamVjdHNcbiAqXG4gKiBUaGUgZmluLWh5cGVyZ3JpZC1yZW5kZXJlciBpcyBpbiBhIHVuaXF1ZSBwb3NpdGlvbiB0byBwcm92aWRlIGNyaXRpY2FsIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIGZpbi1oeXBlcmdyaWQgaW4gYSBoaWdodGx5IHBlcmZvcm1hbnQgbWFubmVyLlxuICogQmVjYXVzZSBpdCBNVVNUIGl0ZXJhdGUgb3ZlciBhbGwgdGhlIHZpc2libGUgY2VsbHMgaXQgY2FuIHN0b3JlIHZhcmlvdXMgYml0cyBvZiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBlbmNhcHN1bGF0ZWQgYXMgYSBzZXJ2aWNlIGZvciBjb25zdW1wdGlvbiBieSB0aGUgZmluLWh5cGVyZ3JpZCBjb21wb25lbnQuXG4gKlxuICogSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0IGhhdmUgYmFzaWNhbGx5IGZvdXIgbWFpbiBmdW5jdGlvbnMuXG4gKlxuICogMS4gcmVuZGVyIGZpeGVkIHJvdyBoZWFkZXJzXG4gKiAyLiByZW5kZXIgZml4ZWQgY29sIGhlYWRlcnNcbiAqIDMuIHJlbmRlciBtYWluIGRhdGEgY2VsbHNcbiAqIDQuIHJlbmRlciBncmlkIGxpbmVzXG4gKlxuICogU2FtZSBwYXJhbWV0ZXJzIGFzIHtAbGluayBSZW5kZXJlciNpbml0aWFsaXplfGluaXRpYWxpemV9LCB3aGljaCBpcyBjYWxsZWQgYnkgdGhpcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKi9cbnZhciBSZW5kZXJlciA9IEJhc2UuZXh0ZW5kKCdSZW5kZXJlcicsIHtcblxuICAgIC8vdGhlIHNoYXJlZCBzaW5nbGUgaXRlbSBcInBvb2xlZFwiIGNlbGwgb2JqZWN0IGZvciBkcmF3aW5nIGVhY2ggY2VsbFxuICAgIGNlbGw6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgIH0sXG5cbiAgICBzY3JvbGxIZWlnaHQ6IDAsXG5cbiAgICB2aWV3SGVpZ2h0OiAwLFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJvdW5kcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIG9yZGVyZWQgc2V0IG9mIHZpc2libGUgY29sdW1ucy4gQXJyYXkgc2l6ZSBpcyBhbHdheXMgdGhlIGV4YWN0IG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnMsIHRoZSBsYXN0IG9mIHdoaWNoIG1heSBvbmx5IGJlIHBhcnRpYWxseSB2aXNpYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHNlcXVlbmNlIG9mIGVsZW1lbnRzJyBgY29sdW1uSW5kZXhgIHZhbHVlcyBhc3N1bWVzIG9uZSBvZiB0aHJlZSBwYXR0ZXJucy4gV2hpY2ggcGF0dGVybiBpcyBiYXNlIG9uIHRoZSBmb2xsb3dpbmcgdHdvIHF1ZXN0aW9uczpcbiAgICAgICAgICogKiBBcmUgdGhlcmUgXCJmaXhlZFwiIGNvbHVtbnMgb24gdGhlIGxlZnQ/XG4gICAgICAgICAqICogSXMgdGhlIGdyaWQgaG9yaXpvbnRhbGx5IHNjcm9sbGVkP1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc2V0IG9mIGBjb2x1bW5JbmRleGAgdmFsdWVzIGNvbnNpc3RzIG9mOlxuICAgICAgICAgKiAxLiBUaGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIC0xIGlmIHRoZSByb3cgaGFuZGxlIGNvbHVtbiBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgICogMi4gQSB6ZXJvLWJhc2VkIGxpc3Qgb2YgY29uc2VjdXRpdmUgb2YgaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBmaXhlZCBjb2x1bW5zIChpZiBhbnkpLlxuICAgICAgICAgKiAzLiBBbiBuLWJhc2VkIGxpc3Qgb2YgY29uc2VjdXRpdmUgb2YgaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBzY3JvbGxhYmxlIGNvbHVtbnMgKHdoZXJlIG4gPSBudW1iZXIgb2YgZml4ZWQgY29sdW1ucyArIHRoZSBudW1iZXIgb2YgY29sdW1ucyBzY3JvbGxlZCBvZmYgdG8gdGhlIGxlZnQpLlxuICAgICAgICAgKiBAdHlwZSB7dmlzaWJsZUNvbHVtbkRlc2NyaXB0b3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoW10sIHZpc2libGVDb2x1bW5Qcm9wZXJ0aWVzRGVzY3JpcHRvcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIG9yZGVyZWQgc2V0IG9mIHZpc2libGUgcm93cy4gQXJyYXkgc2l6ZSBpcyBhbHdheXMgdGhlIGV4YWN0IG51bWJlciBvZiB2aXNpYmxlIHJvd3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzZXF1ZW5jZSBvZiBlbGVtZW50cycgYHJvd0luZGV4YCB2YWx1ZXMgaXMgbG9jYWwgdG8gZWFjaCBzdWJncmlkLlxuICAgICAgICAgKiAqICoqRm9yIGVhY2ggbm9uLXNjcm9sbGFibGUgc3ViZ3JpZDoqKiBUaGUgc2VxdWVuY2UgaXMgYSB6ZXJvLWJhc2VkIGxpc3Qgb2YgY29uc2VjdXRpdmUgaW50ZWdlcnMuXG4gICAgICAgICAqICogKipGb3IgdGhlIHNjcm9sbGFibGUgc3ViZ3JpZDoqKlxuICAgICAgICAgKiAgIDEuIEEgemVyby1iYXNlZCBsaXN0IG9mIGNvbnNlY3V0aXZlIG9mIGludGVnZXJzIHJlcHJlc2VudGluZyB0aGUgZml4ZWQgcm93cyAoaWYgYW55KS5cbiAgICAgICAgICogICAyLiBBbiBuLWJhc2VkIGxpc3Qgb2YgY29uc2VjdXRpdmUgb2YgaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBzY3JvbGxhYmxlIHJvd3MgKHdoZXJlIG4gPSBudW1iZXIgb2YgZml4ZWQgcm93cyArIHRoZSBudW1iZXIgb2Ygcm93cyBzY3JvbGxlZCBvZmYgdGhlIHRvcCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCBub24tc2Nyb2xsYWJsZSBzdWJncmlkcyBjYW4gY29tZSBib3RoIGJlZm9yZSBfYW5kXyBhZnRlciB0aGUgc2Nyb2xsYWJsZSBzdWJncmlkLlxuICAgICAgICAgKiBAdHlwZSB7dmlzaWJsZVJvd0Rlc2NyaXB0b3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGVSb3dzID0gW107XG5cbiAgICAgICAgdGhpcy5pbnNlcnRpb25Cb3VuZHMgPSBbXTtcblxuICAgICAgICB0aGlzLmNlbGxFdmVudFBvb2wgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29uc3RydWN0b3IgbG9naWNcbiAgICAgKiBAZGVzYyBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB1cG9uIGluc3RhbnRpYXRpb24gb2YgdGhpcyBjbGFzcyBvciBvZiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIGZyb20gdGhpcyBjbGFzcy5cbiAgICAgKiA+IEFsbCBgaW5pdGlhbGl6ZSgpYCBtZXRob2RzIGluIHRoZSBpbmhlcml0YW5jZSBjaGFpbiBhcmUgY2FsbGVkLCBpbiB0dXJuLCBlYWNoIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciwgYmVnaW5uaW5nIHdpdGggdGhhdCBvZiB0aGUgbW9zdCBcInNlbmlvclwiIGNsYXNzIHRocm91Z2ggdGhhdCBvZiB0aGUgY2xhc3Mgb2YgdGhlIG5ldyBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG4gICAgICAgIC8vIHR5cGljYWxseSBncmlkIHByb3BlcnRpZXMgd29uJ3QgZXhpc3QgeWV0XG4gICAgICAgIHRoaXMuc2V0R3JpZFJlbmRlcmVyKHRoaXMucHJvcGVydGllcy5ncmlkUmVuZGVyZXIgfHwgJ2J5LWNvbHVtbnMtYW5kLXJvd3MnKTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIGdyaWRSZW5kZXJlcnM6IHt9LFxuXG4gICAgcmVnaXN0ZXJHcmlkUmVuZGVyZXI6IGZ1bmN0aW9uKGdyaWRSZW5kZXJlciwgbmFtZSkge1xuICAgICAgICB0aGlzLmdyaWRSZW5kZXJlcnNbbmFtZSB8fCBncmlkUmVuZGVyZXIua2V5XSA9IGdyaWRSZW5kZXJlcjtcbiAgICB9LFxuXG4gICAgc2V0R3JpZFJlbmRlcmVyOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHBhaW50Q2VsbHMgPSB0aGlzLmdyaWRSZW5kZXJlcnNba2V5XTtcblxuICAgICAgICBpZiAoIXBhaW50Q2VsbHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0aGlzLkh5cGVyZ3JpZEVycm9yKCdVbnJlZ2lzdGVyZWQgZ3JpZCByZW5kZXJlciBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWludENlbGxzICE9PSB0aGlzLnBhaW50Q2VsbHMpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDZWxscyA9IHBhaW50Q2VsbHM7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q2VsbHMucmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlc2V0QWxsR3JpZFJlbmRlcmVyczogZnVuY3Rpb24oYmxhY2tMaXN0KSB7XG4gICAgICAgIC8vIE5vdGlmeSByZW5kZXJlcnMgdGhhdCBncmlkIHNoYXBlIGhhcyBjaGFuZ2VkXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZ3JpZFJlbmRlcmVycykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFJlbmRlcmVyc1trZXldLnJlc2V0ID0gIWJsYWNrTGlzdCB8fCBibGFja0xpc3QuaW5kZXhPZihrZXkpIDwgMDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlcnRhaW4gcmVuZGVyZXJzIHRoYXQgcHJlLWJ1bmRsZSBjb2x1bW4gcmVjdHMgYmFzZWQgb24gY29sdW1ucycgYmFja2dyb3VuZCBjb2xvcnMgbmVlZCB0byByZS1idW5kbGUgd2hlbiBjb2x1bW5zJyBiYWNrZ3JvdW5kIGNvbG9ycyBjaGFuZ2UuIFRoaXMgbWV0aG9kIHNldHMgdGhlIGByZWJ1bmRsZWAgcHJvcGVydHkgdG8gYHRydWVgIGZvciB0aG9zZSByZW5kZXJlcnMgdGhhdCBoYXZlIHRoYXQgcHJvcGVydHkuXG4gICAgICovXG4gICAgcmVidW5kbGVHcmlkUmVuZGVyZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ncmlkUmVuZGVyZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKCdyZWJ1bmRsZScgaW4gdGhpcy5ncmlkUmVuZGVyZXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRSZW5kZXJlcnNba2V5XS5yZWJ1bmRsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgc2V2ZXJhbCBkYXRhIHN0cnVjdHVyZXM6XG4gICAgICogKiB7QGxpbmsgUmVuZGVyZXIjdmlzaWJsZUNvbHVtbnN9XG4gICAgICogT3JpZ2luYWwgY29tbWVudDpcbiAgICAgKiBcInRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgdGhlIGdyaWQgY29vcmRpbmF0ZXMgdXNlZCBmb3IgZXh0cmVtZWx5IGZhc3QgaXRlcmF0aW9uIG92ZXJcbiAgICAgKiBwYWludGluZyB0aGUgZ3JpZCBjZWxscy4gdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IGZhc3QsIGZvciB0aG91c2FuZCByb3dzIFggMTAwIGNvbHVtbnNcbiAgICAgKiBvbiBhIG1vZGVzdCBtYWNoaW5lIHRha2luZyB1c3VhbGx5IDBtcyBhbmQgbm8gbW9yZSB0aGF0IDMgbXMuXCJcbiAgICAgKi9cbiAgICBjb21wdXRlQ2VsbHNCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCksXG5cbiAgICAgICAgICAgIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgZml4ZWRSb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCksXG5cbiAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG4gICAgICAgICAgICBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICAgICAgYmVoYXZpb3IgPSBncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgZWRpdG9yQ2VsbEV2ZW50ID0gZ3JpZC5jZWxsRWRpdG9yICYmIGdyaWQuY2VsbEVkaXRvci5ldmVudCxcblxuICAgICAgICAgICAgdmNFZCwgeEVkLFxuICAgICAgICAgICAgdnJFZCwgeUVkLFxuICAgICAgICAgICAgc2dFZCwgaXNTdWJncmlkRWQsXG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IDAsXG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gMCxcblxuICAgICAgICAgICAgbGluZVdpZHRoID0gZ3JpZC5wcm9wZXJ0aWVzLmxpbmVXaWR0aCxcblxuICAgICAgICAgICAgc3RhcnQgPSBncmlkLnByb3BlcnRpZXMuc2hvd1Jvd051bWJlcnMgPyAtMSA6IDAsXG4gICAgICAgICAgICB4LCBYLCAvLyBob3Jpem9udGFsIHBpeGVsIGxvb3AgaW5kZXggYW5kIGxpbWl0XG4gICAgICAgICAgICB5LCBZLCAvLyB2ZXJ0aWNhbCBwaXhlbCBsb29wIGluZGV4IGFuZCBsaW1pdFxuICAgICAgICAgICAgYywgQywgLy8gY29sdW1uIGxvb3AgaW5kZXggYW5kIGxpbWl0XG4gICAgICAgICAgICBnLCBHLCAvLyBzdWJncmlkIGxvb3AgaW5kZXggYW5kIGxpbWl0XG4gICAgICAgICAgICByLCBSLCAvLyByb3cgbG9vcCBpbmRleCBhbmQgbGltaXRyb3dzIGluIGN1cnJlbnQgc3ViZ3JpZFxuICAgICAgICAgICAgc3Vicm93cywgLy8gcm93cyBpbiBzdWJncmlkIGdcbiAgICAgICAgICAgIGJhc2UsIC8vIHN1bSBvZiByb3dzIGZvciBhbGwgc3ViZ3JpZHMgc28gZmFyXG4gICAgICAgICAgICBzdWJncmlkcyA9IGJlaGF2aW9yLnN1YmdyaWRzLFxuICAgICAgICAgICAgc3ViZ3JpZCxcbiAgICAgICAgICAgIHJvd0luZGV4LFxuICAgICAgICAgICAgc2Nyb2xsYWJsZVN1YmdyaWQsXG4gICAgICAgICAgICBmb290ZXJIZWlnaHQsXG4gICAgICAgICAgICB2eCwgdnksXG4gICAgICAgICAgICB2ciwgdmMsXG4gICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgICAgZmlyc3RWWCwgbGFzdFZYLFxuICAgICAgICAgICAgZmlyc3RWWSwgbGFzdFZZLFxuICAgICAgICAgICAgdG9wUixcbiAgICAgICAgICAgIHhTcGFjZWQsIHdpZHRoU3BhY2VkLCBoZWlnaHRTcGFjZWQ7IC8vIGFkanVzdGVkIGZvciBjZWxsIHNwYWNpbmdcblxuICAgICAgICBpZiAoZWRpdG9yQ2VsbEV2ZW50KSB7XG4gICAgICAgICAgICB4RWQgPSBlZGl0b3JDZWxsRXZlbnQuZ3JpZENlbGwueDtcbiAgICAgICAgICAgIHlFZCA9IGVkaXRvckNlbGxFdmVudC5kYXRhQ2VsbC55O1xuICAgICAgICAgICAgc2dFZCA9IGVkaXRvckNlbGxFdmVudC5zdWJncmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSAwO1xuXG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy52aXNpYmxlUm93cy5sZW5ndGggPSAwO1xuXG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnNCeUluZGV4ID0gW107IC8vIGFycmF5IGJlY2F1c2UgbnVtYmVyIG9mIGNvbHVtbnMgd2lsbCBhbHdheXMgYmUgcmVhc29uYWJsZVxuICAgICAgICB0aGlzLnZpc2libGVSb3dzQnlEYXRhUm93SW5kZXggPSB7fTsgLy8gaGFzaCBiZWNhdXNlIGtleWVkIGJ5IChmaXhlZCBhbmQpIHNjcm9sbGVkIHJvdyBpbmRleGVzXG5cbiAgICAgICAgdGhpcy5pbnNlcnRpb25Cb3VuZHMgPSBbXTtcblxuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgeCA9IDAsIGMgPSBzdGFydCwgQyA9IHRoaXMuZ3JpZC5nZXRDb2x1bW5Db3VudCgpLCBYID0gYm91bmRzLndpZHRoIHx8IGdyaWQuY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgYyA8IEMgJiYgeCA8PSBYO1xuICAgICAgICAgICAgYysrXG4gICAgICAgICkge1xuICAgICAgICAgICAgdnggPSBjO1xuICAgICAgICAgICAgaWYgKGMgPj0gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgICAgIGxhc3RWWCA9IHZ4ICs9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0VlggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFZYID0gbGFzdFZYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2eCA+PSBDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIHNjcm9sbGVkIGJleW9uZCBsYXN0IGNvbHVtblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGguY2VpbChiZWhhdmlvci5nZXRDb2x1bW5XaWR0aCh2eCkpO1xuXG4gICAgICAgICAgICB4U3BhY2VkID0geCA/IHggKyBsaW5lV2lkdGggOiB4O1xuICAgICAgICAgICAgd2lkdGhTcGFjZWQgPSB4ID8gd2lkdGggLSBsaW5lV2lkdGggOiB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnNbY10gPSB0aGlzLnZpc2libGVDb2x1bW5zQnlJbmRleFt2eF0gPSB2YyA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogYyxcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogdngsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4odngpLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHhTcGFjZWQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoU3BhY2VkLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB4U3BhY2VkICsgd2lkdGhTcGFjZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoeEVkID09PSB2eCkge1xuICAgICAgICAgICAgICAgIHZjRWQgPSB2YztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeCArPSB3aWR0aDtcblxuICAgICAgICAgICAgaW5zZXJ0aW9uQm91bmRzQ3Vyc29yICs9IE1hdGgucm91bmQod2lkdGggLyAyKSArIHByZXZpb3VzSW5zZXJ0aW9uQm91bmRzQ3Vyc29yVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcy5wdXNoKGluc2VydGlvbkJvdW5kc0N1cnNvcik7XG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gTWF0aC5yb3VuZCh3aWR0aCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGhlaWdodCBvZiB0b3RhbCBudW1iZXIgb2Ygcm93cyBpbiBhbGwgc3ViZ3JpZHMgZm9sbG93aW5nIHRoZSBkYXRhIHN1YmdyaWRcbiAgICAgICAgZm9vdGVySGVpZ2h0ID0gZ3JpZC5wcm9wZXJ0aWVzLmRlZmF1bHRSb3dIZWlnaHQgKlxuICAgICAgICAgICAgc3ViZ3JpZHMucmVkdWNlKGZ1bmN0aW9uKHJvd3MsIHN1YmdyaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYWJsZVN1YmdyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93cyArPSBzdWJncmlkLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYWJsZVN1YmdyaWQgPSBzdWJncmlkLmlzRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgYmFzZSA9IHIgPSBnID0geSA9IDAsIEcgPSBzdWJncmlkcy5sZW5ndGgsIFkgPSBib3VuZHMuaGVpZ2h0IC0gZm9vdGVySGVpZ2h0O1xuICAgICAgICAgICAgZyA8IEc7XG4gICAgICAgICAgICBnKyssIGJhc2UgKz0gc3Vicm93c1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHN1YmdyaWQgPSBzdWJncmlkc1tnXTtcbiAgICAgICAgICAgIHN1YnJvd3MgPSBzdWJncmlkLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICBzY3JvbGxhYmxlU3ViZ3JpZCA9IHN1YmdyaWQuaXNEYXRhO1xuICAgICAgICAgICAgaXNTdWJncmlkRWQgPSAoc2dFZCA9PT0gc3ViZ3JpZCk7XG4gICAgICAgICAgICB0b3BSID0gcjtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggcm93IG9mIGVhY2ggc3ViZ3JpZC4uLlxuICAgICAgICAgICAgZm9yIChSID0gciArIHN1YnJvd3M7IHIgPCBSICYmIHkgPCBZOyByKyspIHtcbiAgICAgICAgICAgICAgICB2eSA9IHI7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGFibGVTdWJncmlkICYmIHIgPj0gZml4ZWRSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICB2eSArPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RWWSA9IHZ5IC0gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VlkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RWWSA9IGxhc3RWWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodnkgPj0gUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHNjcm9sbGVkIGJleW9uZCBsYXN0IHJvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93SW5kZXggPSB2eSAtIGJhc2U7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gYmVoYXZpb3IuZ2V0Um93SGVpZ2h0KHJvd0luZGV4LCBzdWJncmlkKTtcblxuICAgICAgICAgICAgICAgIGhlaWdodFNwYWNlZCA9IGhlaWdodCAtIGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVSb3dzW3JdID0gdnIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiByLFxuICAgICAgICAgICAgICAgICAgICBzdWJncmlkOiBzdWJncmlkLFxuICAgICAgICAgICAgICAgICAgICByb3dJbmRleDogcm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogeSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRTcGFjZWQsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogeSArIGhlaWdodFNwYWNlZFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYWJsZVN1YmdyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlUm93c0J5RGF0YVJvd0luZGV4W3Z5IC0gYmFzZV0gPSB2cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNTdWJncmlkRWQgJiYgeUVkID09PSByb3dJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2ckVkID0gdnI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxhYmxlU3ViZ3JpZCkge1xuICAgICAgICAgICAgICAgIHN1YnJvd3MgPSByIC0gdG9wUjtcbiAgICAgICAgICAgICAgICBZICs9IGZvb3RlckhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGl0b3JDZWxsRXZlbnQpIHtcbiAgICAgICAgICAgIGVkaXRvckNlbGxFdmVudC52aXNpYmxlQ29sdW1uID0gdmNFZDtcbiAgICAgICAgICAgIGVkaXRvckNlbGxFdmVudC52aXNpYmxlUm93ID0gdnJFZDtcbiAgICAgICAgICAgIGVkaXRvckNlbGxFdmVudC5ncmlkQ2VsbC55ID0gdnJFZCAmJiB2ckVkLmluZGV4O1xuICAgICAgICAgICAgZWRpdG9yQ2VsbEV2ZW50Ll9ib3VuZHMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gWTtcblxuICAgICAgICB0aGlzLmRhdGFXaW5kb3cgPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKGZpcnN0VlgsIGZpcnN0VlksIGxhc3RWWCAtIGZpcnN0VlgsIGxhc3RWWSAtIGZpcnN0VlkpO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBDZWxsRXZlbnQgcG9vbFxuICAgICAgICB2YXIgcG9vbCA9IHRoaXMuY2VsbEV2ZW50UG9vbCxcbiAgICAgICAgICAgIHByZXZpb3VzTGVuZ3RoID0gcG9vbC5sZW5ndGgsXG4gICAgICAgICAgICBQID0gKHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gc3RhcnQpICogdGhpcy52aXNpYmxlUm93cy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKFAgPiBwcmV2aW91c0xlbmd0aCkge1xuICAgICAgICAgICAgcG9vbC5sZW5ndGggPSBQOyAvLyBncm93IHBvb2wgdG8gYWNjb21tb2RhdGUgbW9yZSBjZWxsc1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHAgPSBwcmV2aW91c0xlbmd0aDsgcCA8IFA7IHArKykge1xuICAgICAgICAgICAgcG9vbFtwXSA9IG5ldyBiZWhhdmlvci5DZWxsRXZlbnQ7IC8vIGluc3RhbnRpYXRlIG5ldyBtZW1iZXJzXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2V0QWxsR3JpZFJlbmRlcmVycygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDQVVUSU9OOiBLZWVwIGluIHBsYWNlISBVc2VkIGJ5IHtAbGluayBDYW52YXN9LlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCBncmlkIHByb3BlcnRpZXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXZpb3VzbHkgdXNlZCBieSBmaW4tY2FudmFzLlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhIHByb3BlcnR5IHZhbHVlIGF0IGEga2V5LCBkZWxlZ2F0ZXMgdG8gdGhlIGdyaWRcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHJlc29sdmVQcm9wZXJ0eTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgncmVzb2x2ZVByb3BlcnR5JywgJ1RoZSAucmVzb2x2ZVByb3BlcnR5KGtleSkgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMi4xMCBpbiBmYXZvciBvZiB0aGUgLmdyaWQucHJvcGVydGllcyBvYmplY3QgZGVyZWZlcmVuY2VkIHdpdGggW2tleV0uIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4pJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNba2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IE5vdGlmeSB0aGUgZmluLWh5cGVyZ3JpZCBldmVyeSB0aW1lIHdlJ3ZlIHJlcGFpbnRlZC5cbiAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyaWQoZ2MpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmdyaWRSZW5kZXJlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRpY2tOb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyaWQudGlja05vdGlmaWNhdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQW5zd2VyIGhvdyBtYW55IHJvd3Mgd2UgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93c0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZVNjcm9sbEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdIZWlnaHQgLSB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFJvd3Mgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGVwcmVjYXRlZCgnZ2V0VmlzaWJsZVJvd3MnLCAnVGhlIGdldFZpc2libGVSb3dzKCkgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMi4wLiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uKSBQcmV2aW91c2x5IHJldHVybmVkIHRoZSB0aGlzLnZpc2libGVSb3dzIGFycmF5IGJ1dCBiZWNhdXNlIHRoaXMudmlzaWJsZVJvd3MgaXMgbm8gbG9uZ2VyIGEgc2ltcGxlIGFycmF5IG9mIGludGVnZXJzIGJ1dCBpcyBub3cgYW4gYXJyYXkgb2Ygb2JqZWN0cywgaXQgbm93IHJldHVybnMgYW4gYXJyYXkgbWFwcGVkIHRvIHRoaXMudmlzaWJsZVJvd3NbKl0ucm93SW5kZXguIE5vdGUgaG93ZXZlciB0aGF0IHRoaXMgbWFwcGluZyBpcyBub3QgZXF1aXZhbGVudCB0byB3aGF0IHRoaXMgbWV0aG9kIHByZXZpb3VzbHkgcmV0dXJuZWQgYmVjYXVzZSB3aGlsZSBlYWNoIG9iamVjdFxcJ3MgLnJvd0luZGV4IHByb3BlcnR5IGlzIHN0aWxsIGFkanVzdGVkIGZvciBzY3JvbGxpbmcgd2l0aGluIHRoZSBkYXRhIHN1YmdyaWQsIHRoZSBpbmRleCBpcyBub3cgbG9jYWwgdG8gKHplcm8tYmFzZWQgd2l0aGluKSBlYWNoIHN1YmdyaWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3MubWFwKGZ1bmN0aW9uKHZyKSB7IHJldHVybiB2ci5yb3dJbmRleDsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgY29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCd2aXNpYmxlQ29sdW1ucycsICdUaGUgZ2V0VmlzaWJsZUNvbHVtbnMoKSBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAuIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4pIFByZXZpb3VzbHkgcmV0dXJuZWQgdGhlIHRoaXMudmlzaWJsZUNvbHVtbnMgYnV0IGJlY2F1c2UgdGhpcy52aXNpYmxlQ29sdW1ucyBpcyBubyBsb25nZXIgYSBzaW1wbGUgYXJyYXkgb2YgaW50ZWdlcnMgYnV0IGlzIG5vdyBhbiBhcnJheSBvZiBvYmplY3RzLCBpdCBub3cgcmV0dXJucyBhbiBhcnJheSBtYXBwZWQgdG8gdGhlIGVxdWl2YWxlbnQgdmlzaWJsZUNvbHVtbnNbKl0uY29sdW1uSW5kZXguJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLm1hcChmdW5jdGlvbih2YykgeyByZXR1cm4gdmMuY29sdW1uSW5kZXg7IH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4IC0gQ2VsbEV2ZW50IG9iamVjdCBvciBncmlkIGNvbHVtbiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLiBPbWl0IGlmIGB4T3JDZWxsRXZlbnRgIGlzIGEgQ2VsbEV2ZW50LlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEJvdW5kaW5nIHJlY3Qgb2YgY2VsbCB3aXRoIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHZjID0gdGhpcy52aXNpYmxlQ29sdW1uc1t4XSxcbiAgICAgICAgICAgIHZyID0gdGhpcy52aXNpYmxlUm93c1t5XTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdmMubGVmdCxcbiAgICAgICAgICAgIHk6IHZyLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiB2Yy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdnIuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgdGhlIGNvbHVtbiBpbmRleCB1bmRlciB0aGUgY29vcmRpbmF0ZSBhdCBwaXhlbFhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxYIC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29sdW1uIGluZGV4IHVuZGVyIHRoZSBjb29yZGluYXRlIGF0IHBpeGVsWC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Gcm9tUGl4ZWxYOiBmdW5jdGlvbihwaXhlbFgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMCxcbiAgICAgICAgICAgIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHRoaXMuZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKSxcbiAgICAgICAgICAgIHZpc2libGVDb2x1bW5zID0gdGhpcy52aXNpYmxlQ29sdW1ucztcblxuICAgICAgICBmb3IgKHZhciBjID0gMTsgYyA8IHZpc2libGVDb2x1bW5zLmxlbmd0aCAtIDE7IGMrKykge1xuICAgICAgICAgICAgd2lkdGggPSB2aXNpYmxlQ29sdW1uc1tjXS5sZWZ0IC0gKHZpc2libGVDb2x1bW5zW2NdLmxlZnQgLSB2aXNpYmxlQ29sdW1uc1tjIC0gMV0ubGVmdCkgLyAyO1xuICAgICAgICAgICAgaWYgKHBpeGVsWCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPiBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGMgKz0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjID4gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgYyArPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjIC0gMTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgQW5zd2VyIHNwZWNpZmljIGRhdGEgY2VsbCBjb29yZGluYXRlcyBnaXZlbiBtb3VzZSBjb29yZGluYXRlcyBpbiBwaXhlbHMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IENlbGwgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICAgIHZycyA9IHRoaXMudmlzaWJsZVJvd3MsXG4gICAgICAgICAgICB2Y3MgPSB0aGlzLnZpc2libGVDb2x1bW5zLFxuICAgICAgICAgICAgZmlyc3RDb2x1bW4gPSB2Y3NbdGhpcy5wcm9wZXJ0aWVzLnNob3dSb3dOdW1iZXJzID8gLTEgOiAwXSxcbiAgICAgICAgICAgIGluRmlyc3RDb2x1bW4gPSB4IDwgZmlyc3RDb2x1bW4ucmlnaHQsXG4gICAgICAgICAgICB2YyA9IGluRmlyc3RDb2x1bW4gPyBmaXJzdENvbHVtbiA6IHZjcy5maW5kKGZ1bmN0aW9uKHZjKSB7IHJldHVybiB4IDwgdmMucmlnaHQ7IH0pLFxuICAgICAgICAgICAgdnIgPSB2cnMuZmluZChmdW5jdGlvbih2cikgeyByZXR1cm4geSA8IHZyLmJvdHRvbTsgfSksXG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgIGlmICh2ciAmJiB2Yykge1xuICAgICAgICAgICAgdmFyIG1vdXNlUG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQoeCAtIHZjLmxlZnQsIHkgLSB2ci50b3ApLFxuICAgICAgICAgICAgICAgIGNlbGxFdmVudCA9IG5ldyB0aGlzLmdyaWQuYmVoYXZpb3IuQ2VsbEV2ZW50KHZjLmNvbHVtbkluZGV4LCB2ci5pbmRleCk7XG5cbiAgICAgICAgICAgIC8vIGNlbGxFdmVudC52aXNpYmxlQ29sdW1uID0gdmM7XG4gICAgICAgICAgICAvLyBjZWxsRXZlbnQudmlzaWJsZVJvdyA9IHZyO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2VsbEV2ZW50LCAnbW91c2VQb2ludCcsIHt2YWx1ZTogbW91c2VQb2ludH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgY29sdW1uIG1hdGNoaW5nIHRoZSBwcm92aWRlZCBncmlkIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAZGVzYyBSZXF1ZXN0ZWQgY29sdW1uIG1heSBub3QgYmUgdmlzaWJsZSBkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IERldGVybWluZXMgaWYgYSBjb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSB0aGUgY29sdW1uIGluZGV4XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0NvbHVtblZpc2libGU6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0VmlzaWJsZUNvbHVtbihjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgXCJ2aXNpYmxlIGNvbHVtblwiIG9iamVjdCBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZ3JpZCBjb2x1bW4gaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIGNvbHVtbiBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3LlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBGaW5kIGEgdmlzaWJsZSBjb2x1bW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSBncmlkIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fHVuZGVmaW5lZH0gVGhlIGdpdmVuIGNvbHVtbiBpZiB2aXNpYmxlIG9yIGB1bmRlZmluZWRgIGlmIG5vdC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5maW5kKGZ1bmN0aW9uKHZjKSB7XG4gICAgICAgICAgICByZXR1cm4gdmMuY29sdW1uSW5kZXggPT09IGNvbHVtbkluZGV4O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBjb2x1bW4gbWF0Y2hpbmcgdGhlIHByb3ZpZGVkIGRhdGEgY29sdW1uIGluZGV4LlxuICAgICAqIEBkZXNjIFJlcXVlc3RlZCBjb2x1bW4gbWF5IG5vdCBiZSB2aXNpYmxlIGR1ZSB0byBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldyBvciBpZiB0aGUgY29sdW1uIGlzIGluYWN0aXZlLlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY29sdW1uIGlzIHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gdGhlIGNvbHVtbiBpbmRleFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIHZpc2libGUuXG4gICAgICovXG4gICAgaXNEYXRhQ29sdW1uVmlzaWJsZTogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRWaXNpYmxlRGF0YUNvbHVtbihjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgXCJ2aXNpYmxlIGNvbHVtblwiIG9iamVjdCBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZGF0YSBjb2x1bW4gaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIGNvbHVtbiBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3IG9yIGlmIHRoZSBjb2x1bW4gaXMgaW5hY3RpdmUuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEZpbmQgYSB2aXNpYmxlIGNvbHVtbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGdyaWQgY29sdW1uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8dW5kZWZpbmVkfSBUaGUgZ2l2ZW4gY29sdW1uIGlmIHZpc2libGUgb3IgYHVuZGVmaW5lZGAgaWYgbm90LlxuICAgICAqL1xuICAgIGdldFZpc2libGVEYXRhQ29sdW1uOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5maW5kKGZ1bmN0aW9uKHZjKSB7XG4gICAgICAgICAgICByZXR1cm4gdmMuY29sdW1uLmluZGV4ID09PSBjb2x1bW5JbmRleDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggeCBjb29yZGluYXRlIG9mIHRoZSBsYXN0IHJlbmRlcmVkIGNvbHVtblxuICAgICAqL1xuICAgIGdldEZpbmFsVmlzaWJsZUNvbHVtbkJvdW5kYXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNob3AgPSB0aGlzLmlzTGFzdENvbHVtblZpc2libGUoKSA/IDIgOiAxO1xuICAgICAgICB2YXIgY29sV2FsbCA9IHRoaXMudmlzaWJsZUNvbHVtbnNbdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSBjaG9wXS5yaWdodDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGNvbFdhbGwsIHRoaXMuZ2V0Qm91bmRzKCkud2lkdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHJvdyBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZ3JpZCByb3cgaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIHJvdyBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgcmVuZGVyZWQgZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyB2aXNpYmlsaXR5IG9mIGEgcm93LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSBncmlkIHJvdyBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIHJvdyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzUm93VmlzaWJsZTogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy52aXNpYmxlUm93c1tyb3dJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgXCJ2aXNpYmxlIHJvd1wiIG9iamVjdCBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZ3JpZCByb3cgaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIHJvdyBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgcmVuZGVyZWQgZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRmluZCBhIHZpc2libGUgcm93IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgZ3JpZCByb3cgaW5kZXguXG4gICAgICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9IFRoZSBnaXZlbiByb3cgaWYgdmlzaWJsZSBvciBgdW5kZWZpbmVkYCBpZiBub3QuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvdzogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3Nbcm93SW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHJvdyBtYXRjaGluZyB0aGUgcHJvdmlkZWQgZGF0YSByb3cgaW5kZXguXG4gICAgICogQGRlc2MgUmVxdWVzdGVkIHJvdyBtYXkgbm90IGJlIHZpc2libGUgZHVlIHRvIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3LlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIHZpc2liaWxpdHkgb2YgYSByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGRhdGEgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7ZGF0YU1vZGVsQVBJfSBbc3ViZ3JpZD10aGlzLmJlaGF2aW9yLnN1YmdyaWRzLmRhdGFdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFSb3dWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCwgc3ViZ3JpZCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldFZpc2libGVEYXRhUm93KHJvd0luZGV4LCBzdWJncmlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBcInZpc2libGUgcm93XCIgb2JqZWN0IG1hdGNoaW5nIHRoZSBwcm92aWRlZCBkYXRhIHJvdyBpbmRleC5cbiAgICAgKiBAZGVzYyBSZXF1ZXN0ZWQgcm93IG1heSBub3QgYmUgdmlzaWJsZSBkdWUgdG8gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEZpbmQgYSB2aXNpYmxlIHJvdyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGRhdGEgcm93IGluZGV4IHdpdGhpbiB0aGUgZ2l2ZW4gc3ViZ3JpZC5cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW3N1YmdyaWQ9dGhpcy5iZWhhdmlvci5zdWJncmlkcy5kYXRhXVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8dW5kZWZpbmVkfSBUaGUgZ2l2ZW4gcm93IGlmIHZpc2libGUgb3IgYHVuZGVmaW5lZGAgaWYgbm90LlxuICAgICAqL1xuICAgIGdldFZpc2libGVEYXRhUm93OiBmdW5jdGlvbihyb3dJbmRleCwgc3ViZ3JpZCkge1xuICAgICAgICBzdWJncmlkID0gc3ViZ3JpZCB8fCB0aGlzLmdyaWQuYmVoYXZpb3Iuc3ViZ3JpZHMubG9va3VwLmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVSb3dzLmZpbmQoZnVuY3Rpb24odnIpIHtcbiAgICAgICAgICAgIHJldHVybiB2ci5zdWJncmlkID09PSBzdWJncmlkICYmIHZyLnJvd0luZGV4ID09PSByb3dJbmRleDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY2VsbCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGNlbGwgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY2VsbCBjb29yZGluYXRlKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgbWFpbiBmb3JraW5nIG9mIHRoZSByZW5kZXJlcmluZyB0YXNrLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHJlbmRlckdyaWQ6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHRoaXMuYnV0dG9uQ2VsbHMgPSB7fTtcbiAgICAgICAgdGhpcy5wYWludENlbGxzKGdjKTtcbiAgICAgICAgcmVzZXROdW1iZXJDb2x1bW5XaWR0aChnYywgdGhpcy5ncmlkLmJlaGF2aW9yKTtcblxuICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlcyhnYyk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJMYXN0U2VsZWN0aW9uKGdjKTtcblxuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyTGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbnMgfHwgc2VsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLm9yaWdpbi54ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gbm8gc2VsZWN0ZWQgYXJlYSwgbGV0cyBleGl0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmNpID0gdGhpcy52aXNpYmxlQ29sdW1uc0J5SW5kZXgsXG4gICAgICAgICAgICB2cmkgPSB0aGlzLnZpc2libGVSb3dzQnlEYXRhUm93SW5kZXgsXG4gICAgICAgICAgICBsYXN0Q29sdW1uID0gdGhpcy52aXNpYmxlQ29sdW1uc1t0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCAtIDFdLCAvLyBsYXN0IGNvbHVtbiBpbiBzY3JvbGxhYmxlIHNlY3Rpb25cbiAgICAgICAgICAgIGxhc3RSb3cgPSB2cmlbdGhpcy5kYXRhV2luZG93LmNvcm5lci55XTsgLy8gbGFzdCByb3cgaW4gc2Nyb2xsYWJsZSBkYXRhIHNlY3Rpb25cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWxhc3RDb2x1bW4gfHwgIWxhc3RSb3cgfHxcbiAgICAgICAgICAgIHNlbGVjdGlvbi5vcmlnaW4ueCA+IGxhc3RDb2x1bW4uY29sdW1uSW5kZXggfHxcbiAgICAgICAgICAgIHNlbGVjdGlvbi5vcmlnaW4ueSA+IGxhc3RSb3cucm93SW5kZXhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gYXJlYSBiZWdpbnMgdG8gcmlnaHQgb3IgYmVsb3cgZ3JpZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZjT3JpZ2luID0gdmNpW3NlbGVjdGlvbi5vcmlnaW4ueF0sXG4gICAgICAgICAgICB2Y0Nvcm5lciA9IHZjaVtzZWxlY3Rpb24uY29ybmVyLnhdLFxuICAgICAgICAgICAgdnJPcmlnaW4gPSB2cmlbc2VsZWN0aW9uLm9yaWdpbi55XSxcbiAgICAgICAgICAgIHZyQ29ybmVyID0gdnJpW3NlbGVjdGlvbi5jb3JuZXIueV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEodmNPcmlnaW4gfHwgdmNDb3JuZXIpIHx8IC8vIGVudGlyZSBzZWxlY3Rpb24gc2Nyb2xsZWQgb3V0IG9mIHZpZXcgdG8gbGVmdCBvZiBzY3JvbGxhYmxlIHJlZ2lvblxuICAgICAgICAgICAgISh2ck9yaWdpbiB8fCB2ckNvcm5lcikgICAgLy8gZW50aXJlIHNlbGVjdGlvbiBzY3JvbGxlZCBvdXQgb2YgdmlldyBhYm92ZSBzY3JvbGxhYmxlIHJlZ2lvblxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncmlkUHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgIHZjT3JpZ2luID0gdmNPcmlnaW4gfHwgdGhpcy52aXNpYmxlQ29sdW1uc1tncmlkUHJvcHMuZml4ZWRDb2x1bW5Db3VudF07XG4gICAgICAgIHZyT3JpZ2luID0gdnJPcmlnaW4gfHwgdGhpcy52aXNpYmxlUm93c1tncmlkUHJvcHMuZml4ZWRSb3dDb3VudF07XG4gICAgICAgIHZjQ29ybmVyID0gdmNDb3JuZXIgfHwgKHNlbGVjdGlvbi5jb3JuZXIueCA+IGxhc3RDb2x1bW4uY29sdW1uSW5kZXggPyBsYXN0Q29sdW1uIDogdmNpW2dyaWRQcm9wcy5maXhlZENvbHVtbkNvdW50IC0gMV0pO1xuICAgICAgICB2ckNvcm5lciA9IHZyQ29ybmVyIHx8IChzZWxlY3Rpb24uY29ybmVyLnkgPiBsYXN0Um93LnJvd0luZGV4ID8gbGFzdFJvdyA6IHZyaVtncmlkUHJvcHMuZml4ZWRSb3dDb3VudCAtIDFdKTtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIHNlbGVjdGlvbiBtb2RlbCBhcm91bmQgdGhlIGJvdW5kc1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICAgICAgeDogdmNPcmlnaW4ubGVmdCxcbiAgICAgICAgICAgICAgICB5OiB2ck9yaWdpbi50b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHZjQ29ybmVyLnJpZ2h0IC0gdmNPcmlnaW4ubGVmdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHZyQ29ybmVyLmJvdHRvbSAtIHZyT3JpZ2luLnRvcFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcjogdGhpcy5wYWludENlbGxzLnBhcnRpYWwgPyAndHJhbnNwYXJlbnQnIDogZ3JpZFByb3BzLnNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcixcbiAgICAgICAgICAgIHNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvcjogZ3JpZFByb3BzLnNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyaWQuY2VsbFJlbmRlcmVycy5nZXQoJ2xhc3RzZWxlY3Rpb24nKS5wYWludChnYywgY29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGl0ZXJhdGUgdGhlIHJlbmRlcmVyaW5nIG92ZXJyaWRlcyBhbmQgbWFuaWZlc3QgZWFjaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHJlbmRlck92ZXJyaWRlczogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5ncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJyaWRlID0gY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZShnYywgb3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgY29weSBlYWNoIG92ZXJyaWRlcyBzcGVjaWZpZWQgYXJlYSB0byBpdCdzIHRhcmdldCBhbmQgYmxhbmsgb3V0IHRoZSBzb3VyY2UgYXJlYVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB7T3ZlcnJpZGVPYmplY3R9IG92ZXJyaWRlIC0gYW4gb2JqZWN0IHdpdGggZGV0YWlscyBjb250YWluIGFuIGFyZWEgYW5kIGEgdGFyZ2V0IGNvbnRleHRcbiAgICAgKi9cbiAgICByZW5kZXJPdmVycmlkZTogZnVuY3Rpb24oZ2MsIG92ZXJyaWRlKSB7XG4gICAgICAgIC8vbGV0cyBibGFuayBvdXQgdGhlIGRyYWcgcm93XG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBvdmVycmlkZS5oZHBpcmF0aW87XG4gICAgICAgIHZhciBzdGFydFggPSBvdmVycmlkZS5zdGFydFg7IC8vaGRwaVJhdGlvICogZWRnZXNbb3ZlcnJpZGUuY29sdW1uSW5kZXhdO1xuICAgICAgICB2YXIgd2lkdGggPSBvdmVycmlkZS53aWR0aCArIDE7XG4gICAgICAgIHZhciBoZWlnaHQgPSBvdmVycmlkZS5oZWlnaHQ7XG4gICAgICAgIHZhciB0YXJnZXRDVFggPSBvdmVycmlkZS5jdHg7XG4gICAgICAgIHZhciBpbWdEYXRhID0gZ2MuZ2V0SW1hZ2VEYXRhKHN0YXJ0WCwgMCwgTWF0aC5yb3VuZCh3aWR0aCAqIGhkcGlSYXRpbyksIE1hdGgucm91bmQoaGVpZ2h0ICogaGRwaVJhdGlvKSk7XG4gICAgICAgIHRhcmdldENUWC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgICAgIGdjLmNhY2hlLmZpbGxTdHlsZSA9IHRoaXMucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3IyO1xuICAgICAgICBnYy5maWxsUmVjdChNYXRoLnJvdW5kKHN0YXJ0WCAvIGhkcGlSYXRpbyksIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgaG9yaXpvbnRhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdjb2x1bW5FZGdlcycsICdUaGUgZ2V0Q29sdW1uRWRnZXMoKSBtZWh0b2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2ZXJzaW9uIDEuMi4wIGluIGZhdm9yIG9mIHZpc2libGVDb2x1bW5zWypdLnRvcC4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLikgTm90ZSBob3dldmVyIHRoYXQgY29sdW1uRWRnZXMgaGFkIG9uZSBhZGRpdGlvbmFsIGVsZW1lbnQgKHJlcHJlc2VudGluZyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgbGFzdCB2aXNpYmxlIGNvbHVtbikgd2hpY2ggdmlzaWJsZUNvbHVtbnMgbGFja3MuIEluc3RlYWQgeW91IGNhbiByZWZlcmVuY2UgdmlzaWJsZUNvbHVtbnNbKl0uYm90dG9tLicpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5tYXAoZnVuY3Rpb24odmMpIHsgcmV0dXJuIHZjLmxlZnQ7IH0pLmNvbmNhdChbdGhpcy52aXNpYmxlQ29sdW1uc1t0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCAtIDFdLnJpZ2h0XSk7XG4gICAgfSxcblxuICAgIGdldFJvd0VkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdyb3dFZGdlcycsICdUaGUgZ2V0Um93RWRnZXMoKSBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2ZXJzaW9uIDEuMi4wIGluIGZhdm9yIG9mIHZpc2libGVSb3dzWypdLnRvcC4gKFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLikgTm90ZSBob3dldmVyIHRoYXQgcm93RWRnZXMgaGFkIG9uZSBhZGRpdGlvbmFsIGVsZW1lbnQgKHJlcHJlc2VudGluZyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGxhc3QgdmlzaWJsZSByb3cpIHdoaWNoIHZpc2libGVSb3dzIGxhY2tzLiBJbnN0ZWFkIHlvdSBjYW4gcmVmZXJlbmNlIHZpc2libGVSb3dzWypdLmJvdHRvbS4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3MubWFwKGZ1bmN0aW9uKHZyKSB7IHJldHVybiB2ci50b3A7IH0pLmNvbmNhdChbdGhpcy52aXNpYmxlUm93c1t0aGlzLnZpc2libGVSb3dzLmxlbmd0aCAtIDFdLmJvdHRvbV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBsYXN0IGNvbCB3YXMgcmVuZGVyZWQgKGlzIHZpc2libGUpXG4gICAgICovXG4gICAgaXNMYXN0Q29sdW1uVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXN0Q29sdW1uSW5kZXggPSB0aGlzLmdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHJldHVybiAhIXRoaXMudmlzaWJsZUNvbHVtbnMuZmluZChmdW5jdGlvbih2YykgeyByZXR1cm4gdmMuY29sdW1uSW5kZXggPT09IGxhc3RDb2x1bW5JbmRleDsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgY29sdW1uIHdpZHRoIGF0IGluZGV4XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGNvbHVtbnMgPSB0aGlzLnZpc2libGVDb2x1bW5zO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSBjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdLnJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sdW1uc1tpbmRleF0ubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgcm93IGhlaWdodCBhdCBpbmRleFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgcm93cyA9IHRoaXMudmlzaWJsZVJvd3M7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IHJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHJvd3Nbcm93cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxhc3QuYm90dG9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcm93c1tpbmRleF0udG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtmaW4tY2FudmFzfSBteSBbZmluLWNhbnZhc10oaHR0cHM6Ly9naXRodWIuY29tL3N0ZXZld2lydHMvZmluLWNhbnZhcylcbiAgICAgKi9cbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRDYW52YXMoKScsICdncmlkLmNhbnZhcycsICcxLjIuMicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFVzZXIgaXMgY3VycmVudGx5IGRyYWdnaW5nIGEgY29sdW1uIGZvciByZW9yZGVyaW5nLlxuICAgICAqL1xuICAgIGlzRHJhZ2dpbmdDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmlzRHJhZ2dpbmdDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgdG8gZ28gdG8gZm9yIGEgcGFnZSB1cC5cbiAgICAgKi9cbiAgICBnZXRQYWdlVXBSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0VmlzaWJsZVNjcm9sbEhlaWdodCgpLFxuICAgICAgICAgICAgdG9wID0gdGhpcy5kYXRhV2luZG93Lm9yaWdpbi55IC0gdGhpcy5wcm9wZXJ0aWVzLmZpeGVkUm93Q291bnQgLSAxLFxuICAgICAgICAgICAgc2NhbkhlaWdodCA9IDA7XG4gICAgICAgIHdoaWxlIChzY2FuSGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIHRvcCA+PSAwKSB7XG4gICAgICAgICAgICBzY2FuSGVpZ2h0ICs9IGdyaWQuZ2V0Um93SGVpZ2h0KHRvcCk7XG4gICAgICAgICAgICB0b3AtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wICsgMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgdG8gZ290byBmb3IgYSBwYWdlIGRvd24uXG4gICAgICovXG4gICAgZ2V0UGFnZURvd25Sb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhV2luZG93LmNvcm5lci55IC0gdGhpcy5wcm9wZXJ0aWVzLmZpeGVkUm93Q291bnQgKyAxO1xuICAgIH0sXG5cbiAgICByZW5kZXJFcnJvckNlbGw6IGZ1bmN0aW9uKGVyciwgZ2MsIHZjLCB2cikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGVyciAmJiAoZXJyLm1lc3NhZ2UgfHwgZXJyKSB8fCAnVW5rbm93biBlcnJvci4nLFxuICAgICAgICAgICAgYm91bmRzID0geyB4OiB2Yy5sZWZ0LCB5OiB2ci50b3AsIHdpZHRoOiB2Yy53aWR0aCwgaGVpZ2h0OiB2ci5oZWlnaHQgfSxcbiAgICAgICAgICAgIGNvbmZpZyA9IHsgYm91bmRzOiBib3VuZHMgfTtcblxuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuXG4gICAgICAgIGdjLmNhY2hlLnNhdmUoKTsgLy8gZGVmaW5lIGNsaXBwaW5nIHJlZ2lvblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MucmVjdChib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgIGdjLmNsaXAoKTtcblxuICAgICAgICB0aGlzLmdyaWQuY2VsbFJlbmRlcmVycy5nZXQoJ2Vycm9yY2VsbCcpLnBhaW50KGdjLCBjb25maWcsIG1lc3NhZ2UpO1xuXG4gICAgICAgIGdjLmNhY2hlLnJlc3RvcmUoKTsgLy8gZGlzY2FyZCBjbGlwcGluZyByZWdpb25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFdlIG9wdGVkIHRvIG5vdCBwYWludCBib3JkZXJzIGZvciBlYWNoIGNlbGwgYXMgdGhhdCB3YXMgZXh0cmVtZWx5IGV4cGVuc2l2ZS4gSW5zdGVhZCB3ZSBkcmF3IGdyaWQgbGluZXMgaGVyZS5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKi9cbiAgICBwYWludEdyaWRsaW5lczogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdmFyIHZpc2libGVDb2x1bW5zID0gdGhpcy52aXNpYmxlQ29sdW1ucywgQyA9IHZpc2libGVDb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgICAgIHZpc2libGVSb3dzID0gdGhpcy52aXNpYmxlUm93cywgUiA9IHZpc2libGVSb3dzLmxlbmd0aDtcblxuICAgICAgICBpZiAoQyAmJiBSKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZFByb3BzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGdyaWRQcm9wcy5saW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgbGluZUNvbG9yID0gZ3JpZFByb3BzLmxpbmVDb2xvcjtcblxuICAgICAgICAgICAgaWYgKGdyaWRQcm9wcy5ncmlkTGluZXNWKSB7XG4gICAgICAgICAgICAgICAgZ2MuY2FjaGUuZmlsbFN0eWxlID0gbGluZUNvbG9yO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gdmlzaWJsZVJvd3NbUiAtIDFdLmJvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgYyA9IGdyaWRQcm9wcy5zaG93Um93TnVtYmVycyA/IC0xIDogMDtcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZFByb3BzLmdyaWRCb3JkZXJMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdjLmZpbGxSZWN0KHZpc2libGVDb2x1bW5zW2NdLmxlZnQsIDAsIGxpbmVXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoYyArPSAxOyBjIDwgQzsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdjLmZpbGxSZWN0KHZpc2libGVDb2x1bW5zW2NdLmxlZnQgLSBsaW5lV2lkdGgsIDAsIGxpbmVXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChncmlkUHJvcHMuZ3JpZEJvcmRlclJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdjLmZpbGxSZWN0KHZpc2libGVDb2x1bW5zW2MgLSAxXS5yaWdodCArIDEgLSBsaW5lV2lkdGgsIDAsIGxpbmVXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JpZFByb3BzLmdyaWRMaW5lc0gpIHtcbiAgICAgICAgICAgICAgICBnYy5jYWNoZS5maWxsU3R5bGUgPSBsaW5lQ29sb3I7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdXaWR0aCA9IHZpc2libGVDb2x1bW5zW0MgLSAxXS5yaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZFByb3BzLmdyaWRCb3JkZXJUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2MuZmlsbFJlY3QoMCwgdmlzaWJsZVJvd3NbMF0udG9wLCB2aWV3V2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZ3JpZFByb3BzLmdyaWRCb3JkZXJCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgUiAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ3JpZFByb3BzLmdyaWRCb3JkZXJSaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3V2lkdGggKz0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IFI7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICBnYy5maWxsUmVjdCgwLCB2aXNpYmxlUm93c1tyXS5ib3R0b20sIHZpZXdXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKi9cbiAgICBwYWludENlbGw6IGZ1bmN0aW9uKGdjLCB4LCB5KSB7XG4gICAgICAgIGdjLm1vdmVUbygwLCAwKTtcblxuICAgICAgICB2YXIgYyA9IHRoaXMudmlzaWJsZUNvbHVtbnNbeF0uaW5kZXgsIC8vIHRvZG8gcmVmYWNcbiAgICAgICAgICAgIHIgPSB0aGlzLnZpc2libGVSb3dzW3ldLmluZGV4O1xuXG4gICAgICAgIGlmIChjKSB7IC8vc29tZXRoaW5nIGlzIGJlaW5nIHZpZXdlZCBhdCBhdCB0aGUgbW9tZW50IChvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIGMsIHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlbmRlciBhIHNpbmdsZSBjZWxsLlxuICAgICAqIEBkZXNjIElNUE9SVEFOVCBOT1RFOiBEbyBub3QgY2hhbmdlIHRoZSBsaW5lIGJlbG93IHdpdGggdGhlIGNvbW1lbnQgXCJTRUUgSU1QT1JUQU5UIE5PVEUgQUJPVkVcIiB3aXRob3V0IGNhcmVmdWwgcGVyZm9ybWFuY2UgdGVzdGluZy4gQnVpbGRpbmcgdGhlIGNvbmZpZyBvYmplY3QgZnJvbSBjZWxsIHByb3BlcnRpZXMgb2JqZWN0IHByb2R1Y2VkIG11Y2ggc2xvd2VyIHJlbmRlcmluZyB0aW1lcy4gVGhlIG9yaWdpbmFsIGxpbmUgd2FzOlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiAgICAgY29uZmlnID0gT2JqZWN0LmNyZWF0ZShjZWxsRXZlbnQuY29sdW1uUHJvcGVydGllcyksXG4gICAgICogYGBgXG4gICAgICogQ2VsbCBwcm9wZXJ0aWVzIG9iamVjdCBjYW1lIGludG8gcGxheSB3aGVuIGBjZWxsRXZlbnQucHJvcGVydGllc2AgZ2V0dGVyIHdoaWNoIHJldHVybnMgY2VsbCBwcm9wZXJ0aWVzIG9iamVjdCB3aGVuIHRoZXJlIGlzIG9uZSAoZWxzZSBpdCByZXR1cm5zIGNvbHVtbiBwcm9wZXJ0aWVzIG9iamVjdCkuIFRoZSByZWFzb24gc2VlbWVkIHRvIGJlIHRoYXQgZG9pbmcgc28gY2F1c2VkIG9wdGltaXphdGlvbiB0byBmYWlsIG9uIHRoZSBjZWxsIHJlbmRlcmVyIGZ1bmN0aW9uLiBUaGUgd29yay1hcm91bmQgd2FzIHRvIGFsd2F5cyBidWlsZCB0aGUgYGNvbmZpZ2Agb2JqZWN0IGZyb20gdGhlIGNvbHVtbiBwcm9wZXJ0aWVzIG9iamVjdCwgYW5kIHRoZW4gX2NvcHlfIHRoZSBcIm93blwiIGNlbGwgcHJvcGVydGllcyBvbnRvIGl0LiBUaGUgY3VycmVudCBsaW5lIGlzOlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiAgICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGNlbGxFdmVudC5jb2x1bW5Qcm9wZXJ0aWVzKSwgY2VsbEV2ZW50LmNlbGxPd25Qcm9wZXJ0aWVzKSxcbiAgICAgKiBgYGBcbiAgICAgKiBXZSBrZXB0IHRoZSBjZWxsIHByb3BlcnRpZXMgb2JqZWN0IHByb3RvdHlwZSBpbiBwbGFjZSAoZXh0ZW5kZWQgZnJvbSBjb2x1bW4gcHJvcGVydGllcykgZm9yIG90aGVyIGxvZ2ljLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBjZWxsRXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpbGxDb2xvcl0gSWYgb21pdHRlZCwgdGhpcyBpcyBhIHBhcnRpYWwgcmVuZGVyZXI7IGFsbCBvdGhlciByZW5kZXJlcnMgbXVzdCBwcm92aWRlIHRoaXMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUHJlZmVycmVkIHdpZHRoIG9mIHJlbm5kZXJlZCBjZWxsLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyXG4gICAgICovXG4gICAgX3BhaW50Q2VsbDogZnVuY3Rpb24oZ2MsIGNlbGxFdmVudCwgcHJlZmlsbENvbG9yKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwgPSBncmlkLnNlbGVjdGlvbk1vZGVsLFxuICAgICAgICAgICAgYmVoYXZpb3IgPSBncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgc3ViZ3JpZCA9IGNlbGxFdmVudC5zdWJncmlkLFxuXG4gICAgICAgICAgICBpc0hhbmRsZUNvbHVtbiA9IGNlbGxFdmVudC5pc0hhbmRsZUNvbHVtbixcbiAgICAgICAgICAgIGlzSGllcmFyY2h5Q29sdW1uID0gY2VsbEV2ZW50LmlzSGllcmFyY2h5Q29sdW1uLFxuICAgICAgICAgICAgaXNDb2x1bW5TZWxlY3RlZCA9IGNlbGxFdmVudC5pc0NvbHVtblNlbGVjdGVkLFxuXG4gICAgICAgICAgICBpc0RhdGFSb3cgPSBjZWxsRXZlbnQuaXNEYXRhUm93LFxuICAgICAgICAgICAgaXNSb3dTZWxlY3RlZCA9IGNlbGxFdmVudC5pc1Jvd1NlbGVjdGVkLFxuICAgICAgICAgICAgaXNDZWxsU2VsZWN0ZWQgPSBjZWxsRXZlbnQuaXNDZWxsU2VsZWN0ZWQsXG5cbiAgICAgICAgICAgIGlzSGVhZGVyUm93ID0gY2VsbEV2ZW50LmlzSGVhZGVyUm93LFxuICAgICAgICAgICAgaXNGaWx0ZXJSb3cgPSBjZWxsRXZlbnQuaXNGaWx0ZXJSb3csXG5cbiAgICAgICAgICAgIGlzUm93SGFuZGxlT3JIaWVyYXJjaHlDb2x1bW4gPSBpc0hhbmRsZUNvbHVtbiB8fCBpc0hpZXJhcmNoeUNvbHVtbixcbiAgICAgICAgICAgIGlzVXNlckRhdGFBcmVhID0gIWlzUm93SGFuZGxlT3JIaWVyYXJjaHlDb2x1bW4gJiYgaXNEYXRhUm93LFxuXG4gICAgICAgICAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoY2VsbEV2ZW50LmNvbHVtblByb3BlcnRpZXMpLCBjZWxsRXZlbnQuY2VsbE93blByb3BlcnRpZXMpLCAvLyBTRUUgSU1QT1JUQU5UIE5PVEUgQUJPVkVcbiAgICAgICAgICAgIHggPSAoY29uZmlnLmdyaWRDZWxsID0gY2VsbEV2ZW50LmdyaWRDZWxsKS54LFxuICAgICAgICAgICAgciA9IChjb25maWcuZGF0YUNlbGwgPSBjZWxsRXZlbnQuZGF0YUNlbGwpLnksXG5cbiAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ7XG5cbiAgICAgICAgaWYgKGlzSGFuZGxlQ29sdW1uKSB7XG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gaXNSb3dTZWxlY3RlZCB8fCBzZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZEluUm93KHIpO1xuICAgICAgICAgICAgY29uZmlnLmhhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNIaWVyYXJjaHlDb2x1bW4pIHtcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkIHx8IHNlbGVjdGlvbk1vZGVsLmlzQ2VsbFNlbGVjdGVkSW5Sb3cocik7XG4gICAgICAgICAgICBjb25maWcuaGFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0YVJvdykge1xuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkIHx8IGlzUm93U2VsZWN0ZWQgfHwgaXNDb2x1bW5TZWxlY3RlZDtcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5mb3JtYXQ7XG5cbiAgICAgICAgICAgIC8vIElmZiB3ZSBoYXZlIGEgZGVmaW5lZCByb3dQcm9wZXJ0aWVzIGFycmF5LCBhcHBseSBpdCB0byBjb25maWcsIHRyZWF0aW5nIGl0IGFzIGEgcmVwZWF0aW5nIHBhdHRlcm4sIGtleWVkIHRvIHJvdyBpbmRleC5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBPYmplY3QuYXNzaWduIHdpbGwgaWdub3JlIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIHZhciByb3cgPSBjZWxsRXZlbnQuY29sdW1uUHJvcGVydGllcy5yb3dQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIHJvdyAmJiByb3dbY2VsbEV2ZW50LmRhdGFDZWxsLnkgJSByb3cubGVuZ3RoXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBzdWJncmlkLmZvcm1hdCB8fCBjb25maWcuZm9ybWF0OyAvLyBzdWJncmlkIGZvcm1hdCBjYW4gb3ZlcnJpZGUgY29sdW1uIGZvcm1hdFxuICAgICAgICAgICAgaWYgKGlzRmlsdGVyUm93KSB7XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NvbHVtblNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBzZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZEluQ29sdW1uKHgpOyAvLyBoZWFkZXIgb3Igc3VtbWFyeSBvciBvdGhlciBub24tbWV0YVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGNlbGwgY29udGVudHM6XG4gICAgICAgIC8vICogRm9yIGFsbCBjZWxsczogc2V0IGBjb25maWcudmFsdWVgICh3cml0YWJsZSBwcm9wZXJ0eSlcbiAgICAgICAgLy8gKiBGb3IgY2VsbHMgb3V0c2lkZSBvZiByb3cgaGFuZGxlIGNvbHVtbjogYWxzbyBzZXQgYGNvbmZpZy5kYXRhUm93YCBmb3IgdXNlIGJ5IHZhbE9yRnVuY1xuICAgICAgICBpZiAoIWlzSGFuZGxlQ29sdW1uKSB7XG4gICAgICAgICAgICBjb25maWcuZGF0YVJvdyA9IGNlbGxFdmVudC5kYXRhUm93O1xuICAgICAgICAgICAgY29uZmlnLnZhbHVlID0gY2VsbEV2ZW50LnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLmlzSGFuZGxlQ29sdW1uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpc0RhdGFSb3cpIHtcbiAgICAgICAgICAgICAgICAvLyByb3cgaGFuZGxlIGZvciBhIGRhdGEgcm93XG4gICAgICAgICAgICAgICAgY29uZmlnLnZhbHVlID0gciArIDE7IC8vIHJvdyBudW1iZXIgaXMgMS1iYXNlZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0hlYWRlclJvdykge1xuICAgICAgICAgICAgICAgIC8vIHJvdyBoYW5kbGUgZm9yIGhlYWRlciByb3c6IGdldHMgXCJtYXN0ZXJcIiBjaGVja2JveFxuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxSb3dzU2VsZWN0ZWQgPSBzZWxlY3Rpb25Nb2RlbC5hcmVBbGxSb3dzU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5pc1NlbGVjdGVkID0gaXNTZWxlY3RlZDtcbiAgICAgICAgY29uZmlnLmlzRGF0YUNvbHVtbiA9ICFpc1Jvd0hhbmRsZU9ySGllcmFyY2h5Q29sdW1uO1xuICAgICAgICBjb25maWcuaXNEYXRhUm93ID0gaXNEYXRhUm93O1xuICAgICAgICBjb25maWcuaXNIZWFkZXJSb3cgPSBpc0hlYWRlclJvdztcbiAgICAgICAgY29uZmlnLmlzRmlsdGVyUm93ID0gaXNGaWx0ZXJSb3c7XG4gICAgICAgIGNvbmZpZy5pc1VzZXJEYXRhQXJlYSA9IGlzVXNlckRhdGFBcmVhO1xuICAgICAgICBjb25maWcuaXNDb2x1bW5Ib3ZlcmVkID0gY2VsbEV2ZW50LmlzQ29sdW1uSG92ZXJlZDtcbiAgICAgICAgY29uZmlnLmlzUm93SG92ZXJlZCA9IGNlbGxFdmVudC5pc1Jvd0hvdmVyZWQ7XG4gICAgICAgIGNvbmZpZy5pc0NlbGxIb3ZlcmVkID0gY2VsbEV2ZW50LmlzQ2VsbEhvdmVyZWQ7XG4gICAgICAgIGNvbmZpZy5ib3VuZHMgPSBjZWxsRXZlbnQuYm91bmRzO1xuICAgICAgICBjb25maWcuaXNDZWxsU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZDtcbiAgICAgICAgY29uZmlnLmlzUm93U2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkO1xuICAgICAgICBjb25maWcuaXNDb2x1bW5TZWxlY3RlZCA9IGlzQ29sdW1uU2VsZWN0ZWQ7XG4gICAgICAgIGNvbmZpZy5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZSA9IHNlbGVjdGlvbk1vZGVsLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlKHgsIHIpO1xuICAgICAgICBjb25maWcucHJlZmlsbENvbG9yID0gcHJlZmlsbENvbG9yO1xuXG4gICAgICAgIGlmIChncmlkLm1vdXNlRG93blN0YXRlKSB7XG4gICAgICAgICAgICBjb25maWcubW91c2VEb3duID0gZ3JpZC5tb3VzZURvd25TdGF0ZS5ncmlkQ2VsbC5lcXVhbHMoY2VsbEV2ZW50LmdyaWRDZWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgY2FsbCdzIGRhdGFNb2RlbC5nZXRDZWxsIHdoaWNoIGRldmVsb3BlciBjYW4gb3ZlcnJpZGUgdG86XG4gICAgICAgIC8vICogbXV0YXRlIHRoZSAod3JpdGFibGUpIHByb3BlcnRpZXMgb2YgYGNvbmZpZ2BcbiAgICAgICAgLy8gKiBtdXRhdGUgY2VsbCByZW5kZXJlciBjaG9pY2UgKGluc3RhbmNlIG9mIHdoaWNoIGlzIHJldHVybmVkKVxuICAgICAgICB2YXIgY2VsbFJlbmRlcmVyID0gYmVoYXZpb3IuZGF0YU1vZGVsLmdldENlbGwoY29uZmlnLCBjb25maWcucmVuZGVyZXIpO1xuXG4gICAgICAgIGlmICghKGNvbmZpZy52YWx1ZSAmJiBjb25maWcudmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5KSkgeyAvLyBmYXN0ZXN0IGFycmF5IGRldGVybWluYXRpb25cbiAgICAgICAgICAgIGNvbmZpZy52YWx1ZSA9IGNvbmZpZy5leGVjKGNvbmZpZy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdmVyd3JpdGUgcG9zc2libHkgbXV0YXRlZCBjZWxsIHByb3BlcnRpZXMsIGlmIHJlcXVlc3RlZCB0byBkbyBzbyBieSBgZ2V0Q2VsbGAgb3ZlcnJpZGVcbiAgICAgICAgaWYgKGNlbGxFdmVudC5jZWxsT3duUHJvcGVydGllcyAmJiBjb25maWcucmVhcHBseUNlbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgY2VsbEV2ZW50LmNlbGxPd25Qcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlaGF2aW9yLmNlbGxQcm9wZXJ0aWVzUHJlUGFpbnROb3RpZmljYXRpb24oY29uZmlnKTtcblxuICAgICAgICAvL2FsbG93IHRoZSByZW5kZXJlciB0byBpZGVudGlmeSBpdHNlbGYgaWYgaXQncyBhIGJ1dHRvblxuICAgICAgICBjb25maWcuYnV0dG9uQ2VsbHMgPSB0aGlzLmJ1dHRvbkNlbGxzO1xuXG4gICAgICAgIGNvbmZpZy5mb3JtYXRWYWx1ZSA9IGdyaWQuZ2V0Rm9ybWF0dGVyKGZvcm1hdCk7XG5cbiAgICAgICAgLy8gRm9sbG93aW5nIHN1cHBvcnRzIHBhcnRpYWwgcmVuZGVyPlxuICAgICAgICBjb25maWcuc25hcHNob3QgPSBjZWxsRXZlbnQuc25hcHNob3Q7XG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IGNlbGxFdmVudC5taW5XaWR0aDsgLy8gaW4gY2FzZSBgcGFpbnRgIGFib3J0cyBiZWZvcmUgc2V0dGluZyBgbWluV2lkdGhgXG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBjZWxsXG4gICAgICAgIGNlbGxSZW5kZXJlci5wYWludChnYywgY29uZmlnKTtcblxuICAgICAgICAvLyBGb2xsb3dpbmcgc3VwcG9ydHMgcGFydGlhbCByZW5kZXI6XG4gICAgICAgIGNlbGxFdmVudC5zbmFwc2hvdCA9IGNvbmZpZy5zbmFwc2hvdDtcbiAgICAgICAgY2VsbEV2ZW50Lm1pbldpZHRoID0gY29uZmlnLm1pbldpZHRoO1xuXG4gICAgICAgIHJldHVybiBjb25maWcubWluV2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfENlbGxFdmVudH0gY29sSW5kZXhPckNlbGxFdmVudCAtIFRoaXMgaXMgdGhlIFwiZGF0YVwiIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jvd0luZGV4XSAtIFRoaXMgaXMgdGhlIFwiZGF0YVwiIHkgY29vcmRpbmF0ZS4gT21pdCBpZiBgY29sSW5kZXhPckNlbGxFdmVudGAgaXMgYSBgQ2VsbEV2ZW50YC5cbiAgICAgKiBAcGFyYW0ge2RhdGFNb2RlbEFQSX0gW2RhdGFNb2RlbD10aGlzLmdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsXSBPbWl0IGlmIGBjb2xJbmRleE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLlxuICAgICAqIEByZXR1cm5zIHtDZWxsRXZlbnR9IFRoZSBtYXRjaGluZyBgQ2VsbEV2ZW50YCBvYmplY3QgZnJvbSB0aGUgcmVuZGVyZXIncyBwb29sLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSByZXF1ZXN0ZWQgY2VsbCBpcyBub3QgY3VycmVudGx5IHZpc2libGUgKGR1ZSB0byBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldykuXG4gICAgICovXG4gICAgZmluZENlbGw6IGZ1bmN0aW9uKGNvbEluZGV4T3JDZWxsRXZlbnQsIHJvd0luZGV4LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgdmFyIGNvbEluZGV4LCBjZWxsRXZlbnQsXG4gICAgICAgICAgICBwb29sID0gdGhpcy5jZWxsRXZlbnRQb29sO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29sSW5kZXhPckNlbGxFdmVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGNvbEluZGV4T3JDZWxsRXZlbnQgaXMgYSBjZWxsIGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgZGF0YU1vZGVsID0gcm93SW5kZXg7XG4gICAgICAgICAgICByb3dJbmRleCA9IGNvbEluZGV4T3JDZWxsRXZlbnQudmlzaWJsZVJvdy5yb3dJbmRleDtcbiAgICAgICAgICAgIGNvbEluZGV4ID0gY29sSW5kZXhPckNlbGxFdmVudC5jb2x1bW4uaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xJbmRleCA9IGNvbEluZGV4T3JDZWxsRXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhTW9kZWwgPSBkYXRhTW9kZWwgfHwgdGhpcy5ncmlkLmJlaGF2aW9yLmRhdGFNb2RlbDtcblxuICAgICAgICBmb3IgKHZhciBwID0gMCwgbGVuID0gdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggKiB0aGlzLnZpc2libGVSb3dzLmxlbmd0aDsgcCA8IGxlbjsgKytwKSB7XG4gICAgICAgICAgICBjZWxsRXZlbnQgPSBwb29sW3BdO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNlbGxFdmVudC5zdWJncmlkID09PSBkYXRhTW9kZWwgJiZcbiAgICAgICAgICAgICAgICBjZWxsRXZlbnQuY29sdW1uLmluZGV4ID09PSBjb2xJbmRleCAmJlxuICAgICAgICAgICAgICAgIGNlbGxFdmVudC52aXNpYmxlUm93LnJvd0luZGV4ID09PSByb3dJbmRleFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGNlbGwgcHJvcGVydGllcyBjYWNoZSBpbiB0aGUgbWF0Y2hpbmcgYENlbGxFdmVudGAgb2JqZWN0IGZyb20gdGhlIHJlbmRlcmVyJ3MgcG9vbC4gVGhpcyB3aWxsIGluc3VyZSB0aGF0IGEgbmV3IGNlbGwgcHJvcGVydGllcyBvYmplY3Qgd2lsbCBiZSBrbm93biB0byB0aGUgcmVuZGVyZXIuIChOb3JtYWxseSwgdGhlIGNhY2hlIGlzIG5vdCByZXNldCB1bnRpbCB0aGUgcG9vbCBpcyB1cGRhdGVkIGJ5IHRoZSBuZXh0IGNhbGwgdG8ge0BsaW5rIFJlbmRlcmVyI2NvbXB1dGVDZWxsQm91bmRzfSkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8Q2VsbEV2ZW50fSB4T3JDZWxsRXZlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldXG4gICAgICogQHBhcmFtIHtkYXRhTW9kZWxBUEl9IFtkYXRhTW9kZWw9dGhpcy5ncmlkLmJlaGF2aW9yLmRhdGFNb2RlbF1cbiAgICAgKiBAcmV0dXJucyB7Q2VsbEV2ZW50fSBUaGUgbWF0Y2hpbmcgYENlbGxFdmVudGAgb2JqZWN0LlxuICAgICAqL1xuICAgIHJlc2V0Q2VsbFByb3BlcnRpZXNDYWNoZTogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5LCBkYXRhTW9kZWwpIHtcbiAgICAgICAgdmFyIGNlbGxFdmVudCA9IHRoaXMuZmluZENlbGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGNlbGxFdmVudCkgeyBjZWxsRXZlbnQuX2NlbGxPd25Qcm9wZXJ0aWVzID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIHJldHVybiBjZWxsRXZlbnQ7XG4gICAgfSxcblxuICAgIHJlc2V0QWxsQ2VsbFByb3BlcnRpZXNDYWNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNlbGxFdmVudFBvb2wuZm9yRWFjaChmdW5jdGlvbihjZWxsRXZlbnQpIHtcbiAgICAgICAgICAgIGNlbGxFdmVudC5fY2VsbE93blByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpc1ZpZXdhYmxlQnV0dG9uOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHZhciBrZXkgPSBjICsgJywnICsgcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnV0dG9uQ2VsbHNba2V5XSA9PT0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgICByZXR1cm4gKHRoaXMuYm91bmRzID0gYm91bmRzKTtcbiAgICB9LFxuXG4gICAgc2V0SW5mbzogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICB2YXIgd2lkdGg7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLnZpc2libGVDb2x1bW5zW3RoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMV0ucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmNhbnZhcy5zZXRJbmZvKG1lc3NhZ2UsIHdpZHRoKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gcmVzZXROdW1iZXJDb2x1bW5XaWR0aChnYywgYmVoYXZpb3IpIHtcbiAgICB2YXIgcm93Q291bnQgPSBiZWhhdmlvci5kYXRhTW9kZWwuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgY29sdW1uUHJvcGVydGllcyA9IGJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoLTEpLFxuICAgICAgICBjZWxsUHJvcGVydGllcyA9IGNvbHVtblByb3BlcnRpZXMucm93SGVhZGVyLFxuICAgICAgICBwYWRkaW5nID0gMiAqIGNvbHVtblByb3BlcnRpZXMuY2VsbFBhZGRpbmcsXG4gICAgICAgIGljb25XaWR0aCA9IGNvbHVtblByb3BlcnRpZXMucHJlZmVycmVkV2lkdGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIGltYWdlcy5jaGVja2VkID8gaW1hZ2VzLmNoZWNrZWQud2lkdGggOiAwLFxuICAgICAgICAgICAgaW1hZ2VzLnVuY2hlY2tlZCA/IGltYWdlcy51bmNoZWNrZWQud2lkdGggOiAwXG4gICAgICAgICk7XG5cbiAgICBnYy5jYWNoZS5mb250ID0gY2VsbFByb3BlcnRpZXMuZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQuaW5kZXhPZignYm9sZCAnKSA+PSAwXG4gICAgICAgID8gY2VsbFByb3BlcnRpZXMuZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQgOiBjZWxsUHJvcGVydGllcy5mb250O1xuXG4gICAgY29sdW1uUHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IGljb25XaWR0aCArIHBhZGRpbmcgKyBnYy5nZXRUZXh0V2lkdGgocm93Q291bnQpO1xuXG4gICAgaWYgKGNvbHVtblByb3BlcnRpZXMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2x1bW5Qcm9wZXJ0aWVzLndpZHRoID0gY29sdW1uUHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aDtcbiAgICB9XG59XG5cblJlbmRlcmVyLnByb3RvdHlwZS5yZWdpc3RlckdyaWRSZW5kZXJlcihyZXF1aXJlKCcuL2J5LWNlbGxzJykpO1xuUmVuZGVyZXIucHJvdG90eXBlLnJlZ2lzdGVyR3JpZFJlbmRlcmVyKHJlcXVpcmUoJy4vYnktY29sdW1ucycpKTtcblJlbmRlcmVyLnByb3RvdHlwZS5yZWdpc3RlckdyaWRSZW5kZXJlcihyZXF1aXJlKCcuL2J5LWNvbHVtbnMtZGlzY3JldGUnKSk7XG5SZW5kZXJlci5wcm90b3R5cGUucmVnaXN0ZXJHcmlkUmVuZGVyZXIocmVxdWlyZSgnLi9ieS1jb2x1bW5zLWFuZC1yb3dzJykpO1xuUmVuZGVyZXIucHJvdG90eXBlLnJlZ2lzdGVyR3JpZFJlbmRlcmVyKHJlcXVpcmUoJy4vYnktcm93cycpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcbiJdfQ==
